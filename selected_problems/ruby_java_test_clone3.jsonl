[{"id": 855, "code1": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int N = in.nextInt();\n        int[] A = new int[N];\n        for (int i = 0; i < N; i++) {\n            A[i] = in.nextInt();\n        }\n        int ans = A[0];\n        for (int i = 1; i < N; i++) {\n            ans = gcd(ans, A[i]);\n        }\n        System.out.println(ans);\n    }\n\n    public static int gcd(int x, int y) {\n        return y == 0 ? x : gcd(y, x % y);\n    }\n}", "code2": "nm = gets.chomp.split\nn = nm[0].to_i\nm = nm[1].to_i\n\np_a = Array.new(n+1){Array.new(2, 0)}\nm.times do\n    ps = gets.chomp.split\n    number = ps[0].to_i\n    judge = ps[1]\n    case judge\n    when \"AC\"\n        p_a[number][0] += 1\n    when \"WA\"\n        if p_a[number][0] == 0\n            p_a[number][1] += 1\n        end\n    end\nend\n\nac_count = 0\nwa_count = 0\nn.times do |i|\n    if p_a[i+1][0] > 0\n        ac_count += 1\n        wa_count += p_a[i+1][1]\n    end\nend\n\nputs ac_count.to_s + \" \" + wa_count.to_s", "label": 0, "name1": "s343621637.java", "name2": "s394854078.rb"}, {"id": 392, "code1": "import java.util.*;\nimport java.lang.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        long a = sc.nextLong();\n        long b = sc.nextLong();\n        long x = sc.nextLong();\n        long countA = a ==0 ? 0 : (a-1)/x+1;\n        long countB = b/x+1;\n        System.out.println(countB-countA);\n\n    }\n}\n", "code2": "w=gets.chomp\nw=w.split(\" \")\na=w[0].to_i\nb=w[1].to_i\nx=w[2].to_i\nans=b / x - (a - 1) / x\nputs ans", "label": 1, "name1": "s118772140.java", "name2": "s552722041.rb"}, {"id": 558, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tint[] num = new int[4];\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tString st =sc.nextLine().split(\",\")[1];\n\t\t\tif(st.equals(\"A\")){\n\t\t\t\tnum[0]++;\n\t\t\t}else if(st.equals(\"B\")){\n\t\t\t\tnum[1]++;\n\t\t\t}else if(st.equals(\"AB\")){\n\t\t\t\tnum[2]++;\n\t\t\t}else if(st.equals(\"O\")){\n\t\t\t\tnum[3]++;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < num.length ; i++){\n\t\t\tSystem.out.println(num[i]);\n\t\t}\n\t\tsc.close();\n\t}\n}", "code2": "a,b,c = gets.split.map(&:to_f)\nr = c * Math::PI / 180\nh = b * Math.sin(r)\ns = a * h / 2\nw = b * Math.cos(r)\nd = Math.hypot(a-w,h)\nl = a + b + d\nputs [s,l,h] * \"\\n\"", "label": 0, "name1": "s769605617.java", "name2": "s377972091.rb"}, {"id": 949, "code1": "import java.util.Scanner;\nimport java.util.ArrayList;\n\npublic class Main{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n\n    //input\n    int d = sc.nextInt();\n    /*\n    int[] c = new int[26]; //array of decrease\n    for(int i = 0; i < c.length; i++){\n      c[i] = sc.nextInt();\n    }\n    */\n\n    int[] c = new int[26];\n    for(int i = 0; i < 26; i++){\n      c[i] = sc.nextInt();\n    }\n\n    int[][] s = new int[d][26]; //two dimensional array of increase\n    for(int row = 0; row < s.length; row++){ //day\n      for(int col = 0; col < s[row].length; col++){ //contest number\n        s[row][col] = sc.nextInt();\n      }\n    }\n    int[] t = new int[d]; //array of contest numbers of the day\n    for(int i = 0; i < t.length; i++){\n      t[i] = 13;\n    }\n\n    //output\n    //based on increase\n    /*\n    int largestNum = s[0][0];\n    int largestNumRow = 0;\n    int largestNumCol = 0;\n    for(int row = 0; row < s.length; row++){\n      for(int col = 0; col < s[row].length; col++){\n        if( s[row][col] > largestNum ){\n          largestNum = s[row][col];\n          largestNumRow = row;\n          largestNumCol = col;\n        }\n      }\n    }\n\n    int largestNuM = c.get(0);\n    int largestNumPos = 0;\n    for(int j = 0; j < c.size(); j++){\n      if( c.get(j) > largestNuM ){\n        largestNuM = c.get(j);\n        largestNumPos = j;\n      }\n    }\n\n    for(int i = 0; i < d; i++){\n      if( largestNum > largestNuM ){\n        System.out.println(largestNumCol+1);\n      }else{\n        System.out.println(largestNumPos+1);\n      }\n    }\n    */\n\n\n    /*\n\n    for(int m = 0; m < d; m++){\n      if( m%2 == 0 ){\n        System.out.println(largestNumCol+1);\n      }else{\n        int largestNuM = c.get(0);\n        int largestNumPos = 0;\n        for(int j = 0; j < c.size(); j++){\n          if( c.get(j) > largestNuM ){\n            largestNuM = c.get(j);\n            largestNumPos = j;\n          }\n        }\n        c.remove(largestNumPos);\n        System.out.println(largestNumPos+1);\n      }\n    }\n    */\n\n\n\n    for(int i = 0; i < d; i++){\n      System.out.println((int)(Math.random()*26+1));\n      //System.out.println(largestNumCol+1);\n    }\n\n    /*\n    int value = 0;\n    for(int i = 0; i < t.length; i++){\n      int contestNum = t[i]-1;\n      int day = i+1;\n      value += s[day-1][contestNum]; //increase\n      for(int j = 0; j < c.length; j++){\n        if( !(j == contestNum) ){\n          int daySinceLast = day;\n          for(int m = 0; m < i; m++){\n            if( j == t[m]-1 ){\n              daySinceLast = day-m-1;\n            }\n          }\n          value -= c[j]*(daySinceLast); //decrease (amount of decrease * days since last one)\n        }\n      }\n      System.out.println(value);\n    }\n    */\n\n\n  }\n}\n", "code2": "N,M,K=gets.split.map &:to_i;puts (0..N).any?{|k|x=K-k*M;y=N-2*k;y==0?x==0:(l=x/y;x%y==0&&0<=l&&l<=M)}?:Yes: :No", "label": 0, "name1": "s036059827.java", "name2": "s961847715.rb"}, {"id": 810, "code1": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t// \u5165\u529b\n\t\tint n = sc.nextInt();\n\t\tGraph g = new Graph(n, false);\n\t\tfor(int i = 0; i < n-1; i++){\n\t\t    int a = sc.nextInt() - 1;\n\t\t    int b = sc.nextInt() - 1;\n\t\t    g.add(a, b);\n\t\t}\n\t\t\n\t\t// \u8a08\u7b97\n\t\tString result = \"Snuke\";\n\t\tlong[] distFromB = g.dijkstra(0);\n\t\tlong[] distFromW = g.dijkstra(n-1);\n\t\tint cnt = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t    if(distFromB[i] <= distFromW[i]) cnt++;\n\t\t}\n\t\tif(cnt > (n-cnt)) result = \"Fennec\";\n\t\t\n\t\t// \u51fa\u529b\n\t\tSystem.out.println(result);\n\t}\n\n}\n\nclass Graph {\n\tint n;\n\tboolean directed;\n\tArrayList<Edge>[] adjList;\n\tint m;\n\tlong[] dist;\n\tlong[][] distWF;\n\tint start;\n\tint[] prev;\n\tArrayList<Integer> path;\n\tlong INF = 1001001001001001001L;\n\n\tpublic Graph (int n, boolean directed) {\n\t\tthis.n = n;\n\t\tthis.m = 0;\n\t\tthis.directed = directed;\n\t\tthis.adjList = new ArrayList[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tadjList[i] = new ArrayList<Edge>();\n\t\t}\n\t}\n\t\n\tpublic void add(int from, int to) {\n\t\tadd(from, to, 1);\n\t}\n\tpublic void add(int from, int to, int w) {\n\t\tadjList[from].add(new Edge(from, to, w));\n\t\tthis.m++;\n\t\tif(!directed){\n\t\t\tadjList[to].add(new Edge(to, from, w));\n\t\t\tthis.m++;\n\t\t}\n\t}\n\t\n\tpublic long[] bfs(int start) { // O(M)\n\t\tthis.start = start;\n\t\tthis.prev = new int[n];\n\t\tArrays.fill(prev, -1);\n\t\tprev[start] = start;\n\t\tthis.dist = new long[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[start] = 0;\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tq.add(start);\n\t\twhile(!q.isEmpty()){\n\t\t\tint now = q.poll();\n\t\t\tfor(Edge e : adjList[now]){\n\t\t\t\tif(dist[e.to] != INF) continue;\n\t\t\t\tdist[e.to] = dist[now] + e.w;\n\t\t\t\tprev[e.to] = now;\n\t\t\t\tq.add(e.to);\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\t\n\tpublic long[] dijkstra(int start) { // O(MlogM)\n\t\tthis.start = start;\n\t\tthis.prev = new int[n];\n\t\tArrays.fill(prev, -1);\n\t\tprev[start] = start;\n\t\tthis.dist = new long[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[start] = 0;\n\t\tPriorityQueue<Vertex> q = new PriorityQueue<Vertex>((x, y) -> Long.compare(x.distance, y.distance));\n\t\tq.add(new Vertex(start, 0));\n\t\twhile(!q.isEmpty()){\n\t\t\tVertex now = q.poll();\n\t\t\tif(now.distance > dist[now.id]) continue; \n\t\t\tfor(Edge e : adjList[now.id]){\n\t\t\t\tlong newDist = now.distance + e.w;\n\t\t\t\tif(dist[e.to] <= newDist) continue;\n\t\t\t\tdist[e.to] = newDist;\n\t\t\t\tprev[e.to] = now.id;\n\t\t\t\tq.add(new Vertex(e.to, newDist));\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\t\n\tpublic long[][] wf() { // O(N^3)\n\t\tthis.distWF = new long[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tArrays.fill(distWF[i], INF);\n\t\t\tdistWF[i][i] = 0;\n\t\t}\n\t\tfor(ArrayList<Edge> list : adjList){\n\t\t\tfor(Edge e : list){\n\t\t\t\tdistWF[e.from][e.to] = e.w;\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < n; k++){\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tdistWF[i][j] = min(distWF[i][j], distWF[i][k] + distWF[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn distWF;\n\t}\n\t\n\tpublic boolean bf(int start) { // O(NM)\n\t\tthis.start = start;\n\t\tthis.prev = new int[n];\n\t\tArrays.fill(prev, -1);\n\t\tprev[start] = start;\n\t\tthis.dist = new long[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[start] = 0;\n\t\tboolean hasNegativeLoop = false;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tfor(Edge e : adjList[j]){\n\t\t\t\t\tif(dist[e.to] <= dist[e.from] + e.w) continue;\n\t\t\t\t\tdist[e.to] = dist[e.from] + e.w;\n\t\t\t\t\tprev[e.to] = e.from;\n\t\t\t\t\tif(i == n-1) hasNegativeLoop = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn hasNegativeLoop;\n\t}\n\t\n\tpublic ArrayList<Integer> pathTo(int to){\n\t\tthis.path = new ArrayList<Integer>();\n\t\treturn pathToRec(to);\n\t}\n\t\n\tprivate ArrayList<Integer> pathToRec(int to){\n\t\tif(to != start) pathToRec(prev[to]);\n\t\tpath.add(to);\n\t\treturn path;\n\t}\n\t\n\tpublic String toString(){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(ArrayList<Edge> list : adjList){\n\t\t\tfor(Edge e : list){\n\t\t\t\tsb.append(e.toString());\n\t\t\t\tsb.append(\"\\n\");\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tpublic String distToString(){\n\t\tif(dist != null) return Arrays.toString(dist);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(distWF[i][j] == INF){\n\t\t\t\t\tsb.append(\"from:\" + i + \" to:\" + j + \" dist:INF\" + \"\\n\");\n\t\t\t\t}else{\n\t\t\t\t\tsb.append(\"from:\" + i + \" to:\" + j + \" dist:\" + distWF[i][j] + \"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tclass Edge {\n\t\tint from;\n\t\tint to;\n\t\tint w;\n\t\t\n\t\tEdge(int from, int to, int w){\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"from:\" + from + \" to:\" + to + \" w:\" + w;\n\t\t}\n\t}\n\t\n\tclass Vertex {\n\t\tint id;\n\t\tlong distance;\n\t\t\n\t\tVertex(int id, long distance){\n\t\t\tthis.id = id;\n\t\t\tthis.distance = distance;\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"id:\" + id + \" distance:\" + distance;\n\t\t}\n\t}\n}\n", "code2": "N, M = gets.split.map(&:to_i)\nedges = M.times.map { gets.split.map(&:to_i) }\ngraph = Array.new(N) { [] }\nedges.each do |u, v|\n  u -= 1\n  v -= 1\n  graph[u].push(v)\n  graph[v].push(u)\nend\n\nrequire 'set'\ndef path_count(u, visited, graph)\n  return 1 if visited.size == N\n  ret = 0\n  graph[u].each do |v|\n    next if visited.include?(v)\n    new_visited = visited | Set.new([v])\n    ret += path_count(v, new_visited, graph)\n  end\n  ret\nend\nvisited = Set.new([0])\nans = path_count(0, visited, graph)\nputs ans", "label": 0, "name1": "s816087530.java", "name2": "s194005594.rb"}, {"id": 800, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\t\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tString[] days={\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\"};\n\t\twhile(sc.hasNextInt()){\n\t\t\tint month=sc.nextInt();\n\t\t\tint day=sc.nextInt();\n\t\t\tint a=modd(month);\n\t\t\tint b=a+day;\n\t\t\tif(month==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif((b-1)%7==0){\n\t\t\t\tSystem.out.println(days[0]);\n\t\t}else if((b-1)%7==1){\n\t\t\tSystem.out.println(days[1]);\n\t\t}else if((b-1)%7==2){\n\t\t\tSystem.out.println(days[2]);\n\t\t}else if((b-1)%7==3){\n\t\t\tSystem.out.println(days[3]);\n\t\t}else if((b-1)%7==4){\n\t\t\tSystem.out.println(days[4]);\n\t\t}else if((b-1)%7==5){\n\t\t\tSystem.out.println(days[5]);\n\t\t}else if((b-1)%7==6){\n\t\t\tSystem.out.println(days[6]);\n\t\t}\n\t}\n\n\t}\n\tpublic static int modd(int month){\n\t\tint[] months={31,29,31,30,31,30,31,31,30,31,30,31};\n\t\tint a=0;\n\t\tfor(int i=0; i<=month-2; i++){\n\t\t\ta+=months[i];\n\t\t}\n\n\t\treturn a;\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n}", "code2": "N = gets.to_i\nR = Array.new(N + 1) { [] }\n(N - 1).times do\n  a, b = gets.split.map(&:to_i)\n  R[a].push b\n  R[b].push a\nend\n\nG = Array.new(N + 1)\nq1 = [1]\nq2 = [N]\nuntil q1.empty? && q2.empty?\n  nq1 = []\n  q1.each do |x|\n    if G[x].nil?\n      G[x] = 1\n      nq1 += R[x]\n    else\n      next\n    end\n  end\n  nq2 = []\n  q2.each do |x|\n    if G[x].nil?\n      G[x] = 2\n      nq2 += R[x]\n    else\n      next\n    end\n  end  \n  q1 = nq1\n  q2 = nq2\nend\n\nif G.count(1) > N / 2\n  puts \"Fennec\"\nelse\n  puts \"Snuke\"\nend", "label": 0, "name1": "s331323698.java", "name2": "s034251111.rb"}, {"id": 680, "code1": "import java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);  \n\t\twhile(true){\n\t\t\t    int n=sc.nextInt();\n\t\t\t    int x=sc.nextInt();\n\t\t\t    if(n==0&&x==0)break;\n\t\t\t    int cnt=0;\n\t\t\t    for(int i=1;i<=n;i++){\n\t\t\t        for(int j=i+1;j<=n;j++){\n\t\t\t            for(int k=j+1;k<=n;k++){\n\t\t\t                if(i+j+k==x)cnt++;\n\t\t\t            }\n\t\t\t        }\n\t\t\t    }\n\t\t\t    System.out.println(cnt);\n\t\t}\n\t}\n}", "code2": "arr = [0,0,0,0,0]\n3.times do |i|\n  a,b = gets.chomp.split(\" \").map(&:to_i)\n  arr[a] += 1\n  arr[b] += 1\nend\nprint arr.max < 3 ? \"YES\" : \"NO\"", "label": 0, "name1": "s954202209.java", "name2": "s043774656.rb"}, {"id": 170, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() { return Double.parseDouble(next());}\n}\npublic class Main {\n\tstatic FastScanner stdIn=new FastScanner();\n\tpublic static void main(String[] args) {\n\t\tString X=stdIn.next();\n\t\tint N=X.length();\n\t\tint s=0,t=0,ans=N;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tchar a=X.charAt(i);\n\t\t\tif(a=='S')\n\t\t\t\ts++;\n\t\t\telse{\n\t\t\t\tif(s!=0){\n\t\t\t\t\tans-=2;\n\t\t\t\t\ts--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n", "code2": "x = gets.chomp\nprev_s = 0\nlen = x.length\ncnt = 0\nlen.times do |i|\n  if x[i] == 'S'\n    prev_s += 1\n  else\n    if prev_s > 0\n      cnt += 1\n      prev_s -= 1\n    end\n  end\nend\nputs len - 2 * cnt", "label": 1, "name1": "s724983945.java", "name2": "s732078334.rb"}, {"id": 185, "code1": "import java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint a = scan.nextInt();\n\t\tint b = scan.nextInt();\n\t\tscan.close();\n\t\tint ans = 12;\n\t\tif(b >= a) {\n\t\t\tans = a;\n\t\t}else {\n\t\t\tans = a - 1;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n", "code2": "a, b = gets.split.map(&:to_i)\nif b < a\n    puts a - 1\nelse\n    puts a\nend", "label": 1, "name1": "s648355489.java", "name2": "s251597929.rb"}, {"id": 56, "code1": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tvoid run(){\n\t\tint s=0;\n\t\tfor(int i=0; i<4; i++){\n\t\t\ts+=sc.nextInt();\n\t\t}\n\t\tprintln(s/60+\"\");\n\t\tprintln(s%60+\"\");\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}", "code2": "n=0\n4.times do\n  n+=gets.chomp.to_i\nend\n\np n/60\np n%60", "label": 1, "name1": "s582549641.java", "name2": "s834558089.rb"}, {"id": 846, "code1": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n  public static void main(String[] args) {\n    FastScanner sc = new FastScanner();\n    int N = sc.nextInt();\n    int L = sc.nextInt();\n    long T = sc.nextLong();\n    \n    long[][] ari = sc.nextLongTable(N, 2);\n    \n    long[] cl = new long[N];\n    long[] ccl = new long[N];\n\n    int p = 0, q = 0;\n    for (int i = 0; i < N; i ++) {\n      if (ari[i][1] == 1) {\n        cl[p ++] = L - ari[i][0];\n      } else {\n        ccl[q ++] = ari[i][0];\n      }\n    }\n    cl = Arrays.copyOf(cl, p);\n    ccl = Arrays.copyOf(ccl, q);\n    Arrays.sort(cl);\n\n    long[] rets = new long[N];\n    for (int i = 0; i < N ;i ++) {\n      if (ari[i][1] == 1) {\n        int count = (int)(count(ccl, ari[i][0], ari[i][0] + 2L * T, L) % N);\n        rets[(i + count) % N] = (ari[i][0] + T) % L;\n      } else {\n        int count = (int)(count(cl, L - ari[i][0], L - ari[i][0] + 2L * T, L) % N);\n        rets[(i + N - count) % N] = (ari[i][0] + L - T % L) % L;\n      }\n    }\n    \n    for (int i = 0; i < N; i ++) {\n      System.out.println(rets[i]);\n    }\n  }\n  \n  private static long count(long[] xs, long f, long t, int L) {\n    long ret = 0;\n    int n = xs.length;\n    {\n      ret += t / L * n;\n      int ind = Arrays.binarySearch(xs, (int)(t % L));\n      if (ind < 0)  ind = -ind - 2;\n      ind ++;\n      ret += ind;\n    }\n    {\n      ret -= f / L * n;\n      int ind = Arrays.binarySearch(xs, (int)(f % L));\n      if (ind < 0)  ind = -ind - 2;\n      ind ++;\n      ret -= ind;\n    }\n    return ret;\n  }\n}\n\n\n\n\nclass FastScanner {\n\tpublic static String debug = null;\n\n\tprivate final InputStream in = System.in;\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate byte[] buffer = new byte[1024];\n\tprivate boolean eos = false;\n\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tif (debug != null) {\n\t\t\t\t\tbuflen = debug.length();\n\t\t\t\t\tbuffer = debug.getBytes();\n\t\t\t\t\tdebug = \"\";\n\t\t\t\t\teos = true;\n\t\t\t\t} else {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen < 0) {\n\t\t\t\teos = true;\n\t\t\t\treturn false;\n\t\t\t} else if (buflen == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\n\tprivate void skipUnprintable() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t}\n\n\tpublic boolean isEOS() {\n\t\treturn this.eos;\n\t}\n\n\tpublic boolean hasNext() {\n\t\tskipUnprintable();\n\t\treturn hasNextByte();\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tpublic int nextInt() {\n\t\treturn (int) nextLong();\n\t}\n\n\tpublic long[] nextLongList(int n) {\n\t\treturn nextLongTable(1, n)[0];\n\t}\n\n\tpublic int[] nextIntList(int n) {\n\t\treturn nextIntTable(1, n)[0];\n\t}\n\n\tpublic long[][] nextLongTable(int n, int m) {\n\t\tlong[][] ret = new long[n][m];\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tfor (int j = 0; j < m; j ++) {\n\t\t\t\tret[i][j] = nextLong();\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic int[][] nextIntTable(int n, int m) {\n\t\tint[][] ret = new int[n][m];\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tfor (int j = 0; j < m; j ++) {\n\t\t\t\tret[i][j] = nextInt();\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n}", "code2": "def gcd(a,b)\n  if a % b == 0\n    b\n  elsif b % a == 0\n    a\n  elsif a < b\n    gcd(a, b % a)\n  else\n    gcd(a % b, b)\n  end\nend\n\nn = gets.to_i\nary = gets.split.map(&:to_i)\n\np ary.reduce { |a,b| gcd(a,b) }\n", "label": 0, "name1": "s345434798.java", "name2": "s961208113.rb"}, {"id": 27, "code1": "import java.util.*;\nimport java.io.*;\n\nimport static java.lang.System.in;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long A = sc.nextLong();\n        long B = sc.nextLong();\n        long[] x = new long[n];\n        for(int i=0;i<n;i++) x[i]=sc.nextLong();\n        long ans= 0;\n        for(int i=0;i<n-1;i++){\n            ans += Math.min(A*(x[i+1]-x[i]),B);\n        }\n        PrintWriter out = new PrintWriter(System.out);\n        out.println(ans);\n        out.flush();\n    }\n}\n", "code2": "n,a,b = gets.chomp.split(\" \").map(&:to_i)\nx = gets.chomp.split(\" \").map(&:to_i)\nborder = b/a\nnow = x[0]\nmp = 0\n(n-1).times do |i|\n  if x[i+1] - now > border\n    mp += b\n    now = x[i+1]\n  else\n    mp += (x[i+1] - now) * a\n    now = x[i+1]\n  end\nend\nputs mp", "label": 1, "name1": "s316016733.java", "name2": "s543935050.rb"}, {"id": 706, "code1": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        // \u6574\u6570\u306e\u5165\u529b\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        int c = sc.nextInt();\n        // \u51fa\u529b\n        int o = c-a+b;\n        System.out.println(o > 0 ? o : 0);\n    }\n}", "code2": "M=1000003\no=->a,n{n<1?1:(n%2>0?a:1)*o[a,n/2]**2%M}\n*f=1\n1.upto(M){|i|f<<f[i-1]*i%M}\ngets\n$<.map{|s|x,d,n=s.split.map &:to_i\nt=x*o[d,M-2]%M\np d<1?o[x,n]:M<t+n||t<1?0:f[t+n-1]*o[f[t-1],M-2]*o[d,n]%M}", "label": 0, "name1": "s598978529.java", "name2": "s699536087.rb"}, {"id": 159, "code1": "import java.util.*;\npublic class Main{\npublic static void main(String[] args){\nScanner sc = new Scanner(System.in);\n  int Q = sc.nextInt();\n  for(int i=0;i<Q;i++){\n    long f = sc.nextLong();\n    long s = sc.nextLong();\n    long a = Math.max(f, s);\n    long b = Math.min(f, s);\n    long K = a*b;\n    long L = (long) Math.sqrt(K);\n    long M = (K-1)/L;\n    long N = Math.max(-1,M-b-1);\n    System.out.println(L+N+b-1);\n  }\n}}\n", "code2": "gets.to_i.times{\n\ta,b=gets.split.map &:to_i\n\tt=a*b\n\ts=Math.sqrt(t).to_i\n\tr=2*s-2\n\tr-=1 if s*s==t\n\tr+=1 if s*(s+1)<t\n\tr+=1 if a==b\n\tp r\n}", "label": 1, "name1": "s709576716.java", "name2": "s605229317.rb"}, {"id": 284, "code1": "import java.io.BufferedReader;\n\nimport static java.util.Comparator.*;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.lang.reflect.Array;\nimport java.math.BigDecimal;\nimport java.util.AbstractMap;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class Main {\n\t\n//\tpublic static Set<String> mem = new HashSet<String>();\n//\tpublic static boolean[] mem_1 = new boolean[100];\n//\tpublic static boolean[] mem_2 = new boolean[100];\n//\tpublic static Set<Integer> mem = new TreeSet<Integer>();\n//\tpublic static Map<String, Integer> mem_1= new HashMap<String, Integer>();\n//\tpublic static Map<String, Integer> mem_2 = new HashMap<String, Integer>();\n\t\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        \n        Solver solver = new Solver();\n        solver.solve(1, in, out);\n        \n        out.close();\n    }\n    \n    // ======================================================================\n    static class Solver {\n    \t\n\t\tList<Pair<Integer, Integer>> lP = new ArrayList<Pair<Integer, Integer>>();\n\t\tList<Pair<Integer, Integer>> lAns = new ArrayList<Pair<Integer, Integer>>();\n\n    \tpublic void solve(int testNumber, MyInput in, PrintWriter out) {\n    \t\tlong ans = 0L;\n    \t\tint[] cnt = new int[4];\n    \t\tfor(int i=0; i < 6; i++) {\n        \t\tint a = in.nextInt();\n        \t\tcnt[a-1] += 1;\n        // \t\tout.println(\"[\" + a + \"]\");\n    \t\t}\n    \t\tboolean f = true;\n    \t\tfor(int i=0; i < 4; i++) {\n        // \t\tout.println(\"[\" + cnt[i] + \"]\");\n    \t\t\tif(cnt[i] >= 3)\t\tf = false;\n    \t\t}\n    \t\tif(f)   \t\tout.println(\"YES\");\n    \t\telse            out.println(\"NO\");\n        }\n    }\n    // ======================================================================\n    static class Pair<K, V> extends AbstractMap.SimpleEntry<K, V> {\n        /** serialVersionUID. */\n        private static final long serialVersionUID = 6411527075103472113L;\n\n        public Pair(final K key, final V value) {\n            super(key, value);\n        }\n        public String getString() {\n            return \"[\" + getKey() + \"] [\" + getValue() + \"]\";\n        }\n     }    \n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n \n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n \n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n \n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n \n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n \n        public String nextString() {\n        \tString ret = new String(nextDChar()).trim();\n            return ret;\n        }\n \n        public char[] nextDChar() {\n            int len = 0;\n            len = reads(len, isSpace);\n            char[] ret = new char[len + 1];\n            for (int i=0; i < len; i++)\t\tret[i] = str[i];\n            ret[len] = 0x00;\n            return ret;\n        }\n \n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n \n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n \n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n    }\n}\n", "code2": "road = []\n3.times do\n  a, b = gets.chop.split.map(&:to_i)\n  road << a\n  road << b\nend\nif road.find_all{|n| n == 1}.length >= 3 || road.find_all{|n| n == 2}.length >= 3 || road.find_all{|n| n == 3}.length >= 3 || road.find_all{|n| n == 4}.length >= 3\n  puts 'NO'\nelse\n  puts 'YES'\nend", "label": 1, "name1": "s961270278.java", "name2": "s052701711.rb"}, {"id": 70, "code1": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\t//\u305d\u308c\u305e\u308c\u306e\u60a3\u8005\u306e\u756a\u53f7 p\n\t\t//1\u56de\u76ee\u306b\u6b69\u3044\u305f\u8ddd\u96e2 d1\n\t\t//2\u56de\u76ee\u306b\u6b69\u3044\u305f\u8ddd\u96e2 d2\n\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();//\u60a3\u8005\u306e\u6570 n\n\t\t\tint maxWalk = 0;//\u4e00\u756a\u6b69\u3044\u305f\u4eba\u306e\u8ddd\u96e2\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tMap<Integer, Integer> walkSum = new HashMap<Integer, Integer>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tint d1 = sc.nextInt();\n\t\t\t\tint d2 = sc.nextInt();\n\t\t\t\tint sumWalk = d1 + d2;\n\t\t\t\tif(sumWalk > maxWalk)maxWalk = sumWalk;\n\t\t\t\twalkSum.put(sumWalk,p);\n\t\t\t}\n\t\t\tSystem.out.println(walkSum.get((Object)maxWalk)+\" \"+maxWalk);\n\t\t}\n\t}\n}", "code2": "puts (1..$_.to_i).map{a,b,c=gets.split.map &:to_i;[a,b+c]}.max_by{|i,j|j}*\" \"while gets>?1", "label": 1, "name1": "s421023762.java", "name2": "s118728373.rb"}, {"id": 933, "code1": "    import java.io.*;\n    import java.util.*;\n\n    public class Main {\n        public static void main(String[] args) throws IOException {\n            FastReader scan = new FastReader();\n            //PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(\"taming.out\")));\n            PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n            Task solver = new Task();\n            //int t = scan.nextInt();\n            int t = 1;\n            for(int i = 1; i <= t; i++) solver.solve(i, scan, out);\n            out.close();\n        }\n        static class Task {\n            boolean[][] matrix;\n            boolean[][] vis;\n            public void solve(int testNumber, FastReader sc, PrintWriter pw){\n                int n = sc.nextInt();\n                int m = sc.nextInt();\n                matrix = new boolean[n][m];\n                vis = new boolean[n][m];\n                long sum = 0;\n                for(int i=0;i<n;i++){\n                    String str = sc.nextLine();\n                    for(int j=0;j<m;j++){\n                        matrix[i][j]=(str.charAt(j)=='#');\n                    }\n                }\n                for(int i=0;i<n;i++){\n                    for(int j=0;j<m;j++){\n                        if(!vis[i][j]){\n                            int[] x = dfs(i,j,matrix[i][j]);\n                            sum+=((long)(x[0]))*x[1];\n                        }\n                    }\n                }\n                pw.println(sum);\n            }\n            public int[] dfs (int x, int y, boolean c){\n                int[] dx = {-1,1,0,0};\n                int[] dy = {0,0,-1,1};\n                if(x<0||y<0||x>=matrix.length||y>=matrix[0].length||vis[x][y]||matrix[x][y]!=c){\n                    return new int[]{0,0};\n                }\n                int a = 0;\n                int b = 0;\n                vis[x][y]=true;\n                if(c){\n                    a++;\n                }\n                else{\n                    b++;\n                }\n                for(int i=0;i<4;i++){\n                    int[] tt = dfs(x+dx[i],y+dy[i],!c);\n                    a+=tt[0];\n                    b+=tt[1];\n                }\n                return new int[]{a,b};\n            }\n        }\n        static class tup implements Comparable<tup> {\n            int a, b;\n            tup() {\n            }\n            ;\n\n\n\n            tup(int a, int b) {\n                this.a=a;\n                this.b=b;\n            }\n\n            @Override\n            public int compareTo(tup o2) {\n                return 0;\n            }\n        }\n        static void shuffle(long[] a) {\n            Random get = new Random();\n            for (int i = 0; i < a.length; i++) {\n                int r = get.nextInt(a.length);\n                long temp = a[i];\n                a[i] = a[r];\n                a[r] = temp;\n            }\n        }\n        static void shuffle(int[] a) {\n            Random get = new Random();\n            for (int i = 0; i < a.length; i++) {\n                int r = get.nextInt(a.length);\n                int temp = a[i];\n                a[i] = a[r];\n                a[r] = temp;\n            }\n        }\n        static void shuffle(int[] a,int l, int rb) {\n            Random get = new Random();\n            for (int i = l; i < rb; i++) {\n                int r = get.nextInt(a.length);\n                int temp = a[i];\n                a[i] = a[r];\n                a[r] = temp;\n            }\n        }\n        static class FastReader {\n            BufferedReader br;\n            StringTokenizer st;\n\n            public FastReader() {\n                br = new BufferedReader(new InputStreamReader(System.in));\n            }\n\n            public FastReader(String s) throws FileNotFoundException {\n                br = new BufferedReader(new FileReader(new File(s)));\n            }\n\n            String next() {\n                while (st == null || !st.hasMoreElements()) {\n                    try {\n                        st = new StringTokenizer(br.readLine());\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n                return st.nextToken();\n            }\n\n            int nextInt() {\n                return Integer.parseInt(next());\n            }\n\n            long nextLong() {\n                return Long.parseLong(next());\n            }\n\n            double nextDouble() {\n                return Double.parseDouble(next());\n            }\n\n            String nextLine() {\n                String str = \"\";\n                try {\n                    str = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                return str;\n            }\n        }\n\n    }", "code2": "n,*a=`dd`.split.map &:to_i\np (1...2*n).bsearch(&->x{\n\tb=a.map{|e|e<x}\n\t1.upto(n-1){|i|\n\t\treturn b[n+i-1] if b[n+i-1]==b[n+i-2]\n\t\treturn b[n-i-1] if b[n-i-1]==b[n-i-0]\n\t}\n\tb[0]\n})-1", "label": 0, "name1": "s881420756.java", "name2": "s377076296.rb"}, {"id": 757, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n\n    void solve() throws IOException {\n        int h = ni(), w = ni();\n        String[] a = nsa(h);\n\n        char[][] ansR = new char[h][w];\n        char[][] ansB = new char[h][w];\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (i == 0 || i < h - 1 && j % 2 == 0) {\n                    ansR[i][j] = '#';\n                    ansB[i][j] = '.';\n                } else {\n                    ansR[i][j] = '.';\n                    ansB[i][j] = '#';\n                }\n            }\n        }\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (a[i].charAt(j) == '#') {\n                    ansR[i][j] = '#';\n                    ansB[i][j] = '#';\n                }\n            }\n        }\n\n        for (int i = 0; i < h; i++) {\n            out.println(String.valueOf(ansR[i]));\n        }\n        out.println();\n        for (int i = 0; i < h; i++) {\n            out.println(String.valueOf(ansB[i]));\n        }\n    }\n\n    String ns() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine(), \" \");\n        }\n        return tok.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.parseInt(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.parseLong(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.parseDouble(ns());\n    }\n\n    String[] nsa(int n) throws IOException {\n        String[] res = new String[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ns();\n        }\n        return res;\n    }\n\n    int[] nia(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ni();\n        }\n        return res;\n    }\n\n    long[] nla(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nl();\n        }\n        return res;\n    }\n\n    class INA {\n        int[][] a;\n\n        INA(int n, int m) throws IOException {\n            this(n, m, -1);\n        }\n\n        INA(int n, int m, int t) throws IOException {\n            a = new int[m][n];\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    a[j][i] = ni() + t;\n                }\n            }\n        }\n\n        int[] get(int i) {\n            return a[i - 1];\n        }\n    }\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        tok = new StringTokenizer(\"\");\n        Main main = new Main();\n        main.solve();\n        out.close();\n    }\n}", "code2": "#!/usr/bin/ruby\n\ni=STDIN.gets\n\nnum = STDIN.gets.split()\nnum.map!{|i| i.to_i}\n\nnum.sort!\n\nputs num.join(\" \")", "label": 0, "name1": "s104811718.java", "name2": "s080700840.rb"}, {"id": 245, "code1": "import java.util.*;\n\nclass Main {\n    public static void main(String[] args) {\n        new Solver().run();\n    }\n}\n\nclass Solver {\n\n    public void run() {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int[] a = new int[N];\n\n        for (int i = 0; i < N; i++) {\n            a[i] = sc.nextInt();\n            a[i]--;\n        }\n\n        int cnt = 0;\n        for (int i = 0; i < N; i++) {\n            if (i == a[a[i]]) cnt++;\n        }\n\n        System.out.println(cnt / 2);\n\n        return;\n    }\n\n}", "code2": "n=gets.to_i\nas=gets.chomp.split.map(&:to_i)\na=0\nn.times{|i|\n    if as[as[i] - 1] - 1 == i\n        a += 1\n    end\n}\np a / 2\n", "label": 1, "name1": "s246692563.java", "name2": "s050852619.rb"}, {"id": 352, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.util.NoSuchElementException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author HBonsai\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CMultipleGift solver = new CMultipleGift();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CMultipleGift {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            long X = in.nextLong();\n            long Y = in.nextLong();\n            int ans = 1;\n            long A = X;\n            while (A <= Y) {\n                A *= 2;\n                if (A > Y) break;\n                ans++;\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class FastScanner implements Closeable {\n        private final InputStream in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        public FastScanner(InputStream in) {\n            this.in = in;\n        }\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        public boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n            return hasNextByte();\n        }\n\n        public long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        public void close() {\n            try {\n                in.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n}\n\n", "code2": "eval'X,Y='+`tr ' ' ,`;p (Y/X).bit_length", "label": 1, "name1": "s947131740.java", "name2": "s262263338.rb"}, {"id": 683, "code1": "import java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);  \n\t\twhile(true){\n\t\t\t    int n=sc.nextInt();\n\t\t\t    int x=sc.nextInt();\n\t\t\t    if(n==0&&x==0)break;\n\t\t\t    int cnt=0;\n\t\t\t    for(int i=1;i<=n;i++){\n\t\t\t        for(int j=i+1;j<=n;j++){\n\t\t\t            for(int k=j+1;k<=n;k++){\n\t\t\t                if(i+j+k==x)cnt++;\n\t\t\t            }\n\t\t\t        }\n\t\t\t    }\n\t\t\t    System.out.println(cnt);\n\t\t}\n\t}\n}", "code2": "n, m = gets.split.map(&:to_i)\nxs = gets.split.map(&:to_i).sort\n\nif n >= m\n  puts 0\n  exit\nend\ndiffs = (xs.size - 1).times.map { |i| xs[i + 1] - xs[i] }.sort\nputs diffs[0..-n].inject(&:+)\n", "label": 0, "name1": "s954202209.java", "name2": "s162653365.rb"}, {"id": 227, "code1": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\t\n\tint n;\n\tint[][] es;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\tes = new int[n][n];\n\t\tfor (int[] a: es) fill(a, INF);\n\t\tfor (int i=0;i<n;i++) es[i][i] = 0;\n\t\tfor (int i=0;i<n;i++) {\n\t\t\tint r = sc.nextInt()-1, k = sc.nextInt();\n\t\t\tfor (int j=0;j<k;j++) {\n\t\t\t\tint t = sc.nextInt()-1;\n\t\t\t\tes[r][t] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int k=0;k<n;k++) for (int i=0;i<n;i++) for (int j=0;j<n;j++) {\n\t\t\tes[i][j] = min(es[i][j], es[i][k] + es[k][j]);\n\t\t}\n\t\tint p = sc.nextInt();\n\t\tfor (int i=0;i<p;i++) {\n\t\t\tint s = sc.nextInt()-1, d = sc.nextInt()-1, v = sc.nextInt();\n\t\t\tSystem.out.println((es[s][d] + 1 <= v ? es[s][d] + 1 : \"NA\"));\n\t\t}\n\t}\n\t\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}", "code2": "Infinity = 1000000\n\ndef dijkstra graph, s\n  n = graph.size\n  dist = Array.new(n, Infinity)\n  visited = Array.new(n, false)\n  dist[s] = 0\n  loop do\n    min = -1\n    sd = Infinity\n    n.times do |i|\n      if (! visited[i]) && dist[i] < sd\n        min = i\n        sd = dist[i]\n      end\n    end\n    break if min == -1\n    visited[min] = true\n    graph[min].each do |node|\n      newLen = dist[min] + 1\n      if(newLen < dist[node])\n        dist[node] = newLen\n      end\n    end\n  end\n  dist\nend\n\n#\u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u53d6\u5f97\nn = $stdin.gets.to_i\ngraph = Array.new(n).map{Array.new}\nn.times do\n  input = $stdin.gets.split(\" \").map(&:to_i)\n  input[1].times do |t|\n    graph[input[0] - 1] << input[t + 2] - 1\n  end\nend\n\n#\u30d1\u30b1\u30c3\u30c8\u51e6\u7406\n$stdin.gets.to_i.times do\n  s, d, v = $stdin.gets.split(\" \").map(&:to_i)\n  dist = dijkstra(graph, s - 1)\n  if dist[d - 1] + 1 <= v\n    puts dist[d - 1] + 1\n  else\n    puts \"NA\"\n  end\nend", "label": 1, "name1": "s834155894.java", "name2": "s718030625.rb"}, {"id": 910, "code1": "import java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.PrimitiveIterator;\nimport java.util.Scanner;\nimport java.util.function.Supplier;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nclass Main{\n\n\tprivate void solve(){\n\t\tint[] c=new int[26];\n\t\tint h=gInt(),w=gInt();\n\t\tSTRS(h).flatMapToInt(String::chars)\n\t\t\t\t.map(i->i-'a')\n\t\t\t\t.forEach(i->++c[i]);\n\t\tint one=(h%2)*(w%2);\n\n\t\tint two=(w%2==1?h/2*2:0)+(h%2==1?w/2*2:0);\n\t\tint four=h*w-one-two;\n\n\t\tSystem.err.println(one);\n\t\tSystem.err.println(two);\n\t\tSystem.err.println(four);\n\t\tSystem.err.println(Arrays.toString(c));\n\t\tfor(int i:rep(26)) {\n\t\t\twhile(four>0&&c[i]>=4) {\n\t\t\t\tfour-=4;\n\t\t\t\tc[i]-=4;\n\t\t\t}\n\t\t}\n\t\tfor(int i:rep(26)) {\n\t\t\ttwo-=c[i]/2*2;\n\t\t\tc[i]%=2;\n\t\t\tif(two<0) {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfor(int i:rep(26)) {\n\t\t\tone-=c[i];\n\t\t\tc[i]=0;\n\t\t\tif(one<0) {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\n\t\t\t\tArrays.stream(c).noneMatch(i->i>0)\n\t\t\t\t?\"Yes\":\"No\");\n\t}\n\n\tpublic static void main(String[]$){\n\t\tnew Main().solve();\n\t}\n\n\tScanner s=new Scanner(System.in);\n\n\tint gInt(){\n\t\treturn Integer.parseInt(s.next());\n\t}\n\tlong gLong(){\n\t\treturn Long.parseLong(s.next());\n\t}\n\tdouble gDouble(){\n\t\treturn Double.parseDouble(s.next());\n\t}\n\n\tSupplierIterator<Integer> ints(int n){\n\t\treturn new SupplierIterator<>(n,this::gInt);\n\t}\n\tSupplierIterator<Long> longs(int n){\n\t\treturn new SupplierIterator<>(n,this::gLong);\n\t}\n\tSupplierIterator<Double> doubles(int n){\n\t\treturn new SupplierIterator<>(n,this::gDouble);\n\t}\n\tSupplierIterator<String> strs(int n){\n\t\treturn new SupplierIterator<>(n,s::next);\n\t}\n\n\tstatic class SupplierIterator<T> implements Iterable<T>,Iterator<T>{\n\t\tint\t\t\tt;\n\t\tSupplier<T>\tsupplier;\n\n\t\tSupplierIterator(int t,Supplier<T> supplier){\n\t\t\tthis.t=t;\n\t\t\tthis.supplier=supplier;\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<T> iterator(){\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean hasNext(){\n\t\t\treturn t>0;\n\t\t}\n\n\t\t@Override\n\t\tpublic T next(){\n\t\t\t--t;\n\t\t\treturn supplier.get();\n\t\t}\n\t}\n\n\n\tRange rep(int i){\n\t\treturn Range.rep(i);\n\t}\n\tRange rep(int f,int t,int d){\n\t\treturn Range.rep(f,t,d);\n\t}\n\tRange rep(int f,int t){\n\t\treturn rep(f,t,1);\n\t}\n\tRange rrep(int f,int t){\n\t\treturn rep(f,t,-1);\n\t}\n\n\tstatic class Range implements Iterable<Integer>,PrimitiveIterator.OfInt{\n\n\t\tint to,cur,d;\n\n\t\tRange(int from,int to,int d){\n\t\t\tthis.cur=from-d;\n\t\t\tthis.to=to;\n\t\t\tthis.d=d;\n\t\t}\n\n\t\tRange(int n){\n\t\t\tthis(0,n-1,1);\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<Integer> iterator(){\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean hasNext(){\n\t\t\treturn cur+d==to||(cur!=to&&(cur<to==cur+d<to));\n\t\t}\n\n\t\t@Override\n\t\tpublic int nextInt(){\n\t\t\treturn cur+=d;\n\t\t}\n\n\t\tstatic Range rep(int i){\n\t\t\treturn new Range(i);\n\t\t}\n\t\tstatic Range rep(int f,int t,int d){\n\t\t\treturn new Range(f,t,d);\n\t\t}\n\t\tstatic Range rep(int f,int t){\n\t\t\treturn rep(f,t,1);\n\t\t}\n\t\tstatic Range rrep(int f,int t){\n\t\t\treturn rep(f,t,-1);\n\t\t}\n\t}\n\n\n\tIntStream REP(int v){\n\t\treturn IntStream.range(0,v);\n\t}\n\tIntStream REP(int l,int r){\n\t\treturn IntStream.rangeClosed(l,r);\n\t}\n\n\tIntStream INTS(int n){\n\t\treturn REP(n).map(i->gInt());\n\t}\n\tStream<String> STRS(int n){\n\t\treturn REP(n).mapToObj(i->s.next());\n\t}\n}\n", "code2": "a = gets.chomp.split('')\nb = gets.chomp.split('')\nc = gets.chomp.split('')\n\ndef fin(x)\n  puts x\n  exit\nend\n\nt = 'a'\nloop do\n  case t\n  when 'a'\n    fin('A') if a.empty?\n    t = a.shift\n  when 'b'\n    fin('B') if b.empty?\n    t = b.shift\n  when 'c'\n    fin('C') if c.empty?\n    t = c.shift\n  end\nend", "label": 0, "name1": "s705438119.java", "name2": "s327342106.rb"}, {"id": 492, "code1": "import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        int A = scan.nextInt();\n        int B = scan.nextInt();\n        int C = scan.nextInt();\n        if(A == B && A== C){\n            System.out.println(\"No\");\n        }\n        else if(A == B || A == C || B == C){\n            System.out.println(\"Yes\");\n        }\n        else{\n            System.out.println(\"No\");\n        }\n    }\n}", "code2": "a, b, c = gets.chomp.split.map(&:to_i)\n\nif a == b && b == c\n  puts 'No'\nelsif a != b && b != c && a != c\n  puts 'No'\nelse\n  puts 'Yes'\nend", "label": 1, "name1": "s236930555.java", "name2": "s684013173.rb"}, {"id": 956, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            int k = in.nextInt();\n            String ans = \"No\";\n            for (int i = 0; i <= n; i++) {\n                for (int j = 0; j <= m; j++) {\n                    int v = (n - i) * j + i * (m - j);\n                    if (v == k) {\n                        ans = \"Yes\";\n                    }\n                }\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n", "code2": "eval\"N,C,*D=\"+`dd`.split*?,\nr=*0...C\ns,t,u=(0...N*N).group_by{|i|(i/N+i%N)%3}.map{|_,v|r.map{|t|s=0;v.map{|f|s+=D[~-D[~f]*C+t]};s}}\np N<2?0:r.permutation(3).map{|x,y,z|s[x]+t[y]+u[z]}.min", "label": 0, "name1": "s599604936.java", "name2": "s260355932.rb"}, {"id": 984, "code1": "import java.util.Scanner;\n\nclass Main {\n    private static boolean[] calcPrimeTable(int n) {\n        boolean[] table = new boolean[n + 1];\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (!table[i]) {\n                for (int j = i + i; j <= n; j += i) {\n                    table[j] = true;\n                }\n            }\n        }\n        return table;\n    }\n\n    private static void solve() {\n        boolean[] table = calcPrimeTable(1000000);\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            int n = scanner.nextInt();\n            int counter = 0;\n            if (n == 0) {\n                break;\n            }\n            for (int i = 2; i <= n / 2; i++) {\n                if (!table[i] && !table[n - i]) {\n                    counter++;\n                }\n            }\n            System.out.println(counter);\n        }\n    }\n\n    public static void main(String... args) {\n        solve();\n    }\n}", "code2": "S = gets.chomp\nputs (S.size / 2 - 1).downto(1).find{|len| S[0,len] == S[len,len] } * 2\n", "label": 0, "name1": "s735863296.java", "name2": "s181959324.rb"}, {"id": 665, "code1": "import java.util.*;\n\nclass Main {\n    public static void main(String[] args) {\n        new Solver().run();\n    }\n}\n\nclass Solver {\n\n    public void run() {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int[] a = new int[N];\n\n        for (int i = 0; i < N; i++) {\n            a[i] = sc.nextInt();\n            a[i]--;\n        }\n\n        int cnt = 0;\n        for (int i = 0; i < N; i++) {\n            if (i == a[a[i]]) cnt++;\n        }\n\n        System.out.println(cnt / 2);\n\n        return;\n    }\n\n}", "code2": "A, B, C, K = gets.chomp.split(' ').map(&:to_i)\n\nif (A >= K)\n  p K\n  return\nend\n\nif (A + B >= K)\n  p A\n  return\nend\n\np A - (K - (A + B))", "label": 0, "name1": "s246692563.java", "name2": "s053433058.rb"}, {"id": 618, "code1": "\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int W = sc.nextInt();\n\t\t\tfinal int H = sc.nextInt();\n\t\t\t\n\t\t\tif(W == 0  && H == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] map = new int[H][W];\n\t\t\t\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tchar[] input = sc.next().toCharArray();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tif('0' <= input[j] && input[j] <= '9'){\n\t\t\t\t\t\tmap[i][j] = input[j] - '0';\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][] len = new int[H][W];\n\t\t\tshort[][][] dp = new short[H][W][H+W+1];\n\t\t\t\n\t\t\tint max = 0;\n\t\t\tint m_x = -1;\n\t\t\tint m_y = -1;\n\t\t\t\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tif(map[i][j] < 0){\n\t\t\t\t\t\tdp[i][j][0] = -1;\n\t\t\t\t\t\tlen[i][j] = -1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(i == 0 && j == 0){\n\t\t\t\t\t\tdp[i][j][0] = (short)(map[i][j]);\n\t\t\t\t\t\tlen[i][j] = map[i][j] == 0 ? 0 : 1;\n\t\t\t\t\t}else if(j == 0){\n\t\t\t\t\t\tfinal int p_len = len[i-1][j];\n\t\t\t\t\t\tif(p_len == -1){\n\t\t\t\t\t\t\tdp[i][j][0] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = map[i][j] == 0 ? 0 : 1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tSystem.arraycopy(dp[i-1][j], 0, dp[i][j], 0, p_len);\n\t\t\t\t\t\t\tdp[i][j][p_len] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = p_len +  (p_len == 0 && map[i][j] == 0 ? 0 : 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(i == 0){\n\t\t\t\t\t\tfinal int p_len = len[i][j-1];\n\t\t\t\t\t\tif(p_len == -1){\n\t\t\t\t\t\t\tdp[i][j][0] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = map[i][j] == 0 ? 0 : 1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tSystem.arraycopy(dp[i][j-1], 0, dp[i][j], 0, p_len);\n\t\t\t\t\t\t\tdp[i][j][p_len] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = p_len + (p_len == 0 && map[i][j] == 0 ? 0 : 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfinal int left_len = len[i][j-1];\n\t\t\t\t\t\tfinal int up_len = len[i-1][j];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(left_len == -1 && up_len == -1){\n\t\t\t\t\t\t\tdp[i][j][0] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = map[i][j] == 0 ? 0 : 1;\n\t\t\t\t\t\t}else if(left_len > up_len){\n\t\t\t\t\t\t\tfinal int p_len = len[i][j-1];\n\t\t\t\t\t\t\tSystem.arraycopy(dp[i][j-1], 0, dp[i][j], 0, p_len);\n\t\t\t\t\t\t\tdp[i][j][p_len] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = p_len + (p_len == 0 && map[i][j] == 0 ? 0 : 1);\n\t\t\t\t\t\t}else if(left_len < up_len){\n\t\t\t\t\t\t\tfinal int p_len = len[i-1][j];\n\t\t\t\t\t\t\tSystem.arraycopy(dp[i-1][j], 0, dp[i][j], 0, p_len);\n\t\t\t\t\t\t\tdp[i][j][p_len] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = p_len + (p_len == 0 && map[i][j] == 0 ? 0 : 1);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tfinal int size = len[i][j-1];\n\t\t\t\t\t\t\tboolean left_f = true;\n\t\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\t\tif(dp[i-1][j][k] < dp[i][j-1][k]){\n\t\t\t\t\t\t\t\t\tleft_f = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}else if(dp[i-1][j][k] > dp[i][j-1][k]){\n\t\t\t\t\t\t\t\t\tleft_f = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(left_f){\n\t\t\t\t\t\t\t\tfinal int p_len = len[i][j-1];\n\t\t\t\t\t\t\t\tSystem.arraycopy(dp[i][j-1], 0, dp[i][j], 0, p_len);\n\t\t\t\t\t\t\t\tdp[i][j][p_len] = (short)(map[i][j]);\n\t\t\t\t\t\t\t\tlen[i][j] = p_len + (p_len == 0 && map[i][j] == 0 ? 0 : 1);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tfinal int p_len = len[i-1][j];\n\t\t\t\t\t\t\t\tSystem.arraycopy(dp[i-1][j], 0, dp[i][j], 0, p_len);\n\t\t\t\t\t\t\t\tdp[i][j][p_len] = (short)(map[i][j]);\n\t\t\t\t\t\t\t\tlen[i][j] = p_len + (p_len == 0 && map[i][j] == 0 ? 0 : 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(max < len[i][j]){\n\t\t\t\t\t\tmax = len[i][j];\n\t\t\t\t\t\tm_x = j;\n\t\t\t\t\t\tm_y = i;\n\t\t\t\t\t}else if(max == len[i][j]){\n\t\t\t\t\t\tfinal int size = len[i][j];\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(dp[m_y][m_x][k] < dp[i][j][k]){\n\t\t\t\t\t\t\t\tmax = len[i][j];\n\t\t\t\t\t\t\t\tm_x = j;\n\t\t\t\t\t\t\t\tm_y = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(dp[m_y][m_x][k] > dp[i][j][k]){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tSystem.out.printf(\"%2d \", len[i][j]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t*/\n\t\t\tfor(int i = 0; i < max; i++){\n\t\t\t\tSystem.out.print(dp[m_y][m_x][i]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t\n\t}\n\n}", "code2": "gets\na = gets.chomp.split.map(&:to_i)\na = a.sort.reverse\n\ncount = 0\n\n(a.count - 1).times do |i|\n  count += a[((i + 1) / 2.0).to_i]\nend\n\np count\n", "label": 0, "name1": "s531751281.java", "name2": "s913271199.rb"}, {"id": 941, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int N = in.nextInt();\n            int A[] = new int[2 * N - 1];\n            for (int i = 0; i < 2 * N - 1; i++) {\n                A[i] = in.nextInt();\n            }\n\n            int lo = 0, hi = 2 * N;\n\n            while (lo + 1 < hi) {\n                int mid = lo + (hi - lo) / 2;\n\n                if (onTopAtLeast(mid, A)) {\n                    lo = mid;\n                } else {\n                    hi = mid;\n                }\n            }\n\n            out.println(lo);\n        }\n\n        private boolean onTopAtLeast(int x, int[] a) {\n            int LEN = a.length; // LEN = 2*N-1\n            int[] b = new int[LEN];\n            for (int i = 0; i < LEN; i++) {\n                b[i] = a[i] < x ? 0 : 1;\n            }\n            int[] c = new int[LEN - 2];\n            for (int i = 1; i < LEN - 1; i++) {\n                c[i - 1] = b[i - 1] + b[i] + b[i + 1] < 2 ? 0 : 1;\n            }\n\n            int MID = c.length / 2;\n            int left = MID;\n            int right = MID;\n\n            while (left > 0 && c[left - 1] != c[left]) left--;\n            while (right < c.length - 1 && c[right] != c[right + 1]) right++;//C[1, 2*N-3]\n\n            int ANS = (MID - left < right - MID) ? c[left] : c[right];\n\n            return ANS == 1;\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n", "code2": "puts gets.count('2')", "label": 0, "name1": "s219661576.java", "name2": "s627016600.rb"}, {"id": 62, "code1": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        try(Scanner scn = new Scanner(System.in)) {\n            int sum = scn.nextInt() + scn.nextInt() + scn.nextInt() + scn.nextInt();\n            System.out.println(sum / 60);\n            System.out.println(sum % 60);\n        }\n    }\n}", "code2": "while x=gets\n a=x.chomp.to_i\n sum=a\n 3.times do\n  b=gets.chomp.to_i\n  sum=sum+b\n end\n m=sum/60\n s=sum%60\n puts m.to_s\n puts s.to_s\nend", "label": 1, "name1": "s061388848.java", "name2": "s557772765.rb"}, {"id": 748, "code1": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tstatic void solve() {\n\t\tlong i = ni(), o = ni(), t = ni(), j = ni(), l = ni(), s = ni(), z = ni();\n\t\tlong ans = 0;\n\t\tans += o;\n\t\t\n\t\t\n\t\tlong rem = i%2+j%2+l%2;\n\t\tif(i==0||j==0||l==0) {\n\t\t\tans += 2*(i/2 + j/2 + l/2);\n\t\t\tout.println(ans);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(rem<=1) {\n\t\t\tans += 2*(i/2 + j/2 + l/2);\n\t\t}\n\t\telse {\n\t\t\tans += 3;\n\t\t\ti--; j--;l--;\n\t\t\tans += 2*(i/2 + j/2 + l/2);\n\t\t}\n\t\tout.println(ans);\n\t\t\n\t}\n\n\t//constant\n\tstatic final long mod = (long) 1e9 + 7;\n\tstatic final int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };\n\tstatic final int[] dx8 = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\tstatic final int inf = Integer.MAX_VALUE / 2;\n\tstatic final long linf = Long.MAX_VALUE / 3;\n\tstatic final double dinf = Double.MAX_VALUE / 3;\n\tstatic final double eps = 1e-10;\n\tstatic final double pi = Math.PI;\n\tstatic StringBuilder sb = new StringBuilder();\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\t//libraries\n\tstatic void reverse(int ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tint t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(long ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tlong t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(double ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tdouble t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(char ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tchar t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic String getReverse(String s) {\n\t\tchar c[] = s.toCharArray();\n\t\treverse(c);\n\t\ts = String.valueOf(c);\n\t\treturn s;\n\t}\n\n\tstatic <T> void reverse(List<T> ls) {\n\t\tint sz = ls.size();\n\t\tfor (int i = 0; i < sz / 2; i++) {\n\t\t\tT t = ls.get(i);\n\t\t\tls.set(i, ls.get(sz - 1 - i));\n\t\t\tls.set(sz - 1 - i, t);\n\t\t}\n\t}\n\n\tstatic <T> void reverse(T[] ar) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tT t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void sbnl() {//StringBuilder\u306b\u6539\u884c\u6587\u5b57\u3092append\u3059\u308b\n\t\tsb.append(\"\\n\");\n\t}\n\n\tstatic int lowerBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int lowerBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int lowerBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int lowerBound(char[] a, char x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(char[] a, char x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(char[] a, char x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(char[] a, char x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic <T> int lowerBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) >= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) >= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) >= 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int upperBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) > 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) > 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) > 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int rupperBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) < 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) < 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) < 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int rlowerBound(List<T> ls, T x) {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) <= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) <= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) <= 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic int[] concat(int x, int arr[]) {\n\t\tint ret[] = new int[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 1, ret.length - 1);\n\t\tret[0] = x;\n\t\treturn ret;\n\t}\n\n\tstatic int[] concat(int arr[], int x) {\n\t\tint ret[] = new int[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 0, ret.length - 1);\n\t\tret[ret.length - 1] = x;\n\t\treturn ret;\n\t}\n\n\tstatic long[] concat(long x, long arr[]) {\n\t\tlong ret[] = new long[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 1, ret.length - 1);\n\t\tret[0] = x;\n\t\treturn ret;\n\t}\n\n\tstatic long[] concat(long arr[], long x) {\n\t\tlong ret[] = new long[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 0, ret.length - 1);\n\t\tret[ret.length - 1] = x;\n\t\treturn ret;\n\t}\n\n\tstatic int max(int x, int y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic int min(int x, int y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic int max(int x, int y, int z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic int min(int x, int y, int z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic long max(long x, long y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic long min(long x, long y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic long max(long x, long y, long z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic long min(long x, long y, long z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic double max(double x, double y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic double min(double x, double y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic double max(double x, double y, double z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic double min(double x, double y, double z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic void sort(int[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void sort(long[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void sort(double[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void sort(char[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void rsort(int[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tint tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void rsort(long[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tlong tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void rsort(double[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tdouble tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void rsort(char[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tchar tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void fill(int arr[], int x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(long arr[], long x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(boolean arr[], boolean x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(double arr[], double x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(int arr[][], int x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(long arr[][], long x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(double arr[][], double x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(boolean arr[][], boolean x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\t//MOD culc\n\tstatic long plus(long x, long y) {\n\t\tlong res = (x + y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long sub(long x, long y) {\n\t\tlong res = (x - y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long mul(long x, long y) {\n\t\tlong res = (x * y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long div(long x, long y) {\n\t\tlong res = x * pow(y, mod - 2) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long pow(long x, long y) {\n\t\tif (y < 0)\n\t\t\treturn 0;\n\t\tif (y == 0)\n\t\t\treturn 1;\n\t\tif (y % 2 == 1)\n\t\t\treturn (x * pow(x, y - 1)) % mod;\n\t\tlong root = pow(x, y / 2);\n\t\treturn root * root % mod;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\t//input\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static long[] nla(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n}\n", "code2": "#!/usr/bin/ruby\nh,w=gets.split.map(&:to_i)\nm=$<.map{|e|e.chomp[1..-2]}\n2.times{|i|h.times{|y|\n\tif i==0\n\t\tif y%2==0\n\t\t\tputs '#'*(w-1)+'.'\n\t\telse\n\t\t\tputs '#'+m[y]+'.'\n\t\tend\n\telse\n\t\tif y%2==0\n\t\t\tputs '.'+m[y]+'#'\n\t\telse\n\t\t\tputs '.'+'#'*(w-1)\n\t\tend\n\tend\n};puts}", "label": 0, "name1": "s751122857.java", "name2": "s030629079.rb"}, {"id": 744, "code1": "import java.util.ArrayList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n/**\n * Created by shoya on 2017/04/12.\n */\npublic class Main {\n    public static void main(String... args) {\n        Scanner sc = new Scanner(System.in);\n        int V = sc.nextInt();\n        int E = sc.nextInt();\n        int r = sc.nextInt();\n        DijkstraClass dijkstra = new DijkstraClass(V, E, r);\n        for (int i = 0; i < E; i++) {\n            int s = sc.nextInt();\n            int d = sc.nextInt();\n            int c = sc.nextInt();\n            dijkstra.addDistande(s, d, c);\n        }\n        int[] dist = dijkstra.dikstra();\n        for (int i = 0; i < dist.length; i++){\n            if (dist[i] == 1 << 30)\n                System.out.println(\"INF\");\n            else\n                System.out.println(dist[i]);\n        }\n        return;\n    }\n\n\n    private static class DijkstraClass {\n        class edge{\n            int dest, cost;\n            edge(int dest, int cost){\n                this.dest = dest;\n                this.cost = cost;\n            }\n        }\n\n        private final int INF = 1 << 30;\n        private int S;\n        private int V;\n        private ArrayList<ArrayList<edge>> edgesOfNodes = new ArrayList<ArrayList<edge>>();\n\n        DijkstraClass(int V, int E, int Start){\n            this.S = Start;\n            this.V = V;\n            for (int i = 0; i < V; i++)\n                edgesOfNodes.add(new ArrayList<edge>());\n        }\n\n        void addDistande(int source, int dest, int cost){\n            edgesOfNodes.get(source).add(new edge(dest, cost));\n        }\n\n\n        int[] dikstra(){\n            class costAndNode implements Comparable {\n                int cost, node;\n                costAndNode(int cost, int node){\n                    this.cost = cost;\n                    this.node = node;\n                }\n                @Override\n                public int compareTo(Object o) {\n                    return this.cost - ((costAndNode) o).cost;\n                }\n            }\n\n            PriorityQueue<costAndNode> pque = new PriorityQueue<costAndNode>();\n            int[] distances = new int[V];\n            for (int i = 0; i < V; i++)\n                distances[i] = INF;\n            distances[S] = 0;\n\n            pque.add(new costAndNode(0, S));\n            while (!pque.isEmpty()){\n                costAndNode item = pque.poll();\n                if (distances[item.node] < item.cost)\n                    continue;\n\n                //System.out.printf(\"Focusing on Node %d\\n\", item.node);\n                //for (int i = 0; i < V; i++)\n                //    System.out.printf(\"%d \", distances[i]);\n                //System.out.println();\n\n                for (edge e : edgesOfNodes.get(item.node)) {\n                    //System.out.printf(\"Node %d -> %d, Cost %d -> %d\\n\",\n                    //        item.node, e.dest, distances[e.dest],\n                    //        distances[item.node] + e.cost);\n                    if (distances[e.dest] > distances[item.node] + e.cost) {\n                        distances[e.dest] = distances[item.node] + e.cost;\n                        pque.add(new costAndNode(distances[e.dest], e.dest));\n                    }\n                }\n            }\n\n            return distances;\n        }\n\n    }\n}", "code2": "H, W = gets.split.map(&:to_i)\nas = []\nH.times do |i|\n    as[i] = gets.chomp\nend\n\nrs = Array.new(H){Array.new(W, '.')}\nbs = Array.new(H){Array.new(W, '.')}\nrs[0] = Array.new(W, '#')\nbs[H-1] = Array.new(W, '#')\n\n(1...(H-1)).each do |i|\n    W.times do |j|\n        if as[i][j] == '#' || j % 2 == 0\n            rs[i][j] = '#'\n        end\n        if as[i][j] == '#' || j % 2 == 1\n            bs[i][j] = '#'\n        end\n    end\nend\n\nH.times do |i|\n    puts rs[i].join\nend\n\nputs\n\nH.times do |i|\n    puts bs[i].join\nend", "label": 0, "name1": "s575620429.java", "name2": "s600860222.rb"}, {"id": 488, "code1": "\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int A = scanner.nextInt();\n        int B = scanner.nextInt();\n        int C = scanner.nextInt();\n\n        if ((A == B && A != C) || (A == C && A != B) || (B == C &&  A != B)) {\n            System.out.println(\"Yes\");\n        } else {\n            System.out.println(\"No\");\n        }\n    }\n}\n", "code2": "a, b, c = gets.chomp.split.map(&:to_i)\n\nif a == b && b == c\n  puts 'No'\nelsif a != b && b != c && a != c\n  puts 'No'\nelse\n  puts 'Yes'\nend", "label": 1, "name1": "s748781959.java", "name2": "s684013173.rb"}, {"id": 807, "code1": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t// \u5165\u529b\n\t\tint n = sc.nextInt();\n\t\tGraph g = new Graph(n, false);\n\t\tfor(int i = 0; i < n-1; i++){\n\t\t    int a = sc.nextInt() - 1;\n\t\t    int b = sc.nextInt() - 1;\n\t\t    g.add(a, b);\n\t\t}\n\t\t\n\t\t// \u8a08\u7b97\n\t\tString result = \"Snuke\";\n\t\tlong[] distFromB = g.dijkstra(0);\n\t\tlong[] distFromW = g.dijkstra(n-1);\n\t\tint cnt = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t    if(distFromB[i] <= distFromW[i]) cnt++;\n\t\t}\n\t\tif(cnt > (n-cnt)) result = \"Fennec\";\n\t\t\n\t\t// \u51fa\u529b\n\t\tSystem.out.println(result);\n\t}\n\n}\n\nclass Graph {\n\tint n;\n\tboolean directed;\n\tArrayList<Edge>[] adjList;\n\tint m;\n\tlong[] dist;\n\tlong[][] distWF;\n\tint start;\n\tint[] prev;\n\tArrayList<Integer> path;\n\tlong INF = 1001001001001001001L;\n\n\tpublic Graph (int n, boolean directed) {\n\t\tthis.n = n;\n\t\tthis.m = 0;\n\t\tthis.directed = directed;\n\t\tthis.adjList = new ArrayList[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tadjList[i] = new ArrayList<Edge>();\n\t\t}\n\t}\n\t\n\tpublic void add(int from, int to) {\n\t\tadd(from, to, 1);\n\t}\n\tpublic void add(int from, int to, int w) {\n\t\tadjList[from].add(new Edge(from, to, w));\n\t\tthis.m++;\n\t\tif(!directed){\n\t\t\tadjList[to].add(new Edge(to, from, w));\n\t\t\tthis.m++;\n\t\t}\n\t}\n\t\n\tpublic long[] bfs(int start) { // O(M)\n\t\tthis.start = start;\n\t\tthis.prev = new int[n];\n\t\tArrays.fill(prev, -1);\n\t\tprev[start] = start;\n\t\tthis.dist = new long[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[start] = 0;\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tq.add(start);\n\t\twhile(!q.isEmpty()){\n\t\t\tint now = q.poll();\n\t\t\tfor(Edge e : adjList[now]){\n\t\t\t\tif(dist[e.to] != INF) continue;\n\t\t\t\tdist[e.to] = dist[now] + e.w;\n\t\t\t\tprev[e.to] = now;\n\t\t\t\tq.add(e.to);\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\t\n\tpublic long[] dijkstra(int start) { // O(MlogM)\n\t\tthis.start = start;\n\t\tthis.prev = new int[n];\n\t\tArrays.fill(prev, -1);\n\t\tprev[start] = start;\n\t\tthis.dist = new long[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[start] = 0;\n\t\tPriorityQueue<Vertex> q = new PriorityQueue<Vertex>((x, y) -> Long.compare(x.distance, y.distance));\n\t\tq.add(new Vertex(start, 0));\n\t\twhile(!q.isEmpty()){\n\t\t\tVertex now = q.poll();\n\t\t\tif(now.distance > dist[now.id]) continue; \n\t\t\tfor(Edge e : adjList[now.id]){\n\t\t\t\tlong newDist = now.distance + e.w;\n\t\t\t\tif(dist[e.to] <= newDist) continue;\n\t\t\t\tdist[e.to] = newDist;\n\t\t\t\tprev[e.to] = now.id;\n\t\t\t\tq.add(new Vertex(e.to, newDist));\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\t\n\tpublic long[][] wf() { // O(N^3)\n\t\tthis.distWF = new long[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tArrays.fill(distWF[i], INF);\n\t\t\tdistWF[i][i] = 0;\n\t\t}\n\t\tfor(ArrayList<Edge> list : adjList){\n\t\t\tfor(Edge e : list){\n\t\t\t\tdistWF[e.from][e.to] = e.w;\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < n; k++){\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tdistWF[i][j] = min(distWF[i][j], distWF[i][k] + distWF[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn distWF;\n\t}\n\t\n\tpublic boolean bf(int start) { // O(NM)\n\t\tthis.start = start;\n\t\tthis.prev = new int[n];\n\t\tArrays.fill(prev, -1);\n\t\tprev[start] = start;\n\t\tthis.dist = new long[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[start] = 0;\n\t\tboolean hasNegativeLoop = false;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tfor(Edge e : adjList[j]){\n\t\t\t\t\tif(dist[e.to] <= dist[e.from] + e.w) continue;\n\t\t\t\t\tdist[e.to] = dist[e.from] + e.w;\n\t\t\t\t\tprev[e.to] = e.from;\n\t\t\t\t\tif(i == n-1) hasNegativeLoop = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn hasNegativeLoop;\n\t}\n\t\n\tpublic ArrayList<Integer> pathTo(int to){\n\t\tthis.path = new ArrayList<Integer>();\n\t\treturn pathToRec(to);\n\t}\n\t\n\tprivate ArrayList<Integer> pathToRec(int to){\n\t\tif(to != start) pathToRec(prev[to]);\n\t\tpath.add(to);\n\t\treturn path;\n\t}\n\t\n\tpublic String toString(){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(ArrayList<Edge> list : adjList){\n\t\t\tfor(Edge e : list){\n\t\t\t\tsb.append(e.toString());\n\t\t\t\tsb.append(\"\\n\");\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tpublic String distToString(){\n\t\tif(dist != null) return Arrays.toString(dist);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(distWF[i][j] == INF){\n\t\t\t\t\tsb.append(\"from:\" + i + \" to:\" + j + \" dist:INF\" + \"\\n\");\n\t\t\t\t}else{\n\t\t\t\t\tsb.append(\"from:\" + i + \" to:\" + j + \" dist:\" + distWF[i][j] + \"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tclass Edge {\n\t\tint from;\n\t\tint to;\n\t\tint w;\n\t\t\n\t\tEdge(int from, int to, int w){\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"from:\" + from + \" to:\" + to + \" w:\" + w;\n\t\t}\n\t}\n\t\n\tclass Vertex {\n\t\tint id;\n\t\tlong distance;\n\t\t\n\t\tVertex(int id, long distance){\n\t\t\tthis.id = id;\n\t\t\tthis.distance = distance;\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"id:\" + id + \" distance:\" + distance;\n\t\t}\n\t}\n}\n", "code2": "n = gets.chomp.to_i\na_arr = gets.chomp.split(\" \").map(&:to_i)\nb_arr = gets.chomp.split(\" \").map(&:to_i)\n\nsum_a = 0\nsum_b = 0\ncount1 = 0\ncount2 = 0\n(0..n-1).each do |i|\n  sum_a += a_arr[i]\n  sum_b += b_arr[i]\n  if a_arr[i] > b_arr[i]\n    count1 += a_arr[i] - b_arr[i]\n  else\n    count2 += ((b_arr[i] - a_arr[i]) / 2.to_f).ceil\n  end\nend\nif sum_b - sum_a >= [count1, count2].max\n  puts \"Yes\"\nelse\n  puts \"No\"\nend\n", "label": 0, "name1": "s816087530.java", "name2": "s183505009.rb"}, {"id": 211, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    void solve() throws IOException {\n    \tint N = ni();\n\n    \tint[] T = new int[N];\n    \tint[] A = new int[N];\n\n    \tfor (int i=0; i<N; i++) {\n\t\t\tT[i] = ni();\n\t\t\tA[i] = ni();\n\t\t}\n\n    \tlong t = T[0];\n    \tlong a = A[0];\n\n    \tfor (int i=1; i<N; i++) {\n    \t\tlong x = (t%T[i]==0)? t/T[i] : (t/T[i] + 1);\n    \t\tlong y = (a%A[i]==0)? a/A[i] : (a/A[i] + 1);\n    \t\tt = T[i] * Math.max(x, y);\n    \t\ta = A[i] * Math.max(x, y);\n    \t}\n\n    \tout.println(t + a);\n    }\n\n    String ns() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine(), \" \");\n        }\n        return tok.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.parseInt(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.parseLong(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.parseDouble(ns());\n    }\n\n    String[] nsa(int n) throws IOException {\n        String[] res = new String[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ns();\n        }\n        return res;\n    }\n\n    int[] nia(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ni();\n        }\n        return res;\n    }\n\n    long[] nla(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nl();\n        }\n        return res;\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        tok = new StringTokenizer(\"\");\n        Main main = new Main();\n        main.solve();\n        out.close();\n    }\n}\n", "code2": "n = gets.to_i\nratio = gets.split(\" \").map(&:to_i)\n\n(n - 1).times do\n  new_ratio = gets.split(\" \").map(&:to_i)\n  amp = new_ratio.zip(ratio).map do |nr, r|\n    r / nr + (r % nr == 0 ? 0 : 1)\n  end.max\n  ratio = new_ratio.map { |r| r * amp }\nend\n\nputs ratio.inject(&:+)", "label": 1, "name1": "s760488688.java", "name2": "s730519785.rb"}, {"id": 892, "code1": "public class Main {\n\tpublic static void main(String[] args){\n\t\tfor(int i=0; i<1000; i++){\n\t\t\tSystem.out.println(\"Hello World\");\n\t\t}\n\t}\n\n}", "code2": "N,M=$<.read.split.map(&:to_i)\n\nputs ((N-M)*100+M*1900)*(2**M)", "label": 0, "name1": "s362909688.java", "name2": "s652082327.rb"}, {"id": 221, "code1": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        Main main = new Main();\n        main.solve();\n    }\n\n    public void solve() {\n        Scanner scan = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n        int N = scan.nextInt();\n        List<Integer> candidate = new ArrayList<>();\n        for (int i = 1; i <= N; i++) {\n            candidate.add(i);\n        }\n        scan.nextLine();\n        String p = scan.nextLine();\n        String q = scan.nextLine();\n        List<List<Integer>> list = make(candidate);\n        List<String> strings = new ArrayList();\n        for (List<Integer> x : list) {\n            strings.add(x.stream().map(i -> i.toString()).collect(Collectors.joining(\" \")));\n        }\n        int len = strings.size();\n        int l = 0;\n        int r = 0;\n        for (int i = 0; i < len; i++) {\n            if (p.equals(strings.get(i))) {\n                l = i;\n            }\n            if (q.equals(strings.get(i))) {\n                r = i;\n            }\n        }\n        System.out.println(Math.abs(l - r));\n    }\n\n    public static List<List<Integer>> make(List<Integer> candidate) {\n        if (candidate.size() == 0) {\n            List<List<Integer>> empty = new ArrayList<>();\n            empty.add(new ArrayList<>());\n            return empty;\n        }\n\n        return candidate.stream().flatMap(i -> {\n            List<Integer> rest = new ArrayList<>(candidate);\n            rest.remove(i);\n            return make(rest).stream().map(list -> {\n                list.add(0, i);\n                return list;\n            });\n        }).collect(Collectors.toList());\n    }\n}\n", "code2": "N = gets.to_i\nP = gets.split.map &:to_i\nQ = gets.split.map &:to_i\nps = [*1..N].permutation(N).to_a\n\na = ps.index P\nb = ps.index Q\n\np (a - b).abs", "label": 1, "name1": "s162956680.java", "name2": "s709261522.rb"}, {"id": 440, "code1": "import java.io.*;\nimport java.util.*;\n\n/**\n *\n * @author baito\n */\nclass UnionFindTree\n{\n    int[] par;\n    int[] rank;\n    int[] sizes;\n\n    UnionFindTree(int n)\n    {\n        par = new int[n];\n        rank = new int[n];\n        sizes = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            par[i] = i;\n            rank[i] = 0;\n            sizes[i] = 1;\n        }\n    }\n\n    int find(int x)\n    {\n        if (par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n\n    void unite(int x, int y)\n    {\n        x = find(x);\n        y = find(y);\n\n        if (x == y) return;\n        if (rank[x] < rank[y])\n        {\n            par[x] = y;\n            sizes[y] += sizes[x];\n        }\n        else\n        {\n            par[y] = x;\n            sizes[x] += sizes[y];\n            if (rank[x] == rank[y]) rank[x]++;\n        }\n    }\n\n    boolean same(int x, int y)\n    {\n        return find(x) == find(y);\n    }\n\n    int size(int x)\n    {\n        return sizes[par[x]];\n    }\n}\npublic class Main\n{\n    static StringBuilder sb = new StringBuilder();\n    static FastScanner sc = new FastScanner(System.in);\n    static int INF = 10000;\n    static long MOD =1000000007;\n    static long[] f;//factorial\n    static int[] y4 = {0,1,0,-1};\n    static int[] x4 = {1,0,-1,0};\n    static int[] y8 = {0,1,0,-1,-1,1,1,-1};\n    static int[] x8 = {1,0,-1,0,1,-1,1,-1};\n\n    static int N,K,L;\n\n    public static void main(String[] args)\n    {\n\n        N = sc.nextInt();\n        K = sc.nextInt();\n        L = sc.nextInt();\n        UnionFindTree u1 = new UnionFindTree(N);\n        UnionFindTree u2 = new UnionFindTree(N);\n        //long\u3092\u5fd8\u308c\u308b\u306a\u30aa\u30fc\u30d0\u30fc\u30d5\u30ed\u30fc\u3059\u308b\u305e\n        for (int i = 0; i < K; i++)\n        {\n            int p = sc.nextInt()-1;\n            int q = sc.nextInt()-1;\n            u1.unite(p,q);\n        }\n        for (int i = 0; i < L; i++)\n        {\n            int p = sc.nextInt()-1;\n            int q = sc.nextInt()-1;\n            u2.unite(p,q);\n        }\n        Map<Long,Integer> sizes = new HashMap<>();\n        for (int i = 0; i < N; i++)\n        {\n            long root1 = u1.find(i);\n            long root2 = u2.find(i);\n            long hash = root1 * 1000000L + root2;\n            int value = sizes.containsKey(hash) ? sizes.get(hash):0;\n            sizes.put(hash,value+1);\n\n\n        }\n        for (int i = 0; i < N; i++)\n        {\n            long root1 = u1.find(i);\n            long root2 = u2.find(i);\n            long hash = root1 * 1000000L + root2;\n            System.out.println(sizes.get(hash));\n        }\n\n\n\n    }\n    //\u2193nCr\u3092mod\u8a08\u7b97\u3059\u308b\u305f\u3081\u306b\u5fc5\u8981\u3002\u3000***factorial(N)\u3092\u547c\u3076\u5fc5\u8981\u304c\u3042\u308b***\n    static long comb(int n, int r)\n    {\n        long result = f[n];\n        result = result * modInv(f[n - r]) % MOD;\n        result = result * modInv(f[r]) % MOD;\n        return result;\n    }\n\n    static long modInv(long n)\n    {\n        return modPow(n, MOD - 2);\n    }\n\n    static void factorial(int n)\n    {\n        f = new long[n + 1];\n        f[0] = f[1] = 1;\n        for (int i = 2; i <= n; i++)\n        {\n            f[i] = (f[i - 1] * i) % MOD;\n        }\n    }\n\n    static long modPow(long x, long n)\n    {\n        long res = 1L;\n        while (n > 0)\n        {\n            if ((n & 1) == 1)\n            {\n                res = res * x % MOD;\n            }\n            x = x * x % MOD;\n            n >>= 1;\n        }\n        return res;\n    }\n\n    //\u2191nCr\u3092mod\u8a08\u7b97\u3059\u308b\u305f\u3081\u306b\u5fc5\u8981\n\n    static int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n    static long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\n    static <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n    static void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n    public static void reverse(int[] x)\n    {\n        int l = 0;\n        int r = x.length - 1;\n        while (l < r)\n        {\n            int temp = x[l];\n            x[l] = x[r];\n            x[r] = temp;\n            l++;\n            r--;\n        }\n    }\n    public static void reverse(int[] x,int s, int e)\n    {\n        int l = s;\n        int r = e;\n        while (l < r)\n        {\n            int temp = x[l];\n            x[l] = x[r];\n            x[r] = temp;\n            l++;\n            r--;\n        }\n    }\n    static int length(int a) {int cou = 0; while(a != 0){ a /= 10; cou++; } return cou;}\n    static int length(long a) {int cou = 0; while(a != 0){ a /= 10; cou++; } return cou;}\n    static int countC2(char[][] a, char c){\n        int co = 0;\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[0].length; j++)\n                if(a[i][j] == c)\n                    co++;\n        return co;\n    }\n    static void fill(int[][] a, int v){\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[0].length; j++)\n                a[i][j] = v;\n    }\n    static class FastScanner {\n\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        public String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        /*public String nextChar(){\n            return (char)next()[0];\n        }*/\n        public String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n        public int [][] nextIntArray2(int h, int w){\n            int[][] a = new int[h][w];\n            for(int hi = 0 ; hi < h ; hi++){\n                for(int wi = 0 ; wi < w ; wi++){\n                    a[hi][wi] = nextInt();\n                }\n            }\n            return a;\n        }\n        public Integer[] nextIntegerArray(int n) {\n            Integer[] a = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n        public char[] nextCharArray(int n){\n            char[] a = next().toCharArray();\n\n            return a;\n        }\n        public char[][] nextCharArray2(int h , int w){\n            char[][] a = new char[h][w];\n            for (int i = 0; i < h; i++) {\n                a[i] = next().toCharArray();\n            }\n            return a;\n        }\n        //\u30b9\u30da\u30fc\u30b9\u304c\u5165\u3063\u3066\u3044\u308b\u5834\u5408\n        public char[][] nextCharArray2s(int h , int w){\n            char[][] a = new char[h][w];\n            for (int i = 0; i < h; i++) {\n                a[i] = nextLine().replace(\" \",\"\").toCharArray();\n            }\n            return a;\n        }\n        public char[][] nextWrapCharArray2(int h , int w, char c){\n            char[][] a = new char[h + 2][w + 2];\n            //char c = '*';\n            int i;\n            for (i = 0; i < w + 2; i++)\n                a[0][i] = c;\n            for (i = 1; i < h + 1; i++) {\n                a[i] = (c + next() + c).toCharArray();\n            }\n            for (i = 0; i < w + 2; i++)\n                a[h + 1][i] = c;\n            return a;\n        }\n        //\u30b9\u30da\u30fc\u30b9\u304c\u5165\u3063\u3066\u308b\u6642\u7528\n        public char[][] nextWrapCharArray2s(int h , int w ,char c){\n            char[][] a = new char[h + 2][w + 2];\n            //char c = '*';\n            int i;\n            for (i = 0; i < w + 2; i++)\n                a[0][i] = c;\n            for (i = 1; i < h + 1; i++) {\n                a[i] = (c + nextLine().replace(\" \",\"\") + c).toCharArray();\n            }\n            for (i = 0; i < w + 2; i++)\n                a[h + 1][i] = c;\n            return a;\n        }\n        public long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextLong();\n            }\n            return a;\n        }\n        public long [][] nextLongArray2(int h, int w){\n            long[][] a = new long[h][w];\n            for(int hi = 0 ; hi < h ; hi++){\n                for(int wi = 0 ; wi < h ; wi++){\n                    a[h][w] = nextLong();\n                }\n            }\n            return a;\n        }\n    }\n}\n", "code2": "def inp() a=gets.chomp.split(\" \").map(&:to_i)end \ndef inpf() a=gets.chomp.split(\" \").map(&:to_f)end\ndef inps() a=gets.chomp.split(\" \")end  \ndef copy(a) Marshal.load(Marshal.dump(a)) end\ndef kaizyo(n)(n < 2)? 1 : (2..n).inject(:*) end\ndef scount(a) b = na(a.max+1); a.each{|n|b[n]+=1};return b end\ndef na(n=0,d=0) Array.new(n,d)end\ndef na2(n,m,d=0) Array.new(n){Array.new(m,d)}end\ndef na3(n,m,l,d=0) Array.new(n){Array.new(m){Array.new(l,d)}}end\ndef uf(a,x)\n  return x if (a[x] == x)\n  a[x] = uf(a,a[x])\nend\ndef ufa(a,x,p,rank)\n  root  = uf(a,x)\n  connect  = uf(a,p)\n  return if root == connect\n  if rank[root] > rank[connect]\n    a[connect] = root\n  elsif rank[root] == rank[connect]\n    a[connect] = root\n    rank[root] += 1\n  else\n    a[root] = connect\n  end\nend\nh = {}\nn,k,l = inp\ndk = na2(n+1,0)\nda = na(n+1)\ndl = na2(n+1,0)\ndb = na(n+1)\nra = na(n+1)\nrb = na(n+1)\n(n+1).times do |i|\n  da[i] = i\n  db[i] = i\nend\n(k).times do |i|\n  d = inp\n  ufa(da,d[1],d[0],ra)\nend\n(l).times do |i|\n  d = inp\n  ufa(db,d[1],d[0],rb)\nend\n(1..n).each do |i|\n  uf(db,i)\n  uf(da,(i))\nend\n(1..n).each do |i|\n  h[[da[i],db[i]]] = 0 if(h[[da[i],db[i]]] == nil)\n  h[[da[i],db[i]]] += 1\nend\n(1..n-1).each do |i|\n  print \"#{h[[da[i],db[i]]]} \" \nend\nputs h[[da[n],db[n]]]\n=begin\nmax = c if max < c \n=end", "label": 1, "name1": "s138073781.java", "name2": "s121422577.rb"}, {"id": 678, "code1": "\nimport java.util.*;\n\npublic class Main {\n    public static void main(final String[] args) {\n        final Scanner sc = new Scanner(System.in);\n        // \u6574\u6570\u306e\u5165\u529b\n        // final int a = sc.nextInt();\n        // \u6587\u5b57\u5217\u306e\u5165\u529b\n        // final String s1 = sc.next();\n        final int a = sc.nextInt();\n        final int b = sc.nextInt();\n        final int c = sc.nextInt();\n        final int k = sc.nextInt();\n        sc.close();\n        int result = 0;\n        if (a >= k) {\n            result = k;\n        } else if (b >= k - a) {\n            result = a;\n        } else if (c >= k - b - a) {\n            result = 2 * a + b - k;\n        }\n\n        System.out.println(result);\n    }\n}\n", "code2": "array =[]\nfor i in (0..2)\n  array[i]=gets.split(\" \").map{|a| a.to_i}\nend\nanswer =\"YES\"\nfor i in(1..4)\n  num =0\n  array.each{|a|\n  if a.include?(i) then\n    num +=1\n  end\n  if num ==3\n    answer = \"NO\"\n  end\n  }\nend\nputs answer\n", "label": 0, "name1": "s239119083.java", "name2": "s124375185.rb"}, {"id": 161, "code1": "import java.util.*;\npublic class Main{\npublic static void main(String[] args){\nScanner sc = new Scanner(System.in);\n  int Q = sc.nextInt();\n  for(int i=0;i<Q;i++){\n    long f = sc.nextLong();\n    long s = sc.nextLong();\n    long a = Math.max(f, s);\n    long b = Math.min(f, s);\n    long K = a*b;\n    long L = (long) Math.sqrt(K);\n    long M = (K-1)/L;\n    long N = Math.max(-1,M-b-1);\n    System.out.println(L+N+b-1);\n  }\n}}\n", "code2": "gets.to_i.times do\n    a,b = gets.split.map(&:to_i)\n    c = (Math.sqrt(a*b)+Float::EPSILON).floor\n    if c*c == a*b\n        if a == b\n            puts c*2-2\n        else\n            puts c*2-3\n        end\n    elsif (c+1)*c < a*b\n        puts c*2-1\n    else\n        puts c*2-2\n    end\nend", "label": 1, "name1": "s709576716.java", "name2": "s357007550.rb"}, {"id": 498, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    int n;\n    char[] cs;\n\n    public static void main(String args[]) {\n        new Main().run();\n    }\n\n    void run() {\n        FastReader sc = new FastReader();\n        n = sc.nextInt();\n        cs = sc.next().toCharArray();\n        solve();\n    }\n\n    void solve() {\n        int[] sumEastL = new int[n];\n        if (cs[0] == 'E') {\n            sumEastL[0] = 1;\n        }\n        for (int i = 1; i < n; i++) {\n            sumEastL[i] = sumEastL[i - 1] + (cs[i] == 'E' ? 1 : 0);\n        }\n        int min = 10000000;\n        for (int i = 0; i < n; i++) {\n            int num = sumEastL[n - 1] - sumEastL[i] + (i > 0 ? i - sumEastL[i - 1] : 0);\n            if (min > num) {\n                min = num;\n            }\n        }\n        System.out.println(min);\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n", "code2": "N = gets.to_i\nS = gets.chomp\n\new = we = 0\nN.times do |i|\n  we += 1 if S[i] == 'E'\nend\n\nans = 1000000\nN.times do |i|\n  we -= 1 if S[i] == 'E'\n  ans = [ans, ew + we].min\n  ew += 1 if S[i] == 'W'\nend\n\nputs ans\n", "label": 1, "name1": "s171588206.java", "name2": "s770679196.rb"}, {"id": 293, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.AbstractCollection;\nimport java.util.PriorityQueue;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CStreamline solver = new CStreamline();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CStreamline {\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            int[] x = in.nextIntArray(m);\n            Arrays.sort(x);\n            int ans = x[m - 1] - x[0];\n            PriorityQueue<Integer> q = new PriorityQueue<>();\n            for (int i = 0; i < m - 1; i++) {\n                q.add(-(x[i + 1] - x[i]));\n            }\n            for (int i = 0; i < n - 1 && !q.isEmpty(); i++) {\n                ans += q.poll();\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        public int[] nextIntArray(final int n) {\n            final int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt();\n            }\n            return res;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n", "code2": "n,m=gets.chomp.split(\" \").map(&:to_i)\nx=gets.chomp.split(\" \").map(&:to_i)\nif m==1 or n>m\n  puts 0\nelse\nx.sort!\nans=x[m-1]-x[0]\ndis=[]\n(m-1).times do|i|\n  dis.push(x[i+1]-x[i])\nend\ndis.sort!.reverse!\n(n-1).times do|i|\n  ans-=dis[i]\nend\nputs ans\n\nend\n", "label": 1, "name1": "s975956716.java", "name2": "s775569908.rb"}, {"id": 542, "code1": "import java.util.*;\nclass Main {\n\tstatic int n;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\tint maxDistance = 0;\n\t\t\tMap<Integer, Integer> map = new HashMap<Integer, Integer>(n);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tint d = sc.nextInt() + sc.nextInt();\n\t\t\t\tmap.put(d, p);\n\t\t\t\tmaxDistance = Math.max(d, maxDistance);\n\t\t\t}\n\t\t\tSystem.out.printf(\"%d %d\\n\", map.get(maxDistance), maxDistance);\n\t\t}\n\t}\n}", "code2": "N = gets.to_i\nM = (2..2*N).find{ |m| m*(m-1)/2 == N }\nif !M \n  puts \"No\"; exit\nend\n\nputs \"Yes\"\np M\nes = {}\ne = 1\n(1..M).each{ |i|\n  #p es[i]\n  (i+1..M).each{ |j|\n    es[i] ||= {}\n    es[j] ||= {}\n    es[i][j] = es[j][i] = e\n    e += 1\n  } \n  puts \"#{M-1} #{es[i].values.join(\" \")}\"\n}\n", "label": 0, "name1": "s188031790.java", "name2": "s628412188.rb"}, {"id": 34, "code1": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // Your code here!\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long a = sc.nextLong();\n        long b = sc.nextLong();\n        long[] array = new long[n];\n        for (int i = 0; i < n; i++) {\n            array[i] = sc.nextLong();\n        }\n        \n        long ans = 0;\n        for (int i = 1; i < n; i++) {\n            long dis = array[i] - array[i-1];\n            if (dis * a < b) {\n                ans += dis * a;\n            } else {\n                ans += b;\n            }\n        }\n        \n        System.out.println(ans);\n    }\n}", "code2": "n,a,b = gets.split.map &:to_i\nz,*x = gets.split.map &:to_i\n\nans = 0\nx.each{|t|\n  w = (t-z)*a\n  w = b if w > b\n  ans += w\n  z = t\n}\n\np ans\n", "label": 1, "name1": "s129000734.java", "name2": "s327159753.rb"}, {"id": 408, "code1": "import java.util.Scanner;\n\npublic class Main {\n  private static Scanner sc;\n\n  public static void main(String[] args) {\n    sc = new Scanner(System.in);\n    new Main().solve();\n  }\n\n  private void solve() {\n    int N = sc.nextInt();\n    int[] a = new int[N + 2];\n    for (int i = 0; i < N; i++) {\n      a[i + 1] = sc.nextInt();\n    }\n    int sum = 0;\n    for (int i = 0; i <= N; i++) {\n      sum += Math.abs(a[i] - a[i + 1]);\n    }\n\n    for (int i = 0; i < N; i++) {\n      System.out.println(sum - Math.abs(a[i] - a[i + 1]) - Math.abs(a[i + 2] - a[i + 1]) + Math.abs(a[i] - a[i + 2]));\n    }\n  }\n}\n", "code2": "n = gets.chomp.to_i\nt = gets.chomp.split(' ').map {|v| v.to_i}\nt.unshift(0)\nt.push(0)\n\not = Array.new(t.length, 0)\n\nall = 0\nfor i in 1...t.length do\n  v = t[i] - t[i - 1]\n  ot[i] = v\n  all += v.abs\nend\n\nfor i in 1...t.length - 1 do\n  f = all - ot[i].abs - ot[i + 1].abs\n  v = t[i + 1] - t[i - 1]\n  f += v.abs\n\n  puts f\nend\n\n\n", "label": 1, "name1": "s142792447.java", "name2": "s176193708.rb"}, {"id": 512, "code1": "import java.util.Scanner;\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\n\t\tlong h = stdIn.nextLong();\n\t\tlong w = stdIn.nextLong();\n\t\t\n\t\tlong cnt = 0;\n\t\tif(h==1 || w == 1) {\n\t\t\tSystem.out.println(1);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(h % 2 == 0 && w % 2 == 0) { //h\u5076\u6570\u3001w\u5076\u6570\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tcnt += w/2;\n\t\t\t}\n\t\t}else if(h % 2 == 0 && w % 2 != 0) { //h\u5076\u6570\u3001w\u5947\u6570\n\t\t\tfor(int i = 0; i < h ; i++) {\n\t\t\t\tif(i % 2 == 0) {\n\t\t\t\t\tcnt += (w+1)/2;\n\t\t\t\t}else {\n\t\t\t\t\tcnt += w/2;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( h % 2 != 0 && w % 2 == 0) { // h\u5947\u6570,w\u5076\u6570\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tcnt += w/2;\n\t\t\t}\n\t\t}else {                                //h\u5947\u6570,w\u5947\u6570\n\t\t\tfor(int i = 0; i < h ; i++) {\n\t\t\t\tif(i % 2 == 0) {\n\t\t\t\t\tcnt += (w+1)/2;\n\t\t\t\t}else {\n\t\t\t\t\tcnt += w/2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(cnt);\n\n\t}\n\n}\n", "code2": "n, a, b = gets.split.map(&:to_i)\nxs = gets.split.map(&:to_i)\n\nans = 0\n(n-1).times do |i|\n    ans += [(xs[i+1] - xs[i])*a, b].min\nend\n\nputs ans\n\n", "label": 0, "name1": "s990691093.java", "name2": "s703254975.rb"}, {"id": 630, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n  public static void main(String[] args) {\n\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    long[] a = new long[n];\n\n    for (int i = 0; i < n; i++) {\n      a[i] = sc.nextInt();\n    }\n\n    Arrays.sort(a); // \u6607\u9806\n    long sum = a[n - 1];\n\n    if (n == 2) {\n      System.out.println(sum);\n    } else {\n      if (n % 2 == 1) {\n        int num = n / 2;\n        sum += a[n - num - 1];\n        for (int i = n - num; i < n - 1; i++) {\n          sum += 2 * a[i];\n        }\n        System.out.println(sum);\n      } else {\n        int num = n / 2;\n        for (int i = n - num; i < n - 1; i++) {\n          sum += 2 * a[i];\n        }\n        System.out.println(sum);\n      }\n    }\n\n  }\n}", "code2": "def get_min_point(points, ratio)\n\n  ap, bp = points\n  ar, br = ratio\n\n  an = get_min_count(ap, ar)\n  bn = get_min_count(bp, br)\n\n  mn = [an, bn].max\n  result = [ar*mn, br*mn]\n  result\nend\n\ndef get_min_count(ap, ar)\n  if ap % ar == 0\n    (ap / ar)\n  else\n    (ap / ar) + 1\n  end\nend\n\ninputs = readlines.map(&:chomp)\npoints = inputs[1].split(\" \").map(&:to_i)\nratios = inputs[2..-1].map {|x| x.split(\" \").map(&:to_i) }\n\nratios.each do |ratio|\n  points = get_min_point(points, ratio)\nend\n\nputs points.reduce(:+)\n", "label": 0, "name1": "s266436818.java", "name2": "s308934020.rb"}, {"id": 662, "code1": "import java.util.*;\n\nclass Main {\n    public static void main(String[] args) {\n        new Solver().run();\n    }\n}\n\nclass Solver {\n\n    public void run() {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int[] a = new int[N];\n\n        for (int i = 0; i < N; i++) {\n            a[i] = sc.nextInt();\n            a[i]--;\n        }\n\n        int cnt = 0;\n        for (int i = 0; i < N; i++) {\n            if (i == a[a[i]]) cnt++;\n        }\n\n        System.out.println(cnt / 2);\n\n        return;\n    }\n\n}", "code2": "def judge(s1, s2)\n    if s1.size != s2.size\n        return false\n    end\n    s1.size.times do |i|\n        if s1[i] != ?? && s1[i] != s2[i]\n            return false\n        end\n    end\n    return true\nend\n\ns,t=$<.map(&:chomp)\nans = -1\ns.size.times do |i|\n    if judge(s[i, t.size], t)\n        tmp = String.new(s)\n        tmp[i, t.size] = t\n        s.size.times do |j|\n            if tmp[j] == ??\n                tmp[j] = ?a\n            end\n        end\n        if ans == -1\n            ans = tmp\n        else\n            ans = [ans, tmp].min\n        end\n    end\nend\nputs (ans == -1 ? \"UNRESTORABLE\" : ans)", "label": 0, "name1": "s246692563.java", "name2": "s522869011.rb"}, {"id": 347, "code1": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\nclass Solver extends Main{\n\tSolver(){\n\t\t\n\t}\n}//Solver_end\n\n@SuppressWarnings(\"unchecked\")\nclass Main{\n\tstatic int imax=Integer.MAX_VALUE;\n\tstatic long lmax=Long.MAX_VALUE;\n\t\n\tpublic static void main(String[] args) throws FileNotFoundException{\n\t\t\n\t\t\n\t\tScanner sc=new Scanner(System.in);\n\t\t//Scanner sc=new Scanner(fp);\n\t\t\n\t\tint[] data=readlnI(sc,\" \");\n\t\tint n=data[0];\n\t\tint m=data[1];\n\t\tint[] path=new int[200000];\n\t\t\n\t\tfor(int i=0;i<m; i++){\n\t\t\tint[] line=readlnI(sc,\" \");\n\t\t\tif(line[0]==1){\n\t\t\t\tpath[line[1]-1]+=1;\n\t\t\t}else if(line[1]==n){\n\t\t\t\tpath[line[0]-1]+=1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean fnd=false;\n\t\t\n\t\tfor(int x:path){\n\t\t\tif(x==2)fnd=true;\n\t\t}\n\t\t\n\t\tputs(fnd==true ? \"POSSIBLE\" : \"IMPOSSIBLE\");\n\t\t\n\t}//main_end\n\t\n//---------------------------------------------------------------------------\n\tstatic int readI(Scanner sc){\n\t\treturn Integer.parseInt(sc.nextLine().trim());\n\t}\n\tstatic long readL(Scanner sc){\n\t\treturn Long.parseLong(sc.nextLine().trim());\n\t}\n\tstatic String readS(Scanner sc){\n\t\treturn sc.nextLine().trim();\n\t}\n\tstatic int[] readlnI(Scanner sc, String dl){\n\t\treturn Arrays.stream(sc.nextLine().trim().split(dl)).mapToInt(Integer::parseInt).toArray();\n\t}\n\tstatic long[] readlnL(Scanner sc, String dl){\n\t\treturn Arrays.stream(sc.nextLine().trim().split(dl)).mapToLong(Long::parseLong).toArray();\n\t}\n\tstatic String[] readlnS(Scanner sc, String dl){\n\t\treturn sc.nextLine().trim().split(dl);\n\t}\n\t@SuppressWarnings(\"unchecked\")\n\tstatic <T> void puts(T... args){\n\t\tfor(int i=0; i<args.length-1; i++){\n\t\t\tSystem.out.printf(\"%s \",args[i]);\n\t\t}\n\t\tSystem.out.println(args[args.length-1]);\n\t}\n\tstatic void puts(int[] ary){\n\t\tfor(int i=0; i<ary.length-1; i++){\n\t\t\tSystem.out.printf(\"%d \",ary[i]);\n\t\t}\n\t\tSystem.out.println(ary[ary.length-1]);\n\t}\n\tstatic void puts(long[] ary){\n\t\tfor(int i=0; i<ary.length-1; i++){\n\t\t\tSystem.out.printf(\"%d \",ary[i]);\n\t\t}\n\t\tSystem.out.println(ary[ary.length-1]);\n\t}\n\tstatic void bs(){\n\t\tSystem.out.println(\"\");\n\t}\n\tstatic int sum(int[] ary){\n\t\tint sum=0;\n\t\tfor(int i=0; i<ary.length; i++) sum+=ary[i];\n\t\treturn sum;\n\t}\n\tstatic long sum(long[] ary){\n\t\tlong sum=0;\n\t\tfor(int i=0; i<ary.length; i++) sum+=ary[i];\n\t\treturn sum;\n\t}\n\tstatic void tblSort(int[][] tbl){\n\t\tArrays.sort(tbl, new Comparator<int[]>(){\n\t\t\t@Override\n\t\t\tpublic int compare(int[] a, int[] b){\n\t\t\t\tif(a[0]==b[0]){\n\t\t\t\t\treturn b[1]-a[1];\n\t\t\t\t}else{\n\t\t\t\t\treturn b[0]-a[0];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n", "code2": "nm = gets.split \" \"\nN = nm[0].to_i\nM = nm[1].to_i\nrelays = []\n\nM.times do\n\ts_g = gets.split \" \"\n\tstart = s_g[0].to_i\n\tgoal = s_g[1].to_i\n\tif start == 1\n\t\trelays << goal\n\tend\n\tif goal == N\n\t\trelays << start\n\tend\nend\n\nif relays.length != relays.uniq.length\n\tputs \"POSSIBLE\"\nelse\n\tputs \"IMPOSSIBLE\"\nend", "label": 1, "name1": "s766623172.java", "name2": "s550018243.rb"}, {"id": 567, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tdouble a = sc.nextDouble();\n\t\tdouble b = sc.nextDouble();\n\t\tdouble C = sc.nextDouble();\n\t\t\n\t\tdouble S = 0.5*a*b*Math.sin(Math.toRadians(C));\n\t\tdouble c = Math.sqrt(Math.pow(a, 2)+Math.pow(b, 2)-(2*a*b*Math.cos(Math.toRadians(C))));\n\t\tdouble L = a + b + c;\n\t\tdouble h = 2*S / a;\n\t\t\n\t\tSystem.out.println(S);\n\t\tSystem.out.println(L);\n\t\tSystem.out.println(h);\n\n\t}\n}", "code2": "a, b, c = gets.chomp!.split(\" \").map!(&:to_i)\n\nputs ((a..b).include?(c)  || (b..a).include?(c)) ? \"Yes\" : \"No\"\n", "label": 0, "name1": "s501686962.java", "name2": "s629547340.rb"}, {"id": 954, "code1": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        String ns = sc.next();\n        int count = 0;\n        for(int i = 0; i < 4; i++){\n            if(ns.charAt(i) == '2') count++;\n        }\n        \n        System.out.println(count);\n    }\n}\n", "code2": "io = STDIN\nn,c=io.gets.split.map(&:to_i)\n$da=[]\nc.times do |i|\n  $da << io.gets.split.map(&:to_i)\nend\n$hash=Hash.new{|h,k|h[k]=Hash.new{|h,k|h[k]=0}}\n#key1:amari\n#key2:color#-1\n#value:count\nn.times do |i|\n  ar = io.gets.split.map(&:to_i).map{|i|i-1}\n  n.times do |j|\n    $hash[(i+j)%3][ar[j]]+=1\n  end\nend\ndef calc(*arg)\n  a,b,c=arg\n  tot=0\n  #a,b,c\u306f\u305d\u308c\u305e\u308c\u3042\u307e\u308a\u304c0,1,2\u306e\u6642\u306e\u306b\u8a2d\u5b9a\u3059\u308b\u8272#-1\n  arg.each_with_index do |amari,i|\n    cl_cnt=$hash[i]\n    cl_cnt.each do |cl,cnt|\n      tot+=$da[cl][amari]*cnt\n    end\n  end\n  tot\nend\n\nans=Float::INFINITY\n(0...c).to_a.permutation(3) do |x,y,z|\n  ans=[calc(x,y,z),ans].min\nend\nputs ans\n", "label": 0, "name1": "s382305590.java", "name2": "s691571255.rb"}, {"id": 533, "code1": "import java.util.Scanner;\nimport java.util.Arrays;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\nclass Main{\n          public static void main(String[] args) {\n                  Scanner scan = new Scanner(System.in);\n                  int count = 0;\n                  int N = scan.nextInt();\n                  int a[] = new int[N];\n                  for (int i = 0; i < N; i++) {\n                          a[i] = scan.nextInt();\n                  }\n                  for(int j = 1; j < N; j++){\n                          if (a[j-1] == a[j]) {\n                                  a[j] = 10001;\n                                  count++;\n                          }\n                  }\n                  System.out.println(count);\n                  }\n}\n", "code2": "loop{n=gets.to_i;exit if n==0;a,b=n.times.map{a=gets.split.map &:to_i;[a[1]+a[2],a[0]]}.sort[-1];puts\"#{b} #{a}\"}\n", "label": 0, "name1": "s420774674.java", "name2": "s848913161.rb"}, {"id": 350, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tint N,M;\n\tboolean[] first,second;\n\n\tpublic void solve() {\n\n\t\tN = nextInt();\n\t\tM = nextInt();\n\n\t\tfirst = new boolean[N];\n\t\tsecond = new boolean[N];\n\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tint a = nextInt()-1;\n\t\t\tint b = nextInt()-1;\n\n\t\t\tif(a == 0){\n\t\t\t\tfirst[b] = true;\n\t\t\t}\n\n\t\t\tif(b == N-1){\n\t\t\t\tsecond[a] = true;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1;i < N - 1;i++){\n\t\t\tif(first[i] && second[i]){\n\t\t\t\tout.println(\"POSSIBLE\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tout.println(\"IMPOSSIBLE\");\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}", "code2": "require 'set'\n\nN, M = gets.split.map(&:to_i)\n\ns = Set.new\ne = Set.new\n\nM.times do |i|\n  a, b= gets.split.map(&:to_i)\n  s << b if a == 1\n  e << a if b == N\nend\n\nputs ( s & e ).size > 0 ? \"POSSIBLE\" : \"IMPOSSIBLE\"", "label": 1, "name1": "s651303084.java", "name2": "s663401228.rb"}, {"id": 329, "code1": "import java.util.Scanner;\n\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    // \u6574\u6570\u306e\u5165\u529b\n    int a = sc.nextInt();\n    // \u30b9\u30da\u30fc\u30b9\u533a\u5207\u308a\u306e\u6574\u6570\u306e\u5165\u529b\n    int b = sc.nextInt();\n    int c = sc.nextInt();\n\n//    int ab = a + b;\n//    int bc = b + c;\n//    int ac = a+c;\n//\n//    int result = Math.min(ab, Math.min(bc , ac));\n\n    int max = Math.max(a, Math.max(b, c));\n\n    System.out.println(a + b + c - max);\n  }\n}\n", "code2": "a,b,c = gets.split.map(&:to_i)\nputs a+b+c - [a,b,c].max", "label": 1, "name1": "s393158982.java", "name2": "s564366262.rb"}, {"id": 996, "code1": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line = br.readLine();\n        char[] alpha = line.toCharArray();\n        int n = alpha.length - 2;\n        int m = n / 2;\n        boolean b = true;\n        while(n != 0) {\n            b = true;\n            for(int i = 0; i < m; i++) {\n                if(alpha[i] != alpha[m + i]) {\n                    b = false;\n                    break;\n                }\n            }\n            if(b) {\n                break;\n            }\n            n = n -2;\n            m = n / 2;\n        }\n        System.out.println(n);\n    }\n}", "code2": "n = gets.to_i\nt, a = gets.split.map &:to_i\nh = gets.split.map &:to_i\nmin = Float::INFINITY\nmini = 0\nfor i in 0...n\n  x = (a - t + h[i]*0.006).abs\n  if x < min\n    mini = i\n    min = x\n  end\nend\np mini+1", "label": 0, "name1": "s226153548.java", "name2": "s386266910.rb"}, {"id": 200, "code1": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\npublic class Main {\n\tstatic final long C =  1000000007;\n\tstatic final int CY = 1000000000;\n\tstatic final int INF = Integer.MAX_VALUE/2;\n\tStringBuilder sb;\n\t//\u30bb\u30c3\u30c8\n\tclass Set<F,S> {\n\t\tF f;\n\t\tS s;\n\t\tSet(F f, S s) {this.f = f;this.s = s;}\n\t}\n\tpublic void calc() {\n\t\tsb = new StringBuilder();\n\n\n\t\tIO sc = new IO();\n\n\t\tint n = sc.nextInt();\n\t\tint[] t = sc.nextIntArray(n);\n\t\tint[] a = sc.nextIntArray(n);\n\n\n\t\tlong ans = 1;\n\t\t//BigInteger bi = new BigInteger(\"1\");\n\t\tint[] min = new int[n];\n\t\tint[] max = new int[n];\n\t\tArrays.fill(min, 1);\n\t\tArrays.fill(max, INF);\n\t\tint b = -1, nb = -1;\n\t\tfor (int i=0; i < n; i++) {\n\t\t\t//System.out.println(\"t\" + i);\n\t\t\tint ni = n-1-i;\n\t\t\tif (b != t[i]) {\n\t\t\t\tmax[i] = Math.min(max[i],t[i]);\n\t\t\t\tmin[i] = Math.max(min[i],t[i]);\n\t\t\t\tb = t[i];\n\t\t\t}else {\n\t\t\t\tmax[i] = Math.min(max[i],t[i]);\n\t\t\t}\n\t\t\tif (nb != a[ni]) {\n\t\t\t\tmax[ni] = Math.min(max[ni],a[ni]);\n\t\t\t\tmin[ni] = Math.max(min[ni],a[ni]);\n\t\t\t\tnb = a[ni];\n\t\t\t}else {\n\t\t\t\tmax[ni] = Math.min(max[ni],a[ni]);\n\t\t\t}\n\n\t\t}\n\n\t\tfor (int i=0; i < n; i++) {\n\t\t\t//System.out.println(min[i] + \":\" + max[i]);\n\t\t\tif (max[i] - min[i] < 0) {\n\t\t\t\tSystem.out.println(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tans *= max[i] - min[i] +1;\n\t\t\tans %= C;\n\t\t\t//bi = bi.multiply(new BigInteger((max[i] - min[i] +1)+\"\" ));\n\n\t\t}\n\n\n\t\tSystem.out.println(ans);\n\t}\n\n\n\tpublic static void main(String[] args) {\n\t\tMain main = new Main();\n\t\tmain.calc();\n\n\t}\n}\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}\n\n", "code2": "N = gets.to_i\nA = gets.split.map(&:to_i)\nT = gets.split.map(&:to_i)\n\nputs (0...N).reduce(1) { |a,i|\n  amin = (i == 0 || A[i] > A[i-1]) ? A[i] : 1\n  tmin = (i == N-1 || T[i] > T[i+1]) ? T[i] : 1\n  a = (a * [[A[i],T[i]].min - [amin, tmin].max + 1, 0].max) % 1000000007\n}\n", "label": 1, "name1": "s145899300.java", "name2": "s632068488.rb"}, {"id": 249, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tpublic void solve() {\n\t\tint N = nextInt();\n\t\tint[] a = new int[N];\n\t\tfor(int i = 0;i < N;i++){\n\t\t\ta[i] = nextInt() - 1;\n\t\t}\n\t\tboolean[] used = new boolean[N];\n\t\tint ans = 0;\n\t\tfor(int i = 0;i < N;i++){\n\t\t\tint x = a[i];\n\t\t\tint y = a[x];\n\t\t\tif(used[x])continue;\n\t\t\tif(used[y])continue;\n\t\t\tif(x == a[y] && y == a[x]){\n\t\t\t\tans++;\n\t\t\t\tused[x] = true;\n\t\t\t\tused[y] = true;\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}", "code2": "n=gets.to_i\nas=gets.chomp.split.map(&:to_i)\na=0\nn.times{|i|\n    if as[as[i] - 1] - 1 == i\n        a += 1\n    end\n}\np a / 2\n", "label": 1, "name1": "s188425538.java", "name2": "s050852619.rb"}, {"id": 742, "code1": "\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.AbstractCollection;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Comparator;\nimport java.util.ArrayList;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author silviase\n */\npublic class Main {\n    \n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DijkstraVerify solver = new DijkstraVerify();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DijkstraVerify {\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            int source = in.nextInt();\n            Graph g = new Graph(n);\n            for (int i = 0; i < m; i++) {\n                g.addEdge(new Edge(in.nextInt(), in.nextInt(), in.nextInt()));\n            }\n            long[] d = g.dijkstra(source);\n            for (int i = 0; i < n; i++) {\n                if (d[i] > 1e15) out.println(\"INF\");\n                else out.println(d[i]);\n            }\n        }\n\n    }\n\n    static class Graph {\n        public int size;\n        public ArrayList<Edge>[] adj;\n        public int[] inDeg;\n        public int[] vertexCost;\n\n        @SuppressWarnings(\"unchecked\")\n        public Graph(int size) {\n            this.size = size;\n            adj = new ArrayList[size];\n            inDeg = new int[size];\n            vertexCost = new int[size];\n            for (int i = 0; i < size; i++) {\n                adj[i] = new ArrayList<>();\n            }\n        }\n\n        public void addEdge(Edge e) {\n            adj[e.from].add(e);\n            inDeg[e.to]++;\n        }\n\n        public long[] dijkstra(int from) {\n            long[] d = new long[size];\n            PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.comparing(e -> d[e]));\n            for (int i = 0; i < size; i++) {\n                d[i] = (i == from) ? 0 : (long) 1e18;\n                pq.add(i);\n            }\n            // System.out.println(Arrays.toString(pq.toArray()));\n            while (!pq.isEmpty()) {\n                int search = pq.poll();\n                // System.out.println(\"now: \" + search);\n                ArrayList<Edge> edges = adj[search];\n                for (Edge e : edges) {\n                    // System.out.println(e.toString());\n                    long cmp = d[search] + e.cost;\n                    if (d[e.to] > d[search] + e.cost) {\n                        // \u66f4\u65b0\u304c\u5165\u308b\n                        // \u51e6\u7406\u3092\u5165\u308c\u305f\u3044\u5834\u5408\u306f\u3053\u3053\u306b\u5165\u308c\u308b\n                        d[e.to] = d[search] + e.cost;\n                        pq.add(e.to);\n                    }\n                }\n                //  System.out.println(Arrays.toString(pq.toArray()));\n            }\n            return d;\n        }\n\n    }\n\n    static class Edge {\n        public int from;\n        public int to;\n        public long cost;\n\n        public Edge(int to) {\n            this.to = to;\n        }\n\n        public Edge(int to, long cost) {\n            this.to = to;\n            this.cost = cost;\n        }\n\n        public Edge(int from, int to, long cost) {\n            this.from = from;\n            this.to = to;\n            this.cost = cost;\n        }\n\n        public String toString() {\n            return \"Edge{\" +\n                    \"from=\" + from +\n                    \", to=\" + to +\n                    \", cost=\" + cost +\n                    '}';\n        }\n\n    }\n}\n\n\n", "code2": "a = gets.split.map(&:to_i)\ntmp1 = 0\ntmp1 += a[0] / 2 * 2\ntmp1 += a[3] / 2 * 2\ntmp1 += a[4] / 2 * 2\ntmp2 = 0\nif a[0] > 0 && a[3] > 0 && a[4] > 0\n    tmp2 += 3\n    a[0] -= 1\n    a[3] -= 1\n    a[4] -= 1\nend\ntmp2 += a[0] / 2 * 2\ntmp2 += a[3] / 2 * 2\ntmp2 += a[4] / 2 * 2\nans = [tmp1, tmp2].max + a[1]\np ans", "label": 0, "name1": "s326905326.java", "name2": "s374653780.rb"}, {"id": 160, "code1": "import java.util.*;\npublic class Main{\npublic static void main(String[] args){\nScanner sc = new Scanner(System.in);\n  int Q = sc.nextInt();\n  for(int i=0;i<Q;i++){\n    long f = sc.nextLong();\n    long s = sc.nextLong();\n    long a = Math.max(f, s);\n    long b = Math.min(f, s);\n    long K = a*b;\n    long L = (long) Math.sqrt(K);\n    long M = (K-1)/L;\n    long N = Math.max(-1,M-b-1);\n    System.out.println(L+N+b-1);\n  }\n}}\n", "code2": "Q = gets.to_i\nABs = readlines.map{|l| l.split.map(&:to_i)}\n\ndef solve(a, b)\n  s = a*b\n  a, b = [a, b].minmax\n  c = (Math.sqrt(s) - 1).ceil\n  case \n  when b == a, b == a + 1\n    2*a - 2\n  when c*(c + 1) >= s\n    2*c - 2\n  else\n    2*c - 1\n  end\nend\n\nABs.each{|a, b| puts solve(a, b)}", "label": 1, "name1": "s709576716.java", "name2": "s379184672.rb"}, {"id": 90, "code1": "import java.util.*;\n\npublic class Main{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    long n = sc.nextLong();\n    long k = sc.nextLong();\n\n    long a = n % k;\n    long b = Math.abs(a - k);\n\n    if(a>b){\n      System.out.println(b);\n    }else{\n      System.out.println(a);\n    }\n\n\n  }\n}", "code2": "n,k = gets.split.map(&:to_i)\np [n%k, k-n%k].min\n", "label": 1, "name1": "s483882254.java", "name2": "s519723899.rb"}, {"id": 404, "code1": "import java.io.FileNotFoundException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tMaxHeapSort maxheap = new MaxHeapSort(new int[] {});\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tmaxheap.add(a[i]);\n\t\t}\n\t\ta = maxheap.sortedArray();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tSystem.out.print(a[i] + (i == n - 1 ? \"\\n\" : \" \"));\n\t\t}\n\t}\n\n\tclass MaxHeapSort {\n\t\tint n;\n\t\tint[] v;\n\n\t\tpublic MaxHeapSort(int[] v_) {\n\t\t\tif (v_.length > 1_000_000)\n\t\t\t\tthrow new AssertionError();\n\t\t\tv = Arrays.copyOf(v_, 1_000_000);\n\t\t\tn = v_.length;\n\t\t\tfor (int i = n; i >= 0; --i) {\n\t\t\t\tmaxHeapify(i);\n\t\t\t}\n\t\t}\n\n\t\tvoid add(int val) {\n\t\t\tv[n] = val;\n\t\t\tint cur = n;\n\t\t\t++n;\n\t\t\twhile (cur > 0) {\n\t\t\t\tcur = (cur - 1) / 2;\n\t\t\t\tmaxHeapify(cur);\n\t\t\t}\n\t\t}\n\n\t\tint[] sortedArray() {\n\t\t\tint sz = n;\n\t\t\tint[] ret = new int[sz];\n\t\t\tfor (int i = 0; i < sz; ++i) {\n\t\t\t\tret[sz - 1 - i] = poll();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tint poll() {\n\t\t\tint ret = v[0];\n\t\t\tv[0] = v[n - 1];\n\t\t\tv[n - 1] = ret;\n\t\t\t--n;\n\t\t\tmaxHeapify(0);\n\t\t\treturn ret;\n\t\t}\n\n\t\tvoid maxHeapify(int cur) {\n\t\t\tif (2 * cur + 1 >= n)\n\t\t\t\treturn;\n\t\t\tif (v[cur] >= v[2 * cur + 1] && (2 * cur + 2 >= n || v[cur] >= v[2 * cur + 2])) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint dst = -1;\n\t\t\tif (2 * cur + 2 >= n || v[2 * cur + 1] >= v[2 * cur + 2]) {\n\t\t\t\tdst = 2 * cur + 1;\n\t\t\t} else {\n\t\t\t\tdst = 2 * cur + 2;\n\t\t\t}\n\t\t\tint tmp = v[cur];\n\t\t\tv[cur] = v[dst];\n\t\t\tv[dst] = tmp;\n\t\t\tmaxHeapify(dst);\n\t\t}\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}", "code2": "class Array\n  def merge_sort\n    tmp = self.dup\n    return tmp if tmp.length <= 1\n    a, b = self.half.map { |e| e.merge_sort }\n    marge(a, b)\n  end\n\n  def half\n    mid = length/2\n    return slice(0...mid), slice(mid..-1)\n  end\n\n  def marge(a, b)\n    res = []\n    until a.empty? and b.empty?\n      res <<\n          case\n            when a.empty? then b.shift\n            when b.empty? then a.shift\n            when a.first > b.first then b.shift\n            else a.shift\n          end\n    end\n    res\n  end\nend\n\nn = gets.to_i\narr = gets.split(' ').map(&:to_i)\n\nres = arr.merge_sort\nputs res.join(' ')", "label": 1, "name1": "s534493670.java", "name2": "s946027094.rb"}, {"id": 94, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        final Scanner sc = new Scanner(System.in);\n\n        final long n = sc.nextLong();\n        final long k = sc.nextLong();\n\n        final long t = n % k;\n        System.out.println(Math.min(t, k-t));\n    }\n}\n", "code2": "n,k=gets.split.map &:to_i\nn%=k\np [n,k-n].min", "label": 1, "name1": "s071954198.java", "name2": "s028993927.rb"}, {"id": 861, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nclass Main {\n\tpublic static void main(String args[]) throws IOException {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tSolver solver = new Solver();\n\t\tsolver.init();\n\t\tsolver.readHead(in.readLine());\n\t\tfor (; solver.hasNext();) {\n\t\t\tsolver.readBody(in.readLine());\n\t\t}\n\t\tsolver.solve();\n\t}\n}\n\nclass Solver {\n\tint N;\n\tint cnt;\n\n\tpublic void init() {\n\t\tN = 0;\n\t\tcnt = 0;\n\t}\n\n\tpublic void readHead(String str) {\n\t\tString[] strArr = str.split(\"\\\\s+\");\n\t\tN = Integer.parseInt(strArr[0]);\n\t\t// System.out.println(N);\n\t\tM = Integer.parseInt(strArr[1]);\n\t\tAC = new int[N + 1];\n\t\tWA = new int[N + 1];\n\t}\n\n\tint M;\n\n\tpublic boolean hasNext() {\n\t\t// return cnt < N;\n\t\treturn cnt < M;\n\t}\n\n\tint[] AC;\n\tint[] WA;\n\n\tpublic void readBody(String str) {\n\t\t// System.out.println(str);\n\t\tString[] strArr = str.split(\"\\\\s+\");\n\t\tint p = Integer.parseInt(strArr[0]);\n\t\tif (AC[p] == 0) {\n\t\t\tif (\"AC\".equals(strArr[1]))\n\t\t\t\tAC[p] = 1;\n\t\t\telse {\n\t\t\t\tWA[p]++;\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t}\n\n\tpublic void solve() {\n\t\tint a = 0;\n\t\tint w = 0;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tif (AC[i] > 0) {\n\t\t\t\ta++;\n\t\t\t\tw += WA[i];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(a + \" \" + w);\n\t}\n}\n", "code2": "def fact(n)\n\t(1..n).inject(:*)\nend\n#fact(1500).to_s.length\nstart = fact(1500)+2\nn = gets.to_i\np start\nn.times {|k|\n\tp 2+k\n}", "label": 0, "name1": "s230790918.java", "name2": "s426934559.rb"}, {"id": 988, "code1": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tint[] a = na(n);\n\t\tint[] f = new int[13];\n\t\tf[0]++;\n\t\tfor(int v : a)f[v]++;\n\t\tif(f[0] >= 2 || f[12] >= 2){\n\t\t\tout.println(0);\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 1;i <= 11;i++){\n\t\t\tif(f[i] >= 3){\n\t\t\t\tout.println(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor(int i = 0;i < 1<<11;i++){\n\t\t\tboolean[] b = new boolean[25];\n\t\t\tb[0] = b[24] = true;\n\t\t\tif(f[12] > 0)b[12] = true;\n\t\t\tfor(int j = 0;j < 11;j++){\n\t\t\t\tif(f[j+1] == 2){\n\t\t\t\t\tb[j+1] = b[24-(j+1)] = true;\n\t\t\t\t}else if(f[j+1] == 1){\n\t\t\t\t\tif(i<<~j<0){\n\t\t\t\t\t\tb[24-(j+1)] = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tb[j+1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint min = 99;\n\t\t\tint pre = -99;\n\t\t\tfor(int j = 0;j <= 24;j++){\n\t\t\t\tif(b[j]){\n\t\t\t\t\tmin = Math.min(min, j-pre);\n\t\t\t\t\tpre = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = Math.max(ans, min);\n\t\t}\n\t\tout.println(ans);\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n", "code2": "s=gets.chomp\np (~-s.size/2).downto(0).find{|i|s[0,i]==s[i,i]}*2", "label": 0, "name1": "s709834289.java", "name2": "s080878381.rb"}, {"id": 983, "code1": "import java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint[] v = new int[500000];\n        for(int i = 0;i < 500000;i++){\n            v[i] = 1;\n        }\n        int p = 3;\n        while(true){\n            if(p*p > 1000000){\n                break;\n            }else{\n                if(v[(p-1)/2] == 0){\n                    p += 2;\n                }else{\n                    int t = p*p;\n                    while(t < 1000000){\n                        v[(t-1)/2] = 0;\n                        t += 2*p;\n                    }\n                    p += 2;\n                }\n            }\n        }\n        v[0] = 0;\n\t\twhile(scan.hasNext()){\n\t\t\tint n = scan.nextInt();\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tfor(int i = 1;i < n/2;i++){\n\t\t\t\tif(v[i] != 1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(v[(n-2*i-2)/2] == 1){\n\t\t\t\t\tcount += ((n-2*i-2)/2 == i)?2:1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count/2);\n        }\n\t}\n}", "code2": "s = gets.chomp\nn = s.length\n\n1.upto(n) do |i|\n  guu = s[0...(n-i)]\n  c = guu.length/2\n  if guu[0...c] == guu[c..-1]\n    puts guu.length\n    exit\n  end\nend", "label": 0, "name1": "s280746172.java", "name2": "s983887093.rb"}, {"id": 547, "code1": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\t//\u305d\u308c\u305e\u308c\u306e\u60a3\u8005\u306e\u756a\u53f7 p\n\t\t//1\u56de\u76ee\u306b\u6b69\u3044\u305f\u8ddd\u96e2 d1\n\t\t//2\u56de\u76ee\u306b\u6b69\u3044\u305f\u8ddd\u96e2 d2\n\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();//\u60a3\u8005\u306e\u6570 n\n\t\t\tint maxWalk = 0;//\u4e00\u756a\u6b69\u3044\u305f\u4eba\u306e\u8ddd\u96e2\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tMap<Integer, Integer> walkSum = new HashMap<Integer, Integer>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tint d1 = sc.nextInt();\n\t\t\t\tint d2 = sc.nextInt();\n\t\t\t\tint sumWalk = d1 + d2;\n\t\t\t\tif(sumWalk > maxWalk)maxWalk = sumWalk;\n\t\t\t\twalkSum.put(sumWalk,p);\n\t\t\t}\n\t\t\tSystem.out.println(walkSum.get((Object)maxWalk)+\" \"+maxWalk);\n\t\t}\n\t}\n}", "code2": "h=Hash.new(0)\n$<.map{|l|h[l.chop.split(?,)[1]]+=1}\np h[?A],h[?B],h[\"AB\"],h[?O]", "label": 0, "name1": "s421023762.java", "name2": "s471451546.rb"}, {"id": 999, "code1": "\nimport java.util.Scanner;\n\nclass Main {\n\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        int t = scan.nextInt();\n        while (t > 0) {\n            int n = scan.nextInt();\n            int s;\n            int f;\n            int sum = 0;\n            for (int i = 0; i < n; i++) {\n                s = scan.nextInt();\n                f = scan.nextInt();\n                sum += f - s;\n            }\n\n            if (t <= sum) {\n                System.out.println(\"OK\");\n            } else {\n                System.out.println(t - sum);\n            }\n            t = scan.nextInt();\n        }\n    }\n}\n\n", "code2": "n = gets.to_i\nt, a = gets.split.map &:to_i\nh = gets.split.map &:to_i\nmin = Float::INFINITY\nmini = 0\nfor i in 0...n\n  x = (a - t + h[i]*0.006).abs\n  if x < min\n    mini = i\n    min = x\n  end\nend\np mini+1", "label": 0, "name1": "s158509930.java", "name2": "s386266910.rb"}, {"id": 703, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyScanner in = new MyScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        C solver = new C();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class C {\n        int N;\n        int M;\n\n        public void solve(int testNumber, MyScanner in, PrintWriter out) {\n            N = in.Int();\n            M = in.Int();\n            DSU dsu = new DSU(N);\n            for (int i = 0; i < M; i++) {\n                int A = in.Int() - 1;\n                int B = in.Int() - 1;\n                dsu.merge(A, B);\n            }\n            out.println(dsu.groups().size() - 1);\n        }\n\n    }\n\n    static class DSU {\n        private int n;\n        private int[] parentOrSize;\n\n        public DSU(int n) {\n            this.n = n;\n            this.parentOrSize = new int[n];\n            Arrays.fill(parentOrSize, -1);\n        }\n\n        int merge(int a, int b) {\n            if (!(0 <= a && a < n))\n                throw new IndexOutOfBoundsException(\"a=\" + a);\n            if (!(0 <= b && b < n))\n                throw new IndexOutOfBoundsException(\"b=\" + b);\n\n            int x = leader(a);\n            int y = leader(b);\n            if (x == y) return x;\n            if (-parentOrSize[x] < -parentOrSize[y]) {\n                int tmp = x;\n                x = y;\n                y = tmp;\n            }\n            parentOrSize[x] += parentOrSize[y];\n            parentOrSize[y] = x;\n            return x;\n        }\n\n        int leader(int a) {\n            if (parentOrSize[a] < 0) {\n                return a;\n            } else {\n                parentOrSize[a] = leader(parentOrSize[a]);\n                return parentOrSize[a];\n            }\n        }\n\n        ArrayList<ArrayList<Integer>> groups() {\n            int[] leaderBuf = new int[n];\n            int[] groupSize = new int[n];\n            for (int i = 0; i < n; i++) {\n                leaderBuf[i] = leader(i);\n                groupSize[leaderBuf[i]]++;\n            }\n            ArrayList<ArrayList<Integer>> result = new ArrayList<>(n);\n            for (int i = 0; i < n; i++) {\n                result.add(new ArrayList<>(groupSize[i]));\n            }\n            for (int i = 0; i < n; i++) {\n                result.get(leaderBuf[i]).add(i);\n            }\n            result.removeIf(ArrayList::isEmpty);\n            return result;\n        }\n\n    }\n\n    static class MyScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public MyScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    return null;\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int Int() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "code2": "M=1000003\no=->a,n{n<1?1:(n%2>0?a:1)*o[a,n/2]**2%M}\n*f=1\n1.upto(M){|i|f<<f[i-1]*i%M}\ngets\n$<.map{|s|x,d,n=s.split.map &:to_i\nt=x*o[d,M-2]%M\np d<1?o[x,n]:M<t+n||t<1?0:f[t+n-1]*o[f[t-1],M-2]*o[d,n]%M}", "label": 0, "name1": "s578903603.java", "name2": "s699536087.rb"}, {"id": 727, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        PrintWriter out = new PrintWriter(System.out);\n        InputStreamScanner in = new InputStreamScanner(System.in);\n        new Main().solve(in, out);\n        out.flush();\n    }\n\n    private void solve(InputStreamScanner in, PrintWriter out) {\n        String s = in.next();\n\n        long t = 0;\n        for (int i = 0; i < 1 << (s.length() - 1); i++) {\n            int p = 0;\n            for (int j = 0; j < s.length() - 1; j++) {\n                if ((1 & i >> j) == 1) {\n                    t += Long.parseLong(s.substring(p, j + 1));\n                    p = j + 1;\n                }\n            }\n            t += Long.parseLong(s.substring(p));\n        }\n\n        out.println(t);\n    }\n\n    static class InputStreamScanner {\n\n        private InputStream in;\n\n        private byte[] buf = new byte[1024];\n        private int len = 0;\n        private int off = 0;\n\n        InputStreamScanner(InputStream in)\t{\n            this.in = in;\n        }\n\n        String next() {\n            StringBuilder sb = new StringBuilder();\n            for (int b = skip(); !isSpace(b);){\n                sb.appendCodePoint(b);\n                b = read();\n            }\n            return sb.toString();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        char nextChar() {\n            return (char)skip();\n        }\n\n        int skip() {\n            for (int b; (b = read()) != -1;) {\n                if (!isSpace(b)) {\n                    return b;\n                }\n            }\n            return -1;\n        }\n\n        private boolean isSpace(int c) {\n            return c < 33 || c > 126;\n        }\n\n        private int read() {\n            if (len == -1) {\n                throw new InputMismatchException(\"End of Input\");\n            }\n            if (off >= len){\n                off = 0;\n                try {\n                    len = in.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException(e.getMessage());\n                }\n                if (len <= 0) {\n                    return -1;\n                }\n            }\n            return buf[off++];\n        }\n    }\n}", "code2": "eval'X,Y='+`tr ' ' ,`;p (Y/X).bit_length", "label": 0, "name1": "s838868939.java", "name2": "s262263338.rb"}, {"id": 783, "code1": "\nimport java.util.HashMap;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main \n{\n\tstatic HashMap<String, String> groupdef;\n\tstatic String firstgroup;\n\tstatic TreeSet<String> members;\n\tstatic TreeSet<String> checked;\n\t\n\tstatic void get(String g)\n\t{\n\t\tString con = groupdef.get(g);\n//\t\tSystem.out.println(\"Getting \" + g + \"...\");\n\t\tif(checked.contains(g))return;\n\t\t\n\t\tint start = 0;\n\t\tint mem = 0;\n\t\tfor(int i = 0; i < con.length(); i++)\n\t\t{\n\t\t\tif(con.charAt(i) == ',' || con.charAt(i) == '.')\n\t\t\t{\n\t\t\t\tString word = con.substring(start, i);\n\t\t\t\tstart = i+1;\n\t\t\t\t\n\t\t\t\tif(groupdef.containsKey(word))\n\t\t\t\t{\n\t\t\t\t\tget(word);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmembers.add(word);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tchecked.add(g);\n//\t\tcache.put(g, mem);\n\t}\n\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0)break;\n\t\t\tgroupdef = new HashMap<String, String>();\n//\t\t\tcache = new HashMap<String, Integer>();\n\t\t\tmembers = new TreeSet<String>();\n\t\t\tchecked = new TreeSet<String>();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tString s = sc.next();\n\t\t\t\tint lim = s.indexOf(':');\n\t\t\t\tString groupname = s.substring(0, lim);\n\t\t\t\tString groupcon = s.substring(lim+1);\n\t\t\t\tif(i == 0)firstgroup = groupname;\n\t\t\t\tgroupdef.put(groupname, groupcon);\n\t\t\t}\n\t\t\t\n\t\t\tget(firstgroup);\n\t\t\tSystem.out.println(members.size());\n//\t\t\tSystem.out.println(members);\n\t\t}\n\t\t\n\n\t}\n\n}\n\n", "code2": "class Node\n    attr_accessor :parent, :rank\n\n    def initialize(n)\n      @parent = n\n      @rank = 0\n    end\nend\n\nclass UnionFindTree\n  def initialize(n)\n    @n = n\n    @nodes = (0..n).to_a.map { |i| Node.new(i) }\n  end\n\n  def find(x)\n    return x if @nodes[x].parent == x\n\n    return @nodes[x].parent = find(@nodes[x].parent)\n  end\n\n  def unite(a, b)\n    a = find(a)\n    b = find(b)\n    return if a == b\n\n    if @nodes[a].rank < @nodes[b].rank\n      @nodes[a].parent = b\n    else\n      @nodes[b].parent = a\n      @nodes[a].rank += 1 if @nodes[a].rank == @nodes[b].rank\n    end\n  end\n\n  def same?(a, b)\n    find(a) == find(b)\n  end\n\n  def parents\n    @nodes.map(&:parent)\n  end\n\n  def roots\n    (1..@n).map {|i| find(i)}\n  end\nend\n\nn,k,l = gets.chomp.split.map(&:to_i)\ntree1 = UnionFindTree.new(n)\nk.times do\n    p,q = gets.chomp.split.map(&:to_i)\n    tree1.unite(p,q)\nend\n\ntree2 = UnionFindTree.new(n)\nl.times do\n    r,s = gets.chomp.split.map(&:to_i)\n    tree2.unite(r,s)\nend\n\np =  (1..n).to_a.zip(tree1.roots, tree2.roots)\ng = p.group_by {|i| [i[1], i[2]]}\n\nans = []\np.each do |v|\n    ans << g[[v[1],v[2]]].size\nend\nputs ans.join(\" \")\n\n\n\n", "label": 0, "name1": "s001547590.java", "name2": "s325987922.rb"}, {"id": 198, "code1": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\npublic class Main {\n\tstatic final long C =  1000000007;\n\tstatic final int CY = 1000000000;\n\tstatic final int INF = Integer.MAX_VALUE/2;\n\tStringBuilder sb;\n\t//\u30bb\u30c3\u30c8\n\tclass Set<F,S> {\n\t\tF f;\n\t\tS s;\n\t\tSet(F f, S s) {this.f = f;this.s = s;}\n\t}\n\tpublic void calc() {\n\t\tsb = new StringBuilder();\n\n\n\t\tIO sc = new IO();\n\n\t\tint n = sc.nextInt();\n\t\tint[] t = sc.nextIntArray(n);\n\t\tint[] a = sc.nextIntArray(n);\n\n\n\t\tlong ans = 1;\n\t\t//BigInteger bi = new BigInteger(\"1\");\n\t\tint[] min = new int[n];\n\t\tint[] max = new int[n];\n\t\tArrays.fill(min, 1);\n\t\tArrays.fill(max, INF);\n\t\tint b = -1, nb = -1;\n\t\tfor (int i=0; i < n; i++) {\n\t\t\t//System.out.println(\"t\" + i);\n\t\t\tint ni = n-1-i;\n\t\t\tif (b != t[i]) {\n\t\t\t\tmax[i] = Math.min(max[i],t[i]);\n\t\t\t\tmin[i] = Math.max(min[i],t[i]);\n\t\t\t\tb = t[i];\n\t\t\t}else {\n\t\t\t\tmax[i] = Math.min(max[i],t[i]);\n\t\t\t}\n\t\t\tif (nb != a[ni]) {\n\t\t\t\tmax[ni] = Math.min(max[ni],a[ni]);\n\t\t\t\tmin[ni] = Math.max(min[ni],a[ni]);\n\t\t\t\tnb = a[ni];\n\t\t\t}else {\n\t\t\t\tmax[ni] = Math.min(max[ni],a[ni]);\n\t\t\t}\n\n\t\t}\n\n\t\tfor (int i=0; i < n; i++) {\n\t\t\t//System.out.println(min[i] + \":\" + max[i]);\n\t\t\tif (max[i] - min[i] < 0) {\n\t\t\t\tSystem.out.println(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tans *= max[i] - min[i] +1;\n\t\t\tans %= C;\n\t\t\t//bi = bi.multiply(new BigInteger((max[i] - min[i] +1)+\"\" ));\n\n\t\t}\n\n\n\t\tSystem.out.println(ans);\n\t}\n\n\n\tpublic static void main(String[] args) {\n\t\tMain main = new Main();\n\t\tmain.calc();\n\n\t}\n}\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}\n\n", "code2": "n=gets.to_i\nT=gets.split.map &:to_i\nA=gets.split.map &:to_i\nX=[0]*n\nc=0\na=1\nn.times{|i|\n  if T[i]!=c\n    X[i] = 1\n    a=0 if T[i]>A[i]\n  end\n  c=T[i]\n}\nY=[0]*n\nc=0\n(n-1).downto(0){|i|\n  if A[i]!=c\n    Y[i] = 1\n    a=0 if T[i]<A[i]\n  end\n  c=A[i]\n}\nn.times{|i|\n  if X[i]+Y[i]<1\n    a *= [T[i],A[i]].min\n    a %= 10**9+7\n  end\n}\np a", "label": 1, "name1": "s145899300.java", "name2": "s894245225.rb"}, {"id": 444, "code1": "import java.util.*;\nclass Main\n{\n    static long mod = 1000000007;\n    public static void main (String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long[] a = new long[n];\n        for(int i = 0; i < n; i++){\n            a[i] = sc.nextLong();\n        }\n        long[] b = new long[n+1];\n        b[0] = 0;\n        for(int i = 1; i <= n; i++){\n            b[i] = (b[i-1] + pow(i, mod - 2)) % mod;\n        }\n        long ans = 0;\n        for(int i = 0; i < n; i++){\n            ans += a[i] * (b[i+1] + b[n - i] - 1);\n            ans %= mod;\n        }\n        for(int i = 1; i <= n; i++){\n            ans *= i;\n            ans %= mod;\n        }\n        System.out.println(ans);\n    }\n    static long pow(long a, long p){\n        if(p == 0) return 1;\n        else if(p % 2 == 0){\n            long d = pow(a, p/2);\n            return d * d % mod;\n        }\n        else return pow(a, p-1) * a % mod;\n    }\n}", "code2": "eval'*A=#'+`tr ' ' ,`\ni=f=1\ns=m=10**9+7\np A.sum{f=f*i%m\ns+=i.pow m-2,m\n_1*~-s+A[1-i+=1]*s}*f%m", "label": 1, "name1": "s041637006.java", "name2": "s721063213.rb"}, {"id": 713, "code1": "import java.util.*;\n\npublic class Main {\n  public static long MOD = (long)Math.pow(10, 6) + 3;\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    long[] kai = new long[(int)MOD];\n//    long[] inkai = new long[(int)MOD];\n//    long[] in = new long[(int)MOD];\n    kai[0] = 1;\n    kai[1] = 1;\n//    inkai[0] = 1;\n//    inkai[1] = 1;\n//    in[1] = 1;\n    for(long i = 2; i < MOD; i++) {\n      kai[(int)i] = (i * kai[(int)i - 1]) % MOD;\n//      inkai[(int)i] = func(kai[(int)i], MOD - 2);\n//      in[(int)i] = func(i, MOD - 2);\n    }\n    int q = sc.nextInt();\n    for(int i = 0; i < q; i++) {\n      long x = sc.nextLong();\n      long d = sc.nextLong();\n      long n = sc.nextLong();\n      long ans = 0;\n      if(d == 0) {\n        if(x == 0) {\n          ans = 0;\n        } else {\n          ans = func(x, n % (MOD - 1));\n        }\n      } else {\n        long inv = func(d, MOD - 2);\n        x = (x * inv) % MOD;\n        if(x == 0) {\n          ans = 0;\n        } else {\n          if((int)(x + n - 1) >= MOD) {\n            ans = 0;\n          } else {\n            long t = func(d, n % (MOD - 1));\n            long invkai = func(kai[(int)x - 1], MOD - 2);\n            ans = (((kai[(int)(x + n - 1)] * invkai) % MOD) * t) % MOD;\n          }\n        }\n      }\n      System.out.println(ans);\n    }\n  }\n  public static long func(long a, long x) {\n    if(x == 0) return 1;\n    if(x >= 1) {\n      if(x % 2 == 0) {\n        long t = func(a, x / 2);\n        return (t * t) % MOD;\n      } else {\n        long t = func(a, x - 1);\n        return (a * t) % MOD;\n      }\n    }\n    return 0;\n  } \n}", "code2": "s = gets.chomp\n\ndef merge(s, t)\n  r = \"\"\n  t.size.times{|i| r += s[i].to_s + t[i].to_s }\n  r += s[(t.size)..-1]\n  r\nend\n\np (0...(2 ** (s.size - 1))).to_a.map {|i|\n  ss = s.clone\n  f = i.to_s(2).rjust(s.size - 1, '0').gsub(/1/, '+').gsub(/0/, ' ')\n  eval(merge(ss, f).gsub(/\\s/, ''))\n}.inject(&:+)", "label": 0, "name1": "s406339057.java", "name2": "s812495641.rb"}, {"id": 801, "code1": "import java.util.*;\nimport java.text.*;\nimport java.math.*;\n\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tScanner in = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint m = in.nextInt();\n\t\t\tint d = in.nextInt();\n\t\t\tif((m|d) == 0) break;\n\t\t\tint day = d;\n\t\t\tswitch(m){\n\t\t\tcase 12:\n\t\t\t\tday += 335;\n\t\t\t\tbreak;\n\t\t\tcase 11:\n\t\t\t\tday += 305;\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tday += 274;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tday += 244;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tday += 213;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tday += 182;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tday += 152;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tday += 121;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tday += 91;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tday += 60;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tday += 31;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t}\n\t\t\tswitch(day%7){\n\t\t\tcase 1:\n\t\t\t\tSystem.out.println(\"Thursday\");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tSystem.out.println(\"Friday\");\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tSystem.out.println(\"Saturday\");\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tSystem.out.println(\"Sunday\");\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tSystem.out.println(\"Monday\");\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tSystem.out.println(\"Tuesday\");\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tSystem.out.println(\"Wednesday\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "code2": "N=gets.to_i\nedges=Array.new(N){Array.new}\n(N-1).times do\n    a,b=gets.split.map(&:to_i)\n    a-=1\n    b-=1\n    edges[a] << b\n    edges[b] << a\nend\ndist_from_1=Array.new(N)\ndist_from_last=Array.new(N)\n\ndef dfs(edges,start,dists)\n    used=Array.new(edges.size,false)\n    used[start]=true\n    dists[start]=0\n    stack=[start]\n    while !stack.empty?\n        v=stack.pop\n        edges[v].each do |vv|\n            next if used[vv]\n            used[vv]=true\n            dists[vv]=dists[v]+1\n            stack << vv\n        end\n    end\nend\n\ndfs(edges,0,dist_from_1)\ndfs(edges,N-1,dist_from_last)\n\n\nb_count=0\nw_count=0\nN.times do |i|\n    b_count+=1 if dist_from_1[i]<=dist_from_last[i]\n    w_count+=1 if dist_from_1[i]>dist_from_last[i]\nend\n\nputs b_count>w_count ? \"Fennec\" : \"Snuke\"", "label": 0, "name1": "s648991274.java", "name2": "s497047069.rb"}, {"id": 378, "code1": "// -*- coding: utf-8 -*-\n//import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream;\n    if (args.length > 0 && args[0].equals(\"devTesting\")) {\n      try {\n        inputStream = new FileInputStream(args[1]);\n      } catch(FileNotFoundException e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      inputStream = System.in;\n    }\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskC solver = new TaskC();\n    int testCase = 1;\n    solver.solve(1, in, out);\n    out.close();\n  }\n  \n  static class TaskC {\n    long h, w;\n    \n    void solve(int testNumber, InputReader in, PrintWriter out) {\n      h = in.nextInt();\n      w = in.nextInt();\n      char[][] superpost = new char[(int) h][];\n      for (int i = 0; i < h; ++i)\n        superpost[i] = in.next().toCharArray();\n      for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j)\n          if (i % 2 == 0 && j < w - 1 || j == 0 || superpost[i][j] == '#')\n            out.print('#');\n          else\n            out.print('.');\n        out.println();\n      }\n      out.println();\n      for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j)\n          if (i % 2 == 1 && j > 0 || j == w - 1 || superpost[i][j] == '#')\n            out.print('#');\n          else\n            out.print('.');\n          out.println();\n      }\n    }\n    \n  }\n      \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public boolean hasInput() {\n      try {\n        if (tokenizer != null && tokenizer.hasMoreTokens()) {\n          return true;\n        }\n        reader.mark(1);\n        int ch = reader.read();\n        if (ch != -1) {\n          reader.reset();\n          return true;\n        }\n        return false;\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n  }\n}\n", "code2": "H, W = gets.split.map(&:to_i)\nas = []\nH.times do |i|\n    as[i] = gets.chomp\nend\n\nrs = Array.new(H){Array.new(W, '.')}\nbs = Array.new(H){Array.new(W, '.')}\nrs[0] = Array.new(W, '#')\nbs[H-1] = Array.new(W, '#')\n\n(1...(H-1)).each do |i|\n    W.times do |j|\n        if as[i][j] == '#' || j % 2 == 0\n            rs[i][j] = '#'\n        end\n        if as[i][j] == '#' || j % 2 == 1\n            bs[i][j] = '#'\n        end\n    end\nend\n\nH.times do |i|\n    puts rs[i].join\nend\n\nputs\n\nH.times do |i|\n    puts bs[i].join\nend", "label": 1, "name1": "s133216279.java", "name2": "s600860222.rb"}, {"id": 688, "code1": "import java.util.*;\n\nclass Main{\n  public static void main(String[] args)\n  {\n    Scanner scanner = new Scanner(System.in);\n    int[] a = new int[3];\n    int[] b = new int[3];\n\n    int iti = 0,ni=0,san=0,si =0;\n\n    int odd=0, even=0;\n\n    for(int i=0; i<3; i++){\n      a[i] = scanner.nextInt();\n      b[i] = scanner.nextInt();\n    }\n\n    for(int i=0; i<3; i++){\n      if(a[i] == 1){\n        iti++;\n      }\n      else if(a[i]==2)\n      {\n        ni++;\n      }else if(a[i] == 3)\n      {\n        san++;\n      }else if(a[i] == 4){\n        si++;\n      }\n\n      if(b[i] == 1){\n        iti++;\n      }\n      else if(b[i]==2)\n      {\n        ni++;\n      }else if(b[i] == 3)\n      {\n        san++;\n      }else if(b[i] == 4){\n        si++;\n      }\n    }\n\n    if(checkEven(iti)){\n      even++;\n    }else{\n      odd++;\n    }\n    if(checkEven(ni)){\n      even++;\n    }else{\n      odd++;\n    }\n    if(checkEven(san)){\n      even++;\n    }else{\n      odd++;\n    }\n\n    if(checkEven(si)){\n      even++;\n    }else{\n      odd++;\n    }\n\n      if(odd == 2 && even == 2)\n      {\n        System.out.println(\"YES\");\n      }else{\n        System.out.println(\"NO\");\n      }\n\n  }\n\n  public static boolean checkEven(int num){\n    if(num %2 == 0){\n      return true;\n    }\n    return false;\n  }\n\n}", "code2": "input = STDIN.read.split(\"\\n\").map{|l| l.split(\" \").map{|a| a.to_i}}\n\nN = input[0][0]\nM = input[0][1]\n\nX = input[1].sort\n\n\ndef main() \n    diffs = []\n\n    if N >= M \n        return 0\n    end\n\n    for i in 0..(M - 2)\n        d = X[i + 1] - X[i] \n        diffs.push([i, d])\n    end\n\n    ds = diffs.sort_by{|x| x[1]}.reverse.slice(0, N - 1).sort_by{|x| x[0]}\n    moves = 0\n\n    if ds.length > 0\n        for i in 0..(N - 1)\n            if i == 0\n                st = 0\n                ed = ds[i][0]\n            elsif i == (N - 1)\n                st = ds[i - 1][0] + 1\n                ed = M - 1\n            else\n                st = ds[i - 1][0] + 1\n                ed = ds[i][0]\n            end\n            moves = moves + (X[ed] - X[st]).abs\n        end\n    else\n        moves = (X.first - X.last).abs\n    end\n    return moves\nend\n\nputs main()", "label": 0, "name1": "s151827431.java", "name2": "s016750008.rb"}, {"id": 47, "code1": "import java.util.Scanner;\nimport java.util.Arrays;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\nclass Main{\n          public static void main(String[] args) {\n                  Scanner scan = new Scanner(System.in);\n                  int count = 0;\n                  int N = scan.nextInt();\n                  int a[] = new int[N];\n                  for (int i = 0; i < N; i++) {\n                          a[i] = scan.nextInt();\n                  }\n                  for(int j = 1; j < N; j++){\n                          if (a[j-1] == a[j]) {\n                                  a[j] = 10001;\n                                  count++;\n                          }\n                  }\n                  System.out.println(count);\n                  }\n}\n", "code2": "n=gets.to_i\ns=gets.split.map(&:to_i)\na=0\nc=1\n(n-1).times do |i|\n  if s[i+1]==s[i]\n    c+=1\n  else\n    a+=c/2\n    c=1\n  end\nend\np a+c/2", "label": 1, "name1": "s420774674.java", "name2": "s006140136.rb"}, {"id": 802, "code1": "/*\n *           AUTHOR: Maria Theresa M. Padayhag\n *             DATE: 20160326\n *  PRE-REQUIREMENT: JDK 1.8\n */\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.time.*;\nimport java.time.format.TextStyle;\nimport java.util.Locale;\n\nclass DayIndentifier\n{\n\tLocalDate date = null;\n\t\n\tpublic \tDayIndentifier( String inMonth, String inDay )\n\t{\n\t\t// NumberFormatException might be thrown here\n\t\t// but it will be handled by the caller.\n\t\tint month = Integer.parseInt( inMonth );\n\t\tint day   = Integer.parseInt( inDay );\n\t\t\n\t\t// DateTimeException might be thrown here\n\t\t// but it will be handled by the caller.\n\t\tdate = LocalDate.of( 2004, month, day );\n\t}\n\t\n\tpublic String getDayOfWeek()\n\t{\n\t\t// NullPointerException might be thrown here\n\t\t// but it will handled by the caller.\n\t\treturn date.getDayOfWeek().getDisplayName(TextStyle.FULL, Locale.ENGLISH);\n\t}\n}\n\npublic class Main\n{\n\tpublic static boolean toExit( String[] dataset )\n\t{\n\t\tfor(String data: dataset)\n\t\t{\n\t\t\tif(data.equals(\"0\"))\n\t\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic static void main( String args[] ) throws IOException\n\t{\n\t\tBufferedReader br = new BufferedReader( new InputStreamReader( System.in ) );\n\t\tString input;\n\t\tString dataset[];\n\t\tDayIndentifier di;\n\t\t\n\t\tREAD: \n\t\twhile( ( input = br.readLine() ) != null ) {\n\t\t\ttry {\n\t\t\t\tdataset = input.split(\" \");\n\t\t\t\n\t\t\t\tif( toExit( dataset ) ) {\n\t\t\t\t\tbreak READ;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif( dataset.length != 2 ) {\n\t\t\t\t\tSystem.out.println(\"Invalid input.\");\n\t\t\t\t\tcontinue READ;\n\t\t\t\t} \t\t\n\t\t\t\t\n\t\t\t\tdi = new DayIndentifier(dataset[0], dataset[1]);\n\t\t\t\tSystem.out.println( di.getDayOfWeek() );\n\t\t\t} catch( Exception e ) {\n\t\t\t\tSystem.out.println(\"Invalid input.\");\n\t\t\t\tcontinue READ;\n\t\t\t}\t\t\n\t\t}\n\t}\n}", "code2": "n = gets.to_i\nadj = Array.new(n).map{Array.new}\n(n-1).times do\n  a,b = gets.chomp.split(\" \").map{|i|i.to_i-1}\n  adj[a] << b\n  adj[b] << a\nend\nvst = Array.new(n,false)\nvst[0] = true\nvst[n-1] = true\nsum = [1,1]\nq = [[],[]]\nf = [[0],[n-1]]\nwhile vst.include?(false)\n  q = Marshal.load(Marshal.dump(f))\n  f = [[],[]]\n  2.times do |i|\n    q[i].each do |j|\n      adj[j].each do |k|\n        if vst[k] == false\n          vst[k] = true\n          f[i] << k\n        end\n      end\n    end\n    sum[i] += f[i].size\n  end\nend\nif sum[0] > sum[1]\n  puts \"Fennec\"\nelse\n  puts \"Snuke\"\nend", "label": 0, "name1": "s944901694.java", "name2": "s543014556.rb"}, {"id": 130, "code1": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable {\n\tFastReader scn;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\n\tvoid solve() {\n\t\tint n = scn.nextInt(), mod = (int) 1e9 + 7;\n\t\tchar[] cmp = scn.next().toCharArray();\n\t\t\n\t\tint[][] dp = new int[n + 1][n + 1];\n\t\tdp[1][1] = 1;\n\t\t\n\t\tfor(int len = 2; len <= n; len++) {\n\t\t\tint[] pref = new int[n + 1];\n\t\t\tfor(int i = 1; i <= n; i++) {\n\t\t\t\tpref[i] = (pref[i - 1] + dp[len - 1][i]) % mod;\n\t\t\t}\n\t\t\tfor(int curr = 1; curr <= len; curr++) {\n\t\t\t\tint L, R;\n\t\t\t\tif(cmp[len - 2] == '<') {\n\t\t\t\t\tL = 1;\n\t\t\t\t\tR = curr - 1;\n\t\t\t\t} else {\n\t\t\t\t\tL = curr;\n\t\t\t\t\tR = n;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(L <= R) {\n\t\t\t\t\tdp[len][curr] += (pref[R] - pref[L - 1]);\n\t\t\t\t\tif(dp[len][curr] >= mod) {\n\t\t\t\t\t\tdp[len][curr] -= mod;\n\t\t\t\t\t} else if(dp[len][curr] < 0) {\n\t\t\t\t\t\tdp[len][curr] += mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor(int curr = 1; curr <= n; curr++) {\n\t\t\tans += dp[n][curr];\n\t\t\tif(ans >= mod) {\n\t\t\t\tans -= mod;\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t}\n\n\tpublic void run() {\n\t\tlong time = System.currentTimeMillis();\n\t\tboolean oj = true;\n\t\tout = new PrintWriter(System.out);\n\t\tscn = new FastReader(oj);\n\t\tsolve();\n\t\tout.flush();\n\t\tif (!oj) {\n\t\t\tSystem.out.println(Arrays.deepToString(new Object[] { System.currentTimeMillis() - time + \" ms\" }));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"Main\", 1 << 26).start();\n\t}\n\n\tclass FastReader {\n\t\tInputStream is;\n\n\t\tpublic FastReader(boolean onlineJudge) {\n\t\t\tis = onlineJudge ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\t}\n\n\t\tpublic FastReader() {\n\t\t\tis = System.in;\n\t\t}\n\n\t\tbyte[] inbuf = new byte[1024];\n\t\tpublic int lenbuf = 0, ptrbuf = 0;\n\n\t\tint readByte() {\n\t\t\tif (lenbuf == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (ptrbuf >= lenbuf) {\n\t\t\t\tptrbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn inbuf[ptrbuf++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tint skip() {\n\t\t\tint b;\n\t\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t\t;\n\t\t\treturn b;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tchar nextChar() {\n\t\t\treturn (char) skip();\n\t\t}\n\n\t\tString next() {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile ((!isSpaceChar(b) || b == ' ')) { // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tchar[] next(int n) {\n\t\t\tchar[] buf = new char[n];\n\t\t\tint b = skip(), p = 0;\n\t\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t\t}\n\n\t\tint nextInt() {\n\t\t\tint num = 0, b;\n\t\t\tboolean minus = false;\n\t\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\tlong num = 0;\n\t\t\tint b;\n\t\t\tboolean minus = false;\n\t\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tchar[][] nextMatrix(int n, int m) {\n\t\t\tchar[][] map = new char[n][];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next(m);\n\t\t\treturn map;\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tint[][] IndIntArray(int n) {\n\t\t\tint[][] a = new int[n][];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = new int[] { nextInt(), i };\n\t\t\treturn a;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tint[][] next2DInt(int n, int m) {\n\t\t\tint[][] arr = new int[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[][] next2DLong(int n, int m) {\n\t\t\tlong[][] arr = new long[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextLongArray(m);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] shuffle(int[] arr) {\n\t\t\tRandom r = new Random();\n\t\t\tfor (int i = 1, j; i < arr.length; i++) {\n\t\t\t\tj = r.nextInt(i);\n\t\t\t\tint c = arr[i];\n\t\t\t\tarr[i] = arr[j];\n\t\t\t\tarr[j] = c;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] shuffle(long[] arr) {\n\t\t\tRandom r = new Random();\n\t\t\tfor (int i = 1, j; i < arr.length; i++) {\n\t\t\t\tj = r.nextInt(i);\n\t\t\t\tlong c = arr[i];\n\t\t\t\tarr[i] = arr[j];\n\t\t\t\tarr[j] = c;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] uniq(int[] arr) {\n\t\t\tarr = scn.shuffle(arr);\n\t\t\tArrays.sort(arr);\n\t\t\tint[] rv = new int[arr.length];\n\t\t\tint pos = 0;\n\t\t\trv[pos++] = arr[0];\n\t\t\tfor (int i = 1; i < arr.length; i++) {\n\t\t\t\tif (arr[i] != arr[i - 1]) {\n\t\t\t\t\trv[pos++] = arr[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Arrays.copyOf(rv, pos);\n\t\t}\n\n\t\tlong[] uniq(long[] arr) {\n\t\t\tarr = scn.shuffle(arr);\n\t\t\tArrays.sort(arr);\n\t\t\tlong[] rv = new long[arr.length];\n\t\t\tint pos = 0;\n\t\t\trv[pos++] = arr[0];\n\t\t\tfor (int i = 1; i < arr.length; i++) {\n\t\t\t\tif (arr[i] != arr[i - 1]) {\n\t\t\t\t\trv[pos++] = arr[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Arrays.copyOf(rv, pos);\n\t\t}\n\n\t\tint[] reverse(int[] arr) {\n\t\t\tint l = 0, r = arr.length - 1;\n\t\t\twhile (l < r) {\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tarr[r] = arr[l] ^ arr[r];\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tl++;\n\t\t\t\tr--;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] reverse(long[] arr) {\n\t\t\tint l = 0, r = arr.length - 1;\n\t\t\twhile (l < r) {\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tarr[r] = arr[l] ^ arr[r];\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tl++;\n\t\t\t\tr--;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] compress(int[] arr) {\n\t\t\tint n = arr.length;\n\t\t\tint[] rv = Arrays.copyOf(arr, n);\n\t\t\trv = uniq(rv);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = Arrays.binarySearch(rv, arr[i]);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] compress(long[] arr) {\n\t\t\tint n = arr.length;\n\t\t\tlong[] rv = Arrays.copyOf(arr, n);\n\t\t\trv = uniq(rv);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = Arrays.binarySearch(rv, arr[i]);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\t}\n}", "code2": "d=*1..gets.to_i;gets.chop.bytes{|c|x=0;n=d.pop;d.map!{|a|x=(x+-c%3*n+a*=1-c%3).%10**9+7}};p *d", "label": 1, "name1": "s976963924.java", "name2": "s665085996.rb"}, {"id": 798, "code1": "import java.util.*;\nclass Main\n{\n    static long mod = 1000000007;\n    public static void main (String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long[] a = new long[n];\n        for(int i = 0; i < n; i++){\n            a[i] = sc.nextLong();\n        }\n        long[] b = new long[n+1];\n        b[0] = 0;\n        for(int i = 1; i <= n; i++){\n            b[i] = (b[i-1] + pow(i, mod - 2)) % mod;\n        }\n        long ans = 0;\n        for(int i = 0; i < n; i++){\n            ans += a[i] * (b[i+1] + b[n - i] - 1);\n            ans %= mod;\n        }\n        for(int i = 1; i <= n; i++){\n            ans *= i;\n            ans %= mod;\n        }\n        System.out.println(ans);\n    }\n    static long pow(long a, long p){\n        if(p == 0) return 1;\n        else if(p % 2 == 0){\n            long d = pow(a, p/2);\n            return d * d % mod;\n        }\n        else return pow(a, p-1) * a % mod;\n    }\n}", "code2": "N=gets.to_i\nedges=Array.new(N){Array.new}\n(N-1).times do\n    a,b=gets.split.map(&:to_i)\n    a-=1\n    b-=1\n    edges[a] << b\n    edges[b] << a\nend\ndist_from_1=Array.new(N)\ndist_from_last=Array.new(N)\n\ndef dfs(edges,start,dists)\n    used=Array.new(edges.size,false)\n    used[start]=true\n    dists[start]=0\n    stack=[start]\n    while !stack.empty?\n        v=stack.pop\n        edges[v].each do |vv|\n            next if used[vv]\n            used[vv]=true\n            dists[vv]=dists[v]+1\n            stack << vv\n        end\n    end\nend\n\ndfs(edges,0,dist_from_1)\ndfs(edges,N-1,dist_from_last)\n\n\nb_count=0\nw_count=0\nN.times do |i|\n    b_count+=1 if dist_from_1[i]<=dist_from_last[i]\n    w_count+=1 if dist_from_1[i]>dist_from_last[i]\nend\n\nputs b_count>w_count ? \"Fennec\" : \"Snuke\"", "label": 0, "name1": "s041637006.java", "name2": "s497047069.rb"}, {"id": 135, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint[] abc = new int[3];\n\t\tArrays.setAll(abc, i -> sc.nextInt());\n\t\tArrays.sort(abc);\n\t\t\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tint dif = abc[2] - abc[i];\n\t\t\tint quo = dif / 2;\n\t\t\tcnt += quo;\n\t\t\tabc[i] += 2 * quo;\n\t\t}\n\t\t\n\t\tArrays.sort(abc);\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tabc[2 - i] -= abc[0];\n\t\t}\n\t\t\n\t\tfor (int i : abc) {\n\t\t\tcnt += i;\n\t\t}\n\t\t\n\t\tSystem.out.println(cnt);\n\t}\t\n}\n", "code2": "inputs = gets.chomp.split(\" \").map(&:to_i).sort\nans = 0\nis_all = inputs[0]\n\nuntil inputs.all?{|v| v == is_all} do\n    if inputs[0] + 2 <= inputs[2]\n        inputs[0] += 2\n    else\n        inputs[0] += 1\n        inputs[1] += 1\n    end\n    inputs.sort!\n    is_all = inputs[0]\n    ans += 1\nend\n\nputs ans", "label": 1, "name1": "s839188761.java", "name2": "s407672581.rb"}, {"id": 500, "code1": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String str = sc.next();\n        int n = str.length();\n        int digitSum = 0;\n        for (int i = 0; i < n; i++)\n            digitSum += (str.charAt(i) - '0');\n        if(digitSum % 9 == 0) {\n            System.out.println(\"Yes\");\n        }\n        else {\n            System.out.println(\"No\");\n        }\n    }\n}\n\n", "code2": "S = gets.chomp.chars\nans = true\nS.each.with_index do |ch, i|\n  i += 1\n  if i.odd?\n    ans = false unless ['R', 'U', 'D'].include?(ch)\n  else\n    ans = false unless ['L', 'U', 'D'].include?(ch)\n  end\nend\nputs(ans ? 'Yes' : 'No')\n", "label": 0, "name1": "s204970720.java", "name2": "s595956620.rb"}, {"id": 262, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint A = sc.nextInt();\n\t\tint B = sc.nextInt();\n\t\tint C = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tint res = 0;\n\t\tres+=Math.min(A, K);\n\t\tK -= res;\n\t\tif(K==0) {\n\t\t\tSystem.out.println(res);\n\t\t\tSystem.exit(0);\n\t\t}\n\t\tK-=B;\n\t\tif(K>0) {\n\t\t\tres-=Math.min(K, C);\n\t\t}\n\t\tSystem.out.println(res);\n\n\t}\n}", "code2": "imput = gets.chomp.split(\" \")\n#puts imput\na = imput[0].to_i\nb = imput[1].to_i\nc = imput[2].to_i\nk = imput[3].to_i\n#puts a,b,c,k\nif (a >= k) then\n    puts k\nelse\n    if (a + b >= k) then\n        puts a\n    else\n        puts (a - (k-a-b))\n        #puts k\n    end\nend\n  ", "label": 1, "name1": "s649759516.java", "name2": "s251719998.rb"}, {"id": 482, "code1": "\n\nimport java.util.*;\nimport java.io.*;\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t\n\tScanner sc=new Scanner(System.in);\n\t     int n=sc.nextInt();\n\t     int m=sc.nextInt();\n\t     ArrayList<ArrayList<Integer>> a=new ArrayList<>();\nfor(int i=0;i<n;i++) {\n\ta.add(new ArrayList<Integer>());\n}\nfor(int j=0;j<m;j++) {\n\tint x=sc.nextInt()-1;\n\tint y=sc.nextInt()-1;\n\ta.get(x).add(y);\n\ta.get(y).add(x);\n}\nboolean vis[]=new boolean[n];\nans=0;\n\tSystem.out.println(dfs(a,0,vis,1,n));\n\t}\nstatic int ans=0;\t\n\tstatic int dfs(ArrayList<ArrayList<Integer>> a,int src,boolean vis[],int count,int n) {\n\t\tvis[src]=true;\n\t\tfor(int i:a.get(src)) {\n\t\t\tif(vis[i]==false) {\n\t\t\t\t\n\t\t\t\tdfs(a,i,vis,count+1,n);\n\t\t\t}\n\t\t}\n\t\tif(count==n) {\n\t\tans++;\n\t\tvis[src]=false;\n\t\t\t}else {\n\t\t\t\tvis[src]=false;\n\t\t\t}\n\t\t\n\t\treturn ans;\n\t}\n\tstatic int[] arr(int n,Scanner sc) {\n\t\tint a[]=new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i]=sc.nextInt();\n\t\t}\n\t\treturn a;\n}\n\n}\n", "code2": "n, m = gets.split.map(&:to_i)\nary = (n + 1).times.map { Array.new(n + 1) }\nm.times {\n  a, b = gets.split.map(&:to_i)\n  ary[a][b] = ary[b][a] = true\n}\n\nputs [*2..n].permutation.count { |a| ([1] + a).each_cons(2).all? { |b| ary.dig(*b) } }", "label": 1, "name1": "s658101216.java", "name2": "s048457622.rb"}, {"id": 167, "code1": "import java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tchar[] s = sc.next().toCharArray();\n\t\tStack<Character> st = new Stack<>();\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < s.length; i++) {\n\t\t\tif (s[i] == 'T') {\n\t\t\t\tif (st.isEmpty()) cnt++;\n\t\t\t\telse st.pop();\n\t\t\t} else {\n\t\t\t\tst.push('S');\n\t\t\t}\n\t\t}\n\t\tcnt += st.size();\n\t\tSystem.out.println(cnt);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}", "code2": "x = gets.chomp\nt = 0\ns = 0\n\nx.each_char do |c|\n  if c == 'S'\n    s += 1\n  else c == 'T'\n    if s == 0\n      t += 1\n    else\n      s -= 1\n    end\n  end\nend\n\nputs t + s\n", "label": 1, "name1": "s350666247.java", "name2": "s945964760.rb"}, {"id": 68, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\n\n\npublic class Main {\n\n\tprivate BufferedReader reader = new BufferedReader(new InputStreamReader(System.in), 1);\n\n\tprivate String inputData = null;\n\n\tpublic String[] data = null;\n\n\tpublic int num = 0;\n\n\tpublic int count = 0;\n\n\tpublic HashMap<Integer, Integer> humanData = new HashMap<Integer, Integer>();\n\n\tpublic ArrayList<Integer> topId = new ArrayList<Integer>();\n\n\tpublic ArrayList<Integer> topLength = new ArrayList<Integer>();\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().start();\n\t\tSystem.exit(0);\n\t}\n\n\tpublic void start() {\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\tthis.inputData = reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t\t\tthis.data = this.inputData.split(\" \");\n\n\t\t\tif (this.data.length == 1) {\n\t\t\t\tif (this.data[0].equals(\"0\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tthis.num = Integer.parseInt(this.data[0]);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.humanData.clear();\n\n\t\t\tfor (int i = 0; i < this.num; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.inputData = reader.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tthis.data = this.inputData.split(\" \");\n\n\t\t\t\tthis.humanData.put(Integer.parseInt(data[0]),\n\t\t\t\t\t\tInteger.parseInt(data[1]) + Integer.parseInt(data[2]));\n\n\t\t\t}\n\n\t\t\tIterator<Integer> itId = this.humanData.keySet().iterator();\n\t\t\tint numCount = 0;\n\t\t\twhile (itId.hasNext()) {\n\t\t\t\tint id = itId.next();\n\t\t\t\tif (numCount == 0) {\n\t\t\t\t\tthis.topId.add(id);\n\t\t\t\t\tthis.topLength.add(this.humanData.get(id));\n\t\t\t\t} else {\n\t\t\t\t\tif (this.topLength.get(count) <= this.humanData.get(id)) {\n\t\t\t\t\t\tthis.topId.set(this.count, id);\n\t\t\t\t\t\tthis.topLength.set(this.count, this.humanData.get(id));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnumCount++;\n\t\t\t}\n\n\t\t\tthis.count++;\n\n\t\t}\n\n\t\tfor (int i = 0; i < this.topId.size(); i++) {\n\t\t\tSystem.out.println(this.topId.get(i) + \" \" + this.topLength.get(i));\n\t\t}\n\n\t}\n\n}", "code2": "puts (1..$_.to_i).map{a,b,c=gets.split.map &:to_i;[a,b+c]}.max_by{|i,j|j}*\" \"while gets>?1", "label": 1, "name1": "s083635030.java", "name2": "s118728373.rb"}, {"id": 546, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\n\n\npublic class Main {\n\n\tprivate BufferedReader reader = new BufferedReader(new InputStreamReader(System.in), 1);\n\n\tprivate String inputData = null;\n\n\tpublic String[] data = null;\n\n\tpublic int num = 0;\n\n\tpublic int count = 0;\n\n\tpublic HashMap<Integer, Integer> humanData = new HashMap<Integer, Integer>();\n\n\tpublic ArrayList<Integer> topId = new ArrayList<Integer>();\n\n\tpublic ArrayList<Integer> topLength = new ArrayList<Integer>();\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().start();\n\t\tSystem.exit(0);\n\t}\n\n\tpublic void start() {\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\tthis.inputData = reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t\t\tthis.data = this.inputData.split(\" \");\n\n\t\t\tif (this.data.length == 1) {\n\t\t\t\tif (this.data[0].equals(\"0\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tthis.num = Integer.parseInt(this.data[0]);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.humanData.clear();\n\n\t\t\tfor (int i = 0; i < this.num; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.inputData = reader.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tthis.data = this.inputData.split(\" \");\n\n\t\t\t\tthis.humanData.put(Integer.parseInt(data[0]),\n\t\t\t\t\t\tInteger.parseInt(data[1]) + Integer.parseInt(data[2]));\n\n\t\t\t}\n\n\t\t\tIterator<Integer> itId = this.humanData.keySet().iterator();\n\t\t\tint numCount = 0;\n\t\t\twhile (itId.hasNext()) {\n\t\t\t\tint id = itId.next();\n\t\t\t\tif (numCount == 0) {\n\t\t\t\t\tthis.topId.add(id);\n\t\t\t\t\tthis.topLength.add(this.humanData.get(id));\n\t\t\t\t} else {\n\t\t\t\t\tif (this.topLength.get(count) <= this.humanData.get(id)) {\n\t\t\t\t\t\tthis.topId.set(this.count, id);\n\t\t\t\t\t\tthis.topLength.set(this.count, this.humanData.get(id));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnumCount++;\n\t\t\t}\n\n\t\t\tthis.count++;\n\n\t\t}\n\n\t\tfor (int i = 0; i < this.topId.size(); i++) {\n\t\t\tSystem.out.println(this.topId.get(i) + \" \" + this.topLength.get(i));\n\t\t}\n\n\t}\n\n}", "code2": "T = ['A', 'B', 'AB', 'O']\nr = Array.new(4, 0)\n\nwhile s = gets\n  r[T.index(s.chomp.split(',')[1])] += 1\nend\n\nr.each { |n| puts n } ", "label": 0, "name1": "s083635030.java", "name2": "s391304310.rb"}, {"id": 510, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString s= sc.next();\n\t\tfor (int i=0;i<s.length();i++) {\n\t\t\tif (s.charAt(i)=='R'||s.charAt(i)=='L') {\n\t\t\t\tif (i%2==0&&s.charAt(i)!='R')\t{\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t\treturn ;\n\t\t\t\t} else if (i%2==1&&s.charAt(i)!='L'){\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t\treturn ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\treturn ;\n\t\t}\n\t}\n}\n", "code2": "n,a,b = gets.chomp.split(\" \").map(&:to_i)\nx = gets.chomp.split(\" \").map(&:to_i)\nborder = b/a\nnow = x[0]\nmp = 0\n(n-1).times do |i|\n  if x[i+1] - now > border\n    mp += b\n    now = x[i+1]\n  else\n    mp += (x[i+1] - now) * a\n    now = x[i+1]\n  end\nend\nputs mp", "label": 0, "name1": "s922990944.java", "name2": "s543935050.rb"}, {"id": 913, "code1": "import java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.PrimitiveIterator;\nimport java.util.Scanner;\nimport java.util.function.Supplier;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nclass Main{\n\n\tprivate void solve(){\n\t\tint[] c=new int[26];\n\t\tint h=gInt(),w=gInt();\n\t\tSTRS(h).flatMapToInt(String::chars)\n\t\t\t\t.map(i->i-'a')\n\t\t\t\t.forEach(i->++c[i]);\n\t\tint one=(h%2)*(w%2);\n\n\t\tint two=(w%2==1?h/2*2:0)+(h%2==1?w/2*2:0);\n\t\tint four=h*w-one-two;\n\n\t\tSystem.err.println(one);\n\t\tSystem.err.println(two);\n\t\tSystem.err.println(four);\n\t\tSystem.err.println(Arrays.toString(c));\n\t\tfor(int i:rep(26)) {\n\t\t\twhile(four>0&&c[i]>=4) {\n\t\t\t\tfour-=4;\n\t\t\t\tc[i]-=4;\n\t\t\t}\n\t\t}\n\t\tfor(int i:rep(26)) {\n\t\t\ttwo-=c[i]/2*2;\n\t\t\tc[i]%=2;\n\t\t\tif(two<0) {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfor(int i:rep(26)) {\n\t\t\tone-=c[i];\n\t\t\tc[i]=0;\n\t\t\tif(one<0) {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\n\t\t\t\tArrays.stream(c).noneMatch(i->i>0)\n\t\t\t\t?\"Yes\":\"No\");\n\t}\n\n\tpublic static void main(String[]$){\n\t\tnew Main().solve();\n\t}\n\n\tScanner s=new Scanner(System.in);\n\n\tint gInt(){\n\t\treturn Integer.parseInt(s.next());\n\t}\n\tlong gLong(){\n\t\treturn Long.parseLong(s.next());\n\t}\n\tdouble gDouble(){\n\t\treturn Double.parseDouble(s.next());\n\t}\n\n\tSupplierIterator<Integer> ints(int n){\n\t\treturn new SupplierIterator<>(n,this::gInt);\n\t}\n\tSupplierIterator<Long> longs(int n){\n\t\treturn new SupplierIterator<>(n,this::gLong);\n\t}\n\tSupplierIterator<Double> doubles(int n){\n\t\treturn new SupplierIterator<>(n,this::gDouble);\n\t}\n\tSupplierIterator<String> strs(int n){\n\t\treturn new SupplierIterator<>(n,s::next);\n\t}\n\n\tstatic class SupplierIterator<T> implements Iterable<T>,Iterator<T>{\n\t\tint\t\t\tt;\n\t\tSupplier<T>\tsupplier;\n\n\t\tSupplierIterator(int t,Supplier<T> supplier){\n\t\t\tthis.t=t;\n\t\t\tthis.supplier=supplier;\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<T> iterator(){\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean hasNext(){\n\t\t\treturn t>0;\n\t\t}\n\n\t\t@Override\n\t\tpublic T next(){\n\t\t\t--t;\n\t\t\treturn supplier.get();\n\t\t}\n\t}\n\n\n\tRange rep(int i){\n\t\treturn Range.rep(i);\n\t}\n\tRange rep(int f,int t,int d){\n\t\treturn Range.rep(f,t,d);\n\t}\n\tRange rep(int f,int t){\n\t\treturn rep(f,t,1);\n\t}\n\tRange rrep(int f,int t){\n\t\treturn rep(f,t,-1);\n\t}\n\n\tstatic class Range implements Iterable<Integer>,PrimitiveIterator.OfInt{\n\n\t\tint to,cur,d;\n\n\t\tRange(int from,int to,int d){\n\t\t\tthis.cur=from-d;\n\t\t\tthis.to=to;\n\t\t\tthis.d=d;\n\t\t}\n\n\t\tRange(int n){\n\t\t\tthis(0,n-1,1);\n\t\t}\n\n\t\t@Override\n\t\tpublic Iterator<Integer> iterator(){\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean hasNext(){\n\t\t\treturn cur+d==to||(cur!=to&&(cur<to==cur+d<to));\n\t\t}\n\n\t\t@Override\n\t\tpublic int nextInt(){\n\t\t\treturn cur+=d;\n\t\t}\n\n\t\tstatic Range rep(int i){\n\t\t\treturn new Range(i);\n\t\t}\n\t\tstatic Range rep(int f,int t,int d){\n\t\t\treturn new Range(f,t,d);\n\t\t}\n\t\tstatic Range rep(int f,int t){\n\t\t\treturn rep(f,t,1);\n\t\t}\n\t\tstatic Range rrep(int f,int t){\n\t\t\treturn rep(f,t,-1);\n\t\t}\n\t}\n\n\n\tIntStream REP(int v){\n\t\treturn IntStream.range(0,v);\n\t}\n\tIntStream REP(int l,int r){\n\t\treturn IntStream.rangeClosed(l,r);\n\t}\n\n\tIntStream INTS(int n){\n\t\treturn REP(n).map(i->gInt());\n\t}\n\tStream<String> STRS(int n){\n\t\treturn REP(n).mapToObj(i->s.next());\n\t}\n}\n", "code2": "N = gets.to_i\ns = []\nN.times{ s << gets.to_i }\ns.sort!\n\nsum = s.inject(:+)\n\nif sum % 10 != 0\n  \n  puts sum\n  \nelse\n  \n  t = []\n  s.each{ |x| t << x if x % 10 != 0 }\n  \n  if t.size == 0\n    puts 0\n  else\n    puts sum - t[0]\n  end\nend\n", "label": 0, "name1": "s705438119.java", "name2": "s641490234.rb"}, {"id": 281, "code1": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String args[])\n    {\n        Scanner sc=new Scanner(System.in);\n       int ar[]=new int[] {0,0,0,0};\n       for(int i=0;i<3;i++)\n       {\n           int a=sc.nextInt();\n           int b=sc.nextInt();\n           ar[a-1]+=1;\n           ar[b-1]+=1;\n       }\n       \n       for(int i = 0; i < 4; i++) {\n\t\t\tif(ar[i] < 1 || ar[i] > 2) {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"YES\");\n       \n//       for(int i:ar)\n//       {\n//           if(i>2)\n//           {\n//               System.out.println(\"NO\");\n//               System.exit(0);\n//           }\n//       }\n//       System.out.println(\"YES\");\n    }\n}", "code2": "path_list = 3.times.map { gets.split(' ').map(&:to_i) }\nedge_to_count = Hash.new(0)\npath_list.each do |(a, b)|\n  edge_to_count[a] += 1\n  edge_to_count[b] += 1\nend\n\nans = edge_to_count.keys.size == 4 && edge_to_count.values.max < 3\nputs(ans ? 'YES': 'NO')\n", "label": 1, "name1": "s048278962.java", "name2": "s267170093.rb"}, {"id": 441, "code1": "import java.io.*;\nimport java.util.*;\n \npublic class Main {\n\tstatic final Reader in = new Reader();\n\tstatic final long M=(long)1e9+7;\n\t\n\tpublic static void main(String[] args) {\n\t\tint n=in.nextInt();\n\t\tlong[] ps = new long[n+1];\n\t\tlong nf=1;\n\t\tfor(int i=1; i<=n; ++i) {\n\t\t\tps[i]=(ps[i-1]+in.nextInt())%M;\n\t\t\tnf=nf*i%M;\n\t\t}\n\t\tlong ans=nf*ps[n]%M, s=0;\n\t\tfor(int i=1; i<=n-1; ++i) {\n\t\t\ts=(s+ps[n-i]-ps[i]+M)%M;\n\t\t\tans=(ans+nf*modI((long)(i+1)*(i>=n-1?1:i+2), M)%M*2*s+nf*modI(i+1, M)%M*(ps[i]+ps[n]-ps[n-i]+M))%M;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\t\n\tstatic long modI(long a, long m) {\n\t\treturn (a%=m)<=1?1:(1-modI(m%a, a)*m)/a+m;\n\t}\n\t\n\tstatic class Reader {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st;\n\t\tString next() {\n\t\t\twhile(st==null||!st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch(Exception e) {}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t}\n}", "code2": "eval'*A=#'+`tr ' ' ,`\ns=m=10**9+7\nf=1\ni=0\np A.sum{i+=1\nf=f*i%m\n-_1+(_1+A[-i])*s+=i.pow(m-2,m)}*f%m", "label": 1, "name1": "s013996602.java", "name2": "s587168748.rb"}, {"id": 367, "code1": "\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.AbstractCollection;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Comparator;\nimport java.util.ArrayList;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author silviase\n */\npublic class Main {\n    \n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DijkstraVerify solver = new DijkstraVerify();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DijkstraVerify {\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            int source = in.nextInt();\n            Graph g = new Graph(n);\n            for (int i = 0; i < m; i++) {\n                g.addEdge(new Edge(in.nextInt(), in.nextInt(), in.nextInt()));\n            }\n            long[] d = g.dijkstra(source);\n            for (int i = 0; i < n; i++) {\n                if (d[i] > 1e15) out.println(\"INF\");\n                else out.println(d[i]);\n            }\n        }\n\n    }\n\n    static class Graph {\n        public int size;\n        public ArrayList<Edge>[] adj;\n        public int[] inDeg;\n        public int[] vertexCost;\n\n        @SuppressWarnings(\"unchecked\")\n        public Graph(int size) {\n            this.size = size;\n            adj = new ArrayList[size];\n            inDeg = new int[size];\n            vertexCost = new int[size];\n            for (int i = 0; i < size; i++) {\n                adj[i] = new ArrayList<>();\n            }\n        }\n\n        public void addEdge(Edge e) {\n            adj[e.from].add(e);\n            inDeg[e.to]++;\n        }\n\n        public long[] dijkstra(int from) {\n            long[] d = new long[size];\n            PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.comparing(e -> d[e]));\n            for (int i = 0; i < size; i++) {\n                d[i] = (i == from) ? 0 : (long) 1e18;\n                pq.add(i);\n            }\n            // System.out.println(Arrays.toString(pq.toArray()));\n            while (!pq.isEmpty()) {\n                int search = pq.poll();\n                // System.out.println(\"now: \" + search);\n                ArrayList<Edge> edges = adj[search];\n                for (Edge e : edges) {\n                    // System.out.println(e.toString());\n                    long cmp = d[search] + e.cost;\n                    if (d[e.to] > d[search] + e.cost) {\n                        // \u66f4\u65b0\u304c\u5165\u308b\n                        // \u51e6\u7406\u3092\u5165\u308c\u305f\u3044\u5834\u5408\u306f\u3053\u3053\u306b\u5165\u308c\u308b\n                        d[e.to] = d[search] + e.cost;\n                        pq.add(e.to);\n                    }\n                }\n                //  System.out.println(Arrays.toString(pq.toArray()));\n            }\n            return d;\n        }\n\n    }\n\n    static class Edge {\n        public int from;\n        public int to;\n        public long cost;\n\n        public Edge(int to) {\n            this.to = to;\n        }\n\n        public Edge(int to, long cost) {\n            this.to = to;\n            this.cost = cost;\n        }\n\n        public Edge(int from, int to, long cost) {\n            this.from = from;\n            this.to = to;\n            this.cost = cost;\n        }\n\n        public String toString() {\n            return \"Edge{\" +\n                    \"from=\" + from +\n                    \", to=\" + to +\n                    \", cost=\" + cost +\n                    '}';\n        }\n\n    }\n}\n\n\n", "code2": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif @array[i][1] < @array[j][1]\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if new_key >= @array[i][1]\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif @array[i][1] > @array[j][1]\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = (@array[j][1] < @array[k][1] ? j : k)\n\t\t\tif @array[i][1] > @array[l][1]\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_neighbour_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef dijkstra(start, goal = nil)\n\t\tstart = Set[start] if !start.kind_of?(Enumerable)\n\t\tgoal = Set[goal] if goal && !goal.kind_of?(Enumerable)\n\n\t\th = Heap.new\n\t\treached = Set.new\n\t\tstart.each{|v|\n\t\t\th.add(v, 0)\n\t\t\treached << v\n\t\t}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if goal && goal.include?(u)\n\t\t\tdist[u] = key\n\t\t\teach_neighbour_of(u){|v|\n\t\t\t\td = dist[u] + edge_length(u, v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tgoal ? nil : dist\n\tend\nend\n\nclass Digraph\n\tinclude Graphical\n\trequire 'set'\n\n\tdef add_node(label = nil)\n\t\tNode.new(label)\n\tend\n\n\tdef add_edge(u, v, label = nil)\n\t\te = Edge.new(u, v, label)\n\t\tu.outgoings[v] = e\n\t\tv.incomings[u] = e\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.outgoings.delete(v)\n\t\tv.incomings.delete(u)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(label)\n\t\t\t@label = label\n\t\t\t@outgoings = {}\n\t\t\t@incomings = {}\n\t\tend\n\n\t\tdef to_s\n\t\t\t@label\n\t\tend\n\t\t\n\t\tattr_accessor :incomings, :outgoings\n\t\tattr_reader :label\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, label = nil)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\t\t@label = label\n\t\tend\n\t\tattr_reader :from, :to, :label\n\tend\n\n\n\tdef get_path_bfs(s, t)\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\tu.outgoings.each{|e|\n\t\t\t\tv = e.to\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tpath_edge[v] = e\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = []\n\t\t\t\t\twhile e = path_edge[v]\n\t\t\t\t\t\tpath.unshift e\n\t\t\t\t\t\tv = e.from\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_dfs(s, t, reached = Set.new)\n\t\treached << s\t\n\t\ts.outgoings.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\treturn [e] if v == t\n\t\t\t\n\t\t\tpath = get_path_dfs(v, t, reached) \n\t\t\treturn [e] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef layers_from(start)\n\t\treached = Set[*start]\n\t\tlayers = [start]\n\n\t\tloop {\n\t\t\tlayers << []\n\t\t\tlayers[-2].each{|u|\n\t\t\t\tu.to_nodes.each{|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tlayers[-1] << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\tif layers[-1].empty?\n\t\t\t\tlayers.pop\n\t\t\t\treturn layers\n\t\t\tend\n\t\t}\n\tend\n\n\t#--- for Graphical module ---\n\tdef each_neighbour_of(u)\n\t\tu.outgoings.each_key{|v|\n\t\t\tyield v\n\t\t}\n\tend\n\n\tdef edge_length(u, v)\n\t\tu.outgoints[v] ? 1 : nil\n\tend\n\t#----------------------------\n\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\tu.outgoings.each{|e|\n\t\t\t\t\tv = e.to\n\t\t\t\t\td = f_dist[u] + e.label\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\tu.incomings.each{|e|\n\t\t\t\t\tv = e.from\n\t\t\t\t\td = b_dist[u] + e.label\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\nend\n\nclass WeightedDigraph < Digraph\n\tdef add_edge(u, v, length, label = nil)\n\t\te = Edge.new(u, v, length, label)\n\t\tu.outgoings[v] = e\n\t\tv.incomings[u] = e\n\t\te\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, length, label = nil)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\t\t@length = length\n\t\t\t@label = label\n\t\tend\n\t\tattr_reader :from, :to, :length, :label\n\tend\n\n\tdef edge_length(u, v)\n\t\tu.outgoings[v].length\n\tend\nend\n\nn, m, r = gets.split.map &:to_i\ng = WeightedDigraph.new\nnodes = (1..n).map{ g.add_node }\nm.times{\n\ti, j, c = gets.split.map &:to_i\n\tg.add_edge(nodes[i], nodes[j], c)\n}\ndist = g.dijkstra(nodes[r])\nputs (0..n-1).map {|i| dist[nodes[i]] || 'INF'}", "label": 1, "name1": "s326905326.java", "name2": "s482014619.rb"}, {"id": 296, "code1": "import java.util.*;\npublic class Main {\n        static Scanner sc = new Scanner(System.in);\n        static void myout(Object t){System.out.println(t);}//standard output\n        static void myerr(Object t){System.err.println(t);}//standard error\n        static String getStr(){return sc.next();}\n        static int getInt(){return Integer.parseInt(getStr());}\n        static long getLong(){return Long.parseLong(getStr());}\n        static boolean isNext(){return sc.hasNext();}\n        static String[] mySplit(String str){return str.split(\"\");}\n        public static void main(String[] args){\n          int N = getInt();\n          int M = getInt();\n          if(N >= M){\n            myout(0);\n            return;\n          }\n          long output = 0;\n          ArrayList<Integer> list = new ArrayList<Integer>(M);\n          for(int i = 0; i < M; i++){\n            list.add(getInt());\n          }\n          Collections.sort(list);\n          //myout(list);\n          PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\n          for(int i = 1; i < M; i++){\n            pq.add(Math.abs(list.get(i)-list.get(i-1)));\n          }\n          for(int i = 0; i < N-1; i++){\n            pq.poll();\n          }\n          while(pq.size() != 0){\n            output += pq.poll();\n          }\n          myout(output);\n        }\n        //\u4fbf\u5229\u30e1\u30bd\u30c3\u30c9\u8ffd\u52a0\u67a0\u3053\u3053\u304b\u3089\n\n        //\u4fbf\u5229\u30e1\u30bd\u30c3\u30c9\u8ffd\u52a0\u67a0\u3053\u3053\u307e\u3067\n}\n", "code2": "n,m = gets.split.map(&:to_i)\nxs = gets.split.map(&:to_i).sort\nys = (m-1).times.map{|i| xs[i+1] - xs[i]}.sort.reverse\nif n >= m\n  p 0\nelse\n  p ys[n-1..-1].inject(:+)\nend", "label": 1, "name1": "s460372083.java", "name2": "s843545160.rb"}, {"id": 966, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main\n{\n\n  public static void main(String[] args) throws IOException\n  {\n    BufferedReader r = new BufferedReader(new InputStreamReader(System.in), 1);\n    String[] sl = r.readLine().split(\"[\\\\s]+\");\n    int n = Integer.parseInt(sl[0]);\n    int c = Integer.parseInt(sl[1]);\n    int d[][] = new int[30][30];\n    int count[][] = new int[3][30];\n\n    for(int i = 0; i < c; i++)\n    {\n      sl = r.readLine().split(\"[\\\\s]+\");\n      for(int j = 0; j < c; j++)\n      {\n        d[i][j] = Integer.parseInt(sl[j]);\n      }\n    }\n\n    for(int i = 0; i < n; i++)\n    {\n      sl = r.readLine().split(\"[\\\\s]+\");\n      for(int j = 0; j < n; j++)\n      {\n        count[(i + j) % 3][Integer.parseInt(sl[j]) - 1]++;\n      }\n    }\n    \n    int sel[] = new int[3];\n    int min = Integer.MAX_VALUE;\n    \n    for(sel[0] = 0; sel[0] < c; sel[0]++)\n    {\n      for(sel[1] = 0; sel[1] < c; sel[1]++)\n      {\n        if(sel[0] == sel[1])\n        {\n          continue;\n        }\n        for(sel[2] = 0; sel[2] < c; sel[2]++)\n        {\n          if(sel[1] == sel[2] || sel[0] == sel[2])\n          {\n            continue;\n          }\n          \n          int stress = 0;\n          for(int i = 0; i < 3; i++)\n          {\n            for(int j = 0; j < c; j++)\n            {\n              stress += count[i][j] * d[j][sel[i]];\n            }\n          }\n          min = Math.min(min, stress);\n        }\n      }\n    }\n    \n    System.out.println(min);\n\n  }\n\n\n}", "code2": "N, A, B, *HS = $stdin.read.split.map(&:to_i)\ndef cleared?(n)\n  hs = HS.map{|h| h - B*n}.reject{|h| h <= 0}\n  times = hs.map{|h| (h.to_f / (A-B)).ceil}.inject(0, :+)\n  return times <= n\nend\nmin = 0\nmax = HS.inject(0, :+) / B\np (min..max).bsearch{|n| cleared?(n)}\n", "label": 0, "name1": "s743770667.java", "name2": "s961437635.rb"}, {"id": 878, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author GYSHGX868\n */\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    OutputWriter out = new OutputWriter(outputStream);\n    TaskA solver = new TaskA();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskA {\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n      char a = in.nextChar();\n      char b = in.nextChar();\n      if (a == 'H') {\n        out.printLine(b);\n      } else {\n        out.printLine(b == 'H' ? 'D' : 'H');\n      }\n    }\n\n  }\n\n  static class InputReader {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private InputReader.SpaceCharFilter filter;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public int read() {\n      if (numChars == -1) {\n        throw new InputMismatchException();\n      }\n      if (curChar >= numChars) {\n        curChar = 0;\n        try {\n          numChars = stream.read(buf);\n        } catch (IOException e) {\n          throw new InputMismatchException();\n        }\n        if (numChars <= 0) {\n          return -1;\n        }\n      }\n      return buf[curChar++];\n    }\n\n    public boolean isSpaceChar(int c) {\n      if (filter != null) {\n        return filter.isSpaceChar(c);\n      }\n      return isWhitespace(c);\n    }\n\n    public static boolean isWhitespace(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public char nextChar() {\n      int c = read();\n      while (isSpaceChar(c)) {\n        c = read();\n      }\n      return (char) c;\n    }\n\n    public interface SpaceCharFilter {\n      boolean isSpaceChar(int ch);\n\n    }\n\n  }\n\n  static class OutputWriter {\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n      this.writer = new PrintWriter(writer);\n    }\n\n    public void printLine(char i) {\n      writer.println(i);\n    }\n\n    public void close() {\n      writer.close();\n    }\n\n  }\n}\n\n", "code2": "k = gets.chomp.to_i\na,b = gets.chomp.split(' ').map(&:to_i)\n \n(a..b).each do |n|\n  if n%k == 0\n    puts \"OK\"\n    exit\n  end\nend\n  puts \"NG\"", "label": 0, "name1": "s595866024.java", "name2": "s738091462.rb"}, {"id": 154, "code1": "import java.io.*;\nimport java.util.*;\n \npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n \n    static class TaskD {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n \n            int N = in.nextInt();\n            for (int i = 0; i < N; i++) {\n                long A = in.nextLong();\n                long B = in.nextLong();\n \n                long a = Math.min(A, B);\n                long b = Math.max(A, B);\n \n                long ans = 2L * (a - 1) + przedzial(a, b);\n \n                out.println(ans);\n            }\n        }\n \n        private long przedzial(long a, long b) {\n            if (a == b || a + 1 == b) {\n                return 0;\n            }\n \n            return 1L + szukaj(a + 1, b - 2, a * b);\n        }\n \n        private long szukaj(long a, long b, long LIMIT) {\n            if (a > b) return 0;\n            if (a == b) {\n                return a * b < LIMIT ? 1 : 0;\n            }\n            long lo = a, hi = b;\n            while (lo + 1 < hi) {\n                long m = lo + (hi - lo) / 2;\n                if (m * m >= LIMIT) {\n                    hi = m;\n                } else {\n                    lo = m;\n                }\n            }\n            long ans1 = 1 + 2L * (lo - 1 - a + 1);\n            long ans2 = 0;\n            if (lo * (lo + 1) < LIMIT) {\n                ans2 = 2L * (lo - a + 1);\n            }\n            return Math.max(ans1, ans2);\n        }\n    }\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n    }\n}", "code2": "#!/usr/bin/env ruby\n\nrequire 'set'\n\nclass Hash\n  def push(key, value)\n    self[key] = [] if self[key] == nil\n    self[key].push(value)\n  end\nend\n\nclass Array\n  def lower_bound(value)\n    left = -1;\n    right = self.length;\n    while left + 1 < right\n      mid = left + (right - left) / 2;\n      if self[mid] >= value\n        right = mid\n      else\n        left = mid\n      end\n    end\n    right\n  end\n\n  def unique\n    res = [self.first]\n    each_cons(2) do |a, b|\n      if a != b\n        res.push(b)\n      end\n    end\n    res\n  end\nend\n\ndef get_ints\n  gets.chomp.split.map(&:to_i)\nend\n\ndef get_ints_minus_one\n  get_ints.map { |x| x - 1 }\nend\n\ndef get_int\n  gets.chomp.to_i\nend\n\nQ = get_int\nQ.times do |i|\n  a, b = get_ints\n\n  if a == b\n    puts 2 * (a-1)\n    next\n  end\n  min = [a, b].min\n  max = [a, b].max\n\n  ab = a * b\n\n  high = max - 1\n  low = min\n  while high - low > 1\n    mid = low + (high - low) / 2\n\n    if mid ** 2 >= ab\n      high = mid\n    else\n      low = mid\n    end\n  end\n\n  high, low = [high, low].max, [high, low].min\n  rest = if high * high < ab\n    high + high - min - 1\n  elsif high * low < ab\n    high + low - min - 1\n  else\n    low + low - min - 1\n  end\n\n  puts min - 1 + rest\n\n  # ab = a * b\n  # b_down = (ab/(a+1)).then { |x| x * (a+1) == ab ? x - 1 : x }\n  # b_down_amari = b - b_down - 1\n  #\n  # a_down = (ab/(b+1)).then { |x| x * (b+1) == ab ? x - 1 : x }\n  # a_down_amari = a - a_down - 1\n  #\n  # binding.pry if a == 22\n  # puts b_down + a_down + [a_down_amari, b_down_amari].min\nend\n", "label": 1, "name1": "s546530291.java", "name2": "s516108110.rb"}, {"id": 645, "code1": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        Main main = new Main();\n        main.solve();\n    }\n\n    public void solve() {\n        Scanner scan = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n        int N = scan.nextInt();\n        List<Integer> candidate = new ArrayList<>();\n        for (int i = 1; i <= N; i++) {\n            candidate.add(i);\n        }\n        scan.nextLine();\n        String p = scan.nextLine();\n        String q = scan.nextLine();\n        List<List<Integer>> list = make(candidate);\n        List<String> strings = new ArrayList();\n        for (List<Integer> x : list) {\n            strings.add(x.stream().map(i -> i.toString()).collect(Collectors.joining(\" \")));\n        }\n        int len = strings.size();\n        int l = 0;\n        int r = 0;\n        for (int i = 0; i < len; i++) {\n            if (p.equals(strings.get(i))) {\n                l = i;\n            }\n            if (q.equals(strings.get(i))) {\n                r = i;\n            }\n        }\n        System.out.println(Math.abs(l - r));\n    }\n\n    public static List<List<Integer>> make(List<Integer> candidate) {\n        if (candidate.size() == 0) {\n            List<List<Integer>> empty = new ArrayList<>();\n            empty.add(new ArrayList<>());\n            return empty;\n        }\n\n        return candidate.stream().flatMap(i -> {\n            List<Integer> rest = new ArrayList<>(candidate);\n            rest.remove(i);\n            return make(rest).stream().map(list -> {\n                list.add(0, i);\n                return list;\n            });\n        }).collect(Collectors.toList());\n    }\n}\n", "code2": "def g;gets.split.map &:to_i;end\nr=1..n=g[0]\nw=[[]]+r.map{[0]+[1e9]*n}\nr.map{f,_,*t=g;t.map{|i|w[f][i]=1}}\nr.map{|k|w.map!{|i|i=i.zip(w[k]).map{|a,b|[a,b+i[k]].min}}}\ng[0].times{s,d,v=g;puts v<(c=w[s][d]+1)?:NA:c}", "label": 0, "name1": "s162956680.java", "name2": "s352888283.rb"}, {"id": 174, "code1": "\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int W = sc.nextInt();\n\t\t\tfinal int H = sc.nextInt();\n\t\t\t\n\t\t\tif(W == 0  && H == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] map = new int[H][W];\n\t\t\t\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tchar[] input = sc.next().toCharArray();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tif('0' <= input[j] && input[j] <= '9'){\n\t\t\t\t\t\tmap[i][j] = input[j] - '0';\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][] len = new int[H][W];\n\t\t\tshort[][][] dp = new short[H][W][H+W+1];\n\t\t\t\n\t\t\tint max = 0;\n\t\t\tint m_x = -1;\n\t\t\tint m_y = -1;\n\t\t\t\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tif(map[i][j] < 0){\n\t\t\t\t\t\tdp[i][j][0] = -1;\n\t\t\t\t\t\tlen[i][j] = -1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(i == 0 && j == 0){\n\t\t\t\t\t\tdp[i][j][0] = (short)(map[i][j]);\n\t\t\t\t\t\tlen[i][j] = map[i][j] == 0 ? 0 : 1;\n\t\t\t\t\t}else if(j == 0){\n\t\t\t\t\t\tfinal int p_len = len[i-1][j];\n\t\t\t\t\t\tif(p_len == -1){\n\t\t\t\t\t\t\tdp[i][j][0] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = map[i][j] == 0 ? 0 : 1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tSystem.arraycopy(dp[i-1][j], 0, dp[i][j], 0, p_len);\n\t\t\t\t\t\t\tdp[i][j][p_len] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = p_len +  (p_len == 0 && map[i][j] == 0 ? 0 : 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(i == 0){\n\t\t\t\t\t\tfinal int p_len = len[i][j-1];\n\t\t\t\t\t\tif(p_len == -1){\n\t\t\t\t\t\t\tdp[i][j][0] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = map[i][j] == 0 ? 0 : 1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tSystem.arraycopy(dp[i][j-1], 0, dp[i][j], 0, p_len);\n\t\t\t\t\t\t\tdp[i][j][p_len] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = p_len + (p_len == 0 && map[i][j] == 0 ? 0 : 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfinal int left_len = len[i][j-1];\n\t\t\t\t\t\tfinal int up_len = len[i-1][j];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(left_len == -1 && up_len == -1){\n\t\t\t\t\t\t\tdp[i][j][0] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = map[i][j] == 0 ? 0 : 1;\n\t\t\t\t\t\t}else if(left_len > up_len){\n\t\t\t\t\t\t\tfinal int p_len = len[i][j-1];\n\t\t\t\t\t\t\tSystem.arraycopy(dp[i][j-1], 0, dp[i][j], 0, p_len);\n\t\t\t\t\t\t\tdp[i][j][p_len] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = p_len + (p_len == 0 && map[i][j] == 0 ? 0 : 1);\n\t\t\t\t\t\t}else if(left_len < up_len){\n\t\t\t\t\t\t\tfinal int p_len = len[i-1][j];\n\t\t\t\t\t\t\tSystem.arraycopy(dp[i-1][j], 0, dp[i][j], 0, p_len);\n\t\t\t\t\t\t\tdp[i][j][p_len] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = p_len + (p_len == 0 && map[i][j] == 0 ? 0 : 1);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tfinal int size = len[i][j-1];\n\t\t\t\t\t\t\tboolean left_f = true;\n\t\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\t\tif(dp[i-1][j][k] < dp[i][j-1][k]){\n\t\t\t\t\t\t\t\t\tleft_f = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}else if(dp[i-1][j][k] > dp[i][j-1][k]){\n\t\t\t\t\t\t\t\t\tleft_f = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(left_f){\n\t\t\t\t\t\t\t\tfinal int p_len = len[i][j-1];\n\t\t\t\t\t\t\t\tSystem.arraycopy(dp[i][j-1], 0, dp[i][j], 0, p_len);\n\t\t\t\t\t\t\t\tdp[i][j][p_len] = (short)(map[i][j]);\n\t\t\t\t\t\t\t\tlen[i][j] = p_len + (p_len == 0 && map[i][j] == 0 ? 0 : 1);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tfinal int p_len = len[i-1][j];\n\t\t\t\t\t\t\t\tSystem.arraycopy(dp[i-1][j], 0, dp[i][j], 0, p_len);\n\t\t\t\t\t\t\t\tdp[i][j][p_len] = (short)(map[i][j]);\n\t\t\t\t\t\t\t\tlen[i][j] = p_len + (p_len == 0 && map[i][j] == 0 ? 0 : 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(max < len[i][j]){\n\t\t\t\t\t\tmax = len[i][j];\n\t\t\t\t\t\tm_x = j;\n\t\t\t\t\t\tm_y = i;\n\t\t\t\t\t}else if(max == len[i][j]){\n\t\t\t\t\t\tfinal int size = len[i][j];\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(dp[m_y][m_x][k] < dp[i][j][k]){\n\t\t\t\t\t\t\t\tmax = len[i][j];\n\t\t\t\t\t\t\t\tm_x = j;\n\t\t\t\t\t\t\t\tm_y = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(dp[m_y][m_x][k] > dp[i][j][k]){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tSystem.out.printf(\"%2d \", len[i][j]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t*/\n\t\t\tfor(int i = 0; i < max; i++){\n\t\t\t\tSystem.out.print(dp[m_y][m_x][i]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t\n\t}\n\n}", "code2": "$x=0\n$y=0\n$bord = []\n$cnt = 0\n\n\ndef calc()\n\n\tmax = 0\n\tfor i in 0..$x-1\n\t\tfor j in 0..$y-1\n\t\t\tif $bord[j][i] != -1 then\n\t\t\t\tif j > 0 then\n\t\t\t\t\tup = $bord[j-1][i]\n\t\t\t\telse\n\t\t\t\t\tup = -1\n\t\t\t\tend\n\t\t\t\n\t\t\t\tif i > 0 then\n\t\t\t\t\tleft = $bord[j][i-1]\n\t\t\t\telse\n\t\t\t\t\tleft = -1\n\t\t\t\tend\n\n\t\t\t\n\t\t\t\tif up > left and up != -1 then\n\t\t\t\t\t$bord[j][i] += up * 10\n\t\t\t\t\t\n\t\t\t\telsif left != -1 then\n\t\t\t\t\t$bord[j][i] += left * 10\n\t\t\t\tend\n\t\t\t\tif $bord[j][i] > max then\n\t\t\t\t\tmax = $bord[j][i]\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn max\nend\n\t\nloop{\n\tline = gets\n\tif line==nil then\n\t\tbreak\n\tend\n\tsp = line.split(nil)\n\t\n\tif sp.count() != 2 then\n\t\tbreak\n\telse\n\t\t$x = sp[0].to_i()\n\t\t$y = sp[1].to_i()\n\t\tif $x == 0 and $y == 0 then\n\t\t\tbreak\n\t\tend\n\t\t\n\t\tsx = 0\n\t\tsy = 0\n\t\t$cnt = 1 \n\t\t$bord = Array.new($y).map{Array.new($x,0)}\n\t\tfor i in 0..$y-1\n\t\t\tline = gets\n\t\t\tfor j in 0..$x-1\n\t\t\t\ttmp = -1\n\t\t\t\tif line[j] =~ /\\d/ then\n\t\t\t\t\ttmp = line[j].to_i() \n\t\t\t\tend\n\t\t\t\t$bord[i][j] = tmp\n\t\t\tend\n\t\tend\n\t\tprint calc()\n\t\tprint(\"\\n\")\n\tend\n}", "label": 1, "name1": "s531751281.java", "name2": "s033677438.rb"}, {"id": 434, "code1": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Map;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class TaskX {\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tint n = in.nextInt();\n\t\t\tint k = in.nextInt();\n\t\t\tint l = in.nextInt();\n\t\t\tUnionFind u1 = new UnionFind(n);\n\t\t\tUnionFind u2 = new UnionFind(n);\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tint p = in.nextInt()-1;\n\t\t\t\tint q = in.nextInt()-1;\n\t\t\t\tu1.link(p, q);\n\t\t\t}\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tint r = in.nextInt()-1;\n\t\t\t\tint s = in.nextInt()-1;\n\t\t\t\tu2.link(r, s);\n\t\t\t}\n\t\t\tMap<Long, Integer> roots = new HashMap<Long, Integer>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tlong code = (long)u1.root(i)<< 32 | u2.root(i);\n\t\t\t\troots.merge(code, 1, Integer::sum);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i > 0)out.print(\" \");\n\t\t\t\tlong code = (long)u1.root(i) << 32 | u2.root(i);\n\t\t\t\tout.print(roots.get(code));\n\t\t\t}\n\n\t\t}\n\n\t\tpublic class UnionFind {\n\t\t\tint[] data;\n\n\t\t\tpublic UnionFind(int n) {\n\t\t\t\tdata = new int[n];\n\t\t\t\tArrays.fill(data, -1);\n\t\t\t}\n\n\t\t\tboolean link(int x, int y) {\n\t\t\t\tx = root(x);\n\t\t\t\ty = root(y);\n\t\t\t\tif (x != y) {\n\t\t\t\t\tif (data[y] < data[x]) {\n\t\t\t\t\t\tdata[y] += data[x];\n\t\t\t\t\t\tdata[x] = y;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdata[x] += data[y];\n\t\t\t\t\t\tdata[y] = x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn x != y;\n\t\t\t}\n\n\t\t\tint root(int x) {\n\t\t\t\treturn data[x] < 0 ? x : (data[x] = root(data[x]));\n\t\t\t}\n\t\t}\n\t}\n\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\n\t}\n\n}\n", "code2": "class Node\n  attr_accessor :parent, :rank\n  def initialize(n)\n    @parent = n\n    @rank = 0\n  end\nend\n\nclass UnionFindTree\n  def initialize(n)\n    @nodes = (0..n).map { |i| Node.new(i) }\n  end\n\n  def unite(a, b)\n    pa = find(a)\n    pb = find(b)\n    return if pa == pb\n\n    if @nodes[pa].rank < @nodes[pb].rank\n      @nodes[pb].parent = pa\n    else\n      @nodes[pa].parent = pb\n      @nodes[pa].rank += 1 if @nodes[pa].rank == @nodes[pb].rank\n    end\n  end\n\n  def find(x)\n    return x if @nodes[x].parent == x\n    @nodes[x].parent = find(@nodes[x].parent)\n  end\nend\n\nn,k,l = gets.split(\" \").map(&:to_i)\n\nroad = UnionFindTree.new(n)\n1.upto(k) do\n  x,y = gets.split(\" \").map(&:to_i)\n  road.unite(x,y)\nend\n\nrail = UnionFindTree.new(n)\n1.upto(l) do\n  x,y = gets.split(\" \").map(&:to_i)\n  rail.unite(x,y)\nend\n\npair = Array.new\nhash = Hash.new(0)\n1.upto(n) do |p|\n x = road.find(p)\n y = rail.find(p)\n key = [x,y]\n pair.push(key)\n \n hash[key] = hash[key] + 1\n  \nend\n\npair.each do |key|\n print hash[key], \" \"\nend\nprint \"\\n\"", "label": 1, "name1": "s544715299.java", "name2": "s211925773.rb"}, {"id": 145, "code1": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint[] pri = new int[25000];\n\t\tpri[0] = 2;\n\t\tpri[1] = 3;\n\t\tpri[2] = 5;\n\t\tpri[3] = 7;\n\t\tpri[4] = 11;\n\t\tpri[5] = 13;\n\t\tpri[6] = 17;\n\t\tpri[7] = 19;\n\t\tpri[8] = 23;\n\t\tpri[9] = 29;\n\t\tint fl = 0;\n\t\tint a=0;\n\t\tint b=0;\n\t\tint c=0;\n\t\twhile(pri[a]<=250000){\n\t\t\tfl++;\n\t\t\tfor(int i=0;i<8;i++){\n\t\t\t\ta=0;\n\t\t\t\tb=0;\n\t\t\t\tc=0;\t\t\t\t\n\t\t\t\tif(i==0){\n\t\t\t\t\tc=1;\n\t\t\t\t}else if(i>0){\n\t\t\t\t\tc=pri[2+i];\n\t\t\t\t}\n\t\t\t\twhile(pri[a]!=0){\n\t\t\t\t\tif((30*fl + c)%pri[a]==0){\n\t\t\t\t\t\tb=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ta++;\n\t\t\t\t}\n\t\t\t\tif(b==0){\n\t\t\t\t\tpri[a]=(30*fl + c);\n\t\t\t\t}\n\t\t\t}\t\t\t\t\t\n\t\t}\n\t\t\n\t\tboolean exit = true;\n\t\twhile(exit==true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)exit=false;\n\t\t\tif(exit==true){\n\t\t\t\tint sum=-1;\n\t\t\t\tint i=0;\n\t\t\t\twhile(true){\n\t\t\t\t\tif(pri[i]>n)sum++;\n\t\t\t\t\tif(pri[i]>2*n)break;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(sum);\n\t\t\t}\n\t\t}\n\t}\n\t\n}", "code2": "objects = []\n\nmax_n = 123456*2\n\nsosu_arr = []\nsosu_set = {}\n\nmax_n.times.each do |ii|\n  i = ii + 1\n  next if i == 1\n  next if sosu_set.key?(i)\n  sosu_arr.push i\n  sosu_set[i] = true\n  (max_n/i).to_i.times.each do |j|\n    next if j == 0\n    sosu_set[i * (j+1)] = false\n  end\nend\n\nlines = []\nwhile num = gets\n  num = num.to_i\n  break if num == 0\n  if num == 1\n    puts 1\n    next\n  end\n  sum = 0\n  ((num+1)..(num*2)).each do |i|\n    sum = sum + 1 if sosu_set[i]\n  end\n  puts sum\nend", "label": 1, "name1": "s593802453.java", "name2": "s102129990.rb"}, {"id": 806, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.stream.IntStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.PriorityQueue;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.AbstractCollection;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            Dijkstra d = new Dijkstra(n);\n            for (int i = 0; i < n - 1; i++) {\n                int from = in.readInt() - 1;\n                int to = in.readInt() - 1;\n                d.addUndirectedEdge(from, to, 1);\n            }\n            long[] dist1 = d.getDist(0);\n            long[] distN = d.getDist(n - 1);\n            long count1 = IntStream.range(0, n)\n                    .filter(i -> dist1[i] <= distN[i])\n                    .count();\n            out.printLine(count1 > n - count1 ? \"Fennec\" : \"Snuke\");\n        }\n\n    }\n\n    static class Dijkstra {\n        int n;\n        ArrayList<Pair>[] G;\n        private long INF = Long.MAX_VALUE / 3;\n\n        public Dijkstra(int n) {\n            this.n = n;\n            G = new ArrayList[n];\n            for (int i = 0; i < n; i++) {\n                G[i] = new ArrayList<>();\n            }\n        }\n\n        public void addUndirectedEdge(int from, int to, long cost) {\n            G[from].add(new Pair(to, cost));\n            G[to].add(new Pair(from, cost));\n        }\n\n        public long[] getDist(int s) {\n            PriorityQueue<Pair> Q = new PriorityQueue<>();\n            Q.add(new Pair(s, 0));\n            long[] dist = new long[n];\n            Arrays.fill(dist, INF);\n            boolean[] used = new boolean[n];\n            while (!Q.isEmpty()) {\n                Pair p = Q.poll();\n                if (used[p.x]) continue;\n                used[p.x] = true;\n                dist[p.x] = p.y;\n\n                for (Pair edge : G[p.x]) {\n                    Q.add(new Pair(edge.x, p.y + edge.y));\n                }\n            }\n            return dist;\n        }\n\n        class Pair implements Comparable<Pair> {\n            int x;\n            long y;\n\n            Pair(int x, long y) {\n                this.x = x;\n                this.y = y;\n            }\n\n            public int compareTo(Pair p) {\n                return Long.compare(y, p.y);\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n}\n\n", "code2": "gets;puts$<.map{|s|s.split.map &:to_i}.transpose.reduce(0){|s,a|s+=(a[1]-a[0])/(a[0]>a[1] ?1:2)}<0 ?:No: :Yes", "label": 0, "name1": "s823656696.java", "name2": "s002794262.rb"}, {"id": 265, "code1": "\nimport java.util.*;\n\npublic class Main {\n    public static void main(final String[] args) {\n        final Scanner sc = new Scanner(System.in);\n        // \u6574\u6570\u306e\u5165\u529b\n        // final int a = sc.nextInt();\n        // \u6587\u5b57\u5217\u306e\u5165\u529b\n        // final String s1 = sc.next();\n        final int a = sc.nextInt();\n        final int b = sc.nextInt();\n        final int c = sc.nextInt();\n        final int k = sc.nextInt();\n        sc.close();\n        int result = 0;\n        if (a >= k) {\n            result = k;\n        } else if (b >= k - a) {\n            result = a;\n        } else if (c >= k - b - a) {\n            result = 2 * a + b - k;\n        }\n\n        System.out.println(result);\n    }\n}\n", "code2": "a, b, c, k = gets.split(\" \").map(&:to_i)\nsum = 0\nif k < a\n  sum = k\n  puts sum\n  exit\nelse\n  sum = a\n  k = k - a\nend\n\nif k < b\n  puts sum\n  exit\nelse\n  k = k - b\nend\n\nif k < c\n  sum = sum + (k * -1)\n  puts sum\nelse\n  sum = sum + (c * -1)\n  puts sum\nend", "label": 1, "name1": "s239119083.java", "name2": "s605447000.rb"}, {"id": 687, "code1": "import java.io.BufferedReader;\n\nimport static java.util.Comparator.*;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.lang.reflect.Array;\nimport java.math.BigDecimal;\nimport java.util.AbstractMap;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class Main {\n\t\n//\tpublic static Set<String> mem = new HashSet<String>();\n//\tpublic static boolean[] mem_1 = new boolean[100];\n//\tpublic static boolean[] mem_2 = new boolean[100];\n//\tpublic static Set<Integer> mem = new TreeSet<Integer>();\n//\tpublic static Map<String, Integer> mem_1= new HashMap<String, Integer>();\n//\tpublic static Map<String, Integer> mem_2 = new HashMap<String, Integer>();\n\t\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        \n        Solver solver = new Solver();\n        solver.solve(1, in, out);\n        \n        out.close();\n    }\n    \n    // ======================================================================\n    static class Solver {\n    \t\n\t\tList<Pair<Integer, Integer>> lP = new ArrayList<Pair<Integer, Integer>>();\n\t\tList<Pair<Integer, Integer>> lAns = new ArrayList<Pair<Integer, Integer>>();\n\n    \tpublic void solve(int testNumber, MyInput in, PrintWriter out) {\n    \t\tlong ans = 0L;\n    \t\tint[] cnt = new int[4];\n    \t\tfor(int i=0; i < 6; i++) {\n        \t\tint a = in.nextInt();\n        \t\tcnt[a-1] += 1;\n        // \t\tout.println(\"[\" + a + \"]\");\n    \t\t}\n    \t\tboolean f = true;\n    \t\tfor(int i=0; i < 4; i++) {\n        // \t\tout.println(\"[\" + cnt[i] + \"]\");\n    \t\t\tif(cnt[i] >= 3)\t\tf = false;\n    \t\t}\n    \t\tif(f)   \t\tout.println(\"YES\");\n    \t\telse            out.println(\"NO\");\n        }\n    }\n    // ======================================================================\n    static class Pair<K, V> extends AbstractMap.SimpleEntry<K, V> {\n        /** serialVersionUID. */\n        private static final long serialVersionUID = 6411527075103472113L;\n\n        public Pair(final K key, final V value) {\n            super(key, value);\n        }\n        public String getString() {\n            return \"[\" + getKey() + \"] [\" + getValue() + \"]\";\n        }\n     }    \n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n \n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n \n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n \n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n \n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n \n        public String nextString() {\n        \tString ret = new String(nextDChar()).trim();\n            return ret;\n        }\n \n        public char[] nextDChar() {\n            int len = 0;\n            len = reads(len, isSpace);\n            char[] ret = new char[len + 1];\n            for (int i=0; i < len; i++)\t\tret[i] = str[i];\n            ret[len] = 0x00;\n            return ret;\n        }\n \n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n \n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n \n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n    }\n}\n", "code2": "n,m = gets.chomp.split(' ').map(&:to_i)\nx = gets.chomp.split(' ').map(&:to_i).sort!\nif x.size == 1 || n >= m\n    puts '0'\nelse\n    diff = Array.new((m-1),0)\n    (m-1).times do |i|\n        diff[i] = x[i+1]-x[i]\n    end\n    puts diff.sort.slice(0,m-n).inject(:+)\nend", "label": 0, "name1": "s961270278.java", "name2": "s394989460.rb"}, {"id": 597, "code1": "import java.util.*;\npublic class Main {\n\tint n;\n\tint[] num;\n\tScanner stdin =new Scanner(System.in);\n\t\n\tvoid Solve(){\n\t\tnum=new int[21000000];\n\t\twhile(true){\n\t\t\tn=stdin.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tSystem.out.println(findPrime(n+1,2*n));\n\t\t}\n\t\t\n\t}\n\tint findPrime(int a,int b){\n\t\tint count=0;\n\t\tfor(int i=a;i<=b;i++){\n\t\t\tif(judgePrime(i)) count++;\n\t\t}\n\t\t\n\t\treturn count;\n\t}\n\t\n\tboolean judgePrime(int p){\n\t\tif(num[p]==1) return true;\n\t\tif(num[p]==-1) return false;\n\t\t\n\t\tif(p<4){\n\t\t\tnum[p]=1;\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\tif(p%2==0){\n\t\t\t\tnum[p]=-1;\n\t\t\t\treturn false; \n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=3;i<p;i++){\n\t\t\t\tif(p%i==0){\n\t\t\t\t\tnum[p]=-1;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tnum[p]=1;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\t\n\t\n\tpublic static void main(String args[]){\n\t\tMain m=new Main();\n\t\tm.Solve();\n\t}\n\t\n}", "code2": "Q = $stdin.gets.chomp.to_i\n\nsums = []\n\nQ.times do |i|\n    # a <= b\n    a, b = $stdin.gets.chomp.split(' ').map(&:to_i).sort\n    prod = a * b\n    sum = 0\n    sum += a - 1\n    sqrt = Math.sqrt(prod)\n    sqrt_f = sqrt == sqrt.floor ? sqrt.floor - 1 : sqrt.floor\n    l = [sqrt_f, a].max\n    sum += l - a\n    r = (prod - 1) / (l + 1)\n    sum += r\n    sums.push(sum)\nend\n\nprint sums.join(\"\\n\")", "label": 0, "name1": "s726742249.java", "name2": "s305871249.rb"}, {"id": 66, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\n\n\npublic class Main {\n\n\tprivate BufferedReader reader = new BufferedReader(new InputStreamReader(System.in), 1);\n\n\tprivate String inputData = null;\n\n\tpublic String[] data = null;\n\n\tpublic int num = 0;\n\n\tpublic int count = 0;\n\n\tpublic HashMap<Integer, Integer> humanData = new HashMap<Integer, Integer>();\n\n\tpublic ArrayList<Integer> topId = new ArrayList<Integer>();\n\n\tpublic ArrayList<Integer> topLength = new ArrayList<Integer>();\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().start();\n\t\tSystem.exit(0);\n\t}\n\n\tpublic void start() {\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\tthis.inputData = reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t\t\tthis.data = this.inputData.split(\" \");\n\n\t\t\tif (this.data.length == 1) {\n\t\t\t\tif (this.data[0].equals(\"0\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tthis.num = Integer.parseInt(this.data[0]);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.humanData.clear();\n\n\t\t\tfor (int i = 0; i < this.num; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.inputData = reader.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tthis.data = this.inputData.split(\" \");\n\n\t\t\t\tthis.humanData.put(Integer.parseInt(data[0]),\n\t\t\t\t\t\tInteger.parseInt(data[1]) + Integer.parseInt(data[2]));\n\n\t\t\t}\n\n\t\t\tIterator<Integer> itId = this.humanData.keySet().iterator();\n\t\t\tint numCount = 0;\n\t\t\twhile (itId.hasNext()) {\n\t\t\t\tint id = itId.next();\n\t\t\t\tif (numCount == 0) {\n\t\t\t\t\tthis.topId.add(id);\n\t\t\t\t\tthis.topLength.add(this.humanData.get(id));\n\t\t\t\t} else {\n\t\t\t\t\tif (this.topLength.get(count) <= this.humanData.get(id)) {\n\t\t\t\t\t\tthis.topId.set(this.count, id);\n\t\t\t\t\t\tthis.topLength.set(this.count, this.humanData.get(id));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnumCount++;\n\t\t\t}\n\n\t\t\tthis.count++;\n\n\t\t}\n\n\t\tfor (int i = 0; i < this.topId.size(); i++) {\n\t\t\tSystem.out.println(this.topId.get(i) + \" \" + this.topLength.get(i));\n\t\t}\n\n\t}\n\n}", "code2": "while line = gets\n  n = line.chomp.to_i\n  break if n == 0\n\n  answer_p = 0\n  answer_d = -Float::INFINITY\n  n.times do\n    p, d1, d2 = gets.chomp.split.map(&:to_i)\n    d = d1 + d2\n    if answer_d < d\n      answer_p = p\n      answer_d = d\n    end\n  end\n\n  puts \"#{answer_p} #{answer_d}\"\nend", "label": 1, "name1": "s083635030.java", "name2": "s402976256.rb"}, {"id": 525, "code1": "import java.util.Scanner;\npublic class Main { \n    public static void main(String[] args) {\n        try (Scanner sc = new Scanner(System.in)) { \n        while (true) { \n        int n = sc.nextInt(); \n            if (n == 0) { \n            break; \n            } \n            int[] scores = new int[n]; \n            for (int i = 0; i < scores.length; i++) { \n            scores[i] = sc.nextInt(); \n            } \n            double average = 0, variance = 0;\n            for(int i = 0; i < scores.length; i++){ \n                average += scores[i]; \n            } \n            average = average/n; \n            for(int i = 0; i < scores.length; i++){ \n                variance += (scores[i]-average)*(scores[i]-average); \n            }\n            variance = variance/n;\n            System.out.println(Math.sqrt(variance)); \n            } \n        } \n    }\n}\n", "code2": "N = gets.chomp.to_i\nAn = gets.chomp.split(\" \").map(&:to_i)\n\ncnt = 0\nprev = 0\nfor i in 0...N do\n  if prev == An[i] then\n    cnt += 1\n    prev = 0\n  else\n    prev = An[i]\n  end\nend\n\np cnt", "label": 0, "name1": "s272580744.java", "name2": "s973857858.rb"}, {"id": 319, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author cunbidun\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        EProductOfArithmeticProgression solver = new EProductOfArithmeticProgression();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EProductOfArithmeticProgression {\n        private static final int MOD = (int) 1e6 + 3;\n        private InputReader in;\n        private PrintWriter out;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            this.in = in;\n            this.out = out;\n            int q = in.nextInt();\n\n            int[] fac = new int[MOD + 1];\n            int[] inv = new int[MOD + 1];\n            fac[0] = 1;\n            inv[0] = Op.inv(1, MOD);\n            for (int i = 1; i <= MOD; i++) {\n                fac[i] = Op.mulMod(fac[i - 1], i, MOD);\n                inv[i] = Op.inv(fac[i], MOD);\n            }\n\n            while (q-- > 0) {\n                int x = in.nextInt();\n                int d = in.nextInt();\n                int n = in.nextInt();\n                if (d == 0) {\n                    out.println(Op.powMod(x, n, MOD));\n                    continue;\n                }\n                x = Op.mulMod(x, Op.inv(d, MOD), MOD);\n                int ans;\n                if (x + n - 1 >= MOD || x == 0) ans = 0;\n                else\n                    ans = Op.mulMod(fac[x + n - 1], inv[x - 1], MOD);\n                out.println(Op.mulMod(ans, Op.powMod(d, n, MOD), MOD));\n            }\n        }\n\n    }\n\n    static class Op {\n        public static int mulMod(int x, int y, int MOD) {\n            return (int) (((long) x * y) % MOD);\n        }\n\n        public static int powMod(int x, long p, int MOD) {\n            if (p == 0) return 1;\n            int t = powMod(x, p / 2, MOD);\n            if ((p & 1) == 1)\n                return mulMod(mulMod(t, t, MOD), x, MOD);\n            return mulMod(t, t, MOD);\n        }\n\n        public static int inv(int x, int MOD) {\n            return powMod(x, MOD - 2, MOD);\n        }\n\n    }\n\n    static class InputReader extends InputStream {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private static boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n", "code2": "o=->a,n{n<1?1:a**n[0]*o[a,n/2]**2%M}\nf=f=1,*(1..M=1000003).map{|i|f=f*i%M}\ngets\n$<.map{|s|x,d,n=s.split.map &:to_i\np d<1?o[x,n]:(u=f[n+t=x*o[d,M-2]%M-1])?u*o[f[t],M-2]*o[d,n]%M: 0}", "label": 1, "name1": "s606724970.java", "name2": "s369167080.rb"}, {"id": 738, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n\t\treturn (int) nl;\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n}\npublic class Main {\n\tstatic FastScanner scan=new FastScanner();\n\tstatic Scanner scanner=new Scanner(System.in);\n\tstatic long mod=1000000007;\n\tstatic double eps=0.0000000001;\n\tstatic int big=Integer.MAX_VALUE;\n\tstatic long gcd (long a, long b) {return b>0?gcd(b,a%b):a;}\n\tstatic long lcm (long a, long b) {return a*b/gcd(a,b);}\n\tstatic int max(int a,int b) {return a>b?a:b;}\n\tstatic int min(int a,int b) {return a<b?a:b;}\n\tstatic long factorial(int i) {return i==1?1:i*factorial(i-1);}\n\tstatic int lower_bound(int a[],int key) {\n\t\tint low=0,high=a.length;\n\t\twhile(low<high) {\n\t\t\tint mid=((high-low)/2)+low;\n\t\t\tif(a[mid]<=key)low=mid+1;\n\t\t\telse high=mid;\n\t\t}\n\t\treturn high;\n\t}\n\tstatic int upper_bound(int a[],int key) {\n\t\tint low=0,high=a.length;\n\t\twhile(low<high) {\n\t\t\tint mid=((high-low)/2)+low;\n\t\t\tif(a[mid]<key)low=mid+1;\n\t\t\telse high=mid;\n\t\t}\n\t\treturn high;\n\t}\n\tstatic boolean isPrime (long n) {\n\t\tif (n==2) return true;\n\t\tif (n<2 || n%2==0) return false;\n\t\tdouble d = Math.sqrt(n);\n\t\tfor (int i=3; i<=d; i+=2)if(n%i==0){return false;}\n\t\treturn true;\n\t}\n\tstatic int upper_division(int a,int b) {\n\t\tif(a%b==0) {\n\t\t\treturn a/b;\n\t\t}\n\t\telse {\n\t\t\treturn a/b+1;\n\t\t}\n\t}\n\tstatic long lupper_division(long a,long b) {\n\t\tif(a%b==0) {\n\t\t\treturn a/b;\n\t\t}\n\t\telse {\n\t\t\treturn a/b+1;\n\t\t}\n\t}\n\tstatic long lmax(long a,long b) {return Math.max(a, b);}\n\tstatic long lmin(long a,long b) {return Math.min(a, b);}\n\tstatic int[] setArray(int a) {\n\t\tint b[]=new int[a];\n\t\tfor(int i=0;i<a;i++) {\n\t\t\tb[i]=scan.nextInt();\n\t\t}\n\t\treturn b;\n\t}\n\tstatic long[] lsetArray(int a) {\n\t\tlong b[]=new long[a];\n\t\tfor(int i=0;i<a;i++) {\n\t\t\tb[i]=scan.nextLong();\n\t\t}\n\t\treturn b;\n\t}\n\tstatic String reverce(String str) {\n\t\tString strr=\"\";\n\t\tfor(int i=str.length()-1;i>=0;i--) {\n\t\t\tstrr+=str.charAt(i);\n\t\t}\n\t\treturn strr;\n\t}\n\tpublic static void printArray(char[] ch) {\n\t\tfor(int i=0;i<ch.length-1;i++) {\n\t\t\tSystem.out.print(ch[i]+\" \");\n\t\t}\n\t\tSystem.out.println(ch[ch.length-1]);\n\t}\n\tpublic static int[][] doublesort(int[][]a) {\n\t\tArrays.sort(a,(x,y)->Integer.compare(x[0],y[0]));\n\t\treturn a;\n\t}\n\tstatic long modpow(long x,long n,long mo) {\n\t\tlong sum=1;\n\t\twhile(n>0) {\n\t\t\tif((n&1)==1) {\n\t\t\t\tsum=sum*x%mo;\n\t\t\t}\n\t\t\tx=x*x%mo;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn sum;\n\t}\n\tpublic static char[] revch(char ch[]) {\n\t\tchar ret[]=new char[ch.length];\n\t\tfor(int i=ch.length-1,j=0;i>=0;i--,j++) {\n\t\t\tret[j]=ch[i];\n\t\t}\n\t\treturn ret;\n\t}\n\tpublic static int[] revint(int ch[]) {\n\t\tint ret[]=new int[ch.length];\n\t\tfor(int i=ch.length-1,j=0;i>=0;i--,j++) {\n\t\t\tret[j]=ch[i];\n\t\t}\n\t\treturn ret;\n\t}\n\tpublic static void warshall_floyd(int v[][],int n) {\n\t\tfor(int k=0;k<n;k++)\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t\tv[i][j]=min(v[i][j],v[i][k]+v[k][j]);\n\t}\n\tpublic static void main(String[] args) {\n\t\tlong a=scan.nextLong();\n\t\tlong b=scan.nextLong();\n\t\tint cnt=0;\n\t\tlong now=a;\n\t\twhile(now<=b) {\n\t\t\tcnt++;\n\t\t\tnow*=2;\n\t\t}\n\t\tSystem.out.println(cnt);\n\t}\n}", "code2": "a,b,c,d,e,f,g = gets.split.map(&:to_i)\nans = 0\nans += b*2\nans += (a/2)*4\nans += (d/2)*4\nans += (e/2)*4\nif a.odd? && d.odd? && e.odd?\n    ans += 6\nelsif d.odd? && e.odd? && a != 0\n    ans += 2\nelsif a.odd? && ((d.odd? && e != 0) || (e.odd? && d != 0))\n    ans += 2\nend\nputs ans/2", "label": 0, "name1": "s941851054.java", "name2": "s340171115.rb"}, {"id": 826, "code1": "import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        int A = scan.nextInt();\n        int B = scan.nextInt();\n        int C = scan.nextInt();\n        if(A == B && A== C){\n            System.out.println(\"No\");\n        }\n        else if(A == B || A == C || B == C){\n            System.out.println(\"Yes\");\n        }\n        else{\n            System.out.println(\"No\");\n        }\n    }\n}", "code2": "N = gets.to_i\nS = gets.chomp\n\new = we = 0\nN.times do |i|\n  we += 1 if S[i] == 'E'\nend\n\nans = 1000000\nN.times do |i|\n  we -= 1 if S[i] == 'E'\n  ans = [ans, ew + we].min\n  ew += 1 if S[i] == 'W'\nend\n\nputs ans\n", "label": 0, "name1": "s236930555.java", "name2": "s770679196.rb"}, {"id": 572, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint a = Integer.parseInt(sc.next());\n\t\tint b = Integer.parseInt(sc.next());\n\t\tint c = Integer.parseInt(sc.next());\n\n\t\tif (a < c && c < b || b < c && c < a){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t}else {\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t}\n}", "code2": "N, K = gets.split.map(&:to_i)\nA = gets.split.map(&:to_i)\n\ndp = Array.new(K + 1, false)\n(0..K).each do |k|\n  A.each do |a|\n    if k - a >= 0\n      dp[k] ||= !dp[k - a]\n    end\n  end\nend\nputs(dp[K] ? 'First' : 'Second')", "label": 0, "name1": "s898770223.java", "name2": "s888131563.rb"}, {"id": 602, "code1": "import java.io.*;\nimport java.util.*;\n \npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n \n    static class TaskD {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n \n            int N = in.nextInt();\n            for (int i = 0; i < N; i++) {\n                long A = in.nextLong();\n                long B = in.nextLong();\n \n                long a = Math.min(A, B);\n                long b = Math.max(A, B);\n \n                long ans = 2L * (a - 1) + przedzial(a, b);\n \n                out.println(ans);\n            }\n        }\n \n        private long przedzial(long a, long b) {\n            if (a == b || a + 1 == b) {\n                return 0;\n            }\n \n            return 1L + szukaj(a + 1, b - 2, a * b);\n        }\n \n        private long szukaj(long a, long b, long LIMIT) {\n            if (a > b) return 0;\n            if (a == b) {\n                return a * b < LIMIT ? 1 : 0;\n            }\n            long lo = a, hi = b;\n            while (lo + 1 < hi) {\n                long m = lo + (hi - lo) / 2;\n                if (m * m >= LIMIT) {\n                    hi = m;\n                } else {\n                    lo = m;\n                }\n            }\n            long ans1 = 1 + 2L * (lo - 1 - a + 1);\n            long ans2 = 0;\n            if (lo * (lo + 1) < LIMIT) {\n                ans2 = 2L * (lo - a + 1);\n            }\n            return Math.max(ans1, ans2);\n        }\n    }\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n    }\n}", "code2": "a = []\na = gets.chomp.split(\"\")\n#p a\ns =[]\na.each do |i|\n    #p i\n    if i == \"S\"\n        #p i\n        s.push(i)\n    elsif i == \"T\"\n        #p i\n        if s[-1] == \"T\" || s.length == 0\n            s.push(i)\n        elsif s[-1] == \"S\"\n            s.pop\n        end\n    end\nend\n#p s\nputs s.length", "label": 0, "name1": "s546530291.java", "name2": "s966060238.rb"}, {"id": 463, "code1": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t// \u5165\u529b\n\t\tint n = sc.nextInt();\n\t\tGraph g = new Graph(n, false);\n\t\tfor(int i = 0; i < n-1; i++){\n\t\t    int a = sc.nextInt() - 1;\n\t\t    int b = sc.nextInt() - 1;\n\t\t    g.add(a, b);\n\t\t}\n\t\t\n\t\t// \u8a08\u7b97\n\t\tString result = \"Snuke\";\n\t\tlong[] distFromB = g.dijkstra(0);\n\t\tlong[] distFromW = g.dijkstra(n-1);\n\t\tint cnt = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t    if(distFromB[i] <= distFromW[i]) cnt++;\n\t\t}\n\t\tif(cnt > (n-cnt)) result = \"Fennec\";\n\t\t\n\t\t// \u51fa\u529b\n\t\tSystem.out.println(result);\n\t}\n\n}\n\nclass Graph {\n\tint n;\n\tboolean directed;\n\tArrayList<Edge>[] adjList;\n\tint m;\n\tlong[] dist;\n\tlong[][] distWF;\n\tint start;\n\tint[] prev;\n\tArrayList<Integer> path;\n\tlong INF = 1001001001001001001L;\n\n\tpublic Graph (int n, boolean directed) {\n\t\tthis.n = n;\n\t\tthis.m = 0;\n\t\tthis.directed = directed;\n\t\tthis.adjList = new ArrayList[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tadjList[i] = new ArrayList<Edge>();\n\t\t}\n\t}\n\t\n\tpublic void add(int from, int to) {\n\t\tadd(from, to, 1);\n\t}\n\tpublic void add(int from, int to, int w) {\n\t\tadjList[from].add(new Edge(from, to, w));\n\t\tthis.m++;\n\t\tif(!directed){\n\t\t\tadjList[to].add(new Edge(to, from, w));\n\t\t\tthis.m++;\n\t\t}\n\t}\n\t\n\tpublic long[] bfs(int start) { // O(M)\n\t\tthis.start = start;\n\t\tthis.prev = new int[n];\n\t\tArrays.fill(prev, -1);\n\t\tprev[start] = start;\n\t\tthis.dist = new long[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[start] = 0;\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tq.add(start);\n\t\twhile(!q.isEmpty()){\n\t\t\tint now = q.poll();\n\t\t\tfor(Edge e : adjList[now]){\n\t\t\t\tif(dist[e.to] != INF) continue;\n\t\t\t\tdist[e.to] = dist[now] + e.w;\n\t\t\t\tprev[e.to] = now;\n\t\t\t\tq.add(e.to);\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\t\n\tpublic long[] dijkstra(int start) { // O(MlogM)\n\t\tthis.start = start;\n\t\tthis.prev = new int[n];\n\t\tArrays.fill(prev, -1);\n\t\tprev[start] = start;\n\t\tthis.dist = new long[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[start] = 0;\n\t\tPriorityQueue<Vertex> q = new PriorityQueue<Vertex>((x, y) -> Long.compare(x.distance, y.distance));\n\t\tq.add(new Vertex(start, 0));\n\t\twhile(!q.isEmpty()){\n\t\t\tVertex now = q.poll();\n\t\t\tif(now.distance > dist[now.id]) continue; \n\t\t\tfor(Edge e : adjList[now.id]){\n\t\t\t\tlong newDist = now.distance + e.w;\n\t\t\t\tif(dist[e.to] <= newDist) continue;\n\t\t\t\tdist[e.to] = newDist;\n\t\t\t\tprev[e.to] = now.id;\n\t\t\t\tq.add(new Vertex(e.to, newDist));\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\t\n\tpublic long[][] wf() { // O(N^3)\n\t\tthis.distWF = new long[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tArrays.fill(distWF[i], INF);\n\t\t\tdistWF[i][i] = 0;\n\t\t}\n\t\tfor(ArrayList<Edge> list : adjList){\n\t\t\tfor(Edge e : list){\n\t\t\t\tdistWF[e.from][e.to] = e.w;\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < n; k++){\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tdistWF[i][j] = min(distWF[i][j], distWF[i][k] + distWF[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn distWF;\n\t}\n\t\n\tpublic boolean bf(int start) { // O(NM)\n\t\tthis.start = start;\n\t\tthis.prev = new int[n];\n\t\tArrays.fill(prev, -1);\n\t\tprev[start] = start;\n\t\tthis.dist = new long[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[start] = 0;\n\t\tboolean hasNegativeLoop = false;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tfor(Edge e : adjList[j]){\n\t\t\t\t\tif(dist[e.to] <= dist[e.from] + e.w) continue;\n\t\t\t\t\tdist[e.to] = dist[e.from] + e.w;\n\t\t\t\t\tprev[e.to] = e.from;\n\t\t\t\t\tif(i == n-1) hasNegativeLoop = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn hasNegativeLoop;\n\t}\n\t\n\tpublic ArrayList<Integer> pathTo(int to){\n\t\tthis.path = new ArrayList<Integer>();\n\t\treturn pathToRec(to);\n\t}\n\t\n\tprivate ArrayList<Integer> pathToRec(int to){\n\t\tif(to != start) pathToRec(prev[to]);\n\t\tpath.add(to);\n\t\treturn path;\n\t}\n\t\n\tpublic String toString(){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(ArrayList<Edge> list : adjList){\n\t\t\tfor(Edge e : list){\n\t\t\t\tsb.append(e.toString());\n\t\t\t\tsb.append(\"\\n\");\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tpublic String distToString(){\n\t\tif(dist != null) return Arrays.toString(dist);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(distWF[i][j] == INF){\n\t\t\t\t\tsb.append(\"from:\" + i + \" to:\" + j + \" dist:INF\" + \"\\n\");\n\t\t\t\t}else{\n\t\t\t\t\tsb.append(\"from:\" + i + \" to:\" + j + \" dist:\" + distWF[i][j] + \"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tclass Edge {\n\t\tint from;\n\t\tint to;\n\t\tint w;\n\t\t\n\t\tEdge(int from, int to, int w){\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"from:\" + from + \" to:\" + to + \" w:\" + w;\n\t\t}\n\t}\n\t\n\tclass Vertex {\n\t\tint id;\n\t\tlong distance;\n\t\t\n\t\tVertex(int id, long distance){\n\t\t\tthis.id = id;\n\t\t\tthis.distance = distance;\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"id:\" + id + \" distance:\" + distance;\n\t\t}\n\t}\n}\n", "code2": "n = gets.chomp.to_i\ntree = Array.new(n)\nn.times { |i| tree[i] = [] }\n(n - 1).times do\n  a, b = gets.chomp.split(' ').map { |x| x.to_i - 1 }\n  tree[a] << b\n  tree[b] << a\nend\n\nvisited = Hash.new(false)\ndistances = Array.new(n, 0)\ndistance = 0\nqueue = [0]\nuntil queue.empty?\n  size = queue.length\n  size.times do\n    q = queue.shift\n    next if visited[q]\n    distances[q] = distance\n    visited[q] = true\n    tree[q].each do |i|\n      next if visited[i]\n      queue << i\n    end\n  end\n  distance += 1\nend\n\nqueue = [n - 1]\nroute = []\nuntil queue.empty?\n  q = queue.shift\n  route.unshift(q)\n  tree[q].each do |i|\n    if distances[q] - distances[i] == 1\n      queue << i\n      break\n    end\n  end\nend\nvisited = Hash.new(false)\nstart_index = route.length % 2 == 0 ? route.length / 2 - 1 : route.length / 2\nqueue = [route[start_index]]\ncount = 0\nuntil queue.empty?\n  q = queue.pop\n  next if visited[q]\n  visited[q] = true\n  count += 1\n  tree[q].each do |i|\n    next if i == route[start_index + 1]\n    next if visited[i]\n    queue << i\n  end\nend\n\nputs count > n - count ? 'Fennec' : 'Snuke'", "label": 1, "name1": "s816087530.java", "name2": "s088298181.rb"}, {"id": 183, "code1": "import java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint a = scan.nextInt();\n\t\tint b = scan.nextInt();\n\t\tscan.close();\n\t\tint ans = 12;\n\t\tif(b >= a) {\n\t\t\tans = a;\n\t\t}else {\n\t\t\tans = a - 1;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n", "code2": "a,b = gets.split.map(&:to_i)\n\nif a <= b\n  puts a\nelse\n  puts a-1\nend", "label": 1, "name1": "s648355489.java", "name2": "s914009735.rb"}, {"id": 549, "code1": "import java.util.*;\n\nclass Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int k = findK(n);\n        if(k==-1){\n            System.out.println(\"No\");\n            System.exit(0);\n        }\n        int[][] res = new int[k][k-1];\n        for(int i=0;i<k-1;i++) res[0][i] = i+1;\n        int[] index = new int[k];\n        for(int i=0;i<k;i++) index[i]=i;\n        for(int row=1;row<k;row++){\n            int idx = 0;\n            for(int j=0;j<row;j++) res[row][idx++] = res[j][index[j]++];\n            if(row==k-1) continue;\n            res[row][idx++]=res[row-1][k-2]+1;\n            while(idx<k-1){\n                res[row][idx] = res[row][idx-1]+1;\n                idx++;\n            }\n        }\n        System.out.println(\"Yes\");\n        System.out.println(k);\n        for(int i=0;i<k;i++){\n            System.out.print(Integer.toString(k-1)+\" \");\n            for(int j=0;j<k-1;j++){\n                System.out.print(Integer.toString(res[i][j])+\" \");\n            }\n            System.out.println(\"\");\n        }\n    }\n    static int findK(int n){\n        int k=1;\n        while(k*(k-1)<=2*n){\n            if(k*(k-1)==2*n) return k;\n            k++;\n        }\n        return -1;\n    }\n}\n", "code2": "T = ['A', 'B', 'AB', 'O']\nr = Array.new(4, 0)\n\nwhile s = gets\n  r[T.index(s.chomp.split(',')[1])] += 1\nend\n\nr.each { |n| puts n } ", "label": 0, "name1": "s741808618.java", "name2": "s391304310.rb"}, {"id": 422, "code1": "import java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n    static void solve() {\n        int n = nextInt();\n\n        long ans = nextLong();\n//        System.out.println(ans);\n        for (int i = 1; i < n; i++) {\n            long t = nextLong();\n            ans = lcm(ans, t);\n//            System.out.println(ans);\n        }\n        out.println(ans);\n    }\n\n    static final int MOD = 1_000_000_007;\n    static long[] fac, finv, inv;\n\n    // nCk\u306e\u521d\u671f\u5316\n    static void comInit(int max) {\n        fac = new long[max];\n        finv = new long[max];\n        inv = new long[max];\n        fac[0] = fac[1] = 1;\n        finv[0] = finv[1] = 1;\n        inv[1] = 1;\n\n        for (int i = 2; i < max; i++) {\n            fac[i] = fac[i - 1] * i % MOD;\n            inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n            finv[i] = finv[i - 1] * inv[i] % MOD;\n        }\n    }\n\n    // nCk\u306e\u8a08\u7b97\n    static long com(int n, int k) {\n        if (n < k)\n            return 0;\n        if (n < 0 || k < 0)\n            return 0;\n        return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n    }\n\n    static PrintWriter out;\n    static Scanner sc;\n\n    static int[][] newIntArray(int h, int w, int value) {\n        int[][] ret = new int[h][w];\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                ret[i][j] = value;\n            }\n        }\n        return ret;\n    }\n\n    static int nextInt() {\n        return Integer.parseInt(sc.next());\n    }\n\n    static long nextLong() {\n        return Long.parseLong(sc.next());\n    }\n\n    static String nextString() {\n        return sc.next();\n    }\n\n    static int[] nextIntArray(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = nextInt();\n        }\n        return a;\n    }\n\n    static List<Integer> nextIntList(int n) {\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add(nextInt());\n        }\n        return list;\n    }\n\n    static List<Double> nextDoubleList(int n) {\n        List<Double> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add((double) nextInt());\n        }\n        return list;\n    }\n\n    static List<Long> nextLongList(int n) {\n        List<Long> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add(nextLong());\n        }\n        return list;\n    }\n\n    static char[][] nextCharArray(int h, int w) {\n        char[][] c = new char[h][w];\n        for (int i = 0; i < h; i++) {\n            String str = nextString();\n            for (int j = 0; j < w; j++) {\n                c[i][j] = str.charAt(j);\n            }\n        }\n        return c;\n    }\n\n    static <T extends Comparable<? super T>> void sort(List<T> list) {\n        Collections.sort(list);\n    }\n\n    // greatest common divisor\n    // \u6700\u5927\u516c\u7d04\u6570\n    static long gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    // least common multiple\n    // \u6700\u5c0f\u516c\u500d\u6570\n    static long lcm(long a, long b) {\n        if (a >= b && a % b == 0)\n            return a;\n        if (b > a && b % a == 0)\n            return b;\n\n//        return a * b / gcd(a, b);\n        if (a > b) {\n            return (a / gcd(a, b)) * b;\n        } else {\n            return (b / gcd(a, b)) * a;\n        }\n    }\n\n    // base\u306en\u4e57\u3092\u8a08\u7b97\u3092\u8fd4\u3059\n    static int pow(int base, int n) {\n        int ret = 1;\n        for (int i = 0; i < n; i++) {\n            ret *= base;\n        }\n        return ret;\n    }\n\n    // return n^k mod m\n    static long powMod(long n, long k, long m) {\n        if (k == 0) {\n            return 1;\n        } else if (k % 2 == 1) {\n            return powMod(n, k - 1, m) * n % m;\n        } else {\n            long tmp = powMod(n, k / 2, m);\n            return tmp * tmp % m;\n        }\n    }\n\n    // int\u3092length\u6841\u306ebit\u6587\u5b57\u5217\u306b\u5909\u63db\n    static String toBitString(int length, int n) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = length - 1; i >= 0; i--) {\n            if ((n >> i) % 2 == 1) {\n                sb.append(\"1\");\n            } else {\n                sb.append(\"0\");\n            }\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        out = new PrintWriter(System.out);\n        sc = new Scanner(System.in);\n\n        solve();\n\n        out.flush();\n        sc.close();\n    }\n\n}\n", "code2": "n = gets.chomp.to_i\na = n.times.map{gets.chomp.to_i}\nans = 1\na.each {|d|ans = ans.lcm(d)}\np ans", "label": 1, "name1": "s078472493.java", "name2": "s352943473.rb"}, {"id": 377, "code1": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tstatic void solve() {\n\t\tlong i = ni(), o = ni(), t = ni(), j = ni(), l = ni(), s = ni(), z = ni();\n\t\tlong ans = 0;\n\t\tans += o;\n\t\t\n\t\t\n\t\tlong rem = i%2+j%2+l%2;\n\t\tif(i==0||j==0||l==0) {\n\t\t\tans += 2*(i/2 + j/2 + l/2);\n\t\t\tout.println(ans);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(rem<=1) {\n\t\t\tans += 2*(i/2 + j/2 + l/2);\n\t\t}\n\t\telse {\n\t\t\tans += 3;\n\t\t\ti--; j--;l--;\n\t\t\tans += 2*(i/2 + j/2 + l/2);\n\t\t}\n\t\tout.println(ans);\n\t\t\n\t}\n\n\t//constant\n\tstatic final long mod = (long) 1e9 + 7;\n\tstatic final int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };\n\tstatic final int[] dx8 = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\tstatic final int inf = Integer.MAX_VALUE / 2;\n\tstatic final long linf = Long.MAX_VALUE / 3;\n\tstatic final double dinf = Double.MAX_VALUE / 3;\n\tstatic final double eps = 1e-10;\n\tstatic final double pi = Math.PI;\n\tstatic StringBuilder sb = new StringBuilder();\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\t//libraries\n\tstatic void reverse(int ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tint t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(long ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tlong t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(double ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tdouble t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(char ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tchar t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic String getReverse(String s) {\n\t\tchar c[] = s.toCharArray();\n\t\treverse(c);\n\t\ts = String.valueOf(c);\n\t\treturn s;\n\t}\n\n\tstatic <T> void reverse(List<T> ls) {\n\t\tint sz = ls.size();\n\t\tfor (int i = 0; i < sz / 2; i++) {\n\t\t\tT t = ls.get(i);\n\t\t\tls.set(i, ls.get(sz - 1 - i));\n\t\t\tls.set(sz - 1 - i, t);\n\t\t}\n\t}\n\n\tstatic <T> void reverse(T[] ar) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tT t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void sbnl() {//StringBuilder\u306b\u6539\u884c\u6587\u5b57\u3092append\u3059\u308b\n\t\tsb.append(\"\\n\");\n\t}\n\n\tstatic int lowerBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int lowerBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int lowerBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int lowerBound(char[] a, char x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(char[] a, char x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(char[] a, char x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(char[] a, char x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic <T> int lowerBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) >= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) >= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) >= 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int upperBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) > 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) > 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) > 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int rupperBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) < 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) < 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) < 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int rlowerBound(List<T> ls, T x) {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) <= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) <= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) <= 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic int[] concat(int x, int arr[]) {\n\t\tint ret[] = new int[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 1, ret.length - 1);\n\t\tret[0] = x;\n\t\treturn ret;\n\t}\n\n\tstatic int[] concat(int arr[], int x) {\n\t\tint ret[] = new int[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 0, ret.length - 1);\n\t\tret[ret.length - 1] = x;\n\t\treturn ret;\n\t}\n\n\tstatic long[] concat(long x, long arr[]) {\n\t\tlong ret[] = new long[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 1, ret.length - 1);\n\t\tret[0] = x;\n\t\treturn ret;\n\t}\n\n\tstatic long[] concat(long arr[], long x) {\n\t\tlong ret[] = new long[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 0, ret.length - 1);\n\t\tret[ret.length - 1] = x;\n\t\treturn ret;\n\t}\n\n\tstatic int max(int x, int y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic int min(int x, int y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic int max(int x, int y, int z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic int min(int x, int y, int z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic long max(long x, long y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic long min(long x, long y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic long max(long x, long y, long z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic long min(long x, long y, long z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic double max(double x, double y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic double min(double x, double y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic double max(double x, double y, double z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic double min(double x, double y, double z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic void sort(int[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void sort(long[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void sort(double[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void sort(char[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void rsort(int[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tint tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void rsort(long[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tlong tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void rsort(double[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tdouble tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void rsort(char[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tchar tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void fill(int arr[], int x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(long arr[], long x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(boolean arr[], boolean x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(double arr[], double x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(int arr[][], int x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(long arr[][], long x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(double arr[][], double x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(boolean arr[][], boolean x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\t//MOD culc\n\tstatic long plus(long x, long y) {\n\t\tlong res = (x + y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long sub(long x, long y) {\n\t\tlong res = (x - y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long mul(long x, long y) {\n\t\tlong res = (x * y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long div(long x, long y) {\n\t\tlong res = x * pow(y, mod - 2) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long pow(long x, long y) {\n\t\tif (y < 0)\n\t\t\treturn 0;\n\t\tif (y == 0)\n\t\t\treturn 1;\n\t\tif (y % 2 == 1)\n\t\t\treturn (x * pow(x, y - 1)) % mod;\n\t\tlong root = pow(x, y / 2);\n\t\treturn root * root % mod;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\t//input\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static long[] nla(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n}\n", "code2": "aI,aO,aT,aJ,aL,aS,aZ = gets.chomp.split(\" \").map{|u|u.to_i}\ncount = aO\nif([aJ,aI,aL].min > 0)\nif(aJ %2 == 1 and aI %2 == 1 and aL %2 == 1)\n    min = 1\n    aJ -= min\n    aI -= min\n    aL -= min\n    count += 3*min \nend\nif(aJ %2 == 1 and aI %2 == 1 and aL %2 == 0)\n    min = 1\n    aJ -= min\n    aI -= min\n    aL -= min\n    count += 3*min \nend\nif(aJ %2 == 1 and aI %2 == 0 and aL %2 == 1)\n    min = 1\n    aJ -= min\n    aI -= min\n    aL -= min\n    count += 3*min \nend\nif(aJ %2 == 0 and aI %2 == 1 and aL %2 == 1)\n    min = 1\n    aJ -= min\n    aI -= min\n    aL -= min\n    count += 3*min \nend\nend\ncount += (aI/2)*2\ncount += (aL/2)*2\ncount += (aJ/2)*2\n \nputs count", "label": 1, "name1": "s751122857.java", "name2": "s258390071.rb"}, {"id": 487, "code1": "\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int A = scanner.nextInt();\n        int B = scanner.nextInt();\n        int C = scanner.nextInt();\n\n        if ((A == B && A != C) || (A == C && A != B) || (B == C &&  A != B)) {\n            System.out.println(\"Yes\");\n        } else {\n            System.out.println(\"No\");\n        }\n    }\n}\n", "code2": "a, b, c = gets.split.map(&:to_i)\n\nputs (a==b && a==c && b == c) || (a != b && a != c && c != b) ? \"No\": \"Yes\"", "label": 1, "name1": "s748781959.java", "name2": "s674156319.rb"}, {"id": 202, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        CTwoAlpinists solver = new CTwoAlpinists();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CTwoAlpinists {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            long[] t = in.readLongArray(n);\n            long[] a = in.readLongArray(n);\n\n            long[] max = new long[n];\n            long[] actual = new long[n];\n\n            {\n                for (int i = 0; i < n; i++) {\n                    max[i] = Math.min(t[i], a[i]);\n                }\n            }\n\n            {\n                long prev = 0;\n                for (int i = 0; i < n; i++) {\n                    if (t[i] > prev) {\n                        if (t[i] > max[i]) {\n                            out.printLine(0);\n                            return;\n                        }\n                        actual[i] = t[i];\n                        prev = t[i];\n                    }\n                }\n            }\n\n            {\n                long prev = 0;\n                for (int i = n - 1; i >= 0; i--) {\n                    if (a[i] > prev) {\n                        if (a[i] > max[i]) {\n                            out.printLine(0);\n                            return;\n                        }\n                        actual[i] = a[i];\n                        prev = a[i];\n                    }\n                }\n            }\n\n            long ans = 1;\n            for (int i = 0; i < n; i++) {\n                if (actual[i] != 0) continue;\n                ans = (ans * max[i]) % MiscUtils.MOD7;\n            }\n\n            out.printLine(ans);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public long[] readLongArray(int size) {\n            long[] array = new long[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readLong();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long readLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class MiscUtils {\n        public static final int MOD7 = (int) (1e9 + 7);\n\n    }\n}\n\n", "code2": "N = gets.to_i\nA = gets.split.map(&:to_i)\nT = gets.split.map(&:to_i)\n\nputs (0...N).reduce(1) { |a,i|\n  amin = (i == 0 || A[i] > A[i-1]) ? A[i] : 1\n  tmin = (i == N-1 || T[i] > T[i+1]) ? T[i] : 1\n  a = (a * [[A[i],T[i]].min - [amin, tmin].max + 1, 0].max) % 1000000007\n}\n", "label": 1, "name1": "s071160485.java", "name2": "s632068488.rb"}, {"id": 381, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\n\n/*\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n            pass System Test!\n*/\n\npublic class Main {\n  private static class Task {\n    void solve(FastScanner in, PrintWriter out) {\n      int H = in.nextInt();\n      int W = in.nextInt();\n      char[][] map = new char[H][];\n      for (int i = 0; i < H; i++) {\n        map[i] = in.next().toCharArray();\n      }\n\n      boolean[][] red = new boolean[H][W];\n      boolean[][] blue = new boolean[H][W];\n      for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n          if (j == 0) red[i][j] = true;\n          else if (j == W - 1) blue[i][j] = true;\n          else if (i % 2 == 0) red[i][j] = true;\n          else blue[i][j] = true;\n        }\n      }\n\n      for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n          if (map[i][j] == '.') continue;\n          blue[i][j] = true;\n          red[i][j] = true;\n        }\n      }\n\n      for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n          out.print(red[i][j] ? \"#\" : \".\");\n        }\n        out.println();\n      }\n      out.println();\n      for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n          out.print(blue[i][j] ? \"#\" : \".\");\n        }\n        out.println();\n      }\n    }\n  }\n\n  /**\n   * \u3053\u3053\u304b\u3089\u4e0b\u306f\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u3067\u3059\u3002\n   */\n  public static void main(String[] args) {\n    OutputStream outputStream = System.out;\n    FastScanner in = new FastScanner();\n    PrintWriter out = new PrintWriter(outputStream);\n    Task solver = new Task();\n    solver.solve(in, out);\n    out.close();\n  }\n  private static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n      int[] array = new int[n];\n      for (int i = 0; i < n; i++) array[i] = nextInt();\n      return array;\n    }\n\n    public long[] nextLongArray(int n) {\n      long[] array = new long[n];\n      for (int i = 0; i < n; i++) array[i] = nextLong();\n      return array;\n    }\n\n    public String[] nextStringArray(int n) {\n      String[] array = new String[n];\n      for (int i = 0; i < n; i++) array[i] = next();\n      return array;\n    }\n\n    public char[][] nextCharMap(int n) {\n      char[][] array = new char[n][];\n      for (int i = 0; i < n; i++) array[i] = next().toCharArray();\n      return array;\n    }\n  }\n}\n", "code2": "#!/usr/bin/ruby\nh,w=gets.split.map(&:to_i)\nm=$<.map{|e|e.chomp[1..-2]}\n2.times{|i|h.times{|y|\n\tif i==0\n\t\tif y%2==0\n\t\t\tputs '#'*(w-1)+'.'\n\t\telse\n\t\t\tputs '#'+m[y]+'.'\n\t\tend\n\telse\n\t\tif y%2==0\n\t\t\tputs '.'+m[y]+'#'\n\t\telse\n\t\t\tputs '.'+'#'*(w-1)\n\t\tend\n\tend\n};puts}", "label": 1, "name1": "s871155444.java", "name2": "s030629079.rb"}, {"id": 811, "code1": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.Stack;\n\nclass Main{\n\tpublic static void main(String[] args) {\n\t\tint INF=1000000007;\n\t\tScanner sc=new Scanner(System.in);\n\t\tint V=sc.nextInt();\n\t\tArrayList<ArrayList<Integer>> v=new ArrayList<ArrayList<Integer>>();\n\t\tfor(int i=0; i<=V; i++) {\n\t\t\tv.add(new ArrayList<Integer>());\n\t\t}\n\t\tfor(int i=0; i<V-1; i++) {\n\t\t\tint a=sc.nextInt();\n\t\t\tint b=sc.nextInt();\n\t\t\t(v.get(a)).add(b);\n\t\t\t(v.get(b)).add(a);\n\t\t}\n\t\tint[] Fe=new int[V+1];\n\t\tint[] Su=new int[V+1];\n\t\tboolean[] Fe_V=new boolean[V+1];\n\t\tboolean[] Su_V=new boolean[V+1];\n\t\tArrays.fill(Fe, INF);\n\t\tArrays.fill(Su, INF);\n\t\tFe[1]=0;\n\t\tSu[V]=0;\n\t\tStack<Integer> Q=new Stack<Integer>();\n\t\tQ.add(1);\n\t\twhile(!Q.isEmpty()) {\n\t\t\tint tmp=Q.pop();\n\t\t\tfor(int i=0; i<v.get(tmp).size(); i++) {\n\t\t\t\tif(!Fe_V[v.get(tmp).get(i)] && Fe[tmp]+1<Fe[v.get(tmp).get(i)]) {\n\t\t\t\t\tFe_V[v.get(tmp).get(i)]=true;\n\t\t\t\t\tFe[v.get(tmp).get(i)]=Fe[tmp]+1;\n\t\t\t\t\tQ.push(v.get(tmp).get(i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tQ.add(V);\n\t\twhile(!Q.isEmpty()) {\n\t\t\tint tmp=Q.pop();\n\t\t\tfor(int i=0; i<v.get(tmp).size(); i++) {\n\t\t\t\tif(!Su_V[v.get(tmp).get(i)] && Su[tmp]+1<Su[v.get(tmp).get(i)]) {\n\t\t\t\t\tSu_V[v.get(tmp).get(i)]=true;\n\t\t\t\t\tSu[v.get(tmp).get(i)]=Su[tmp]+1;\n\t\t\t\t\tQ.push(v.get(tmp).get(i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint Su_w=0;\n\t\tint Fe_w=0;\n\t\tfor(int i=1; i<=V; i++) {\n\t\t\tif(Fe[i]<=Su[i]) {\n\t\t\t\tFe_w++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSu_w++;\n\t\t\t}\n\t\t}\n\t\tif(Su_w>=Fe_w) {\n\t\t\tSystem.out.println(\"Snuke\");\n\t\t\tSystem.out.flush();\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"Fennec\");\n\t\t\tSystem.out.flush();\n\t\t}\n\t}\n}", "code2": "N, M = gets.split.map(&:to_i)\ngraph = Array.new(N + 1) { [] }\nM.times do\n  a, b = gets.split.map(&:to_i)\n  graph[a] << b\n  graph[b] << a\nend\n\nans = 0\n(2..N).to_a.permutation(N - 1).each do |p|\n  p.unshift(1)\n  ans += 1 if (1...N).all? { |i| graph[p[i - 1]].include?(p[i]) }\nend\nputs ans\n", "label": 0, "name1": "s522721717.java", "name2": "s112297491.rb"}, {"id": 301, "code1": "import java.util.*;\n\npublic class Main {\n    \n    public static boolean[] alr;\n    \n    public static List<List<Integer>> list = new ArrayList<>();\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        alr = new boolean[N];\n        for (int i = 0; i < N; i++) {\n            list.add(new ArrayList<>());\n        }\n        for (int i = 0; i < M; i++) {\n            int A = sc.nextInt()-1;\n            int B = sc.nextInt()-1;\n            list.get(A).add(B);\n            list.get(B).add(A);\n        }\n        long count = 0;\n        for (int i = 0; i < list.size(); i++) {\n            if (alr[i]) {\n                continue;\n            } else {\n                alr[i] = true;\n                count++;\n            }\n            List<Integer> lst = list.get(i);\n            count(lst);\n        }\n        System.out.println(count-1);\n    }\n    \n    private static void count(List<Integer> lst) {\n        int friends = 0;\n        for (Integer i : lst) {\n            if (alr[i]) {\n                continue;\n            } else {\n                alr[i] = true;\n            }           \n            count(list.get(i));\n        }\n    }\n}\n", "code2": "class UnionFind\n\tNode = Struct.new(:p, :h)\n\tdef initialize(size); @p, @r = size.times.to_a, [0]*size; end\n\tdef unite(i, j); k, l = parent(i), parent(j); if @r[k] < @r[l]; @p[k] = l; @r[l] += 1 if @r[k] == @r[l]; else; @p[l] = k; end; end\n\tdef united?(i, j); parent(i) == parent(j); end\n\tdef parent(i); j = i; until i == @p[i]; j, i = i, @p[j] = @p[i]; end; i; end\nend\n\nn, m = gets.split.map &:to_i\nuf = UnionFind.new n\nm.times do\n  a, b = gets.split.map &:to_i\n  uf.unite(a-1, b-1)\nend\n\nrequire \"set\"\ns = Set.new\nn.times do |i|\n  s << uf.parent(i)\nend\n\np s.size-1", "label": 1, "name1": "s602301737.java", "name2": "s827373738.rb"}, {"id": 754, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n\n    void solve() throws IOException {\n        int h = ni(), w = ni();\n        String[] a = nsa(h);\n\n        char[][] ansR = new char[h][w];\n        char[][] ansB = new char[h][w];\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (i == 0 || i < h - 1 && j % 2 == 0) {\n                    ansR[i][j] = '#';\n                    ansB[i][j] = '.';\n                } else {\n                    ansR[i][j] = '.';\n                    ansB[i][j] = '#';\n                }\n            }\n        }\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (a[i].charAt(j) == '#') {\n                    ansR[i][j] = '#';\n                    ansB[i][j] = '#';\n                }\n            }\n        }\n\n        for (int i = 0; i < h; i++) {\n            out.println(String.valueOf(ansR[i]));\n        }\n        out.println();\n        for (int i = 0; i < h; i++) {\n            out.println(String.valueOf(ansB[i]));\n        }\n    }\n\n    String ns() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine(), \" \");\n        }\n        return tok.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.parseInt(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.parseLong(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.parseDouble(ns());\n    }\n\n    String[] nsa(int n) throws IOException {\n        String[] res = new String[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ns();\n        }\n        return res;\n    }\n\n    int[] nia(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ni();\n        }\n        return res;\n    }\n\n    long[] nla(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nl();\n        }\n        return res;\n    }\n\n    class INA {\n        int[][] a;\n\n        INA(int n, int m) throws IOException {\n            this(n, m, -1);\n        }\n\n        INA(int n, int m, int t) throws IOException {\n            a = new int[m][n];\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    a[j][i] = ni() + t;\n                }\n            }\n        }\n\n        int[] get(int i) {\n            return a[i - 1];\n        }\n    }\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        tok = new StringTokenizer(\"\");\n        Main main = new Main();\n        main.solve();\n        out.close();\n    }\n}", "code2": "a,b,x=gets.split.map &:to_i\np b/x-(a-1)/x", "label": 0, "name1": "s104811718.java", "name2": "s453515568.rb"}, {"id": 31, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tMyInput in = new MyInput(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic long LINF = 1L << 55;\n\tstatic int MOD = 1000000007;\n\tstatic int[] mh4 = { 0, -1, 1, 0 };\n\tstatic int[] mw4 = { -1, 0, 0, 1 };\n\tstatic int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\tstatic int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n\tstatic class TaskX {\n\n\t\tpublic void solve(int testNumber, MyInput in, PrintWriter out) {\n\n\t\t\tint n = in.nextInt();\n\t\t\tlong a = in.nextLong(), b = in.nextLong();\n\t\t\tlong[] x = in.nextLongArray(n);\n\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\t\tans += Math.min(a * (x[i+1] - x[i]), b);\n\t\t\t}\n\t\t\tout.println(ans);\n\n\t\t}\n\t}\n\n\tstatic class MyInput {\n\t\tprivate final BufferedReader in;\n\t\tprivate static int pos;\n\t\tprivate static int readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500 * 8 * 2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic {\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tisDigit['0' + i] = true;\n\t\t\t}\n\t\t\tisDigit['-'] = true;\n\t\t\tisSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n\t\t\tisLineSep['\\r'] = isLineSep['\\n'] = true;\n\t\t}\n\n\t\tpublic MyInput(InputStream is) {\n\t\t\tin = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (pos >= readLen) {\n\t\t\t\tpos = 0;\n\t\t\t\ttry {\n\t\t\t\t\treadLen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException();\n\t\t\t\t}\n\t\t\t\tif (readLen <= 0) {\n\t\t\t\t\tthrow new MyInput.EndOfFileRuntimeException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buffer[pos++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\tint i = 0;\n\t\t\tint ret = 0;\n\t\t\tif (str[0] == '-') {\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t\tfor (; i < len; i++)\n\t\t\t\tret = ret * 10 + str[i] - '0';\n\t\t\tif (str[0] == '-') {\n\t\t\t\tret = -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\tint i = 0;\n\t\t\tlong ret = 0;\n\t\t\tif (str[0] == '-') {\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t\tfor (; i < len; i++)\n\t\t\t\tret = ret * 10 + str[i] - '0';\n\t\t\tif (str[0] == '-') {\n\t\t\t\tret = -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic char nextChar() {\n\t\t\twhile (true) {\n\t\t\t\tfinal int c = read();\n\t\t\t\tif (!isSpace[c]) {\n\t\t\t\t\treturn (char) c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic String nextString() {\n\t\t\treturn new String(nextChars());\n\t\t}\n\n\t\tpublic char[] nextChars() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\treturn Arrays.copyOf(str, len);\n\t\t}\n\n\t\tpublic char[][] next2DChars(int h, int w) {\n\t\t\tchar[][] s = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\ts[i] = nextChars();\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\n\t\tint reads(int len, boolean[] accept) {\n\t\t\ttry {\n\t\t\t\twhile (true) {\n\t\t\t\t\tfinal int c = read();\n\t\t\t\t\tif (accept[c]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (str.length == len) {\n\t\t\t\t\t\tchar[] rep = new char[str.length * 3 / 2];\n\t\t\t\t\t\tSystem.arraycopy(str, 0, rep, 0, str.length);\n\t\t\t\t\t\tstr = rep;\n\t\t\t\t\t}\n\t\t\t\t\tstr[len++] = (char) c;\n\t\t\t\t}\n\t\t\t} catch (MyInput.EndOfFileRuntimeException e) {\n\t\t\t}\n\t\t\treturn len;\n\t\t}\n\n\t\tpublic int[] nextIntArray(final int n) {\n\t\t\tfinal int[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArray1Index(final int n) {\n\t\t\tfinal int[] res = new int[n + 1];\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArrayDec(final int n) {\n\t\t\tfinal int[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(final int n) {\n\t\t\tfinal long[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray1Index(final int n) {\n\t\t\tfinal long[] res = new long[n + 1];\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArrayDec(final int n) {\n\t\t\tfinal long[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic double[] nextDoubleArray(int n) {\n\t\t\tdouble[] res = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextDouble();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\t}\n\n\t}\n\n}\n", "code2": "n,a,b=gets.split.map(&:to_i)\nx=gets.split.map(&:to_i)\nc=0\n(n-1).times do |i|\n  if (x[i+1]-x[i])*a>b\n    c+=b\n  else\n    c+=(x[i+1]-x[i])*a\n  end\nend\nputs c\n", "label": 1, "name1": "s004356600.java", "name2": "s333982418.rb"}, {"id": 611, "code1": "import java.util.Scanner;\nimport java.util.Stack;\n\nclass Main{\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tString str=sc.next();\n\t\t\tStack<Integer> st=new Stack<Integer>();\n\t\t\tfor(int i=0;i<str.length();i++){\n\t\t\t\tif(st.isEmpty() || st.peek()==1 || str.charAt(i)=='S') st.add(str.charAt(i)=='S' ? 0 : 1);\n\t\t\t\telse st.pop();\n\t\t\t}\n\t\t\tSystem.out.println(st.size());\n\t\t}\n\t}\n}", "code2": "a,b = gets.split(\" \").map(&:to_i)\nputs a <= b ? a : a-1", "label": 0, "name1": "s831441158.java", "name2": "s970317079.rb"}, {"id": 873, "code1": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int a=sc.nextInt(),b=sc.nextInt(),ab=sc.nextInt(),x=sc.nextInt(),y=sc.nextInt();\n        if(ab*2>a+b){\n          System.out.println(a*x+b*y);\n        }else if(x>y&&ab*2<a){\n          System.out.println(ab*2*x);\n        }else if(x<y&&ab*2<b){\n          System.out.println(ab*2*y);\n        }else if(x>y){\n          System.out.println(ab*2*y+a*(x-y));\n        }else if(x<y){\n          System.out.println(ab*2*x+b*(y-x));\n        }else{\n          System.out.println(ab*2*x);\n        }\n\n\n    }\n}", "code2": "a,b = gets.split(' ')\n\nif (a == 'H' && b == 'H') || (a == 'D' && b == 'D') \n  puts 'H'\nelse\n  puts 'D'\nend\n", "label": 0, "name1": "s137655006.java", "name2": "s829363993.rb"}, {"id": 569, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in);) {\n\t\t\tdouble a = sc.nextDouble();\n\t\t\tdouble b = sc.nextDouble();\n\t\t\tdouble c = sc.nextDouble();\n\t\t\t//\uff12\u70b9\u9593\u306e\u8ddd\u96e2\n\t\t\tdouble s = (a * b / 2 * Math.sin(Math.toRadians(c)));\n\t\t\t\tSystem.out.println(s);\n\t\t\tdouble l = (a + b +Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) - 2 * a * b\n\t\t\t\t\t* Math.cos(Math.toRadians(c))));\n\t\t\t\tSystem.out.println(l);\n\t\t\tdouble h = (b * Math.sin(Math.toRadians(c)));\n\t\t\t\tSystem.out.println(h);\n\t\t}\n\t}\n}\n", "code2": "N, K = gets.split.map(&:to_i)\nA = gets.split.map(&:to_i)\n\ndp = Array.new(K + 1, false)\n(0..K).each do |k|\n  A.each do |a|\n    if k - a >= 0\n      dp[k] ||= !dp[k - a]\n    end\n  end\nend\nputs(dp[K] ? 'First' : 'Second')", "label": 0, "name1": "s947759194.java", "name2": "s888131563.rb"}, {"id": 571, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        double[] a = new double[]{sc.nextDouble(), sc.nextDouble(), sc.nextDouble()};\n        System.out.println(a[0] * a[1] * Math.sin((Math.PI / 180) * a[2]) / 2.0);\n        System.out.println(\n            a[0] + a[1] + Math.sqrt(a[0] * a[0] + a[1] * a[1] - 2 * a[0] * a[1] * Math.cos(Math.PI / 180 * a[2])));\n        System.out.println(a[1] * Math.sin(Math.PI / 180 * a[2]));\n    }\n}", "code2": "n, k = gets.split.map(&:to_i)\na = gets.split.map(&:to_i)\n\ndp = Array.new(k+1) {[nil, nil]}\n\n(k+1).times do |i|\n    2.times do |player|\n        a.each do |e|\n            if i < e\n                dp[i][player] = player ^ 1\n                break\n            end\n\n            if dp[i-e][player ^ 1] == player\n                dp[i][player] = player\n                break\n            end\n        end or next\n        dp[i][player] = player ^ 1\n    end\nend\n\nputs dp[k][0] == 0 ? \"First\" : \"Second\"", "label": 0, "name1": "s203375488.java", "name2": "s522658822.rb"}, {"id": 693, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.AbstractCollection;\nimport java.util.PriorityQueue;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CStreamline solver = new CStreamline();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CStreamline {\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            int[] x = in.nextIntArray(m);\n            Arrays.sort(x);\n            int ans = x[m - 1] - x[0];\n            PriorityQueue<Integer> q = new PriorityQueue<>();\n            for (int i = 0; i < m - 1; i++) {\n                q.add(-(x[i + 1] - x[i]));\n            }\n            for (int i = 0; i < n - 1 && !q.isEmpty(); i++) {\n                ans += q.poll();\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        public int[] nextIntArray(final int n) {\n            final int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt();\n            }\n            return res;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n", "code2": "class DisjointSet\n\tdef initialize(n)\n\t\t@parent = Array.new(n){-1}\n\tend\n\tdef find(a)\n\t\treturn a if @parent[a]<0\n\t\t@parent[a] = find(@parent[a])\n\tend\n\tdef union(a, b)\n\t\tx = find(a)\n\t\ty = find(b)\n\t\treturn x if x == y\n\t\tif size(x) < size(y)\n\t\t\tt = x\n\t\t\tx = y\n\t\t\ty = t\n\t\tend\n\t\t@parent[x] += @parent[y]\n\t\t@parent[y] = x\n\t\tx\n\tend\n\tdef size(a)\n\t\t-@parent[find(a)]\n\tend\nend\n\nN,M=gets.split.map(&:to_i)\nds=DisjointSet.new(N)\nM.times{\n\ta,b=gets.split.map(&:to_i)\n\tds.union(a-1,b-1)\n}\nr=0\n(1 .. N-1).each{|i|\n\tif ds.find(i)!=ds.find(0)\n\t\tds.union(i,0)\n\t\tr+=1\n\tend\n}\nputs r\n", "label": 0, "name1": "s975956716.java", "name2": "s385678464.rb"}, {"id": 808, "code1": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.Stack;\n\nclass Main{\n\tpublic static void main(String[] args) {\n\t\tint INF=1000000007;\n\t\tScanner sc=new Scanner(System.in);\n\t\tint V=sc.nextInt();\n\t\tArrayList<ArrayList<Integer>> v=new ArrayList<ArrayList<Integer>>();\n\t\tfor(int i=0; i<=V; i++) {\n\t\t\tv.add(new ArrayList<Integer>());\n\t\t}\n\t\tfor(int i=0; i<V-1; i++) {\n\t\t\tint a=sc.nextInt();\n\t\t\tint b=sc.nextInt();\n\t\t\t(v.get(a)).add(b);\n\t\t\t(v.get(b)).add(a);\n\t\t}\n\t\tint[] Fe=new int[V+1];\n\t\tint[] Su=new int[V+1];\n\t\tboolean[] Fe_V=new boolean[V+1];\n\t\tboolean[] Su_V=new boolean[V+1];\n\t\tArrays.fill(Fe, INF);\n\t\tArrays.fill(Su, INF);\n\t\tFe[1]=0;\n\t\tSu[V]=0;\n\t\tStack<Integer> Q=new Stack<Integer>();\n\t\tQ.add(1);\n\t\twhile(!Q.isEmpty()) {\n\t\t\tint tmp=Q.pop();\n\t\t\tfor(int i=0; i<v.get(tmp).size(); i++) {\n\t\t\t\tif(!Fe_V[v.get(tmp).get(i)] && Fe[tmp]+1<Fe[v.get(tmp).get(i)]) {\n\t\t\t\t\tFe_V[v.get(tmp).get(i)]=true;\n\t\t\t\t\tFe[v.get(tmp).get(i)]=Fe[tmp]+1;\n\t\t\t\t\tQ.push(v.get(tmp).get(i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tQ.add(V);\n\t\twhile(!Q.isEmpty()) {\n\t\t\tint tmp=Q.pop();\n\t\t\tfor(int i=0; i<v.get(tmp).size(); i++) {\n\t\t\t\tif(!Su_V[v.get(tmp).get(i)] && Su[tmp]+1<Su[v.get(tmp).get(i)]) {\n\t\t\t\t\tSu_V[v.get(tmp).get(i)]=true;\n\t\t\t\t\tSu[v.get(tmp).get(i)]=Su[tmp]+1;\n\t\t\t\t\tQ.push(v.get(tmp).get(i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint Su_w=0;\n\t\tint Fe_w=0;\n\t\tfor(int i=1; i<=V; i++) {\n\t\t\tif(Fe[i]<=Su[i]) {\n\t\t\t\tFe_w++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSu_w++;\n\t\t\t}\n\t\t}\n\t\tif(Su_w>=Fe_w) {\n\t\t\tSystem.out.println(\"Snuke\");\n\t\t\tSystem.out.flush();\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"Fennec\");\n\t\t\tSystem.out.flush();\n\t\t}\n\t}\n}", "code2": "N = gets.to_i\nA = gets.split.map(&:to_i)\nB = gets.split.map(&:to_i)\n\nlimit = B.inject(:+) - A.inject(:+)\ncnt1 = 0\ncnt2 = 0\n\nA.zip(B).each do |a, b|\n  next if a == b\n\n  if a > b\n    cnt1 += a - b\n  else\n    cnt2 += ((b - a) / 2.0).ceil\n  end\nend\n\nif cnt1 <= limit && cnt2 <= limit\n  puts 'Yes'\nelse\n  puts 'No'\nend\n", "label": 0, "name1": "s522721717.java", "name2": "s143550502.rb"}, {"id": 803, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\t\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tString[] days={\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\"};\n\t\twhile(sc.hasNextInt()){\n\t\t\tint month=sc.nextInt();\n\t\t\tint day=sc.nextInt();\n\t\t\tint a=modd(month);\n\t\t\tint b=a+day;\n\t\t\tif(month==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif((b-1)%7==0){\n\t\t\t\tSystem.out.println(days[0]);\n\t\t}else if((b-1)%7==1){\n\t\t\tSystem.out.println(days[1]);\n\t\t}else if((b-1)%7==2){\n\t\t\tSystem.out.println(days[2]);\n\t\t}else if((b-1)%7==3){\n\t\t\tSystem.out.println(days[3]);\n\t\t}else if((b-1)%7==4){\n\t\t\tSystem.out.println(days[4]);\n\t\t}else if((b-1)%7==5){\n\t\t\tSystem.out.println(days[5]);\n\t\t}else if((b-1)%7==6){\n\t\t\tSystem.out.println(days[6]);\n\t\t}\n\t}\n\n\t}\n\tpublic static int modd(int month){\n\t\tint[] months={31,29,31,30,31,30,31,31,30,31,30,31};\n\t\tint a=0;\n\t\tfor(int i=0; i<=month-2; i++){\n\t\t\ta+=months[i];\n\t\t}\n\n\t\treturn a;\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n}", "code2": "gets;puts$<.map{|s|s.split.map &:to_i}.transpose.reduce(0){|s,a|s+=(a[1]-a[0])/(a[0]>a[1] ?1:2)}<0 ?:No: :Yes", "label": 0, "name1": "s331323698.java", "name2": "s002794262.rb"}, {"id": 1, "code1": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String str = sc.next();\n        int n = str.length();\n        int digitSum = 0;\n        for (int i = 0; i < n; i++)\n            digitSum += (str.charAt(i) - '0');\n        if(digitSum % 9 == 0) {\n            System.out.println(\"Yes\");\n        }\n        else {\n            System.out.println(\"No\");\n        }\n    }\n}\n\n", "code2": "s = gets.to_s\n\nd_sum = 0\n0.upto(s.size-1) do |i|\n  d_sum += s[i].to_i\nend\n\nif d_sum % 9 == 0\n  puts \"Yes\"\nelse\n  puts \"No\"\nend", "label": 1, "name1": "s204970720.java", "name2": "s099992332.rb"}, {"id": 21, "code1": "import java.util.*;\n \npublic class Main{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    double H = sc.nextDouble();\n    double W = sc.nextDouble();\n    if (H != 1 && W != 1)\n\t\t\tSystem.out.println((long) Math.ceil(H * W / 2));\n\t\telse\n\t\t\tSystem.out.println(1);\n  }\n}\n    ", "code2": "h, w = gets.chomp.split.map(&:to_i)\nif (h == 1 || w == 1 )\n  puts \"1\"\nelse\n  puts \"#{(h * w / 2.0).round}\"\nend\n", "label": 1, "name1": "s603185414.java", "name2": "s520164559.rb"}, {"id": 452, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\t\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tString[] days={\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\"};\n\t\twhile(sc.hasNextInt()){\n\t\t\tint month=sc.nextInt();\n\t\t\tint day=sc.nextInt();\n\t\t\tint a=modd(month);\n\t\t\tint b=a+day;\n\t\t\tif(month==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif((b-1)%7==0){\n\t\t\t\tSystem.out.println(days[0]);\n\t\t}else if((b-1)%7==1){\n\t\t\tSystem.out.println(days[1]);\n\t\t}else if((b-1)%7==2){\n\t\t\tSystem.out.println(days[2]);\n\t\t}else if((b-1)%7==3){\n\t\t\tSystem.out.println(days[3]);\n\t\t}else if((b-1)%7==4){\n\t\t\tSystem.out.println(days[4]);\n\t\t}else if((b-1)%7==5){\n\t\t\tSystem.out.println(days[5]);\n\t\t}else if((b-1)%7==6){\n\t\t\tSystem.out.println(days[6]);\n\t\t}\n\t}\n\n\t}\n\tpublic static int modd(int month){\n\t\tint[] months={31,29,31,30,31,30,31,31,30,31,30,31};\n\t\tint a=0;\n\t\tfor(int i=0; i<=month-2; i++){\n\t\t\ta+=months[i];\n\t\t}\n\n\t\treturn a;\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n}", "code2": "day=[\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\"]\nwhile true\n\tm,d=gets.chomp.split(\" \").map{|s| s.to_i}\n\tbreak if m==0&&d==0\n\tcount=2\n\tfor i in (1..m-1) do\n\t\tif(i==2) then \n\t\t\tcount+=29\n\t\telsif (i==4||i==6||i==9||i==11) then\n\t\t\tcount+=30\n\t\telse\n\t\t\tcount+=31\n\t\tend\t\n\tend\n\tcount+=d\n\tcount%=7\n\tputs day[count]\nend\n", "label": 1, "name1": "s331323698.java", "name2": "s196769013.rb"}, {"id": 100, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in);) {\n\t\t\tdouble a = sc.nextDouble();\n\t\t\tdouble b = sc.nextDouble();\n\t\t\tdouble c = sc.nextDouble();\n\t\t\t//\uff12\u70b9\u9593\u306e\u8ddd\u96e2\n\t\t\tdouble s = (a * b / 2 * Math.sin(Math.toRadians(c)));\n\t\t\t\tSystem.out.println(s);\n\t\t\tdouble l = (a + b +Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) - 2 * a * b\n\t\t\t\t\t* Math.cos(Math.toRadians(c))));\n\t\t\t\tSystem.out.println(l);\n\t\t\tdouble h = (b * Math.sin(Math.toRadians(c)));\n\t\t\t\tSystem.out.println(h);\n\t\t}\n\t}\n}\n", "code2": "a,b,c = gets.chomp.split.map(&:to_f)\n\ns = (a * b * Math.sin(c * Math::PI / 180)) * 0.5\nl = (a + b) + (a*a + b*b - 2*a*b*Math.cos(c * Math::PI / 180)) ** 0.5\nh = b * Math.sin(c * Math::PI / 180)\n\nputs s\nputs l\nputs h", "label": 1, "name1": "s947759194.java", "name2": "s128364594.rb"}, {"id": 868, "code1": "import java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String args[]){\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tint num = sc.nextInt();\n\n\t\tBigInteger big_num = BigInteger.valueOf(1);\n\n\t\tfor(int i = 2; i <= num+1; i++){\n\t\t\tbig_num = big_num.multiply(BigInteger.valueOf(i));\n\t\t}\n\n\t\tSystem.out.println(big_num.add(BigInteger.valueOf(2)));\n\n\t\tfor(int i = 2; i <= num+1; i++){\n\t\t\tSystem.out.println(i);\n\t\t}\n\n\t}\n}", "code2": "A,B,C,X,Y = gets.chomp.split.map(&:to_i)\na = 0\nb = 0\ncost = 0\nif A+B >= C*2\n\ta = [X,Y].min\n\tb = a\n\tcost += a*C*2\nend\nif A >= C*2\n\tcost += (X-a)*C*2\n\tb += (X-a)\nelse\n\tcost += (X-a)*A\nend\nif B >= C*2\n\tcost += (Y-b)*C*2\nelse\n\tcost += (Y-b)*B\nend\np cost", "label": 0, "name1": "s634203769.java", "name2": "s390656619.rb"}, {"id": 852, "code1": "import java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\n\nclass Person implements Comparable<Person> {\n\n    final int no;\n    final double time;\n\n    Person( final int no, final double time ) {\n\tthis.no = no;\n\tthis.time = time;\n    }\n    \n    public int compareTo( final Person p ) {\n\treturn Double.compare( time, p.time );\n    }\n\n    public String toString() {\n\treturn String.format( \"%d %.2f\", no, time );\n    }\n}\n\nclass Main {\n\n    public static void main( final String[] args ) {\n\n\tfinal Scanner stdin = new Scanner( System.in );\n\tfinal ArrayList<Person> last = new ArrayList<Person>();\n\tfinal ArrayList<Person> rest = new ArrayList<Person>();\n\t\n\tfor ( int i = 0; i < 3; i++ ) {\n\t    final ArrayList<Person> semifinal = new ArrayList<Person>();\n\t    for ( int j = 0; j < 8; j++ ) {\n\t\tsemifinal.add( new Person( stdin.nextInt(), stdin.nextDouble() ) );\n\t    }\n\t    Collections.sort( semifinal );\n\t    last.add( semifinal.remove( 0 ) );\n\t    last.add( semifinal.remove( 0 ) );\n\t    rest.addAll( semifinal );\n\t}\n\tCollections.sort( rest );\n\tlast.add( rest.remove( 0 ) );\n\tlast.add( rest.remove( 0 ) );\n\tfor ( Person p : last ) {\n\t    System.out.println( p );\n\t}\n    }    \n}", "code2": "nm = gets.chomp.split\nn = nm[0].to_i\nm = nm[1].to_i\n\np_a = Array.new(n+1){Array.new(2, 0)}\nm.times do\n    ps = gets.chomp.split\n    number = ps[0].to_i\n    judge = ps[1]\n    case judge\n    when \"AC\"\n        p_a[number][0] += 1\n    when \"WA\"\n        if p_a[number][0] == 0\n            p_a[number][1] += 1\n        end\n    end\nend\n\nac_count = 0\nwa_count = 0\nn.times do |i|\n    if p_a[i+1][0] > 0\n        ac_count += 1\n        wa_count += p_a[i+1][1]\n    end\nend\n\nputs ac_count.to_s + \" \" + wa_count.to_s", "label": 0, "name1": "s209430606.java", "name2": "s394854078.rb"}, {"id": 146, "code1": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint[] pri = new int[25000];\n\t\tpri[0] = 2;\n\t\tpri[1] = 3;\n\t\tpri[2] = 5;\n\t\tpri[3] = 7;\n\t\tpri[4] = 11;\n\t\tpri[5] = 13;\n\t\tpri[6] = 17;\n\t\tpri[7] = 19;\n\t\tpri[8] = 23;\n\t\tpri[9] = 29;\n\t\tint fl = 0;\n\t\tint a=0;\n\t\tint b=0;\n\t\tint c=0;\n\t\twhile(pri[a]<=250000){\n\t\t\tfl++;\n\t\t\tfor(int i=0;i<8;i++){\n\t\t\t\ta=0;\n\t\t\t\tb=0;\n\t\t\t\tc=0;\t\t\t\t\n\t\t\t\tif(i==0){\n\t\t\t\t\tc=1;\n\t\t\t\t}else if(i>0){\n\t\t\t\t\tc=pri[2+i];\n\t\t\t\t}\n\t\t\t\twhile(pri[a]!=0){\n\t\t\t\t\tif((30*fl + c)%pri[a]==0){\n\t\t\t\t\t\tb=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ta++;\n\t\t\t\t}\n\t\t\t\tif(b==0){\n\t\t\t\t\tpri[a]=(30*fl + c);\n\t\t\t\t}\n\t\t\t}\t\t\t\t\t\n\t\t}\n\t\t\n\t\tboolean exit = true;\n\t\twhile(exit==true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)exit=false;\n\t\t\tif(exit==true){\n\t\t\t\tint sum=-1;\n\t\t\t\tint i=0;\n\t\t\t\twhile(true){\n\t\t\t\t\tif(pri[i]>n)sum++;\n\t\t\t\t\tif(pri[i]>2*n)break;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(sum);\n\t\t\t}\n\t\t}\n\t}\n\t\n}", "code2": "require 'prime'\nwhile n = gets.to_i\n  break if n == 0\n  p Prime.each(2 * n).drop_while{ |p| p <= n }.size\nend", "label": 1, "name1": "s593802453.java", "name2": "s276322945.rb"}, {"id": 729, "code1": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\nclass Solver extends Main{\n\tSolver(){\n\t\t\n\t}\n}//Solver_end\n\n@SuppressWarnings(\"unchecked\")\nclass Main{\n\tstatic int imax=Integer.MAX_VALUE;\n\tstatic long lmax=Long.MAX_VALUE;\n\t\n\tpublic static void main(String[] args) throws FileNotFoundException{\n\t\t\n\t\t\n\t\tScanner sc=new Scanner(System.in);\n\t\t//Scanner sc=new Scanner(fp);\n\t\t\n\t\tint[] data=readlnI(sc,\" \");\n\t\tint n=data[0];\n\t\tint m=data[1];\n\t\tint[] path=new int[200000];\n\t\t\n\t\tfor(int i=0;i<m; i++){\n\t\t\tint[] line=readlnI(sc,\" \");\n\t\t\tif(line[0]==1){\n\t\t\t\tpath[line[1]-1]+=1;\n\t\t\t}else if(line[1]==n){\n\t\t\t\tpath[line[0]-1]+=1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean fnd=false;\n\t\t\n\t\tfor(int x:path){\n\t\t\tif(x==2)fnd=true;\n\t\t}\n\t\t\n\t\tputs(fnd==true ? \"POSSIBLE\" : \"IMPOSSIBLE\");\n\t\t\n\t}//main_end\n\t\n//---------------------------------------------------------------------------\n\tstatic int readI(Scanner sc){\n\t\treturn Integer.parseInt(sc.nextLine().trim());\n\t}\n\tstatic long readL(Scanner sc){\n\t\treturn Long.parseLong(sc.nextLine().trim());\n\t}\n\tstatic String readS(Scanner sc){\n\t\treturn sc.nextLine().trim();\n\t}\n\tstatic int[] readlnI(Scanner sc, String dl){\n\t\treturn Arrays.stream(sc.nextLine().trim().split(dl)).mapToInt(Integer::parseInt).toArray();\n\t}\n\tstatic long[] readlnL(Scanner sc, String dl){\n\t\treturn Arrays.stream(sc.nextLine().trim().split(dl)).mapToLong(Long::parseLong).toArray();\n\t}\n\tstatic String[] readlnS(Scanner sc, String dl){\n\t\treturn sc.nextLine().trim().split(dl);\n\t}\n\t@SuppressWarnings(\"unchecked\")\n\tstatic <T> void puts(T... args){\n\t\tfor(int i=0; i<args.length-1; i++){\n\t\t\tSystem.out.printf(\"%s \",args[i]);\n\t\t}\n\t\tSystem.out.println(args[args.length-1]);\n\t}\n\tstatic void puts(int[] ary){\n\t\tfor(int i=0; i<ary.length-1; i++){\n\t\t\tSystem.out.printf(\"%d \",ary[i]);\n\t\t}\n\t\tSystem.out.println(ary[ary.length-1]);\n\t}\n\tstatic void puts(long[] ary){\n\t\tfor(int i=0; i<ary.length-1; i++){\n\t\t\tSystem.out.printf(\"%d \",ary[i]);\n\t\t}\n\t\tSystem.out.println(ary[ary.length-1]);\n\t}\n\tstatic void bs(){\n\t\tSystem.out.println(\"\");\n\t}\n\tstatic int sum(int[] ary){\n\t\tint sum=0;\n\t\tfor(int i=0; i<ary.length; i++) sum+=ary[i];\n\t\treturn sum;\n\t}\n\tstatic long sum(long[] ary){\n\t\tlong sum=0;\n\t\tfor(int i=0; i<ary.length; i++) sum+=ary[i];\n\t\treturn sum;\n\t}\n\tstatic void tblSort(int[][] tbl){\n\t\tArrays.sort(tbl, new Comparator<int[]>(){\n\t\t\t@Override\n\t\t\tpublic int compare(int[] a, int[] b){\n\t\t\t\tif(a[0]==b[0]){\n\t\t\t\t\treturn b[1]-a[1];\n\t\t\t\t}else{\n\t\t\t\t\treturn b[0]-a[0];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n", "code2": "x, y = gets.split.map &:to_i\ncnt = 0\nwhile x <= y\n  y >>= 1\n  cnt += 1\nend\np cnt\n", "label": 0, "name1": "s766623172.java", "name2": "s741410088.rb"}, {"id": 796, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        BRemovingBlocks solver = new BRemovingBlocks();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BRemovingBlocks {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            long[] a = in.readLongArray(n);\n\n            Modulo.mod = MiscUtils.MOD7;\n\n            long[] s = new long[n];\n            s[0] = 1;\n            for (int i = 1; i < n; i++) {\n                s[i] = Modulo.add(s[i - 1], Modulo.rev(i + 1));\n            }\n\n            long ans = 0;\n            for (int i = 0; i < n; i++) {\n                long sum = Modulo.mlt(a[i], s[i] + s[n - 1 - i] - 1);\n                ans = Modulo.add(ans, sum);\n            }\n            for (int i = 1; i <= n; i++) ans = Modulo.mlt(ans, i);\n            out.printLine(ans);\n        }\n\n    }\n\n    static class Modulo {\n        public static long mod;\n        private long value;\n\n        public Modulo(long value) {\n            this.value = (value % mod + mod) % mod;\n        }\n\n        public static long add(long a, long b) {\n            return ((a + b) % mod + mod) % mod;\n        }\n\n        public static long mlt(long a, long b) {\n            return ((a % mod + mod) * (b % mod + mod)) % mod;\n        }\n\n        public static long rev(long a) {\n            //return pow(a, mod - 2);\n            return (Euclid.extgcd(a, mod, new long[3])[0] % mod + mod) % mod;\n        }\n\n        public String toString() {\n            return \"\" + value;\n        }\n\n    }\n\n    static class Euclid {\n        public static long[] extgcd(long a, long b, long[] is) {\n            if (a == 0) {\n                is[0] = 0;\n                is[1] = 1;\n                is[2] = b;\n            } else {\n                extgcd(b % a, a, is);\n                long x = is[1] - b / a * is[0];\n                is[1] = is[0];\n                is[0] = x;\n            }\n            return is;\n        }\n\n    }\n\n    static class MiscUtils {\n        public static final int MOD7 = (int) (1e9 + 7);\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public long[] readLongArray(int size) {\n            long[] array = new long[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readLong();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long readLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "code2": "require \"date\"\narr = Array.new\nuntil (line = gets) == \"0 0\\n\"\n  arr << line\nend\narr.each do |i|\n  a = i.split(\" \")\n  a.map!{|j| j.to_i}\n  m = a[0]\n  d = a[1]\n  wday = [\"Sunday\",\n          \"Monday\",\n          \"Tuesday\",\n          \"Wednesday\",\n          \"Thursday\",\n          \"Friday\",\n          \"Saturday\"]\n  day = Date::new(2004, m, d)\n  puts wday[day.wday]\nend", "label": 0, "name1": "s003754625.java", "name2": "s152498090.rb"}, {"id": 43, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Optional;\nimport java.util.OptionalDouble;\nimport java.util.stream.DoubleStream;\nimport java.util.stream.Stream;\n\npublic class Main {\n\n  public static void main(String[] args) throws IOException {\n    \n    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {\n\n      String line;\n      String[] lines;\n      double[] s;\n      while( !(line = br.readLine()).equals(\"0\") ){\n\n        int n = Integer.parseInt(line);\n        lines = br.readLine().split(\" \");\n\n        s =\n          Stream.of(lines)\n            .mapToDouble(Double::parseDouble)\n            .toArray();\n        \n        double dm =\n          Arrays.stream(s)\n            .average()\n          .getAsDouble();\n\n        double result =\n        Arrays.stream(s)\n          .map(d -> Math.pow((d-dm),2) / n)\n          .sum();\n\n        System.out.printf(\"%.8f\\n\" , Math.sqrt(result));\n      }\n    }\n  }\n}\n", "code2": "#!/usr/bin/ruby\n# -*- coding: utf-8 -*-\n=begin\nITP1_10-C\n\nMath Functions - Standard Deviation\nTime Limit : 1 sec, Memory Limit : 65536 KB\n?\u00a8??????????\n\nn ????????????????????????????????\u00a7????????\u00b0???????????\u00b0???????\u00a8?????????\u00a3??????????????????????????????s1, s2 ... sn??\u00a8????????\u00a8??????????\u00a8??????????????\u00b1???????????????\u00b0????????????????????????\n\n??????????????????????????\u00a8????????\u00b0????????\u00a3?\u00b12?????\\???????????\u00a7???????????????\n\n?\u00b12 = (???ni=1(si - m)2)/n\n\n?????\u00a3?????\u00a3????????????????\u00a8???????????\u00b1??\u00a8?????????\nInput\n\n?????\u00b0??????????????????????????\\?????\u00a8??????????????????????????????????????????????????\\????????\u00a2?????\u00a7??????????????????\n\n???????????\u00b0 n\ns1 s2 ... sn\n\nn ??? 0 ?????\u00a8?????\\?????????????????\u00a8?????????\nOutput\n\n?????????????????????????????????????\u00a8?????????????????????????????????????????????????0.0001??\\????????????????????\u00a3???????????????\nConstraints\n\n    ??\\?????\u00a7??????????????? n ???1000????\u00b6????????????\u00a8????????????\n    0 ??? si ??? 100\n\nSample Input\n\n5\n70 80 100 90 20\n3\n80 80 80\n0\n\nSample Output\n\n27.85677655\n0.00000000\n\n=end\n\nclass Main\n  def initialize\n    fh = STDIN\n    while fh.gets do\n      n = $_.chomp.to_i\n      break if n==0 \n      fl = fh.gets.chomp.split.map{|x| x.to_f}\n      puts stddev(fl)\n    end\n  end\n\n  def stddev(f)\n    n = f.length\n    sum = f.inject(0.0){|acc,x| acc + x}\n    ave = sum / n\n    sq_sum = f.inject(0.0){|acc,x| acc + (x - ave)**2}\n    Math.sqrt(sq_sum / n) \n  end\nend\n\nif $0==__FILE__ then\n  Main.new()\nend", "label": 1, "name1": "s757478171.java", "name2": "s375636149.rb"}, {"id": 541, "code1": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        try(Scanner scn = new Scanner(System.in)) {\n            int sum = scn.nextInt() + scn.nextInt() + scn.nextInt() + scn.nextInt();\n            System.out.println(sum / 60);\n            System.out.println(sum % 60);\n        }\n    }\n}", "code2": "def  nnp1(n)\n    a=((n*2)**(0.5)).to_i\n    return a*(a+1)==n*2\nend\n\ndef  nnp(n)\n    a=((n*2)**(0.5)).to_i\n    return a\nend\n\nn=gets.strip.to_i\n\nif nnp1(n) == false \n    puts 'No'\n    exit\nend\nputs 'Yes'\na=nnp(n)\nx=Array.new(a+1).map{Array.new(a)}\nc=1\nputs a+1\n(0..a-1).each{|i|\n    \n    cc=c\n    (i..a-1).each{|j|\n        x[i][j]=cc\n        cc+=1\n    }\n\n    cc=c\n    (i+1..a).each{|j|\n        x[j][i]=cc\n        cc+=1\n    }\n    c=cc\n}\n\nx.each do |i|\n    print a.to_s + \" \"\n    puts i.join(\" \")\n\nend", "label": 0, "name1": "s061388848.java", "name2": "s713749025.rb"}, {"id": 466, "code1": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.Stack;\n\nclass Main{\n\tpublic static void main(String[] args) {\n\t\tint INF=1000000007;\n\t\tScanner sc=new Scanner(System.in);\n\t\tint V=sc.nextInt();\n\t\tArrayList<ArrayList<Integer>> v=new ArrayList<ArrayList<Integer>>();\n\t\tfor(int i=0; i<=V; i++) {\n\t\t\tv.add(new ArrayList<Integer>());\n\t\t}\n\t\tfor(int i=0; i<V-1; i++) {\n\t\t\tint a=sc.nextInt();\n\t\t\tint b=sc.nextInt();\n\t\t\t(v.get(a)).add(b);\n\t\t\t(v.get(b)).add(a);\n\t\t}\n\t\tint[] Fe=new int[V+1];\n\t\tint[] Su=new int[V+1];\n\t\tboolean[] Fe_V=new boolean[V+1];\n\t\tboolean[] Su_V=new boolean[V+1];\n\t\tArrays.fill(Fe, INF);\n\t\tArrays.fill(Su, INF);\n\t\tFe[1]=0;\n\t\tSu[V]=0;\n\t\tStack<Integer> Q=new Stack<Integer>();\n\t\tQ.add(1);\n\t\twhile(!Q.isEmpty()) {\n\t\t\tint tmp=Q.pop();\n\t\t\tfor(int i=0; i<v.get(tmp).size(); i++) {\n\t\t\t\tif(!Fe_V[v.get(tmp).get(i)] && Fe[tmp]+1<Fe[v.get(tmp).get(i)]) {\n\t\t\t\t\tFe_V[v.get(tmp).get(i)]=true;\n\t\t\t\t\tFe[v.get(tmp).get(i)]=Fe[tmp]+1;\n\t\t\t\t\tQ.push(v.get(tmp).get(i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tQ.add(V);\n\t\twhile(!Q.isEmpty()) {\n\t\t\tint tmp=Q.pop();\n\t\t\tfor(int i=0; i<v.get(tmp).size(); i++) {\n\t\t\t\tif(!Su_V[v.get(tmp).get(i)] && Su[tmp]+1<Su[v.get(tmp).get(i)]) {\n\t\t\t\t\tSu_V[v.get(tmp).get(i)]=true;\n\t\t\t\t\tSu[v.get(tmp).get(i)]=Su[tmp]+1;\n\t\t\t\t\tQ.push(v.get(tmp).get(i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint Su_w=0;\n\t\tint Fe_w=0;\n\t\tfor(int i=1; i<=V; i++) {\n\t\t\tif(Fe[i]<=Su[i]) {\n\t\t\t\tFe_w++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSu_w++;\n\t\t\t}\n\t\t}\n\t\tif(Su_w>=Fe_w) {\n\t\t\tSystem.out.println(\"Snuke\");\n\t\t\tSystem.out.flush();\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"Fennec\");\n\t\t\tSystem.out.flush();\n\t\t}\n\t}\n}", "code2": "n = gets.chomp.to_i\ntree = Array.new(n)\nn.times { |i| tree[i] = [] }\n(n - 1).times do\n  a, b = gets.chomp.split(' ').map { |i| i.to_i - 1 }\n  tree[a] << b\n  tree[b] << a\nend\n\ndistances = Array.new(n, 100001)\nqueue = [0]\nvisited = Hash.new(false)\ndistance = 0\nuntil queue.empty?\n  length = queue.length\n  length.times do\n    q = queue.shift\n    next if visited[q]\n    visited[q] = true\n    distances[q] = distance\n    tree[q].each do |t|\n      next if visited[t]\n      queue << t\n    end\n  end\n  distance += 1\nend\n\nroute = [n - 1]\ncurrent = n - 1\nwhile route.first != 0 do\n  tree[current].each do |i|\n    if distances[current] - distances[i] == 1\n      current = i\n      route.unshift(i)\n      break\n    end\n  end\nend\n\nstart_index = route.length % 2 == 0 ? (route.length / 2) - 1 : route.length / 2\nstart = route[start_index]\nclose = route[start_index + 1]\ntree[start].delete(close)\nqueue = [start]\nvisited = Hash.new(false)\nfennec_count = 0\nuntil queue.empty?\n  q = queue.pop\n  next if visited[q]\n  visited[q] = true\n  fennec_count += 1\n  tree[q].each do |t|\n    next if visited[t]\n    queue << t\n  end\nend\n\nputs fennec_count > n - fennec_count ? 'Fennec' : 'Snuke'", "label": 1, "name1": "s522721717.java", "name2": "s449655546.rb"}, {"id": 536, "code1": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tvoid run(){\n\t\tint s=0;\n\t\tfor(int i=0; i<4; i++){\n\t\t\ts+=sc.nextInt();\n\t\t}\n\t\tprintln(s/60+\"\");\n\t\tprintln(s%60+\"\");\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}", "code2": "loop{n=gets.to_i;exit if n==0;a,b=n.times.map{a=gets.split.map &:to_i;[a[1]+a[2],a[0]]}.sort[-1];puts\"#{b} #{a}\"}\n", "label": 0, "name1": "s582549641.java", "name2": "s848913161.rb"}, {"id": 95, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        final Scanner sc = new Scanner(System.in);\n\n        final long n = sc.nextLong();\n        final long k = sc.nextLong();\n\n        final long t = n % k;\n        System.out.println(Math.min(t, k-t));\n    }\n}\n", "code2": "n, k = gets.rstrip.split(\" \").map { |c| c.to_i}\n\nif n < (n-k).abs then\n  puts n\n  exit\nend\n  \ndiv = n / k\na = n - div*k\nb = a - k\n\nputs [a.abs, b.abs].min", "label": 1, "name1": "s071954198.java", "name2": "s822166626.rb"}, {"id": 328, "code1": "import java.util.Scanner;\n\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    // \u6574\u6570\u306e\u5165\u529b\n    int a = sc.nextInt();\n    // \u30b9\u30da\u30fc\u30b9\u533a\u5207\u308a\u306e\u6574\u6570\u306e\u5165\u529b\n    int b = sc.nextInt();\n    int c = sc.nextInt();\n\n//    int ab = a + b;\n//    int bc = b + c;\n//    int ac = a+c;\n//\n//    int result = Math.min(ab, Math.min(bc , ac));\n\n    int max = Math.max(a, Math.max(b, c));\n\n    System.out.println(a + b + c - max);\n  }\n}\n", "code2": "price = gets.split.map(&:to_i)\nsorted_p = price.sort\nans = sorted_p[0] + sorted_p[1]\nputs ans", "label": 1, "name1": "s393158982.java", "name2": "s680191741.rb"}, {"id": 617, "code1": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t\n\tint cmp (String p1, String p2) {\n\t\tif( p1.length() != p2.length() ) return p2.length() - p1.length();\n\t\treturn p2.compareTo(p1);\n\t}\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif((w|h) == 0 ) break;\n\t\t\t\n\t\t\tString[][] dp = new String[h+1][w+1];\n\t\t\tString pass = \"\";\n\t\t\tchar[][] map = new char[h+1][w+1];\n\t\t\t\n\t\t\tfor(String[] a: dp) fill(a, \"\");\n\t\t\t\n\t\t\tfor(int i=1;i<=h;i++) {\n\t\t\t\tString str = sc.next();\n\t\t\t\tfor(int j=1;j<=w;j++) {\n\t\t\t\t\tmap[i][j] = str.charAt(j-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=1;i<=h;i++) for(int j=1;j<=w;j++) {\n\t\t\t\tif( '0' <= map[i][j] && map[i][j] <= '9' ) {\n\t\t\t\t\tif( map[i][j] == '0' && dp[i-1][j].equals(\"\") && dp[i][j-1].equals(\"\") ) continue;\n\t\t\t\t\tdp[i][j] = ( cmp(dp[i-1][j], dp[i][j-1])<0? dp[i-1][j]: dp[i][j-1] ) + (char)map[i][j];\n\t\t\t\t}\n\t\t\t\tpass = cmp(pass, dp[i][j])<0? pass: dp[i][j];\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(pass);\n\t\t\t\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}", "code2": "# \u89e3\u8aac\u898b\u305f\n\nn = gets.to_i\nfriendly = gets.strip.split.map(&:to_i).sort\nans = 0\n(1..(n - 1)).each do |i|\n  ans += friendly[n - (i / 2) - 1]\nend\nputs(ans)\n", "label": 0, "name1": "s246113848.java", "name2": "s991737388.rb"}, {"id": 388, "code1": "import java.util.Scanner;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    long a = sc.nextLong();\n    long b = sc.nextLong();\n    long c;\n    long x = sc.nextLong();\n    if(a%x == 0) {\n      c = a / x -1;\n    }else {\n      c = a / x;\n    }\n    System.out.println(b/x-c);\n  }\n}\n", "code2": "a,b,x=gets.split.map &:to_i\np b/x-(a-1)/x", "label": 1, "name1": "s320140275.java", "name2": "s453515568.rb"}, {"id": 61, "code1": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        try(Scanner scn = new Scanner(System.in)) {\n            int sum = scn.nextInt() + scn.nextInt() + scn.nextInt() + scn.nextInt();\n            System.out.println(sum / 60);\n            System.out.println(sum % 60);\n        }\n    }\n}", "code2": "x = gets.to_i\nx += gets.to_i\nx += gets.to_i\nx += gets.to_i\nputs x/60\nputs x%60\n", "label": 1, "name1": "s061388848.java", "name2": "s649714862.rb"}, {"id": 642, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    void solve() throws IOException {\n    \tint N = ni();\n\n    \tint[] T = new int[N];\n    \tint[] A = new int[N];\n\n    \tfor (int i=0; i<N; i++) {\n\t\t\tT[i] = ni();\n\t\t\tA[i] = ni();\n\t\t}\n\n    \tlong t = T[0];\n    \tlong a = A[0];\n\n    \tfor (int i=1; i<N; i++) {\n    \t\tlong x = (t%T[i]==0)? t/T[i] : (t/T[i] + 1);\n    \t\tlong y = (a%A[i]==0)? a/A[i] : (a/A[i] + 1);\n    \t\tt = T[i] * Math.max(x, y);\n    \t\ta = A[i] * Math.max(x, y);\n    \t}\n\n    \tout.println(t + a);\n    }\n\n    String ns() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine(), \" \");\n        }\n        return tok.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.parseInt(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.parseLong(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.parseDouble(ns());\n    }\n\n    String[] nsa(int n) throws IOException {\n        String[] res = new String[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ns();\n        }\n        return res;\n    }\n\n    int[] nia(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ni();\n        }\n        return res;\n    }\n\n    long[] nla(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nl();\n        }\n        return res;\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        tok = new StringTokenizer(\"\");\n        Main main = new Main();\n        main.solve();\n        out.close();\n    }\n}\n", "code2": "def g;gets.split.map &:to_i;end\nr=1..n=g[0]\nw=[[]]+r.map{[0]+[1e9]*n}\nr.map{f,_,*t=g;t.map{|i|w[f][i]=1}}\nr.map{|k|w.map!{|i|i=i.zip(w[k]).map{|a,b|[a,b+i[k]].min}}}\ng[0].times{s,d,v=g;puts v<(c=w[s][d]+1)?:NA:c}", "label": 0, "name1": "s760488688.java", "name2": "s352888283.rb"}, {"id": 442, "code1": "import java.io.*;\nimport java.util.*;\n \npublic class Main {\n\tstatic final Reader in = new Reader();\n\tstatic final long M=(long)1e9+7;\n\t\n\tpublic static void main(String[] args) {\n\t\tint n=in.nextInt();\n\t\tlong[] ps = new long[n+1];\n\t\tlong nf=1;\n\t\tfor(int i=1; i<=n; ++i) {\n\t\t\tps[i]=(ps[i-1]+in.nextInt())%M;\n\t\t\tnf=nf*i%M;\n\t\t}\n\t\tlong ans=nf*ps[n]%M, s=0;\n\t\tfor(int i=1; i<=n-1; ++i) {\n\t\t\ts=(s+ps[n-i]-ps[i]+M)%M;\n\t\t\tans=(ans+nf*modI((long)(i+1)*(i>=n-1?1:i+2), M)%M*2*s+nf*modI(i+1, M)%M*(ps[i]+ps[n]-ps[n-i]+M))%M;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\t\n\tstatic long modI(long a, long m) {\n\t\treturn (a%=m)<=1?1:(1-modI(m%a, a)*m)/a+m;\n\t}\n\t\n\tstatic class Reader {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st;\n\t\tString next() {\n\t\t\twhile(st==null||!st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch(Exception e) {}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t}\n}", "code2": "eval'*A=#'+`tr ' ' ,`\ni=f=1\ns=m=10**9+7\np A.sum{f=f*i%m\ns+=i.pow m-2,m\n_1*~-s+A[1-i+=1]*s}*f%m", "label": 1, "name1": "s013996602.java", "name2": "s721063213.rb"}, {"id": 960, "code1": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.BigDecimal;\n\npublic class Main{\n    public static void main (String[] args) throws java.lang.Exception {\n        InputReader in = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n        int n = in.nextInt(), m = in.nextInt(), k = in.nextInt();\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j <= m; j++) {\n                long cur = i * m + j * n - 2 * (i * j);\n                if (cur == k) {\n                    w.println(\"Yes\");\n                    w.close();\n                    return;\n                }\n            }\n        }\n        w.println(\"No\");\n        w.close();\n    }\n\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new UnknownError();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new UnknownError();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int peek() {\n            if (numChars == -1)\n                return -1;\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    return -1;\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar];\n        }\n\n        public void skip(int x) {\n            while (x-- > 0)\n                read();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public String nextString() {\n            return next();\n        }\n\n        public String next() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuffer res = new StringBuffer();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        public String nextLine() {\n            StringBuffer buf = new StringBuffer();\n            int c = read();\n            while (c != '\\n' && c != -1) {\n                if (c != '\\r')\n                    buf.appendCodePoint(c);\n                c = read();\n            }\n            return buf.toString();\n        }\n\n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n        public int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n        public long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n        public boolean hasNext() {\n            int value;\n            while (isSpaceChar(value = peek()) && value != -1)\n                read();\n            return value != -1;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}", "code2": "n = gets.chomp.to_i\na = gets.chomp.split().map(&:to_i)\nb = gets.chomp.split().map(&:to_i)\nc = gets.chomp.split().map(&:to_i)\n\na.sort!\nb.sort!\nc.sort!\n\n# p a, b, c\n\nans = 0\nb.each do |e|\n#  p ['loop', e]\n  aa_index = a.bsearch_index{|x| e <= x}\n#  p ['aa_i', aa_index]\n  aa_index ||= n\n\n  cc_index = c.bsearch_index{|x| e < x}\n#  p ['cc_i', cc_index]\n  next if cc_index.nil?\n\n#  p [e, ' ', aa_index, n-cc_index]\n  ans += aa_index * (n-cc_index)\nend\n\nputs ans", "label": 0, "name1": "s982439298.java", "name2": "s764468939.rb"}, {"id": 387, "code1": "import java.util.Scanner;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    long a = sc.nextLong();\n    long b = sc.nextLong();\n    long c;\n    long x = sc.nextLong();\n    if(a%x == 0) {\n      c = a / x -1;\n    }else {\n      c = a / x;\n    }\n    System.out.println(b/x-c);\n  }\n}\n", "code2": "a, b, x = gets.split.map(&:to_i)\nputs b / x - (a - 1) / x\n", "label": 1, "name1": "s320140275.java", "name2": "s654797155.rb"}, {"id": 275, "code1": "import java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc= new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint count=0;\n\t\t\tint n=sc.nextInt();\n\t\t\tint x=sc.nextInt();\n\t\t\tif(n==0 && x==0) break;\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=i+1;j<=n;j++){\n\t\t\t\t\tfor(int k=j+1;k<=n;k++){\n\t\t\t\t\t\tif(i+j+k == x) count++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}", "code2": "while(n,x=gets.split.map &:to_i;n>0)\np [*1..n].combination(3).count{|i,j,k|i+j+k==x}\nend", "label": 1, "name1": "s030330226.java", "name2": "s151756888.rb"}, {"id": 731, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tprivate void solve() {\n\t\tScanner io = new Scanner(System.in);\n\t\tint N = io.nextInt();\n\t\tint M = io.nextInt();\n\t\tboolean[] medium = new boolean[N];\n\t\tboolean[] ableToN = new boolean[N];\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint a = io.nextInt()-1;\n\t\t\tint b = io.nextInt()-1;\n\t\t\tif(a==0) medium[b] = true;\n\t\t\tif(b==0) medium[a] = true;\n\t\t\tif(a==N-1) ableToN[b] = true;\n\t\t\tif(b==N-1) ableToN[a] = true;\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(medium[i] && ableToN[i]){\n\t\t\t\tSystem.out.println(\"POSSIBLE\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"IMPOSSIBLE\");\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\n}", "code2": "# ?????????????????????????????????????\u00a7???????????????????????????????\n# @param [Array]   g Edge ?????????????????\u00a7??\u00a8???????????\u00b0??????\n# @param [Integer] s ????\u00a7????????????????\n# @return [Array]  ?????????????????\u00a7???????\u00a8?????????????????\u00b4????????????????\n# g ??????????????????????????\u00a7?????????\n# g_i ?????? i ???????????????????????????????????\u00a8??????????????????????????\u00a8??????????\u00b4?????????????\ndef dijkstra(g, s)\n  def enq(pq, val)\n    pq << val\n    cd = pq.size\n    pr = cd / 2\n    until pr.zero? || (pq[pr - 1] <=> pq[cd - 1]) < 0\n      pq[pr - 1], pq[cd - 1] = pq[cd - 1], pq[pr - 1]\n      cd = pr\n      pr = cd / 2\n    end\n  end\n\n  def deq(pq)\n    rs = pq[0]\n    pq[0] = pq[-1]\n    pq.delete_at(-1)\n    unless pq.empty?\n      pr = 1\n      cd = [pr * 2, pr * 2 + 1].select { |i| pq[i - 1] }.min_by { |i| pq[i - 1] }\n      until cd.nil? || (pq[pr - 1] <=> pq[cd - 1]) < 0\n        pq[pr - 1], pq[cd - 1] = pq[cd - 1], pq[pr - 1]\n        pr = cd\n        cd = [pr * 2, pr * 2 + 1].select { |i| pq[i - 1] }.min_by { |i| pq[i - 1] }\n      end\n    end\n    rs\n  end\n\n  pq = []\n  d = Array.new(g.size) { Float::INFINITY }\n  d[s] = 0\n  enq(pq, [0, s])\n\n  until pq.empty?\n    v_cost, v = deq(pq)\n    next if d[v] < v_cost\n    g[v].each do |e|\n      if d[e.to] > d[v] + e.cost\n        d[e.to] = d[v] + e.cost\n        enq(pq, [d[e.to], e.to])\n      end\n    end\n  end\n\n  d\nend\n\nEdge = Struct.new('Edge', :to, :cost)\n\nv, e, r = gets.split.map(&:to_i)\ng = Array.new(v) { [] }\ne.times do\n  s, t, d = gets.split.map(&:to_i)\n  g[s] << Edge.new(t, d)\nend\n\ndijkstra(g, r).each do |sum|\n  puts (sum == Float::INFINITY ? 'INF' : sum)\nend", "label": 0, "name1": "s464102860.java", "name2": "s587327683.rb"}, {"id": 203, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        CTwoAlpinists solver = new CTwoAlpinists();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CTwoAlpinists {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            long[] t = in.readLongArray(n);\n            long[] a = in.readLongArray(n);\n\n            long[] max = new long[n];\n            long[] actual = new long[n];\n\n            {\n                for (int i = 0; i < n; i++) {\n                    max[i] = Math.min(t[i], a[i]);\n                }\n            }\n\n            {\n                long prev = 0;\n                for (int i = 0; i < n; i++) {\n                    if (t[i] > prev) {\n                        if (t[i] > max[i]) {\n                            out.printLine(0);\n                            return;\n                        }\n                        actual[i] = t[i];\n                        prev = t[i];\n                    }\n                }\n            }\n\n            {\n                long prev = 0;\n                for (int i = n - 1; i >= 0; i--) {\n                    if (a[i] > prev) {\n                        if (a[i] > max[i]) {\n                            out.printLine(0);\n                            return;\n                        }\n                        actual[i] = a[i];\n                        prev = a[i];\n                    }\n                }\n            }\n\n            long ans = 1;\n            for (int i = 0; i < n; i++) {\n                if (actual[i] != 0) continue;\n                ans = (ans * max[i]) % MiscUtils.MOD7;\n            }\n\n            out.printLine(ans);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public long[] readLongArray(int size) {\n            long[] array = new long[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readLong();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long readLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class MiscUtils {\n        public static final int MOD7 = (int) (1e9 + 7);\n\n    }\n}\n\n", "code2": "eval\"N,*T=#{`tr \u0001-! ,`}0\"\nz=1\nN.times{|i|a,b=T[N+i,2]\nz*=[[[a,t=T[i]].min,0,-1[a-t]][s=T[i-1]<=>t],0,(s%3-1)[t-a]][b<=>a]\nz%=10**9+7}\np z", "label": 1, "name1": "s071160485.java", "name2": "s222734626.rb"}, {"id": 233, "code1": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-9;\n\n\tint n;\n\tint start, goal, ttl;\n\tLinkedList<Integer>[] graph;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tn = sc.nextInt();\n\t\tgraph = new LinkedList[n];\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint u = sc.nextInt() - 1;// \u0083\u008b\u0081[\u0083^\u0094\u00d4\u008d\u0086\n\t\t\tint m = sc.nextInt();\n\t\t\tgraph[u] = new LinkedList<Integer>();\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint v = sc.nextInt() - 1;\n\t\t\t\tgraph[u].add(v);\n\t\t\t}\n\t\t}\n\t\tint p = sc.nextInt();\n\t\tfor (int i = 0; i < p; i++) {\n\t\t\tstart = sc.nextInt() - 1;\n\t\t\tgoal = sc.nextInt() - 1;\n\t\t\tttl = sc.nextInt();\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve() {\n\t\tLinkedList<Integer> que = new LinkedList<Integer>();\n\t\tboolean[] visited = new boolean[n];\n\t\tint[] d = new int[n];\n\t\tArrays.fill(d, INF);\n\t\tque.offer(start);\n\t\td[start] = 1;\n\t\tvisited[start] = true;\n\t\tfor (; !que.isEmpty();) {\n\t\t\tint u = que.poll();\n\t\t\tfor (int v : graph[u]) {\n\t\t\t\tif (!visited[v]) {\n\t\t\t\t\tque.offer(v);\n\t\t\t\t\td[v] = d[u] + 1;\n\t\t\t\t\tvisited[v] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[goal] <= ttl) {\n\t\t\tprintln(\"\" + d[goal]);\n\t\t} else {\n\t\t\tprintln(\"NA\");\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s) {\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s) {\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}", "code2": "def g;gets.split.map &:to_i;end\nr=1..n=g[0]\nw=[0]+r.map{[0]+[1e9]*n}\nr.map{f,_,*t=g;t.map{|i|w[f][i]=1}}\nr.map{|k|r.map{|i|r.map{|j|(a=(b=w[i])[k]+w[k][j])<b[j]&&b[j]=a}}}\ng[0].times{s,d,v=g;puts v<(c=w[s][d]+1)?:NA:c}", "label": 1, "name1": "s019260377.java", "name2": "s626153320.rb"}, {"id": 775, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n + 2];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tsc.close();\n\n\t\tint sum = 0;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsum += Math.abs(a[i] - a[i + 1]);\n\t\t}\n\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tSystem.out.println(sum + Math.abs(a[i- 1] - a[i + 1])\n\t\t\t\t\t- Math.abs(a[i] - a[i + 1]) - Math.abs(a[i] - a[i - 1]));\n\t\t}\n\t}\n}\n", "code2": "def find(x, root)\n  return unless @group[x]\n  return true if @group[x].include?(root)\n  @group[x].each do |m|\n    return true if find(m, root)\n  end\n  false\nend\n\nwhile n = gets.to_i\n  break if n == 0\n  root = ''\n  @group = {}\n  n.times do |i|\n    g, m = gets.split(':')\n    root = g if i == 0\n    ms = m[0..-3].split(',')\n    ms.each{ |m| @group[m] ||= []; @group[m] << g }\n  end\n  cnt = 0\n  @group.keys.each do |name|\n    if find(name, root) && !@group.values.flatten.include?(name)\n      cnt += 1\n    end\n  end\n  p cnt\nend", "label": 0, "name1": "s784073174.java", "name2": "s172002341.rb"}, {"id": 659, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n    static class FS {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            return hasNextByte() ? buffer[ptr++] : -1;\n        }\n\n        private boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        private void skipUnprintable() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        }\n\n        public boolean hasNext() {\n            skipUnprintable();\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n    }\n\n    static int[] np;\n    static int n;\n\n    public static void main(String[] args) throws Exception {\n        FS fs = new FS();\n//        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n//        String s = bf.readLine();\n//        int n = Integer.parseInt(s.substring(0, s.indexOf(' ')));//n packages\n//        int k = Integer.parseInt(s.substring(s.indexOf(' '), s.length()));//k trucks\n        n = fs.nextInt();\n        int k = fs.nextInt();\n\n\n        np = new int[n];\n        int max = 0;\n        for (int i = 0; i < n; i++) {\n\n            np[i] = fs.nextInt();\n            max = max < np[i] ? np[i] : max;\n        }\n        int p = 0;\n        int resids = 0;\n\n        int maxInt = 10000 *100000;\n        int minInt = max-1;\n        int mid = (maxInt + minInt) / 2;\n        while (maxInt - minInt > 1) {\n            int v = checkN(mid);\n            if (v > k) minInt = mid;\n            else maxInt = mid;\n\n            mid = (maxInt + minInt) / 2;\n        }\n        System.out.println(maxInt);\n    }\n\n    private static int checkN(int p) {\n        int resids = p;\n        int ink = 1;//\u5f53\u524d\u5df2\u7528\u5361\u8f66\n        for (int i = 0; i < n; i++) {\n            int j = np[i];\n            if (resids >= j) {\n                resids -= j;\n            } else {\n                ink++;\n                resids = p;\n                i--;\n            }\n        }\n        return ink;\n    }\n}\n", "code2": "def judge(s1, s2)\n    if s1.size != s2.size\n        return false\n    end\n    s1.size.times do |i|\n        if s1[i] != ?? && s1[i] != s2[i]\n            return false\n        end\n    end\n    return true\nend\n\ns,t=$<.map(&:chomp)\nans = -1\ns.size.times do |i|\n    if judge(s[i, t.size], t)\n        tmp = String.new(s)\n        tmp[i, t.size] = t\n        s.size.times do |j|\n            if tmp[j] == ??\n                tmp[j] = ?a\n            end\n        end\n        if ans == -1\n            ans = tmp\n        else\n            ans = [ans, tmp].min\n        end\n    end\nend\nputs (ans == -1 ? \"UNRESTORABLE\" : ans)", "label": 0, "name1": "s272482227.java", "name2": "s522869011.rb"}, {"id": 405, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int N = sc.nextInt();\n        int[] a = new int[N];\n        for (int i=0; i<N; i++) {\n            a[i] = sc.nextInt();\n        }\n\n        int[] ans = solve(N, a);\n\n        for (int i=0; i<N; i++) {\n            System.out.println(ans[i]);\n        }\n    }\n\n    private static int[] solve(int N, int[] a) {\n        int[] ans = new int[N];\n        int total = Math.abs(a[0]) + Math.abs(a[N-1]);\n\n        for (int i=0; i<N-1; i++) {\n            total += Math.abs(a[i+1] - a[i]);\n        }\n\n        for (int i=0; i<N; i++) {\n            ans[i] = total;\n\n            if (i == 0) {\n                if (0 <= a[i] && a[i] <= a[i+1]\n                        || a[i+1] <= a[i] && a[i] <= 0) {\n//                    System.err.println(\"ans[\" + i + \"] : skip\");\n                    continue;\n                }\n                ans[i] = total - Math.abs(a[i] - 0) - Math.abs(a[i] - a[i+1]) + Math.abs(a[i+1] - 0);\n//                System.err.println(\"ans[\" + i + \"] = \" + ans[i]);\n            } else if (i == N-1) {\n                if (0 <= a[i] && a[i] <= a[i-1]\n                        || a[i-1] <= a[i] && a[i] <= 0) {\n//                    System.err.println(\"ans[\" + i + \"] : skip\");\n                    continue;\n                }\n\n                ans[i] = total - Math.abs(a[i] - 0) - Math.abs(a[i] - a[i-1]) + Math.abs(a[i-1] - 0);\n//                System.err.println(\"ans[\" + i + \"] = \" + ans[i]);\n            }\n            else if (a[i-1] <= a[i] && a[i] <= a[i+1]\n                    || a[i+1] <= a[i] && a[i] < a[i-1]) {\n//                System.err.println(\"ans[\" + i + \"] : skip\");\n                continue;\n            } else {\n                ans[i] = total - Math.abs(a[i] - a[i-1]) - Math.abs(a[i] - a[i+1]) + Math.abs(a[i+1] - a[i-1]);\n//                System.err.println(\"ans[\" + i + \"] = \" + ans[i]);\n            }\n        }\n\n        return ans;\n    }\n}", "code2": "n=gets.to_i\na=gets.split.map(&:to_i)\na.unshift 0\na.push 0\nsum=a.each_cons(2).map{|x,y|(x-y).abs}.inject(:+)\na.each_cons(3){|x,y,z|puts sum+(x-z).abs-(x-y).abs-(y-z).abs}", "label": 1, "name1": "s919464469.java", "name2": "s365262629.rb"}, {"id": 609, "code1": "import java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tchar[] s = sc.next().toCharArray();\n\t\tStack<Character> st = new Stack<>();\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < s.length; i++) {\n\t\t\tif (s[i] == 'T') {\n\t\t\t\tif (st.isEmpty()) cnt++;\n\t\t\t\telse st.pop();\n\t\t\t} else {\n\t\t\t\tst.push('S');\n\t\t\t}\n\t\t}\n\t\tcnt += st.size();\n\t\tSystem.out.println(cnt);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}", "code2": "# The Secret Number from Aizu Online Judge\n\n# \u6f38\u5316\u5f0f:\n#    S(i, j) = max( S(i-1,j), S(i,j-1) ) D_ij if D_ij \u2208 { 0,1,2,3,4,5,6,7,8,9 }\n#            = \u03c6 otherwise\n\ndef secret_number(w, h, matrix)\n  subsol = Array.new(h+1) { |i| Array.new(w+1) { |j| i*j==0 ? '' : nil } }\n  1.upto h do |i|\n    1.upto w do |j|\n      c = matrix[i-1][j-1]\n      subsol[i][j] = if c =~ /\\d/\n                       [subsol[i-1][j], subsol[i][j-1]].max_by(&:to_i) + c\n                     else\n                       ''\n                     end\n    end\n  end\n  subsol.map { |row| row.max_by(&:to_i) }.max_by(&:to_i).to_i\nend\n\n# ----------------------------------------\nloop do\n  w, h = gets.split.map(&:to_i)\n  break if [w,h] == [0,0]\n\n  matrix = h.times.map { gets.chomp.chars }\n  ans = secret_number(w, h, matrix)\n  puts ans\nend", "label": 0, "name1": "s350666247.java", "name2": "s488110677.rb"}, {"id": 417, "code1": "import java.math.BigInteger;\nimport java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = Integer.parseInt(sc.next());\n\t\tlong m = Long.parseLong(sc.next());\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tm = lcm(m, Long.parseLong(sc.next()));\n\t\tSystem.out.println(m);\n\t}\n\tpublic static long lcm(long m, long n) {\n\t\tBigInteger M = new BigInteger(String.valueOf(m));\n\t\tBigInteger N = new BigInteger(String.valueOf(n));\n\t\tBigInteger G = new BigInteger(String.valueOf(gcd(m, n)));\n\t\treturn M.multiply(N).divide(G).longValue();\n\t}\n\tpublic static long gcd(long m, long n) {\n\t\tif (m < n) {\n\t\t\tlong tem = m;\n\t\t\tm = n;\n\t\t\tn = tem;\n\t\t}\n\t\tlong r = -1;\n\t\twhile (r != 0) {\n\t\t\tr = m % n;\n\t\t\tm = n;\n\t\t\tn = r;\n\t\t}\n\t\treturn m;\n\t}\n}", "code2": "def main()\n  n = gets.chomp.to_i\n  x = []\n  for i in 0..n-1 do\n     x << gets.chomp.to_i\n  end\n  puts x.inject(:lcm)\nend\n\nmain()", "label": 1, "name1": "s725061223.java", "name2": "s027645540.rb"}, {"id": 210, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    void solve() throws IOException {\n    \tint N = ni();\n\n    \tint[] T = new int[N];\n    \tint[] A = new int[N];\n\n    \tfor (int i=0; i<N; i++) {\n\t\t\tT[i] = ni();\n\t\t\tA[i] = ni();\n\t\t}\n\n    \tlong t = T[0];\n    \tlong a = A[0];\n\n    \tfor (int i=1; i<N; i++) {\n    \t\tlong x = (t%T[i]==0)? t/T[i] : (t/T[i] + 1);\n    \t\tlong y = (a%A[i]==0)? a/A[i] : (a/A[i] + 1);\n    \t\tt = T[i] * Math.max(x, y);\n    \t\ta = A[i] * Math.max(x, y);\n    \t}\n\n    \tout.println(t + a);\n    }\n\n    String ns() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine(), \" \");\n        }\n        return tok.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.parseInt(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.parseLong(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.parseDouble(ns());\n    }\n\n    String[] nsa(int n) throws IOException {\n        String[] res = new String[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ns();\n        }\n        return res;\n    }\n\n    int[] nia(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ni();\n        }\n        return res;\n    }\n\n    long[] nla(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nl();\n        }\n        return res;\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        tok = new StringTokenizer(\"\");\n        Main main = new Main();\n        main.solve();\n        out.close();\n    }\n}\n", "code2": "N = gets.to_i\nTs = Array.new(N)\nAs = Array.new(N)\nN.times do |i|\n  Ts[i], As[i] = gets.split.map(&:to_i)\nend\n\ntz = az = 1\nN.times do |i|\n  tk = (tz + Ts[i] - 1) / Ts[i]\n  ak = (az + As[i] - 1) / As[i]\n  k = [tk, ak].max\n  tz = Ts[i] * k\n  az = As[i] * k\nend\n\nputs tz + az\n", "label": 1, "name1": "s760488688.java", "name2": "s973322062.rb"}, {"id": 860, "code1": "import java.io.*;\nimport java.util.*;\n\nclass Main{\n    public static void main(String args[])throws IOException{\n      try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))){\n        //input\n        String[] input = br.readLine().split(\" \");\n        int N = Integer.parseInt(input[0]);\n        int M = Integer.parseInt(input[1]);\n\n        //for algorithm & input\n        boolean[] answer = new boolean[N+1];\n        int[] wrong = new int[N+1];\n      \n        Arrays.fill(answer, false);\n        Arrays.fill(wrong, 0);\n        int pena = 0;\n        int result = 0;\n\n        for(int i = 0; i < M; i++){\n          String[] in = br.readLine().split(\" \");\n          int num = Integer.parseInt(in[0]);\n         \n          if(answer[num] == false){\n            if(in[1].equals(\"AC\")){\n              answer[num] = true;\n              result++;\n              pena += wrong[num];\n            }else{\n              wrong[num] += 1;\n            }\n          }else{\n            continue;\n          }\n        }\n\n        System.out.println(result + \" \" + pena);\n\n      }\n    }\n}\n", "code2": "n=gets.to_i;m=1\nfor i in 2..n+1 do\n    m=m*i\nend\np m+2\nfor i in 2..n+1 do\n    p i\nend", "label": 0, "name1": "s713620418.java", "name2": "s199593134.rb"}, {"id": 506, "code1": "import java.util.*;\n\npublic class Main{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n\n    String[] s = sc.next().split(\"\");\n    int l =  s.length;\n    int count =0;\n    for(int i=0; i<l; i++){\n      if(s[i].equals(\"U\")||s[i].equals(\"D\")){\n        count +=1;\n        continue;\n      }\n\n\n      if(i%2==0){\n        if(s[i].equals(\"R\")){\n          count += 1;\n        }\n      }else{\n        if(s[i].equals(\"L\")){\n          count += 1;\n        }\n      }\n    }\n    if(count == l){\n      System.out.println(\"Yes\");\n    }else{\n      System.out.println(\"No\");\n    }\n\n\n\n\n  }\n}", "code2": "h,w = gets.chomp.split.map(&:to_i)\nif h == 1 || w == 1\n  ans = 1\nelse\n  ans = ((w/2 + w%2) * (h/2 + h%2)) + ((w/2) * (h/2))\nend\nputs ans", "label": 0, "name1": "s855266906.java", "name2": "s041871374.rb"}, {"id": 248, "code1": "import java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.util.Scanner;\n\npublic class Main{\n\tstatic Scanner sc;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t//InputStream in = new FileInputStream(\"src/input.txt\");\n\t\tInputStream in = System.in;\n\t\t//PrintStream out = new PrintStream(\"src/output.txt\");\n\n\t\t//System.setOut(out);\n\n\t\tsc = new Scanner(in);\n\n\t\tint N = sc.nextInt();\n\t\tint[] a = new int[N];\n\t\tint answer = 0;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(a[a[i]-1] == i+1){\n\t\t\t\tanswer++;\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(answer/2);\n\n\t\t//out.close();\n\t}\n}", "code2": "n = gets.to_i\na = gets.split.map(&:to_i)\n\np n.times.map{|i| (i+1 == a[a[i]-1])? 1:0}.inject(:+)/2\n", "label": 1, "name1": "s219137444.java", "name2": "s544447985.rb"}, {"id": 874, "code1": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int a = Integer.parseInt(sc.next());\n        int b = Integer.parseInt(sc.next());\n        int c = Integer.parseInt(sc.next());\n        int x = Integer.parseInt(sc.next());\n        int y = Integer.parseInt(sc.next());\n\n        long ans = Long.MAX_VALUE;\n\n        for (int i = 0; i <= Math.max(x*2, y*2); i+=2) {\n          long tmp = c*i + a*(Math.max(0,x-i/2)) + b*(Math.max(0,y-i/2));\n          ans = Math.min(tmp, ans);   \n        }\n\n        System.out.println(ans);\n        sc.close();\n    }\n}", "code2": "a,b = gets.split.map(&:to_s)\nputs \"H\" if a == b\nputs \"D\" if a != b", "label": 0, "name1": "s740047463.java", "name2": "s017635501.rb"}, {"id": 216, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[] fact = new int[9];\n\n\n\tpublic static void main(String[] args) {\n\t\tfact[1] = 1;\n\t\tfor(int i = 2; i <= 8; i++)\n\t\t\tfact[i] = fact[i-1] * i;\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] p = new int[n];\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tp[i] = sc.nextInt();\n\n\t\tint[] q = new int[n];\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tq[i] = sc.nextInt();\n\n\t\tint ans = Math.abs(getPosi(p) - getPosi(q));\n\t\tSystem.out.println(ans);\n        return;\n    }\n\n\tstatic private int getPosi(int[] x) {\n\n\t\t\tint l = x.length;\n\t\t\tint p = 1;\n\n\t\t\tfor(int i = 0; i < l; i++) {\n\t\t\t\tp += fact[l-i-1] * (x[i]-1);\n\t\t\t\tfor(int j = i+1; j < l; j++) {\n\t\t\t\t\tif(x[j] > x[i])\n\t\t\t\t\t\tx[j]--;\n\t\t\t\t}\n\t\t\t}\n\t\treturn p;\n\n\t}\n\n}\n\n", "code2": "# matrix\u306e\u57fa\u672c\u64cd\u4f5c\n\ndef same_el(array_)\n  if array_.kind_of?(Array)\n    output = []\n    for i in  0..(array_.count-1)\n      output.push(array_[i])\n    end\n  end\n  return output\nend\n\n# ---------------------------------------------\n\ndef replace(n)\n\n  sgn=[]\n  remain=[]\n  output=[] #n!\u500b\u306e\u8981\u7d20\u3092\u6301\u3064\u914d\u5217\u3092\u8fd4\u3059\n  for i in 0..n\n    sgn << i\n    remain << i\n  end\n  output << []\n  for i in 0..n\n    output[0] << i\n  end\n\n  while true\n    remain_act = same_el(remain)\n    remain_act.delete(0)\n    for i in 1..n-1\n      judge_order = true\n      for j in i+1..n-1\n        sgn[j]<sgn[j+1] && judge_order = false\n      end\n      judge_order && break\n      remain_act.delete(sgn[i])\n    end\n    singular = i\n    remain_act.sort!\n    for i in 0..n-(singular-2)\n      if sgn[singular] == remain_act[i]\n        sgn[singular] = remain_act[i+1]\n        break\n      end\n    end\n    remain_act.delete(sgn[singular])\n    for i in singular+1..n\n      sgn[i] = remain_act[i-(singular+1)]\n    end\n    inp =same_el(sgn)\n    output << inp\n    lastmat=true\n    for i in 1..n\n      sgn[i] != n+1-i && lastmat=false\n    end\n    lastmat && break\n  end\n\n  for i in 0..output.count-1\n    output[i].delete(0)\n  end\n  output\nend\n\n# ---------------------------------------------\n\ndef signal(replaces)\n  output = Array.new\n  index = Array.new\n\n  replace.size.times do |i|\n    for j in 0..replaces.size-1\n      index[j] = j+1\n    end\n    i_op = i.clone\n    while true\n      j = 0\n      nimotu = index[0]\n      sgn_part = -1\n      while true\n        if i_op[j] == nimotu\n\n        else\n        end\n      end\n\n    end\n    output << sgn\n  end\nend\n\nN=gets.to_i\nar=replace(N)\nps=gets.split.map(&:to_i)\nqs=gets.split.map(&:to_i)\np (ar.index(ps)-ar.index(qs)).abs", "label": 1, "name1": "s530732207.java", "name2": "s189807644.rb"}, {"id": 902, "code1": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class Main {\n\n\tprivate static final String NO = \"No\";\n\tprivate static final String YES = \"Yes\";\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\tprivate List<Integer>[] g;\n\n\tprivate static final long MOD = 998244353;\n\tprivate static final int INF = Integer.MAX_VALUE;\n\n\tvoid solve() {\n\t\tint T = 1;\n\t\tfor (int i = 0; i < T; i++)\n\t\t\tsolve(i);\n\t}\n\n\tvoid solve(int T) {\n\t\tint n = ni();\n\t\twhile (!isPrime(n))\n\t\t\tn++;\n\t\tout.println(n);\n\t}\n\n\tprivate boolean isPrime(int n) {\n\t\tfor (int i = 2; i <= Math.sqrt(n); i++)\n\t\t\tif (n % i == 0)\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t// a^b\n\tlong power(long a, long b) {\n\t\tlong x = 1, y = a;\n\t\twhile (b > 0) {\n\t\t\tif (b % 2 != 0) {\n\t\t\t\tx = (x * y) % MOD;\n\t\t\t}\n\t\t\ty = (y * y) % MOD;\n\t\t\tb /= 2;\n\t\t}\n\t\treturn x % MOD;\n\t}\n\n\tprivate long gcd(long a, long b) {\n\t\twhile (a != 0) {\n\t\t\tlong tmp = b % a;\n\t\t\tb = a;\n\t\t\ta = tmp;\n\t\t}\n\t\treturn b;\n\t}\n\n\tvoid run() throws Exception {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\tif (!INPUT.isEmpty())\n\t\t\ttr(System.currentTimeMillis() - s + \"ms\");\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\tprivate boolean vis[];\n\n\tprivate int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != '\n\t\t\t\t\t\t\t\t\t// ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n) {\n\t\t\tif (!(isSpaceChar(b)))\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate List<Integer> na2(int n) {\n\t\tList<Integer> a = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta.add(ni());\n\t\treturn a;\n\t}\n\n\tprivate int[][] na(int n, int m) {\n\t\tint[][] a = new int[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = na(m);\n\t\treturn a;\n\t}\n\n\tprivate int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate long[] nl(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate long[][] nl(int n, int m) {\n\t\tlong[][] a = new long[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nl(m);\n\t\treturn a;\n\t}\n\n\tprivate long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}", "code2": "#input of int(split by space)\ndef get_i()\n  return gets.chomp.split(\" \").map(&:to_i)\nend\n#input of float(split by space)\ndef get_f()\n  return gets.chomp.split(\" \").map(&:to_f)\nend\n#input of string(split by space)\ndef get()\n  return gets.chomp.split(\" \")\nend\n#input of string(split per one character)\ndef get_nsp()\n  return gets.chomp.split(\"\")\nend\n#yes or no decision\ndef yn_judge(bool,y=\"Yes\",n=\"No\")\n  return bool ? y : n \nend\n#create of array\ndef array(size1,init=nil,size2=-1)\n  if size2==-1\n      return Array.new(size1){init}\n  else\n      return Array.new(size2){Array.new(size1){init}}\n  end\nend\n\ndef max(a,b)\n    return a>b ? a : b\nend\n\ndef min(a,b)\n    return a>b ? b : a\nend\n\nINF=Float::INFINITY\n\nH,W=get_i\nkind=Hash.new(0)\nH.times do|i|\n    get_nsp.each do|a|\n        kind[a]+=1\n    end\nend\n\nif W.even? or H.even?\n  kind.each do|k,v|\n      if kind[k].odd?\n          puts \"No\"\n          exit\n      end\n      kind[k]/=2\n  end\n  cnt=kind.count{|x| x[1].odd?}\n  if W.even? and H.even?\n    if cnt.zero?\n        puts \"Yes\"\n    else\n        puts \"No\"\n    end\n  else\n      even=(W.even? ? W : H)\n      if cnt<=even/2\n          puts \"Yes\"\n      else\n          puts \"No\"\n      end\n  end\nelse\n    g={}\n    g[1]=0\n    g[2]=0\n    g[4]=0\n    kind.each do|k,v|\n      if v>=4\n          g[4]+=v/4\n          v%=4\n      end\n      if v>=2\n          g[2]+=1\n          v%=2\n      end\n      if v==1\n          g[1]+=1\n      end\n    end\n    if g[1]==1 and g[4]>=(H/2)*(W/2) and (g[4]-(H/2)*(W/2))*2+g[2]>=H/2+W/2\n        puts \"Yes\"\n    else\n        puts \"No\"\n    end\nend", "label": 0, "name1": "s541097399.java", "name2": "s908373380.rb"}, {"id": 113, "code1": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n    \tScanner sc = new Scanner(System.in);\n      \tint A,B,C;\n      \tA = sc.nextInt();\n      \tB = sc.nextInt();\n      \tC = sc.nextInt();\n      \tif ((A < C && C < B) || (B < C && C < A)) {\n            \tSystem.out.print(\"Yes\");\n        }  else {\n        \tSystem.out.print(\"No\");\n        }   \n    }\n}", "code2": "a, b, c = gets.chomp.split.map(&:to_i)\nmsg = (a < b && a < c && c < b) || (b < a && b < c && c < a) ? \"Yes\" : \"No\"\nputs msg", "label": 1, "name1": "s403728510.java", "name2": "s427997233.rb"}, {"id": 574, "code1": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        int c = sc.nextInt();\n\n        int min = Math.min(a, b);\n        int max = Math.max(a, b);\n        \n        boolean ans = false;\n        if (min < c && c < max)\n            ans = true;\n        System.out.println(ans ? \"Yes\" : \"No\");\n    }\n}", "code2": "n, k = gets.split.map(&:to_i)\na = gets.split.map(&:to_i)\n\ndp = Array.new(k+1) {[nil, nil]}\n\n(k+1).times do |i|\n    2.times do |player|\n        a.each do |e|\n            if i < e\n                dp[i][player] = player ^ 1\n                break\n            end\n\n            if dp[i-e][player ^ 1] == player\n                dp[i][player] = player\n                break\n            end\n        end or next\n        dp[i][player] = player ^ 1\n    end\nend\n\nputs dp[k][0] == 0 ? \"First\" : \"Second\"", "label": 0, "name1": "s912321420.java", "name2": "s522658822.rb"}, {"id": 396, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String args[]){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tInteger[] num = new Integer[n];\n\t\tStringBuilder s = new StringBuilder(\"\");\n\t\tfor(int i=0;i<n;i++){\n\t\t\tnum[i] = scan.nextInt();\n\t\t}\n\t\tArrays.sort(num);\n\t\t\n\t\ts.append(num[0]);\n\t\tfor(int i=1;i<num.length;i++){\n\t\t\ts.append(\" \"+num[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(s);\n\t}\n}", "code2": "class Array\n  def merge_sort\n    return self if length <= 1\n    a, b = half.map(&:merge_sort)\n    merge(a, b)\n  end\n\n  def half\n    n = (length/2.0).floor\n    return self[0...n], self[n..(length-1)]\n  end\n\n  private\n\n  def merge(a, b)\n    result = []\n    while a.size > 0 || b.size > 0\n      result << if a.empty?\n                  b.shift\n                elsif b.empty?\n                  a.shift\n                elsif a.first < b.first\n                  a.shift\n                else\n                  b.shift\n                end\n    end\n    result\n  end\nend\n\nwhile n = gets.to_i\n  break if n == 0\n  puts gets.split(' ').map(&:to_i).merge_sort.join(' ')\nend", "label": 1, "name1": "s177932526.java", "name2": "s469802588.rb"}, {"id": 497, "code1": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tstatic final long mod = (long) 1e9 + 7;\n\tstatic final int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };\n\tstatic final int[] dx8 = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\tstatic final int inf = Integer.MAX_VALUE / 3;\n\tstatic final long linf = Long.MAX_VALUE / 3;\n\tstatic final double dinf = Double.MAX_VALUE / 3;\n\tstatic final double eps = 1e-10;\n\tstatic final double pi = Math.PI;\n\tstatic StringBuilder sb = new StringBuilder();\n\n\tstatic void solve() {\n\t\tint n = ni();\n\t\tchar s[] = ns(n);\n\t\t//\u5de6\u304b\u3089W\u3092\u5411\u3044\u3066\u308b\u4eba\u3001\u53f3\u304b\u3089E\u3092\u5411\u3044\u3066\u308b\u4eba\u3092\u6570\u3048\u308b\n\t\tint suml[] = new int[n+1];\n\t\tint sumr[] = new int[n+1];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tsuml[i+1] = suml[i] + (s[i]=='W'?1:0);\n\t\t\tsumr[n-i-1] = sumr[n-i] + (s[n-1-i]=='E'?1:0);\n\t\t}\n\t\t\n\t\tint ans = inf;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint t = suml[i]+sumr[i+1];\n\t\t\tans = min(ans, t);\n\t\t}\n\t\tout.println(ans);\n\t\t\n\t}\n\n\t//libraries\n\tstatic void reverse(int ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tint t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(long ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tlong t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(double ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tdouble t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(char ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tchar t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic String getReverse(String s) {\n\t\tchar c[] = s.toCharArray();\n\t\treverse(c);\n\t\ts = String.valueOf(c);\n\t\treturn s;\n\t}\n\n\tstatic <T> void reverse(List<T> ls) {\n\t\tint sz = ls.size();\n\t\tfor (int i = 0; i < sz / 2; i++) {\n\t\t\tT t = ls.get(i);\n\t\t\tls.set(i, ls.get(sz - 1 - i));\n\t\t\tls.set(sz - 1 - i, t);\n\t\t}\n\t}\n\n\tstatic void sbnl() {//StringBuilder\u306b\u6539\u884c\u6587\u5b57\u3092append\u3059\u308b\n\t\tsb.append(\"\\n\");\n\t}\n\n\tstatic int lowerBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int lowerBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int lowerBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic <T> int lowerBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) >= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) >= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) >= 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int upperBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) > 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) > 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) > 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int rupperBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) < 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) < 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) < 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int rlowerBound(List<T> ls, T x) {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) <= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) <= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) <= 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic int[] concat(int x, int arr[]) {\n\t\tint ret[] = new int[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 1, ret.length - 1);\n\t\tret[0] = x;\n\t\treturn ret;\n\t}\n\n\tstatic int[] concat(int arr[], int x) {\n\t\tint ret[] = new int[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 0, ret.length - 1);\n\t\tret[ret.length - 1] = x;\n\t\treturn ret;\n\t}\n\n\tstatic long[] concat(long x, long arr[]) {\n\t\tlong ret[] = new long[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 1, ret.length - 1);\n\t\tret[0] = x;\n\t\treturn ret;\n\t}\n\n\tstatic long[] concat(long arr[], long x) {\n\t\tlong ret[] = new long[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 0, ret.length - 1);\n\t\tret[ret.length - 1] = x;\n\t\treturn ret;\n\t}\n\n\tstatic int max(int x, int y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic int min(int x, int y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic int max(int x, int y, int z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic int min(int x, int y, int z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic long max(long x, long y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic long min(long x, long y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic long max(long x, long y, long z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic long min(long x, long y, long z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic double max(double x, double y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic double min(double x, double y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic double max(double x, double y, double z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic double min(double x, double y, double z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic void sort(int[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void sort(long[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void sort(double[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void rsort(int[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tint tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void rsort(long[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tlong tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void rsort(double[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tdouble tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void fill(int arr[], int x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(long arr[], long x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(boolean arr[], boolean x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(double arr[], double x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(int arr[][], int x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(long arr[][], long x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(double arr[][], double x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(boolean arr[][], boolean x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\t//MOD culc\n\tstatic long plus(long x, long y) {\n\t\tlong res = (x + y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long sub(long x, long y) {\n\t\tlong res = (x - y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long mul(long x, long y) {\n\t\tlong res = (x * y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long div(long x, long y) {\n\t\tlong res = x * pow(y, mod - 2) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long pow(long x, long y) {\n\t\tif (y < 0)\n\t\t\treturn 0;\n\t\tif (y == 0)\n\t\t\treturn 1;\n\t\tif (y % 2 == 1)\n\t\t\treturn (x * pow(x, y - 1)) % mod;\n\t\tlong root = pow(x, y / 2);\n\t\treturn root * root % mod;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\t//input\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static long[] nla(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n}\n", "code2": "n = gets.to_i\nstr = gets.chomp\n\ndp = Array.new(n, 0)\n\nacc_w = 0\nacc_e = 0\n\n1.upto(n - 1) do |i|\n  acc_w += 1 if str[i - 1] == \"W\"\n  dp[i] += acc_w\n  acc_e += 1 if str[n - i] == \"E\"\n  dp[n - i - 1] += acc_e\nend\n\nputs dp.min", "label": 1, "name1": "s594845311.java", "name2": "s400591939.rb"}, {"id": 412, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n + 2];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tsc.close();\n\n\t\tint sum = 0;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsum += Math.abs(a[i] - a[i + 1]);\n\t\t}\n\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tSystem.out.println(sum + Math.abs(a[i- 1] - a[i + 1])\n\t\t\t\t\t- Math.abs(a[i] - a[i + 1]) - Math.abs(a[i] - a[i - 1]));\n\t\t}\n\t}\n}\n", "code2": "n = gets.to_i\nnum = gets.chomp.split.map(&:to_i)\nnum.unshift(0)\nnum.push(0)\n#num\u306e\u9577\u3055\u306fn+2\u3060\u3088\nsum = 0\n(n+1).times do |i|\n  sum += (num[i+1]-num[i]).abs\nend\nfor i in 1..n\n  puts sum-(num[i]-num[i-1]).abs-(num[i+1]-num[i]).abs+(num[i+1]-num[i-1]).abs\nend", "label": 1, "name1": "s784073174.java", "name2": "s132287654.rb"}, {"id": 692, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint N = scan.nextInt();\n\t\tint M = scan.nextInt();\n\n\t\tint[] X = new int[M];\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tX[i] = scan.nextInt();\n\t\t}\n\n\t\tscan.close();\n\t\t\n\t\tif(M <= N) {\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tArrays.sort(X);\n\t\t\n\t\tint distance[] = new int[M-1];\n\t\tfor(int i=0; i<M-1; i++) {\n\t\t\tdistance[i] = X[i+1] - X[i];\n\t\t}\n\t\t\n\t\tArrays.sort(distance);\n\t\t\n\t\tint sum = 0;\n\t\tfor(int i=0; i<(M-N); i++) {\n\t\t\tsum+=distance[i];\n\t\t}\n\t\tSystem.out.println(sum);\n\n\n\t}\n\n}", "code2": "class UnionFind\n  def initialize(n)\n    @size = Array.new(n, 1)\n    @rank = Array.new(n, 0)\n    @parent = []\n\n    (0..n).each do |i|\n      @parent[i] = i\n    end\n  end\n\n  def find(x)\n    if @parent[x] == x\n      x\n    else\n      @parent[x] = find(@parent[x])\n    end\n  end\n\n  def unite(x, y)\n    x = find(x)\n    y = find(y)\n    return if x == y\n\n    if @rank[x] < @rank[y]\n      @parent[x] = y\n      @size[y] += @size[x]\n    else\n      @parent[y] = x\n      @size[x] += @size[y]\n\n      @rank[x] += 1 if @rank[x] == @rank[y]\n    end\n  end\n\n  def same?(x, y)\n    find(x) == find(y)\n  end\n\n  def size(x)\n    @size[find(x)]\n  end\nend\n\nN, M = gets.split.map(&:to_i)\nuf = UnionFind.new(N + 1)\nM.times do\n  a, b = gets.split.map(&:to_i)\n\n  uf.unite(a, b)\nend\n\nputs (1..N).map { |x| uf.find(x) }.uniq.size - 1\n", "label": 0, "name1": "s564605710.java", "name2": "s192407245.rb"}, {"id": 162, "code1": "import java.util.Scanner;\nimport java.util.Stack;\n\nclass Main{\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tString str=sc.next();\n\t\t\tStack<Integer> st=new Stack<Integer>();\n\t\t\tfor(int i=0;i<str.length();i++){\n\t\t\t\tif(st.isEmpty() || st.peek()==1 || str.charAt(i)=='S') st.add(str.charAt(i)=='S' ? 0 : 1);\n\t\t\t\telse st.pop();\n\t\t\t}\n\t\t\tSystem.out.println(st.size());\n\t\t}\n\t}\n}", "code2": "X = gets.chomp\n\np 2*X.each_char.inject(0){|acc, c|\n\t[acc + (c.ord&2) - 1, 0].max\n}\n", "label": 1, "name1": "s831441158.java", "name2": "s636939727.rb"}, {"id": 51, "code1": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt(), result = 0, combo = 0, color = 0;\n        for (int i = 0; i < n; i++) {\n            int j = scanner.nextInt();\n            combo++;\n\n            if (j != color) {\n                result += combo / 2;\n                combo = 0;\n                color = j;\n            }\n        }\n        System.out.println(result + ++combo / 2);\n    }\n}", "code2": "n=gets.to_i\ns=gets.split.map(&:to_i)\na=0\nc=1\n(n-1).times do |i|\n  if s[i+1]==s[i]\n    c+=1\n  else\n    a+=c/2\n    c=1\n  end\nend\np a+c/2", "label": 1, "name1": "s379654146.java", "name2": "s006140136.rb"}, {"id": 535, "code1": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt(), result = 0, combo = 0, color = 0;\n        for (int i = 0; i < n; i++) {\n            int j = scanner.nextInt();\n            combo++;\n\n            if (j != color) {\n                result += combo / 2;\n                combo = 0;\n                color = j;\n            }\n        }\n        System.out.println(result + ++combo / 2);\n    }\n}", "code2": "while line = gets\n  n = line.chomp.to_i\n  break if n == 0\n\n  answer_p = 0\n  answer_d = -Float::INFINITY\n  n.times do\n    p, d1, d2 = gets.chomp.split.map(&:to_i)\n    d = d1 + d2\n    if answer_d < d\n      answer_p = p\n      answer_d = d\n    end\n  end\n\n  puts \"#{answer_p} #{answer_d}\"\nend", "label": 0, "name1": "s379654146.java", "name2": "s402976256.rb"}, {"id": 626, "code1": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\n\nimport static java.util.Comparator.reverseOrder;\n\npublic class Main {\n\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n\n        List<Long> inputList = new ArrayList<Long>();\n        for(int i = 0; i < n ;i++) {\n            inputList.add(sc.nextLong());\n        }\n\n        /*\n        List<Integer> sortedList = inputList.stream().sorted(reverseOrder()).collect(Collectors.toList());\n        for(int a: sortedList) {\n            System.out.println(a);\n        }\n        */\n        List<Long> sortedList = inputList.stream().sorted(reverseOrder()).collect(Collectors.toList());\n        long result = sortedList.get(0);\n        int index = 1;\n        int count = 0;\n        for (int i = 0; i < n - 2 ; i++) {\n            result += sortedList.get(index);\n            count = count + 1;\n            if (count == 2) {\n                count = 0;\n                index = index + 1;\n            }\n        }\n        System.out.println(result);\n    }\n}", "code2": "eval\"N,*T=#{`tr \u0001-! ,`}0\"\nz=1\nN.times{|i|a,b=T[N+i,2]\nz=z*[[[a,t=T[i]].min,0,-1[a-t]][s=T[i-1]<=>t],0,(s%3-1)[t-a]][b<=>a]%(10**9+7)}\np z", "label": 0, "name1": "s542407178.java", "name2": "s466517342.rb"}, {"id": 288, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint N = scan.nextInt();\n\t\tint M = scan.nextInt();\n\n\t\tint[] X = new int[M];\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tX[i] = scan.nextInt();\n\t\t}\n\n\t\tscan.close();\n\t\t\n\t\tif(M <= N) {\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tArrays.sort(X);\n\t\t\n\t\tint distance[] = new int[M-1];\n\t\tfor(int i=0; i<M-1; i++) {\n\t\t\tdistance[i] = X[i+1] - X[i];\n\t\t}\n\t\t\n\t\tArrays.sort(distance);\n\t\t\n\t\tint sum = 0;\n\t\tfor(int i=0; i<(M-N); i++) {\n\t\t\tsum+=distance[i];\n\t\t}\n\t\tSystem.out.println(sum);\n\n\n\t}\n\n}", "code2": "n,m = gets.chomp.split(' ').map(&:to_i)\nx = gets.chomp.split(' ').map(&:to_i).sort!\nif x.size == 1 || n >= m\n    puts '0'\nelse\n    diff = Array.new((m-1),0)\n    (m-1).times do |i|\n        diff[i] = x[i+1]-x[i]\n    end\n    puts diff.sort.slice(0,m-n).inject(:+)\nend", "label": 1, "name1": "s564605710.java", "name2": "s394989460.rb"}, {"id": 953, "code1": "import java.util.*;\npublic class Main{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    String N = sc.next();\n    int count = 0;\n    for(int i = 0; i < N.length(); i++){\n      if(N.charAt(i) == '2') count++;\n    }\n    System.out.println(count);\n  }\n}", "code2": "eval\"N,C,*D=\"+`dd`.split*?,\nr=*0...C\ns,t,u=(0...N*N).group_by{|i|(i/N+i%N)%3}.map{|_,v|r.map{|t|s=0;v.map{|f|s+=D[~-D[~f]*C+t]};s}}\np N<2?0:r.permutation(3).map{|x,y,z|s[x]+t[y]+u[z]}.min", "label": 0, "name1": "s986275992.java", "name2": "s260355932.rb"}, {"id": 679, "code1": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Random;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        try (BufferedInputStream in = new BufferedInputStream(System.in);\n             PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out))) {\n\n            _Scanner sc = new _Scanner(in);\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            int c = sc.nextInt();\n            int k = sc.nextInt();\n\n            if (a + b >= k) {\n                out.println(Math.min(k, a));\n            } else {\n                out.println(a - (k - a - b));\n            }\n        }\n    }\n\n    private static void reverse(int[] vs) {\n        for (int i = 0; i < vs.length / 2; i++) {\n            swap(vs, i, vs.length - 1 - i);\n        }\n    }\n\n    static class _Scanner {\n        InputStream is;\n        _Scanner(InputStream is) {\n            this.is = is;\n        }\n        byte[] bb = new byte[1 << 15];\n        int k, l;\n        byte getc() {\n            try {\n                if (k >= l) {\n                    k = 0;\n                    l = is.read(bb);\n                    if (l < 0) return -1;\n                }\n                return bb[k++];\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        byte skip() {\n            byte b;\n            while ((b = getc()) <= 32)\n                ;\n            return b;\n        }\n\n        int nextInt() {\n            int n = 0;\n            int sig = 1;\n            for (byte b = skip(); b > 32; b = getc()) {\n                if (b == '-') {\n                    sig = -1;\n                } else {\n                    n = n * 10 + b - '0';\n                }\n            }\n            return sig * n;\n        }\n\n        long nextLong() {\n            long n = 0;\n            long sig = 1;\n            for (byte b = skip(); b > 32; b = getc()) {\n                if (b == '-') {\n                    sig = -1;\n                } else {\n                    n = n * 10 + b - '0';\n                }\n            }\n            return sig * n;\n        }\n\n        public String next() {\n            StringBuilder sb = new StringBuilder();\n            for (int b = skip(); b > 32; b = getc()) {\n                sb.append(((char) b));\n            }\n            return sb.toString();\n        }\n    }\n\n    private static void shuffle(int[] ar) {\n        Random rnd = new Random();\n        for (int i = 0; i < ar.length; i++) {\n            int j = i + rnd.nextInt(ar.length - i);\n            swap(ar, i, j);\n        }\n    }\n\n    private static void shuffle(Object[] ar) {\n        Random rnd = new Random();\n        for (int i = 0; i < ar.length; i++) {\n            int j = i + rnd.nextInt(ar.length - i);\n            swap(ar, i, j);\n        }\n    }\n\n    private static void swap(int[] ar, int i, int j) {\n        int t = ar[i];\n        ar[i] = ar[j];\n        ar[j] = t;\n    }\n\n    private static void swap(Object[] ar, int i, int j) {\n        Object t = ar[i];\n        ar[i] = ar[j];\n        ar[j] = t;\n    }\n\n\n}\n", "code2": "a = Array.new(3)\nb = Array.new(3)\n\ncounts = Hash.new(0)\n3.times do|i|\n  a, b = gets.split.map(&:to_i)\n  counts[a.to_s] += 1\n  counts[b.to_s] += 1\nend\n\nputs counts.sort { |(k1, v1), (k2, v2)| v1<=>v2 }.map { |k, v| v } == [1, 1, 2, 2] ? 'YES' : 'NO'\n", "label": 0, "name1": "s673107340.java", "name2": "s056579310.rb"}, {"id": 753, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\n\n/*\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n            pass System Test!\n*/\n\npublic class Main {\n  private static class Task {\n    void solve(FastScanner in, PrintWriter out) {\n      int H = in.nextInt();\n      int W = in.nextInt();\n      char[][] map = new char[H][];\n      for (int i = 0; i < H; i++) {\n        map[i] = in.next().toCharArray();\n      }\n\n      boolean[][] red = new boolean[H][W];\n      boolean[][] blue = new boolean[H][W];\n      for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n          if (j == 0) red[i][j] = true;\n          else if (j == W - 1) blue[i][j] = true;\n          else if (i % 2 == 0) red[i][j] = true;\n          else blue[i][j] = true;\n        }\n      }\n\n      for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n          if (map[i][j] == '.') continue;\n          blue[i][j] = true;\n          red[i][j] = true;\n        }\n      }\n\n      for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n          out.print(red[i][j] ? \"#\" : \".\");\n        }\n        out.println();\n      }\n      out.println();\n      for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n          out.print(blue[i][j] ? \"#\" : \".\");\n        }\n        out.println();\n      }\n    }\n  }\n\n  /**\n   * \u3053\u3053\u304b\u3089\u4e0b\u306f\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u3067\u3059\u3002\n   */\n  public static void main(String[] args) {\n    OutputStream outputStream = System.out;\n    FastScanner in = new FastScanner();\n    PrintWriter out = new PrintWriter(outputStream);\n    Task solver = new Task();\n    solver.solve(in, out);\n    out.close();\n  }\n  private static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n      int[] array = new int[n];\n      for (int i = 0; i < n; i++) array[i] = nextInt();\n      return array;\n    }\n\n    public long[] nextLongArray(int n) {\n      long[] array = new long[n];\n      for (int i = 0; i < n; i++) array[i] = nextLong();\n      return array;\n    }\n\n    public String[] nextStringArray(int n) {\n      String[] array = new String[n];\n      for (int i = 0; i < n; i++) array[i] = next();\n      return array;\n    }\n\n    public char[][] nextCharMap(int n) {\n      char[][] array = new char[n][];\n      for (int i = 0; i < n; i++) array[i] = next().toCharArray();\n      return array;\n    }\n  }\n}\n", "code2": "a, b, x = gets.split.map(&:to_i)\nputs b / x - (a - 1) / x\n", "label": 0, "name1": "s871155444.java", "name2": "s654797155.rb"}, {"id": 423, "code1": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tString s;\n\t\t\tString[][] a = new String[n][];\n\t\t\tint p;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\ts = sc.next().replaceAll(\":\", \" \").replaceAll(\",\", \" \");\n\t\t\t\ta[i] = s.split(\" \");\n\t\t\t\tp = a[i].length-1;\n\t\t\t\ta[i][p] = a[i][p].substring(0,a[i][p].length()-1);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<String> list = new ArrayList<String>();\n\t\t\tfor(int i=1;i<a[0].length;i++) list.add(a[0][i]);\n\t\t\t\n\t\t\tboolean flag;\n\t\t\twhile(true){\n\t\t\t\tflag = false;\n\t\t\t\tfor(int i=1;i<n;i++){\n\t\t\t\t\tif(list.contains(a[i][0])==true){\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tlist.remove(list.indexOf(a[i][0]));\n\t\t\t\t\t\tfor(int j=1;j<a[i].length;j++){\n\t\t\t\t\t\t\tif(list.contains(a[i][j])==false) list.add(a[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag==false) break;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(list.size());\n\t\t}\t\n\t}\t\n}", "code2": "def fold arr\n    arr2 = []\n    arr.each{|name|\n        if @h.key? name\n            @h[name] = fold(@h[name])\n            @h[name].each{|name2| arr2 << name2}\n        else\n            arr2 << name\n        end\n    }\n    arr2.uniq!\n    arr2\nend\n\nwhile true\n    n = gets.to_i\n    break if n == 0\n    @h = Hash.new{|h, k| h[k] = []}\n    firstgroup = nil\n    n.times{|i|\n        group, members = (gets.chomp)[0..-2].split(\":\")\n        members = members.split(\",\")\n        @h[group] = members\n        firstgroup = group if i == 0\n    }\n    puts fold(@h[firstgroup]).length\nend\n", "label": 1, "name1": "s663814901.java", "name2": "s533876771.rb"}, {"id": 476, "code1": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\n\t\tint n = sc.nextInt();\n\n\t\tint a[] = new int[n];\n\t\tint b[] = new int[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tb[i] = sc.nextInt();\n\t\t}\n\n\t\tlong ba = 0;\n\t\tlong ab = 0;\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (b[i] > a[i]) {\n\t\t\t\tba += (b[i] - a[i]) / 2;\n\t\t\t} else {\n\t\t\t\tab += (a[i] - b[i]);\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tSystem.out.println(ab <= ba ? \"Yes\" : \"No\");\n\t}\n}\n", "code2": "#input of int(split by space)\ndef get_i()\n  return gets.chomp.split(\" \").map(&:to_i)\nend\n#input of float(split by space)\ndef get_f()\n  return gets.chomp.split(\" \").map(&:to_f)\nend\n#input of string(split by space)\ndef get()\n  return gets.chomp.split(\" \")\nend\n#input of string(split per one character)\ndef get_nsp()\n  return gets.chomp.split(\"\")\nend\n#yes or no decision\ndef yn_judge(bool,y=\"Yes\",n=\"No\")\n  return bool ? y : n \nend\n#create of array\ndef array(size1,init=nil,size2=-1)\n  if size2==-1\n      return Array.new(size1){init}\n  else\n      return Array.new(size2){Array.new(size1){init}}\n  end\nend\n\ndef max(a,b)\n    return a>b ? a : b\nend\n\ndef min(a,b)\n    return a>b ? b : a\nend\n\nINF=Float::INFINITY\n\nN=gets.to_i\nA=get_i\nB=get_i\nr=0\nN.times do|i|\n  r+=max(0,A[i]-B[i])\nend\nN.times do|i|\n  if A[i]<B[i]\n    r-=(B[i]-A[i])/2\n  end\n  break if r<=0\nend\nputs yn_judge(r<=0)", "label": 1, "name1": "s582242118.java", "name2": "s701875688.rb"}, {"id": 511, "code1": "import java.util.*;\n \nclass Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    \n    String s = sc.next();\n    boolean a = true, b = true;\n \n    for(int i=0;i<s.length();i+=2){\n        if(s.charAt(i) == 'L'){\n            a = false;\n            break;\n        }\n    }\n    \n    for(int i=1;i<s.length();i+=2){\n        if (!a){break;}\n        if(s.charAt(i) == 'R'){\n            b = false;\n            break;\n        }\n    }\n    \n    if(a&&b){System.out.println(\"Yes\");}\n    else{System.out.println(\"No\");}\n  }\n}", "code2": "\nn,a,b = gets.split.map(&:to_i)\nx = gets.split.map(&:to_i)\n\ncost = 0\nlast = x[0]\n\n(1...n).each{|i|\n    if (x[i]-last)*a < b\n        cost += (x[i]-last)*a\n    else\n        cost += b\n    end\n    last = x[i]\n}\n\np cost\n", "label": 0, "name1": "s301964893.java", "name2": "s273635362.rb"}, {"id": 368, "code1": "\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.AbstractCollection;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Comparator;\nimport java.util.ArrayList;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author silviase\n */\npublic class Main {\n    \n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DijkstraVerify solver = new DijkstraVerify();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DijkstraVerify {\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            int source = in.nextInt();\n            Graph g = new Graph(n);\n            for (int i = 0; i < m; i++) {\n                g.addEdge(new Edge(in.nextInt(), in.nextInt(), in.nextInt()));\n            }\n            long[] d = g.dijkstra(source);\n            for (int i = 0; i < n; i++) {\n                if (d[i] > 1e15) out.println(\"INF\");\n                else out.println(d[i]);\n            }\n        }\n\n    }\n\n    static class Graph {\n        public int size;\n        public ArrayList<Edge>[] adj;\n        public int[] inDeg;\n        public int[] vertexCost;\n\n        @SuppressWarnings(\"unchecked\")\n        public Graph(int size) {\n            this.size = size;\n            adj = new ArrayList[size];\n            inDeg = new int[size];\n            vertexCost = new int[size];\n            for (int i = 0; i < size; i++) {\n                adj[i] = new ArrayList<>();\n            }\n        }\n\n        public void addEdge(Edge e) {\n            adj[e.from].add(e);\n            inDeg[e.to]++;\n        }\n\n        public long[] dijkstra(int from) {\n            long[] d = new long[size];\n            PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.comparing(e -> d[e]));\n            for (int i = 0; i < size; i++) {\n                d[i] = (i == from) ? 0 : (long) 1e18;\n                pq.add(i);\n            }\n            // System.out.println(Arrays.toString(pq.toArray()));\n            while (!pq.isEmpty()) {\n                int search = pq.poll();\n                // System.out.println(\"now: \" + search);\n                ArrayList<Edge> edges = adj[search];\n                for (Edge e : edges) {\n                    // System.out.println(e.toString());\n                    long cmp = d[search] + e.cost;\n                    if (d[e.to] > d[search] + e.cost) {\n                        // \u66f4\u65b0\u304c\u5165\u308b\n                        // \u51e6\u7406\u3092\u5165\u308c\u305f\u3044\u5834\u5408\u306f\u3053\u3053\u306b\u5165\u308c\u308b\n                        d[e.to] = d[search] + e.cost;\n                        pq.add(e.to);\n                    }\n                }\n                //  System.out.println(Arrays.toString(pq.toArray()));\n            }\n            return d;\n        }\n\n    }\n\n    static class Edge {\n        public int from;\n        public int to;\n        public long cost;\n\n        public Edge(int to) {\n            this.to = to;\n        }\n\n        public Edge(int to, long cost) {\n            this.to = to;\n            this.cost = cost;\n        }\n\n        public Edge(int from, int to, long cost) {\n            this.from = from;\n            this.to = to;\n            this.cost = cost;\n        }\n\n        public String toString() {\n            return \"Edge{\" +\n                    \"from=\" + from +\n                    \", to=\" + to +\n                    \", cost=\" + cost +\n                    '}';\n        }\n\n    }\n}\n\n\n", "code2": "require \"set\"\n\nclass St\n  attr :p, :cost\n\n  def initialize(p, cost)\n    @p = p\n    @cost = cost\n  end\n\n  def >(other)\n    @cost == other.cost ? @p > other.p : @cost > other.cost\n  end\nend\n\nclass PriorityQueue\n  def initialize()\n    @data = []\n  end\n\n  def push(x)\n    i = @data.bsearch_index { |y| y > x }\n    if i\n      @data.insert(i, x)\n    else\n      @data.push(x)\n    end\n  end\n\n  def length()\n    @data.length\n  end\n\n  def pop()\n    @data.shift\n  end\nend\n\nclass Dijkstra\n  def initialize(n)\n    @n = n\n    @adj = Array.new(n) { Array.new(0) }\n  end\n\n  def set(s, t, cost)\n    @adj[s].push({ to: t, cost: cost })\n  end\n\n  def calc(s)\n    @visited = Array.new(@n, -1)\n    que = PriorityQueue.new\n    que.push(St.new(s, 0))\n    while que.length > 0\n      current = que.pop\n      cp = current.p\n      next if (@visited[cp] != -1)\n      @visited[cp] = current.cost\n      @adj[cp].each do |a|\n        if (@visited[a[:to]] == -1)\n          que.push(St.new(a[:to], current.cost + a[:cost]))\n        end\n      end\n    end\n  end\n\n  def result(p)\n    @visited[p]\n  end\nend\n\nvn, en, r = gets.split.map(&:to_i)\ng = Dijkstra.new(vn)\nen.times do\n  s, t, d = gets.split.map(&:to_i)\n  g.set(s, t, d)\nend\n\ng.calc(r)\n\nvn.times do |i|\n  res = g.result(i)\n  puts(res == -1 ? \"INF\" : res)\nend\n\n", "label": 1, "name1": "s326905326.java", "name2": "s906623850.rb"}, {"id": 780, "code1": "import java.math.BigInteger;\nimport java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = Integer.parseInt(sc.next());\n\t\tlong m = Long.parseLong(sc.next());\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tm = lcm(m, Long.parseLong(sc.next()));\n\t\tSystem.out.println(m);\n\t}\n\tpublic static long lcm(long m, long n) {\n\t\tBigInteger M = new BigInteger(String.valueOf(m));\n\t\tBigInteger N = new BigInteger(String.valueOf(n));\n\t\tBigInteger G = new BigInteger(String.valueOf(gcd(m, n)));\n\t\treturn M.multiply(N).divide(G).longValue();\n\t}\n\tpublic static long gcd(long m, long n) {\n\t\tif (m < n) {\n\t\t\tlong tem = m;\n\t\t\tm = n;\n\t\t\tn = tem;\n\t\t}\n\t\tlong r = -1;\n\t\twhile (r != 0) {\n\t\t\tr = m % n;\n\t\t\tm = n;\n\t\t\tn = r;\n\t\t}\n\t\treturn m;\n\t}\n}", "code2": "class Node\n    attr_accessor :parent, :rank\n\n    def initialize(n)\n      @parent = n\n      @rank = 0\n    end\nend\n\nclass UnionFindTree\n  def initialize(n)\n    @n = n\n    @nodes = (0..n).to_a.map { |i| Node.new(i) }\n  end\n\n  def find(x)\n    return x if @nodes[x].parent == x\n\n    return @nodes[x].parent = find(@nodes[x].parent)\n  end\n\n  def unite(a, b)\n    a = find(a)\n    b = find(b)\n    return if a == b\n\n    if @nodes[a].rank < @nodes[b].rank\n      @nodes[a].parent = b\n    else\n      @nodes[b].parent = a\n      @nodes[a].rank += 1 if @nodes[a].rank == @nodes[b].rank\n    end\n  end\n\n  def same?(a, b)\n    find(a) == find(b)\n  end\n\n  def parents\n    @nodes.map(&:parent)\n  end\n\n  def roots\n    (1..@n).map {|i| find(i)}\n  end\nend\n\nn,k,l = gets.chomp.split.map(&:to_i)\ntree1 = UnionFindTree.new(n)\nk.times do\n    p,q = gets.chomp.split.map(&:to_i)\n    tree1.unite(p,q)\nend\n\ntree2 = UnionFindTree.new(n)\nl.times do\n    r,s = gets.chomp.split.map(&:to_i)\n    tree2.unite(r,s)\nend\n\np =  (1..n).to_a.zip(tree1.roots, tree2.roots)\ng = p.group_by {|i| [i[1], i[2]]}\n\nans = []\np.each do |v|\n    ans << g[[v[1],v[2]]].size\nend\nputs ans.join(\" \")\n\n\n\n", "label": 0, "name1": "s725061223.java", "name2": "s325987922.rb"}, {"id": 71, "code1": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\t//\u305d\u308c\u305e\u308c\u306e\u60a3\u8005\u306e\u756a\u53f7 p\n\t\t//1\u56de\u76ee\u306b\u6b69\u3044\u305f\u8ddd\u96e2 d1\n\t\t//2\u56de\u76ee\u306b\u6b69\u3044\u305f\u8ddd\u96e2 d2\n\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();//\u60a3\u8005\u306e\u6570 n\n\t\t\tint maxWalk = 0;//\u4e00\u756a\u6b69\u3044\u305f\u4eba\u306e\u8ddd\u96e2\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tMap<Integer, Integer> walkSum = new HashMap<Integer, Integer>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tint d1 = sc.nextInt();\n\t\t\t\tint d2 = sc.nextInt();\n\t\t\t\tint sumWalk = d1 + d2;\n\t\t\t\tif(sumWalk > maxWalk)maxWalk = sumWalk;\n\t\t\t\twalkSum.put(sumWalk,p);\n\t\t\t}\n\t\t\tSystem.out.println(walkSum.get((Object)maxWalk)+\" \"+maxWalk);\n\t\t}\n\t}\n}", "code2": "while true\n    n = gets.to_i\n    break if n == 0\n    arr = []\n    n.times{\n        p, d1, d2 = gets.chomp.split.map(&:to_i)\n        arr << [p, d1 + d2]\n    }\n    arr.sort_by!{|p, d| d}\n    puts arr.last.join(\" \")\nend\n", "label": 1, "name1": "s421023762.java", "name2": "s881713119.rb"}, {"id": 460, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.stream.IntStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.PriorityQueue;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.AbstractCollection;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            Dijkstra d = new Dijkstra(n);\n            for (int i = 0; i < n - 1; i++) {\n                int from = in.readInt() - 1;\n                int to = in.readInt() - 1;\n                d.addUndirectedEdge(from, to, 1);\n            }\n            long[] dist1 = d.getDist(0);\n            long[] distN = d.getDist(n - 1);\n            long count1 = IntStream.range(0, n)\n                    .filter(i -> dist1[i] <= distN[i])\n                    .count();\n            out.printLine(count1 > n - count1 ? \"Fennec\" : \"Snuke\");\n        }\n\n    }\n\n    static class Dijkstra {\n        int n;\n        ArrayList<Pair>[] G;\n        private long INF = Long.MAX_VALUE / 3;\n\n        public Dijkstra(int n) {\n            this.n = n;\n            G = new ArrayList[n];\n            for (int i = 0; i < n; i++) {\n                G[i] = new ArrayList<>();\n            }\n        }\n\n        public void addUndirectedEdge(int from, int to, long cost) {\n            G[from].add(new Pair(to, cost));\n            G[to].add(new Pair(from, cost));\n        }\n\n        public long[] getDist(int s) {\n            PriorityQueue<Pair> Q = new PriorityQueue<>();\n            Q.add(new Pair(s, 0));\n            long[] dist = new long[n];\n            Arrays.fill(dist, INF);\n            boolean[] used = new boolean[n];\n            while (!Q.isEmpty()) {\n                Pair p = Q.poll();\n                if (used[p.x]) continue;\n                used[p.x] = true;\n                dist[p.x] = p.y;\n\n                for (Pair edge : G[p.x]) {\n                    Q.add(new Pair(edge.x, p.y + edge.y));\n                }\n            }\n            return dist;\n        }\n\n        class Pair implements Comparable<Pair> {\n            int x;\n            long y;\n\n            Pair(int x, long y) {\n                this.x = x;\n                this.y = y;\n            }\n\n            public int compareTo(Pair p) {\n                return Long.compare(y, p.y);\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n}\n\n", "code2": "n = gets.to_i\nadj = Array.new(n).map{Array.new}\n(n-1).times do\n  a,b = gets.chomp.split(\" \").map{|i|i.to_i-1}\n  adj[a] << b\n  adj[b] << a\nend\nvst = Array.new(n,false)\nvst[0] = true\nvst[n-1] = true\nsum = [1,1]\nq = [[],[]]\nf = [[0],[n-1]]\nwhile vst.include?(false)\n  q = Marshal.load(Marshal.dump(f))\n  f = [[],[]]\n  2.times do |i|\n    q[i].each do |j|\n      adj[j].each do |k|\n        if vst[k] == false\n          vst[k] = true\n          f[i] << k\n        end\n      end\n    end\n    sum[i] += f[i].size\n  end\nend\nif sum[0] > sum[1]\n  puts \"Fennec\"\nelse\n  puts \"Snuke\"\nend", "label": 1, "name1": "s823656696.java", "name2": "s543014556.rb"}, {"id": 84, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tint[] num = new int[4];\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tString st =sc.nextLine().split(\",\")[1];\n\t\t\tif(st.equals(\"A\")){\n\t\t\t\tnum[0]++;\n\t\t\t}else if(st.equals(\"B\")){\n\t\t\t\tnum[1]++;\n\t\t\t}else if(st.equals(\"AB\")){\n\t\t\t\tnum[2]++;\n\t\t\t}else if(st.equals(\"O\")){\n\t\t\t\tnum[3]++;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < num.length ; i++){\n\t\t\tSystem.out.println(num[i]);\n\t\t}\n\t\tsc.close();\n\t}\n}", "code2": "h=Hash.new(0)\n$<.map{|l|h[l.chop.split(?,)[1]]+=1}\np h[?A],h[?B],h[\"AB\"],h[?O]", "label": 1, "name1": "s769605617.java", "name2": "s471451546.rb"}, {"id": 539, "code1": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tvoid run(){\n\t\tint s=0;\n\t\tfor(int i=0; i<4; i++){\n\t\t\ts+=sc.nextInt();\n\t\t}\n\t\tprintln(s/60+\"\");\n\t\tprintln(s%60+\"\");\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}", "code2": "N = gets.to_i\nM = (2..2*N).find{ |m| m*(m-1)/2 == N }\nif !M \n  puts \"No\"; exit\nend\n\nputs \"Yes\"\np M\nes = {}\ne = 1\n(1..M).each{ |i|\n  #p es[i]\n  (i+1..M).each{ |j|\n    es[i] ||= {}\n    es[j] ||= {}\n    es[i][j] = es[j][i] = e\n    e += 1\n  } \n  puts \"#{M-1} #{es[i].values.join(\" \")}\"\n}\n", "label": 0, "name1": "s582549641.java", "name2": "s628412188.rb"}, {"id": 505, "code1": "import java.util.*;\n\nclass Main{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    String N = sc.next();\n    int sum = 0;\n    for(int i = 0;i<N.length();i++){\n      sum+=Integer.parseInt(N.substring(i,i+1));\n      sum=sum%9;\n    }\n    if(sum == 0){\n      System.out.println(\"Yes\");\n    }else{\n      System.out.println(\"No\");\n    }\n  }\n}", "code2": "h, w = gets.chomp.split.map(&:to_i)\nif (h == 1 || w == 1 )\n  puts \"1\"\nelse\n  puts \"#{(h * w / 2.0).round}\"\nend\n", "label": 0, "name1": "s788833633.java", "name2": "s520164559.rb"}, {"id": 209, "code1": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\t\n\tpublic static void main(String[] args){\n\t\tnew Main();\n\t}\n\tpublic Main(){\n\t\tnew A().doIt();\n\t}\n\tclass A{\n\t\tlong euclid(long a, long b){\n\t\t    long temp;\n\n\t\t    if(a < b) { \n\t\t    \ttemp = a;\n\t\t    \ta = b;\n\t\t    \tb = temp;\n\t\t    }\n\t\t    if(a % b == 0) return b;\n\t\t    return euclid( b, a % b );\n\t\t}\n\t\tvoid doIt(){\n\t\t\tint n = sc.nextInt();\n\t\t\tlong A = 1;\n\t\t\tlong B = 1;\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tlong aa = sc.nextLong();\n\t\t\t\tlong bb = sc.nextLong();\n\t\t\t\tif(A % aa != 0)A = A + aa - (A % aa);\n\t\t\t\tif(B % bb != 0)B = B + bb - (B % bb);\n\t\t\t\tlong max = Math.max(A/aa,B/bb);\n\t\t\t\tA = max * aa;\n\t\t\t\tB = max * bb;\n//\t\t\t\tSystem.out.println(A+\" \"+B);\n\t\t\t}\n\t\t\tSystem.out.println(A+B);\n\t\t}\n\t}\n}\n", "code2": "n = gets.to_i\nratio = gets.split(\" \").map(&:to_i)\n\n(n - 1).times do\n  new_ratio = gets.split(\" \").map(&:to_i)\n  amp = new_ratio.zip(ratio).map do |nr, r|\n    r / nr + (r % nr == 0 ? 0 : 1)\n  end.max\n  ratio = new_ratio.map { |r| r * amp }\nend\n\nputs ratio.inject(&:+)", "label": 1, "name1": "s857617870.java", "name2": "s730519785.rb"}, {"id": 191, "code1": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\n\nimport static java.util.Comparator.reverseOrder;\n\npublic class Main {\n\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n\n        List<Long> inputList = new ArrayList<Long>();\n        for(int i = 0; i < n ;i++) {\n            inputList.add(sc.nextLong());\n        }\n\n        /*\n        List<Integer> sortedList = inputList.stream().sorted(reverseOrder()).collect(Collectors.toList());\n        for(int a: sortedList) {\n            System.out.println(a);\n        }\n        */\n        List<Long> sortedList = inputList.stream().sorted(reverseOrder()).collect(Collectors.toList());\n        long result = sortedList.get(0);\n        int index = 1;\n        int count = 0;\n        for (int i = 0; i < n - 2 ; i++) {\n            result += sortedList.get(index);\n            count = count + 1;\n            if (count == 2) {\n                count = 0;\n                index = index + 1;\n            }\n        }\n        System.out.println(result);\n    }\n}", "code2": "n=gets.to_i\na = gets.split.map(&:to_i).sort\na.unshift(0)\nsum = 0\n(1..n-1).each do |k|\n  sum += a[n-k/2]\nend\np sum\n", "label": 1, "name1": "s542407178.java", "name2": "s326126157.rb"}, {"id": 499, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    int n;\n    char[] cs;\n\n    public static void main(String args[]) {\n        new Main().run();\n    }\n\n    void run() {\n        FastReader sc = new FastReader();\n        n = sc.nextInt();\n        cs = sc.next().toCharArray();\n        solve();\n    }\n\n    void solve() {\n        int[] sumEastL = new int[n];\n        if (cs[0] == 'E') {\n            sumEastL[0] = 1;\n        }\n        for (int i = 1; i < n; i++) {\n            sumEastL[i] = sumEastL[i - 1] + (cs[i] == 'E' ? 1 : 0);\n        }\n        int min = 10000000;\n        for (int i = 0; i < n; i++) {\n            int num = sumEastL[n - 1] - sumEastL[i] + (i > 0 ? i - sumEastL[i - 1] : 0);\n            if (min > num) {\n                min = num;\n            }\n        }\n        System.out.println(min);\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n", "code2": "n = gets.to_i\nstr = gets.chomp\n\ndp = Array.new(n, 0)\n\nacc_w = 0\nacc_e = 0\n\n1.upto(n - 1) do |i|\n  acc_w += 1 if str[i - 1] == \"W\"\n  dp[i] += acc_w\n  acc_e += 1 if str[n - i] == \"E\"\n  dp[n - i - 1] += acc_e\nend\n\nputs dp.min", "label": 1, "name1": "s171588206.java", "name2": "s400591939.rb"}, {"id": 689, "code1": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String args[])\n    {\n        Scanner sc=new Scanner(System.in);\n       int ar[]=new int[] {0,0,0,0};\n       for(int i=0;i<3;i++)\n       {\n           int a=sc.nextInt();\n           int b=sc.nextInt();\n           ar[a-1]+=1;\n           ar[b-1]+=1;\n       }\n       \n       for(int i = 0; i < 4; i++) {\n\t\t\tif(ar[i] < 1 || ar[i] > 2) {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"YES\");\n       \n//       for(int i:ar)\n//       {\n//           if(i>2)\n//           {\n//               System.out.println(\"NO\");\n//               System.exit(0);\n//           }\n//       }\n//       System.out.println(\"YES\");\n    }\n}", "code2": "class UnionFind\n  def initialize(n)\n    @size = Array.new(n, 1)\n    @rank = Array.new(n, 0)\n    @parent = []\n\n    (0..n).each do |i|\n      @parent[i] = i\n    end\n  end\n\n  def find(x)\n    if @parent[x] == x\n      x\n    else\n      @parent[x] = find(@parent[x])\n    end\n  end\n\n  def unite(x, y)\n    x = find(x)\n    y = find(y)\n    return if x == y\n\n    if @rank[x] < @rank[y]\n      @parent[x] = y\n      @size[y] += @size[x]\n    else\n      @parent[y] = x\n      @size[x] += @size[y]\n\n      @rank[x] += 1 if @rank[x] == @rank[y]\n    end\n  end\n\n  def same?(x, y)\n    find(x) == find(y)\n  end\n\n  def size(x)\n    @size[find(x)]\n  end\nend\n\nN, M = gets.split.map(&:to_i)\nuf = UnionFind.new(N + 1)\nM.times do\n  a, b = gets.split.map(&:to_i)\n\n  uf.unite(a, b)\nend\n\nputs (1..N).map { |x| uf.find(x) }.uniq.size - 1\n", "label": 0, "name1": "s048278962.java", "name2": "s192407245.rb"}, {"id": 54, "code1": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tvoid run(){\n\t\tint s=0;\n\t\tfor(int i=0; i<4; i++){\n\t\t\ts+=sc.nextInt();\n\t\t}\n\t\tprintln(s/60+\"\");\n\t\tprintln(s%60+\"\");\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}", "code2": "a=gets.to_i\nb=gets.to_i\nc=gets.to_i\nd=gets.to_i\na=a+b\na=a+c\na=a+d\nsec=a%60\na=a-sec\nmin=a/60\nprint(\"#{min}\\n#{sec}\\n\")", "label": 1, "name1": "s582549641.java", "name2": "s727924665.rb"}, {"id": 613, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() { return Double.parseDouble(next());}\n}\npublic class Main {\n\tstatic FastScanner stdIn=new FastScanner();\n\tpublic static void main(String[] args) {\n\t\tString X=stdIn.next();\n\t\tint N=X.length();\n\t\tint s=0,t=0,ans=N;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tchar a=X.charAt(i);\n\t\t\tif(a=='S')\n\t\t\t\ts++;\n\t\t\telse{\n\t\t\t\tif(s!=0){\n\t\t\t\t\tans-=2;\n\t\t\t\t\ts--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n", "code2": "a,b = gets.split.map(&:to_i)\n\nif a <= b\n  puts a\nelse\n  puts a-1\nend", "label": 0, "name1": "s724983945.java", "name2": "s914009735.rb"}, {"id": 944, "code1": "import static java.lang.Math.exp;\nimport static java.lang.Math.max;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.function.IntUnaryOperator;\nimport java.util.function.LongUnaryOperator;\n\npublic class Main {\n    public static void main(String[] args) {\n        new Solver(false);\n    }\n}\n\nclass Solver {\n    final In in;\n\n    static final int D = 365;\n    static final int A = 26;\n\n    static final int SWAP_WIDTH = 10;\n    final int[] c = new int[A];\n    final int[][] s = new int[D][A];\n    final double[][] w = new double[D][A];\n    final int[] x = new int[D];\n    final Random rnd = new Random();\n\n    static final double START_TEMP = 1000;\n    static final double END_TEMP = 15;\n    static final double DEL_TEMP = END_TEMP - START_TEMP;\n\n    static final long TIME_LIMIT = 1_900_000_000l;\n    final long startTime = System.nanoTime();\n    final long endTime = startTime + TIME_LIMIT;\n\n    int score;\n    int iteration = 0;\n\n    public Solver (boolean debug) {\n        if (debug) {\n            try {\n                System.setIn(new FileInputStream(new File(\"./marathon/tester/example/sample2.in\")));\n                System.setOut(new PrintStream(new File(\"./marathon/debug_output\")));\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        in = new In();\n        input();\n        // setWeight(50);\n        // annealing(debug);\n        greedy3();\n        output();\n        if (debug) {\n            long time = (System.nanoTime() - startTime) / 1_000_000;\n            System.out.println(String.format(\"Time: %d ms\", time));\n            int expected = score();\n            if (expected != score) {\n                System.out.println(score);\n                System.out.println(expected);\n                String err = String.format(\"\\nexpected = %d\\nactual = %d\", expected, score);\n                throw new RuntimeException(err);\n            }\n            score = max(score + 1000000, 0);\n            System.out.printf(\"Iteration: %d\\nScore: %d\\n\", iteration, score);\n        }\n    }\n\n    public void initialize() {\n        greedy3();\n    }\n\n    public void annealing(boolean debug) {\n        initialize();\n        long nowTime = System.nanoTime();\n        while (nowTime < endTime) {\n            if ((++iteration & 3) == 0) {\n                tryChange(nowTime);\n                if ((iteration & 0x3ff) == 0) nowTime = System.nanoTime();\n            } else {\n                trySwap(nowTime);\n            }\n        }\n    }\n\n    public void tryChange(long nowTime) {\n        int day = rnd.nextInt(D);\n        int fr = x[day];\n        // int to = weightedRandomContest(day);\n        int to = rnd.nextInt(A);\n        int newScore = ifChanged(day, fr, to, score);\n        double temp = START_TEMP + DEL_TEMP * (nowTime - startTime) / TIME_LIMIT;\n        double prob = exp((newScore - score) / temp);\n        if (prob > rnd.nextDouble()) {\n            x[day] = to;\n            score = newScore;\n        }\n    }\n\n    public void trySwap(long nowTime) {\n        int day1 = rnd.nextInt(D);\n        int day2;\n        do {day2 = randomSwapDay(day1);} while (x[day1] == x[day2]);\n        int newScore = ifSwapped(day1, day2, score);\n        double temp = START_TEMP + DEL_TEMP * (nowTime - startTime) / TIME_LIMIT;\n        double prob = exp((newScore - score) / temp);\n        if (prob > rnd.nextDouble()) {\n            int tmp = x[day1]; x[day1] = x[day2]; x[day2] = tmp;\n            score = newScore;\n        }\n    }\n\n    public int ifChanged(int day, int fr, int to, int oldScore) {\n        int newScore = oldScore + s[day][to] - s[day][fr];\n        newScore += (day - higher(day, fr)) * (day - lower(day, fr)) * c[fr];\n        newScore -= (day - higher(day, to)) * (day - lower(day, to)) * c[to];\n        return newScore;\n    }\n\n    public int ifSwapped(int day1, int day2, int oldScore) {\n        int x1 = x[day1], x2 = x[day2];\n        int newScore = ifChanged(day1, x1, x2, oldScore);\n        x[day1] = x2;\n        newScore = ifChanged(day2, x2, x1, newScore);\n        x[day1] = x1;\n        return newScore;\n    }\n\n    public void setWeight(int param) {\n        for (int i = 0; i < D; i++) {\n            double sum = 0;\n            for (int j = 0; j < A; j++) sum += c[j] * param + s[i][j];\n            for (int j = 0; j < A; j++) {\n                w[i][j] = (c[j] * param + s[i][j]) / sum;\n                if (j > 0) w[i][j] += w[i][j - 1];\n            }\n        }\n    }\n\n    public int weightedRandomContest(int day) {\n        double v = rnd.nextDouble();\n        for (int i = 0; i < A; i++) if (w[day][i] >= v) return i;\n        return A - 1;\n        // int l = -1, r = A;\n        // while (r - l > 1) {\n        //     int m = (l + r) >> 1;\n        //     if (w[day][m] < v) l = m;\n        //     else r = m;\n        // }\n        // return r == A ? 0 : r;\n    }\n\n    public int randomSwapDay(int day) {\n        int l = Math.min(day, SWAP_WIDTH);\n        int r = Math.min(D - 1 - day, SWAP_WIDTH);\n        int v = rnd.nextInt(l + r);\n        return v < l ? day - l + v : day - l + v + 1;\n    }\n\n    public void greedy() {\n        int[] last = new int[A];\n        for (int i = 0; i + 2 < D; i += 3) {\n            int max = -Const.IINF;\n            int mx1 = -1, mx2 = -1, mx3 = -1;\n            for (int x1 = 0; x1 < A; x1++) for (int x2 = 0; x2 < A; x2++) for (int x3 = 0; x3 < A; x3++) {\n                int l1 = last[x1], l2 = last[x2], l3 = last[x3];\n                int delta = 0;\n                last[x1] = i + 1;\n                delta += s[i][x1];\n                for (int j = 0; j < A; j++) delta -= c[j] * (i + 1 - last[j]);\n                last[x2] = i + 2;\n                delta += s[i + 1][x2];\n                for (int j = 0; j < A; j++) delta -= c[j] * (i + 2 - last[j]);\n                last[x3] = i + 3;\n                delta += s[i + 2][x3];\n                for (int j = 0; j < A; j++) delta -= c[j] * (i + 3 - last[j]);\n                if (delta > max) {\n                    max = delta;\n                    mx1 = x1; mx2 = x2; mx3 = x3;\n                }\n                last[x1] = l1; last[x2] = l2; last[x3] = l3;\n            }\n            x[i] = mx1; x[i + 1] = mx2; x[i + 2] = mx3;\n            last[mx1] = i + 1; last[mx2] = i + 2; last[mx3] = i + 3;\n            score += max;\n        }\n        int max = -Const.IINF;\n        int mx1 = -1, mx2 = -1;\n        for (int x1 = 0; x1 < A; x1++) for (int x2 = 0; x2 < A; x2++) {\n            int l1 = last[x1], l2 = last[x2];\n            int delta = 0;\n            last[x1] = D - 1;\n            delta += s[D - 2][x1];\n            for (int j = 0; j < A; j++) delta -= c[j] * (D - 1 - last[j]);\n            last[x2] = D;\n            delta += s[D - 1][x2];\n            for (int j = 0; j < A; j++) delta -= c[j] * (D - last[j]);\n            if (delta > max) {\n                max = delta;\n                mx1 = x1; mx2 = x2;\n            }\n            last[x1] = l1; last[x2] = l2;\n        }\n        x[D - 2] = mx1; x[D - 1] = mx2;\n        last[mx1] = D - 1; last[mx2] = D;\n        score += max;\n    }\n\n    public void greedy2() {\n        for (int i = 0; i < A; i++) score -= D * (D + 1) * c[i] / 2;\n        int[] last = new int[A];\n        Arrays.fill(last, -1);\n        for (int i = 0; i < D; i++) {\n            int max = 0, xi = -1;\n            for (int j = 0; j < A; j++) {\n                int delta = s[i][j] + (D - i) * (i - last[j]) * c[j];\n                if (delta > max) {\n                    max = delta;\n                    xi = j;\n                }\n            }\n            last[xi] = i;\n            x[i] = xi;\n            score += max;\n        }\n    }\n\n    public void greedy3() {\n        for (int i = 0; i < A; i++) score -= D * (D + 1) * c[i] / 2;\n        int[] last = new int[A];\n        Arrays.fill(last, -1);\n        for (int i = 0; i + 3 < D; i += 4) {\n            int max = 0;\n            int mx1 = -1, mx2 = -1, mx3 = -1, mx4 = -1;\n            for (int x1 = 0; x1 < A; x1++) for (int x2 = 0; x2 < A; x2++) \n            for (int x3 = 0; x3 < A; x3++) for (int x4 = 0; x4 < A; x4++) {\n                int l1 = last[x1], l2 = last[x2], l3 = last[x3], l4 = last[x4];\n                int delta = 0;\n                delta += s[i][x1] + (D - i) * (i - last[x1]) * c[x1];\n                last[x1] = i;\n                delta += s[i + 1][x2] + (D - i - 1) * (i + 1 - last[x2]) * c[x2];\n                last[x2] = i + 1;\n                delta += s[i + 2][x3] + (D - i - 2) * (i + 2 - last[x3]) * c[x3];\n                last[x3] = i + 2;\n                delta += s[i + 3][x4] + (D - i - 3) * (i + 3 - last[x4]) * c[x4];\n                last[x4] = i + 3;\n                if (delta > max) {\n                    max = delta;\n                    mx1 = x1; mx2 = x2; mx3 = x3; mx4 = x4;\n                }\n                last[x1] = l1; last[x2] = l2; last[x3] = l3; last[x4] = l4;\n            }\n            x[i] = mx1; x[i + 1] = mx2; x[i + 2] = mx3; x[i + 3] = mx4;\n            last[mx1] = i; last[mx2] = i + 1; last[mx3] = i + 2; last[mx4] = i + 3;\n            score += max;\n        }\n        int max = 0;\n        int mx1 = -1;\n        for (int x1 = 0; x1 < A; x1++) {\n            int l1 = last[x1];\n            int delta = 0;\n            delta += s[D - 1][x1] + (D - 1 - last[x1]) * c[x1];\n            last[x1] = D - 1;\n            if (delta > max) {\n                max = delta;\n                mx1 = x1;\n            }\n            last[x1] = l1;\n        }\n        x[D - 1] = mx1;\n        last[mx1] = D - 1;\n        score += max;\n    }\n\n    public void input() {\n        in.ni();\n        Arrays.setAll(c, $ -> in.ni());\n        for (int i = 0; i < D; i++) Arrays.setAll(s[i], $ -> in.ni());\n    }\n\n    public void output() {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < D; i++) sb.append(x[i] + 1).append('\\n');\n        System.out.print(sb);\n    }\n\n    public int score() {\n        int[] last = new int[A];\n        int score = 0;\n        for (int i = 0; i < D; i++) {\n            last[x[i]] = i + 1;\n            score += s[i][x[i]];\n            for (int j = 0; j < A; j++) score -= c[j] * (i + 1 - last[j]);\n        }\n        return score;\n    }\n\n    public int higher(int day, int v) {\n        for (int i = day + 1; i < D; i++) if (x[i] == v) return i;\n        return D;\n    }\n\n    public int lower(int day, int v) {\n        for (int i = day - 1; i >= 0; i--) if (x[i] == v) return i;\n        return -1;\n    }\n}\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class In {\n    final FastScanner fsc = new FastScanner();\n    public int ni() {return fsc.nextInt();}\n    public int[] ni(final int n) {\n        final int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = fsc.nextInt();\n        return a;\n    }\n    public int[] ni(final int n, final IntUnaryOperator f) {\n        final int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = f.applyAsInt(fsc.nextInt());\n        return a;\n    }\n    public int[][] ni(final int n, final int m) {\n        final int[][] a = new int[n][m];\n        for (int i = 0; i < n; i++) a[i] = ni(m);\n        return a;\n    }\n    public int[][] ni(final int n, final int m, final IntUnaryOperator f) {\n        final int[][] a = new int[n][m];\n        for (int i = 0; i < n; i++) a[i] = ni(m, f);\n        return a;\n    }\n    public long nl() {return fsc.nextLong();}\n    public long[] nl(final int n) {\n        final long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = fsc.nextLong();\n        return a;\n    }\n    public long[] nl(final int n, final LongUnaryOperator f) {\n        final long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = f.applyAsLong(fsc.nextLong());\n        return a;\n    }\n    public long[][] nl(final int n, final int m) {\n        final long[][] a = new long[n][m];\n        for (int i = 0; i < n; i++) a[i] = nl(m);\n        return a;\n    }\n    public long[][] nl(final int n, final int m, final LongUnaryOperator f) {\n        final long[][] a = new long[n][m];\n        for (int i = 0; i < n; i++) a[i] = nl(m, f);\n        return a;\n    }\n    public char[] nc() {return fsc.next().toCharArray();}\n    public char[][] nc(final int n) {\n        final char[][] c = new char[n][];\n        for (int i = 0; i < n; i++) c[i] = nc();\n        return c;\n    }\n    public double nd() {return fsc.nextDouble();}\n    public double[] nd(final int n) {\n        final double[] a = new double[n];\n        for (int i = 0; i < n; i++) a[i] = fsc.nextDouble();\n        return a;\n    }\n    public double[][] nd(final int n, final int m) {\n        final double[][] a = new double[n][m];\n        for (int i = 0; i < n; i++) a[i] = nd(m);\n        return a;\n    }\n    public String ns() {return fsc.next();}\n    public String[] ns(final int n) {\n        final String[] s = new String[n];\n        for (int i = 0; i < n; i++) s[i] = fsc.next();\n        return s;\n    }\n    public boolean[][] grid(final int h, final int w, final char trueCharacter) {\n        final boolean[][] grid = new boolean[h][w];\n        for (int i = 0; i < h; i++) {\n            final char[] s = fsc.next().toCharArray();\n            for (int j = 0; j < w; j++) grid[i][j] = s[j] == trueCharacter;\n        }\n        return grid;\n    }\n}\n\n\nfinal class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try {buflen = in.read(buffer);}\n        catch (final IOException e) {e.printStackTrace();}\n        return buflen > 0;\n    }\n    private int readByte() {return hasNextByte() ? buffer[ptr++] : -1;}\n    public boolean hasNext() {\n        while (hasNextByte() && !(33 <= buffer[ptr] && buffer[ptr] <= 126)) ptr++;\n        return hasNextByte();\n    }\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        final StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (33 <= b && b <= 126) {sb.appendCodePoint(b); b = readByte();}\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {minus = true; b = readByte();}\n        if (b < '0' || '9' < b) throw new NumberFormatException();\n        for (; ; b = readByte()) {\n            if ('0' <= b && b <= '9') n = n * 10 + b - '0';\n            else if (b == -1 || !(33 <= b && b <= 126)) return minus ? -n : n;\n            else throw new NumberFormatException();\n        }\n    }\n    public int nextInt() {return Math.toIntExact(nextLong());}\n    public double nextDouble() {return Double.parseDouble(next());}\n}\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass Const {\n    public static final long MOD7 = 1_000_000_007;\n    public static final long MOD9 = 1_000_000_009;\n    public static final long MOD99 = 998_244_353;\n\n    public static final long LINF = Long.MAX_VALUE >> 2;\n    public static final int IINF = Integer.MAX_VALUE >> 1;\n    public static final double DINF = 1e150;\n\n    public static final double SDELTA = 1e-12;\n    public static final double DELTA = 1e-9;\n    public static final double LDELTA = 1e-6;\n\n    public static final int[] dx8 = {1, 0, -1, 0, 1, -1, -1, 1};\n    public static final int[] dy8 = {0, 1, 0, -1, 1, 1, -1, -1};\n    public static final int[] dx4 = {1, 0, -1, 0};\n    public static final int[] dy4 = {0, 1, 0, -1};\n\n    private Const(){}\n}\n\nfinal class Random {\n    private static final double DOUBLE_UNIT = 0x1.0p-53;\n    private int x = 123456789;\n    private int y = 362436069;\n    private int z = 521288629;\n    private int w = 88675123;\n    public int nextInt() {\n        int t = x ^ (x << 11);\n        x = y; y = z; z = w;\n        return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n    }\n    public long nextLong() {\n        return ((long) (nextInt()) << 32) + nextInt();\n    }\n    public int nextInt(int bound) {\n        return nextInt() % bound;\n    }\n    public boolean nextBoolean() {\n        return (nextInt() & 1) == 0;\n    }\n    public double nextDouble() {\n        return (((long) (next(26)) << 27) + next(27)) * DOUBLE_UNIT;\n    }\n    private int next(int bits) {\n        int mask = bits == 32 ? -1 : (1 << bits) - 1;\n        return nextInt() & mask;\n    }\n}\n", "code2": "puts gets.count('2')", "label": 0, "name1": "s001261503.java", "name2": "s627016600.rb"}, {"id": 240, "code1": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\n\tstatic class TaskX {\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tint n = in.nextInt();\n\t\t\tint k = in.nextInt();\n\t\t\tint[] wn = in.nextIntArray(n);\n\n\t\t\tint left = 0;\n\t\t\tint right = INF;\n\t\t\tint mid = 0;\n\t\t\twhile (right > left + 1) {\n\t\t\t\tmid = (left + right) / 2;\n\t\t\t\tint count = 1;\n\t\t\t\tint ca = mid;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (ca - wn[i] >= 0) {\n\t\t\t\t\t\tca -= wn[i];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tca = mid;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tif (ca - wn[i] >= 0) {\n\t\t\t\t\t\t\tca -= wn[i];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcount = INF;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// k\u53f0\u4ee5\u4e0b\u3067\u7a4d\u3081\u308b\u5834\u5408\n\t\t\t\tif (count <= k){\n\t\t\t\t\tright = mid;\n\n\t\t\t\t// \uff4b\u53f0\u4ee5\u4e0a\u5fc5\u8981\u306a\u5834\u5408\n\t\t\t\t} else if (count > k) {\n\t\t\t\t\tleft = mid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout.println(right);\n\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\n\t}\n\n}\n\n", "code2": "n, k = gets.chomp.split(' ').map(&:to_i)\nw = n.times.map{gets.chomp.to_i}\n\nN_MAX = K_MAX = 100000\nW_MAX = 10000\n\nleft = 0\nright = N_MAX * W_MAX\nmid = nil\n\nload_buggage = -> (p) do\n  i = 0\n  0.step(k-1) do |j|\n    s = 0\n    #STDERR.puts \"  kj=#{j}\"\n    while s + w[i] <= p\n      s += w[i]\n      #STDERR.puts \"    #{i}: w[#{i}]=#{w[i]}, s=#{s}\"\n      i += 1\n      break if i == n\n    end\n    break if i == n\n  end\n  #STDERR.puts \"load: #{i}\"\n  i\nend\n\nuntil (right - left) == 1 do\n  mid = (left + right) / 2\n  #STDERR.puts \"L=#{left}, M=#{mid}, R=#{right}\"\n  v = load_buggage.(mid)\n  if (v >= n)\n    right = mid\n  else\n    left = mid\n  end\nend\n\nputs right\n", "label": 1, "name1": "s166648431.java", "name2": "s107592187.rb"}, {"id": 333, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n    private static int[] arr;\n\n    public static void main(String[] args) {\n\n        Scanner scanner = new Scanner(System.in);\n        String input = scanner.nextLine();\n        arr = Arrays.stream(input.split(\"\")).mapToInt(Integer::parseInt).toArray();\n\n        long sum = calc(0, arr.length - 1);\n        System.out.println(sum);\n    }\n\n    private static long calc(int position, int end) {\n        if (position > end) return 0;\n\n        long tmp = 0;\n        for (int i = position; i < end; i++) {\n            tmp += toInt(position, i) * Math.pow(2, (end - i - 1)) + calc(i + 1, end);\n        }\n        tmp += toInt(position, end);\n        return tmp;\n    }\n\n    private static long toInt(int start, int end) {\n        if (start == end) {\n//            System.out.println(\"start: \" + start + \" end: \" + end + \" -> \" + arr[start]);\n            return arr[start];\n        }\n\n        long tmp = 0;\n        for (int i = start; i <= end; i++) {\n            tmp += arr[i] * Math.pow(10, (end - i));\n        }\n//        System.out.println(\"start: \" + start + \" end: \" + end + \" -> \" + tmp);\n        return tmp;\n    }\n}", "code2": "def main\n  s = ARGF.gets.chomp\n\n  # + \u3092\u5165\u308c\u3089\u308c\u308b\u5834\u6240\u306e\u6570\n  n = s.length - 1\n\n  sum = 0\n  # 2^n     = 1 << n\n  0.upto((1 << n) - 1) do |mask|\n    # puts \"mask = #{mask}\"\n    last_idx = 0\n    0.upto(n-1) do |i|\n      if mask[i] == 1\n        # '+'\u3092 i\u756a\u76ee \u3068 i+1\u756a\u76ee\u306e\u9593\u306b\u5165\u308c\u308b\n        part = s.slice(last_idx, i - last_idx + 1)\n        # puts part\n        sum += part.to_i\n        last_idx = i+1\n      end\n    end\n    last_part = s.slice(last_idx..-1)\n    # puts last_part\n    sum += last_part.to_i\n  end\n\n  puts sum\nend\n\nif __FILE__ == $0\n  main\nend\n", "label": 1, "name1": "s752481979.java", "name2": "s267462480.rb"}, {"id": 973, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = Integer.parseInt(sc.next());\n\t\tlong[] a = new long[n];\n\t\tlong[] b = new long[n];\n\t\tlong[] c = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = Long.parseLong(sc.next());\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tb[i] = Long.parseLong(sc.next());\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tc[i] = Long.parseLong(sc.next());\n\t\tArrays.sort(a);\n\t\tArrays.sort(b);\n\t\tArrays.sort(c);\n\t\tlong[] u = new long[n];\n\t\tint index = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\twhile (index < n && a[index] < b[i])\n\t\t\t\tindex++;\n\t\t\tif (i == 0)\n\t\t\t\tu[i] = index;\n\t\t\telse\n\t\t\t\tu[i] = u[i - 1] + index;\n\t\t}\n\t\tint[] l = new int[n];\n\t\tindex = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\twhile (index < n && b[index] < c[i])\n\t\t\t\tindex++;\n\t\t\tl[i] = index;\n\t\t}\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (l[i] != 0)\n\t\t\t\tans += u[l[i] - 1];\n\t\tSystem.out.println(ans);\n\n\t}\n}", "code2": "require 'prime'\n \nprimes = Prime.each(1_000_000).to_a\n \nwhile (n = gets.to_i) > 0\n    i = 0\n    j = (primes.find_index{|x| x > n} || primes.size) - 1\n \n    count = 0\n    while\n        s = primes[i] + primes[j]\n        count += 1 if s == n\n        break if i == j\n        if s < n\n            i += 1\n        else\n            j -= 1\n        end\n    end\n    p count\nend", "label": 0, "name1": "s329855365.java", "name2": "s198211396.rb"}, {"id": 903, "code1": "import java.util.*; \n\nclass Main{\npublic static void main(String[] args){\n\tScanner sc=new Scanner(System.in);\n        int x=sc.nextInt();\n  \t\tint t=0;\n  if(x==2){\n \t System.out.println(x);\n  }else{\n  \n   for(int x1=x;x1>0;x1++){\n     for(int c=2;c<x1;c++){\n         if(x1%c==0){\n           t=0;\n           break;\n          }else{\n           t++;\n         }\n    \t }\n     if(t>0){\n        System.out.println(x1);\n           return;\n     } \n   }\n\n  }\n    }\n}", "code2": "def main(argv)\n  (h, w) = gets.chomp.split(' ').map(&:to_i)\n  a = [nil] * h\n  h.times{|y| a[y] = gets.chomp }\n\n  counter = [0] * 26\n  h.times{|y| w.times{|x| counter[a[y][x].ord - 'a'.ord] += 1 }}\n\n  x = w / 2\n  y = h / 2\n\n  div4 = 0\n  counter.size.times do |i|\n    div4 += counter[i] / 4\n    counter[i] = counter[i] % 4\n  end\n\n  if div4 < x * y then\n    puts 'No'\n    return\n  end\n\n  div2 = (div4 - (x * y)) * 2\n  counter.size.times do |i|\n    div2 += counter[i] / 2\n    counter[i] = counter[i] % 2\n  end\n\n  flag = true\n  if h % 2 == 0 then\n    if w % 2 == 0 then\n      flag = true\n    else # w % 2 == 1\n      flag = div2 == y\n    end\n  else # h % 2 == 1\n    if w % 2 == 0 then\n      flag = div2 == x\n    else # w % 2 == 1\n      flag = div2 == x + y\n    end\n  end\n  puts (flag ? 'Yes' : 'No')\nend\n\nif self.to_s == 'main' then\n  main(ARGV)\nend", "label": 0, "name1": "s993503161.java", "name2": "s841406733.rb"}, {"id": 741, "code1": "import java.util.ArrayList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n/**\n * Created by shoya on 2017/04/12.\n */\npublic class Main {\n    public static void main(String... args) {\n        Scanner sc = new Scanner(System.in);\n        int V = sc.nextInt();\n        int E = sc.nextInt();\n        int r = sc.nextInt();\n        DijkstraClass dijkstra = new DijkstraClass(V, E, r);\n        for (int i = 0; i < E; i++) {\n            int s = sc.nextInt();\n            int d = sc.nextInt();\n            int c = sc.nextInt();\n            dijkstra.addDistande(s, d, c);\n        }\n        int[] dist = dijkstra.dikstra();\n        for (int i = 0; i < dist.length; i++){\n            if (dist[i] == 1 << 30)\n                System.out.println(\"INF\");\n            else\n                System.out.println(dist[i]);\n        }\n        return;\n    }\n\n\n    private static class DijkstraClass {\n        class edge{\n            int dest, cost;\n            edge(int dest, int cost){\n                this.dest = dest;\n                this.cost = cost;\n            }\n        }\n\n        private final int INF = 1 << 30;\n        private int S;\n        private int V;\n        private ArrayList<ArrayList<edge>> edgesOfNodes = new ArrayList<ArrayList<edge>>();\n\n        DijkstraClass(int V, int E, int Start){\n            this.S = Start;\n            this.V = V;\n            for (int i = 0; i < V; i++)\n                edgesOfNodes.add(new ArrayList<edge>());\n        }\n\n        void addDistande(int source, int dest, int cost){\n            edgesOfNodes.get(source).add(new edge(dest, cost));\n        }\n\n\n        int[] dikstra(){\n            class costAndNode implements Comparable {\n                int cost, node;\n                costAndNode(int cost, int node){\n                    this.cost = cost;\n                    this.node = node;\n                }\n                @Override\n                public int compareTo(Object o) {\n                    return this.cost - ((costAndNode) o).cost;\n                }\n            }\n\n            PriorityQueue<costAndNode> pque = new PriorityQueue<costAndNode>();\n            int[] distances = new int[V];\n            for (int i = 0; i < V; i++)\n                distances[i] = INF;\n            distances[S] = 0;\n\n            pque.add(new costAndNode(0, S));\n            while (!pque.isEmpty()){\n                costAndNode item = pque.poll();\n                if (distances[item.node] < item.cost)\n                    continue;\n\n                //System.out.printf(\"Focusing on Node %d\\n\", item.node);\n                //for (int i = 0; i < V; i++)\n                //    System.out.printf(\"%d \", distances[i]);\n                //System.out.println();\n\n                for (edge e : edgesOfNodes.get(item.node)) {\n                    //System.out.printf(\"Node %d -> %d, Cost %d -> %d\\n\",\n                    //        item.node, e.dest, distances[e.dest],\n                    //        distances[item.node] + e.cost);\n                    if (distances[e.dest] > distances[item.node] + e.cost) {\n                        distances[e.dest] = distances[item.node] + e.cost;\n                        pque.add(new costAndNode(distances[e.dest], e.dest));\n                    }\n                }\n            }\n\n            return distances;\n        }\n\n    }\n}", "code2": "a,b,c,d,e,f,g = gets.split.map(&:to_i)\nans = 0\nans += b*2\nans += (a/2)*4\nans += (d/2)*4\nans += (e/2)*4\nif a.odd? && d.odd? && e.odd?\n    ans += 6\nelsif d.odd? && e.odd? && a != 0\n    ans += 2\nelsif a.odd? && ((d.odd? && e != 0) || (e.odd? && d != 0))\n    ans += 2\nend\nputs ans/2", "label": 0, "name1": "s575620429.java", "name2": "s340171115.rb"}, {"id": 589, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tMyInput in = new MyInput(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic long LINF = 1L << 55;\n\tstatic int MOD = 1000000007;\n\tstatic int[] mh4 = { 0, -1, 1, 0 };\n\tstatic int[] mw4 = { -1, 0, 0, 1 };\n\tstatic int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\tstatic int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n\tstatic class TaskX {\n\n\t\tpublic void solve(int testNumber, MyInput in, PrintWriter out) {\n\n\t\t\tint n = in.nextInt();\n\t\t\tchar[] s = in.nextChars();\n\n\t\t\tlong[][] dp = new long[n+1][n+1];\n\t\t\tArrays.fill(dp[0], 1);\n\n\t\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\t\tif (s[i] == '<') {\n\t\t\t\t\tfor (int j = 0; j < n-i; j++) {\n\t\t\t\t\t\tdp[i+1][j] += dp[i][j];\n\t\t\t\t\t\tdp[i+1][j] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (int j = 0; j < n-i; j++) {\n\t\t\t\t\t\tdp[i+1][0] += dp[i][j];\n\t\t\t\t\t\tdp[i+1][j] -= dp[i][j] - MOD;\n\t\t\t\t\t\tdp[i+1][0] %= MOD;\n\t\t\t\t\t\tdp[i+1][j] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 1; j < n-1-i; j++) {\n\t\t\t\t\tdp[i+1][j] += dp[i+1][j-1];\n\t\t\t\t\tdp[i+1][j] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout.println(dp[n-1][0]);\n\n\t\t}\n\t}\n\n\tstatic class MyInput {\n\t\tprivate final BufferedReader in;\n\t\tprivate static int pos;\n\t\tprivate static int readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500 * 8 * 2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic {\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tisDigit['0' + i] = true;\n\t\t\t}\n\t\t\tisDigit['-'] = true;\n\t\t\tisSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n\t\t\tisLineSep['\\r'] = isLineSep['\\n'] = true;\n\t\t}\n\n\t\tpublic MyInput(InputStream is) {\n\t\t\tin = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (pos >= readLen) {\n\t\t\t\tpos = 0;\n\t\t\t\ttry {\n\t\t\t\t\treadLen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException();\n\t\t\t\t}\n\t\t\t\tif (readLen <= 0) {\n\t\t\t\t\tthrow new MyInput.EndOfFileRuntimeException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buffer[pos++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\tint i = 0;\n\t\t\tint ret = 0;\n\t\t\tif (str[0] == '-') {\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t\tfor (; i < len; i++)\n\t\t\t\tret = ret * 10 + str[i] - '0';\n\t\t\tif (str[0] == '-') {\n\t\t\t\tret = -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\tint i = 0;\n\t\t\tlong ret = 0;\n\t\t\tif (str[0] == '-') {\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t\tfor (; i < len; i++)\n\t\t\t\tret = ret * 10 + str[i] - '0';\n\t\t\tif (str[0] == '-') {\n\t\t\t\tret = -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic char nextChar() {\n\t\t\twhile (true) {\n\t\t\t\tfinal int c = read();\n\t\t\t\tif (!isSpace[c]) {\n\t\t\t\t\treturn (char) c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic String nextString() {\n\t\t\treturn new String(nextChars());\n\t\t}\n\n\t\tpublic char[] nextChars() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\treturn Arrays.copyOf(str, len);\n\t\t}\n\n\t\tint reads(int len, boolean[] accept) {\n\t\t\ttry {\n\t\t\t\twhile (true) {\n\t\t\t\t\tfinal int c = read();\n\t\t\t\t\tif (accept[c]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (str.length == len) {\n\t\t\t\t\t\tchar[] rep = new char[str.length * 3 / 2];\n\t\t\t\t\t\tSystem.arraycopy(str, 0, rep, 0, str.length);\n\t\t\t\t\t\tstr = rep;\n\t\t\t\t\t}\n\t\t\t\t\tstr[len++] = (char) c;\n\t\t\t\t}\n\t\t\t} catch (MyInput.EndOfFileRuntimeException e) {\n\t\t\t}\n\t\t\treturn len;\n\t\t}\n\n\t\tpublic int[] nextIntArray(final int n) {\n\t\t\tfinal int[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArray1Index(final int n) {\n\t\t\tfinal int[] res = new int[n + 1];\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArrayDec(final int n) {\n\t\t\tfinal int[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(final int n) {\n\t\t\tfinal long[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray1Index(final int n) {\n\t\t\tfinal long[] res = new long[n + 1];\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArrayDec(final int n) {\n\t\t\tfinal long[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic double[] nextDoubleArray(int n) {\n\t\t\tdouble[] res = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextDouble();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\t}\n\n\t}\n\n}\n", "code2": "objects = []\n\nmax_n = 123456*2\n\nsosu_arr = []\nsosu_set = {}\n\nmax_n.times.each do |ii|\n  i = ii + 1\n  next if i == 1\n  next if sosu_set.key?(i)\n  sosu_arr.push i\n  sosu_set[i] = true\n  (max_n/i).to_i.times.each do |j|\n    next if j == 0\n    sosu_set[i * (j+1)] = false\n  end\nend\n\nlines = []\nwhile num = gets\n  num = num.to_i\n  break if num == 0\n  if num == 1\n    puts 1\n    next\n  end\n  sum = 0\n  ((num+1)..(num*2)).each do |i|\n    sum = sum + 1 if sosu_set[i]\n  end\n  puts sum\nend", "label": 0, "name1": "s819730919.java", "name2": "s102129990.rb"}, {"id": 989, "code1": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.awt.Point;\n\npublic class Main {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"\";\n    int n;\n    void solve()\n    {\n        n = ni();\n        int[] d  = new int[n+1];\n        d[0] = 0;\n        for(int i = 0; i < n; i++){\n            d[i+1] = ni();\n        }\n        n++;\n        boolean[] seen = new boolean[25];\n        int min = 0;\n        int ans = 0;\n        for(int i = 0; i <= 24; i++){\n            int[][] e = new int[n][2];\n            e[0][0] = i;\n            e[0][1] = i;\n            for(int j = 0; j < n-1; j++){\n                e[j+1][0] = (d[j+1]+i)%24;\n                e[j+1][1] = (-d[j+1]+i+24)%24;\n            }\n            int left = 1;\n            int right = 24;\n            while(left+1<right){\n                int res = (left+right)/2;\n                if(f(e,res,0,seen)) left = res;\n                else{\n                    right = res;\n                }\n            }\n            if(left>min){\n                // if(left==5){\n                //     out.println(i);\n                // }\n                if(left == 1){\n                    if(f(e,left,0,seen)){\n                        min = left;\n                    }\n                }\n                else min = left;\n            }\n        }\n\n        ans = min;\n        out.println(ans);\n    }\n\n    boolean f(int[][] d, int sub, int k, boolean[] seen){\n        if(k==n){\n            return true;\n        }\n        boolean res = false;\n        for(int i = 0; i < 2; i++){\n            boolean[] seenc  = new boolean[25];\n            for(int j = 0; j <= 24; j++) seenc[j] = seen[j];\n            seenc[d[k][i]] = true;\n            if(d[k][i]==0) seenc[24] = true;\n            if(d[k][i]==24) seenc[0] = true;\n            for(int j = 0; j <= 24; j++){\n                if(d[k][i]-sub < j && j < d[k][i]+sub) seenc[j] = true;\n                if(d[k][i]-sub < 0 && j > d[k][i]-sub+24) seenc[j] = true;\n                if(d[k][i]+sub > 24 && j < d[k][i]+sub-24) seenc[j] = true;\n            }\n            // for(int g = 0; g <= 24; g++){\n            //     if(seenc[g]) out.print(g);\n            // }\n            // out.println();\n            // out.println(d[k][i]);\n            // if(!seen[d[k][i]])out.println(\"ok\");\n            // else out.println(\"ng\");\n            if(!seen[d[k][i]]){\n                if(d[k][i]==0){\n                    if(!seen[24])res |= f(d, sub, k+1, seenc);\n                } \n                else if(d[k][i]==24){\n                    if(!seen[0])res |= f(d, sub, k+1, seenc);\n                } \n                else res |= f(d, sub, k+1, seenc);\n            }\n        }  \n        return res;\n    }   \n    \n    void run() throws Exception\n    {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        \n        long s = System.currentTimeMillis();\n        solve();\n        out.flush();\n        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n    }\n    \n    public static void main(String[] args) throws Exception { new Main().run(); }\n    \n    private byte[] inbuf = new byte[1024];\n    private int lenbuf = 0, ptrbuf = 0;\n    \n    private int readByte()\n    {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n    \n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n    \n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n    \n    private String ns()\n    {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b) && b != ' ')){\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    \n    private char[] ns(int n)\n    {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    \n    private char[][] nm(int n, int m)\n    {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n    \n    private int[] na(int n)\n    {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n    \n    private int ni()\n    {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private long nl()\n    {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }\n\n    static class ArrayUtils {\n        public static void fill(double[][] array, double value) {\n            for (double[] a : array) Arrays.fill(a, value);\n        }\n \n        public static void fill(double[][][] array, double value) {\n            for (double[][] l : array) fill(l, value);\n        } \n    }\n}", "code2": "loop{\n\nif (target = gets.to_i) == 0\n\tbreak\nend\n\ntime = Array.new(gets.to_i);\n\ntime.size.times do |i|\n\ttime[i] = gets.chomp\n\ttarget = target - (time[i].split(nil)[1].to_i - time[i].split(nil)[0].to_i)\nend\n\nif target <= 0\n\tprint \"OK\\n\"\nelsif\n\tprint target,\"\\n\"\nend\n\n}", "label": 0, "name1": "s840399954.java", "name2": "s022863364.rb"}, {"id": 623, "code1": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tString str = scanner.nextLine();\n\t\tString[] ab = str.split(\" \");\n\t\tint a = Integer.parseInt(ab[0]);\n\t\tint b = Integer.parseInt(ab[1]);\n\t\tif (a > b) {\n\t\t\tSystem.out.println(a - 1);\n\t\t}else {\n\t\t\tSystem.out.println(a);\n\t\t}\n\t\t\n\t\tscanner.close();\n\n\t}\n\n}\n", "code2": "eval\"N,*T=#{`tr \u0001-! ,`}0\"\nz=1\nN.times{|i|a,b=T[N+i,2]\nz=z*[[[a,t=T[i]].min,0,-1[a-t]][s=T[i-1]<=>t],0,(s%3-1)[t-a]][b<=>a]%(10**9+7)}\np z", "label": 0, "name1": "s957138694.java", "name2": "s466517342.rb"}, {"id": 276, "code1": "import java.util.*;\n\nclass Main {\n\tpublic static void main(String args[]) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint m, f, count = 0, sum;\n\t\tm = scanner.nextInt();\n\t\tf = scanner.nextInt();\n\t\twhile(!(m == 0 && f == 0)) {\n\t\t\tfor(int i = 1;i < m+1;i++) {\n\t\t\t\tfor(int j = 1;j < m+1;j++) {\n\t\t\t\t\tfor(int k = 1;k < m+1;k++) {\n\t\t\t\t\t\t\tsum =  i+j+k;\n\t\t\t\t\t\t\tif(sum == f && (i!=j)&&(j!=k)&&(k!=i)) \n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count/(1*2*3));\n\t\t\tcount = 0;\n\t\t\tm = scanner.nextInt();\n\t\t\tf = scanner.nextInt();\n\t\t}\n\t\tscanner.close();\n\t}\n}", "code2": "#!ruby -an\nn,m=$F.map &:to_i\nbreak if n<3\np [*1..n].combination(3).map{|i|i.inject(:+)}.count m", "label": 1, "name1": "s275047149.java", "name2": "s772764129.rb"}, {"id": 939, "code1": "import java.lang.reflect.Array;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static boolean check(int a,int b,int mid){\n        if(a <= mid && b <= mid || a > mid && b > mid)return true;\n        return false;\n    }\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        int array[] = new int[2 * n + 1];\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        for (int i = 1; i < 2 * n; i++)\n            array[i] = Integer.parseInt(st.nextToken());\n        array[0] = array[2 * n] = -1;\n        int infinity = (int) 1E9 + 5;\n        int low = 1;\n        int high = 2 * n;\n        TreeSet<Integer> zero;\n        TreeSet<Integer> ones;\n        while (low < high) {\n            int mid = (low + high) / 2;\n            int temp = -1;\n            zero = new TreeSet<>();\n            ones = new TreeSet<>();\n            ones.add(infinity);\n            ones.add(-infinity);\n            zero.add(infinity);\n            zero.add(-infinity);\n            for (int i = 1; i < 2 * n; i++) {\n                if (check(array[i],array[i - 1],mid) && i != 1) {\n                    //System.out.println(array[i] + \" \" + mid + \" \" + i);\n                    if (array[i] > mid) ones.add(i);\n                    else zero.add(i);\n                }\n                if (check(array[i],array[i + 1],mid) && i != 2*n - 1) {\n                    //System.out.println(array[i] + \" \" + mid + \" \" + i);\n                    if (array[i] > mid) ones.add(i);\n                    else zero.add(i);\n                }\n            }\n                int beforezero = zero.floor(n);\n                int afterzero = zero.ceiling(n);\n                int beforeone = ones.floor(n);\n                int afterone = ones.ceiling(n);\n                int beforemax = Math.max(beforeone, beforezero);\n                int aftermin = Math.min(afterone, afterzero);\n                int min = Math.min(aftermin - n, n - beforemax);\n                //System.out.println(\"1 \" + aftermin + \" \" + beforemax + \" \" + min + \" \" + beforezero + \" \" + afterzero + \" \" + beforeone + \" \" + afterone);\n                if (min == aftermin - n) {\n                    if (afterone < afterzero) temp = 1;\n                    else temp = 0;\n                }\n                if (min == n - beforemax) {\n                    if (beforeone < beforezero) temp = 0;\n                    else temp = 1;\n            }\n            if(min > n - 2){\n                if((n & 1) == 0)temp = (array[n] > mid) ? 0 : 1;\n                else temp = (array[n] > mid) ? 1 : 0;\n            }\n            //System.out.println(mid + \" \" + low + \" \" + high + \" \" + zero + \" \" + ones + \" \" + temp);\n            if (temp == 1) low = mid + 1;\n            else high = mid;\n        }\n        System.out.println(low);\n    }\n}", "code2": "start = Time.now\nD = gets.to_i\n@c = gets.split.map(&:to_i)\n@s = Array.new D\nD.times do |i|\n  @s[i] = gets.split.map(&:to_i)\nend\n\nt = Array.new D\nscore = 0\nlast = Array.new 26, 0\nD.times do |i|\n  best = -99999999999\n  res = nil\n  base_c = 0\n  26.times do |t|\n    base_c += (i - last[t] + 1) * @c[t]\n  end\n  \n  26.times do |t|\n    diff = @s[i][t]\n    diff -= base_c\n    diff += @c[t] * (i - last[t] + 1)\n\n    if diff > best\n      best = diff\n      res = t\n    end\n  end\n  score +=  best\n  last[res] = i + 1\n  t[i] = res\nend\n\n@q = Array.new\ndef calc_pena t\n  kei = Array.new(26, (1+D)*D/2)\n  last = Array.new(26, 0)\n  t.each_with_index do |_t, i|\n    kei[_t] -= (i+1 - last[_t]) * (D - i)\n    last[_t] = i + 1\n  end\n  res = 0\n  26.times do |i|\n    res += kei[i] * @c[i]\n  end\n  res\nend\npena = calc_pena(t)\nbase_score = score + pena\n\nwhile(Time.now - start < 1.9) do\n  100.times do\n    new_t = t.dup\n    new_base_score = base_score\n    (rand(D)+1).times do\n      d = rand(D)\n      old = new_t[d]\n      rep = rand(26)\n      new_t[d] = rep\n      new_base_score = new_base_score - @s[d][old] + @s[d][rep]\n    end\n\n    new_pena = calc_pena(new_t)\n    if new_base_score - new_pena > base_score - pena\n      t = new_t\n      base_score = new_base_score\n      pena = new_pena\n    end\n  end\nend\nt.each do |_t|\n  puts _t + 1\nend", "label": 0, "name1": "s535697054.java", "name2": "s577016088.rb"}, {"id": 815, "code1": "import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long[] a = new long[n];\n        long[] b = new long[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextLong();\n        }\n        for (int i = 0; i < n; i++) {\n            b[i] = sc.nextLong();\n        }\n        long sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += b[i] - a[i];\n        }\n\n        long cnt = 0;\n        for (int i = 0; i < n; i++) {\n            if (a[i] < b[i]) {\n                cnt += (b[i] - a[i] + 1) / 2;\n            }\n        }\n        if (cnt <= sum) {\n            System.out.println(\"Yes\");\n            return;\n        }\n        System.out.println(\"No\");\n    }\n}\n", "code2": "array = gets.split(' ').map(&:to_i)\n\narray.uniq!\n\nif array.count == 2\n  puts \"Yes\"\nelse\n  puts \"No\"\nend", "label": 0, "name1": "s202753514.java", "name2": "s533397443.rb"}, {"id": 393, "code1": "\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scn = new Scanner(System.in);\n\n        long a = scn.nextLong(), b = scn.nextLong(), x = scn.nextLong();\n        long ans = 0;\n\n        ans = (b / x) - (a / x);\n\n        if(a % x == 0){\n            ans++;\n        }\n\n        System.out.println(ans);\n\n    }\n\n}", "code2": "a,b,x=gets.split.map &:to_i\np b/x-(a-1)/x", "label": 1, "name1": "s378055358.java", "name2": "s276778558.rb"}, {"id": 886, "code1": "import java.io.*;\nimport java.math.*;\nimport java.security.*;\nimport java.text.*;\nimport java.util.*;\nimport java.util.stream.*;\nimport java.util.concurrent.*;\nimport java.util.regex.*;\nimport java.util.function.*;\nimport static java.lang.System.out;\n\npublic final class Main {\n    public static void main(String[] args) throws Exception {\n        try (var input = new Reader()) {\n            int k = input.nextInt();\n            int a = input.nextInt();\n          \tint b = input.nextInt();\n          \tfor (int i = a; i <= b; ++i) {\n              \tif (i % k == 0) {\n                  out.printf(\"OK%n\");\n                  return;\n                }\n            }\n          \tout.printf(\"NG%n\");\n        }\n    }\n\n    private static final class Reader implements AutoCloseable {\n        private final int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private FileInputStream fis;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        private Reader() {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        private Reader(String filename) throws IOException {\n            fis = new FileInputStream(filename);\n            din = new DataInputStream(fis);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        private String readLine() throws IOException {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') { break; }\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        private int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') { c = read(); }\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg) { return -ret; }\n            return ret;\n        }\n\n        private long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ') { c = read(); }\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg) { return -ret; }\n            return ret;\n        }\n\n        private double nextDouble() throws IOException {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ') { c = read(); }\n            boolean neg = (c == '-');\n            if (neg) { c = read(); }\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg) { return -ret; }\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1) { buffer[0] = -1; }\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead) { fillBuffer(); }\n            return buffer[bufferPointer++];\n        }\n\n        @Override\n        public void close() throws Exception {\n            if (fis != null) {\n                fis.close();\n            }\n\n            if (din != null) {\n                din.close();\n            }\n        }\n    }\n}\n\n", "code2": "1000.times do\n  puts \"Hello World\"\nend", "label": 0, "name1": "s495906634.java", "name2": "s534011518.rb"}, {"id": 972, "code1": "\nimport java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tC();\n\t}\n\t\n\tpublic static void A() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString s1 = sc.next();\n\t\tString s2 = sc.next();\n\t\tfor(int i=0;i<3;i++) {\n\t\t\tif(s1.charAt(i)!=s2.charAt(2-i)) {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"YES\");\n\t}\n\t\n\t// 1\u304b\u3089\u9806\u306b\uff12\u4e57\u3092\u8a08\u7b97\u3057\u3066\u3001N\u3092\u8d85\u3048\u308b\u304b\u3069\u3046\u304b\u78ba\u8a8d\u3059\u308b\u3002 O(root(N))\n\t//\uff12\u5206\u63a2\u7d22\u3059\u308b\u306a\u3089\u3001O(logN)\n\t// \u4e8c\u5206\u63a2\u7d22\u3067\u3001N\u306e\uff12\u4e57\u3092\u8d85\u3048\u306a\u3044\u6700\u5c0f\u306e\u5e73\u65b9\u6570\u3092\u767a\u898b\n\tpublic static long binsearchN2(long left, long right, int N) {\n\t\tif(left >= right) return (long) Math.pow(right, 2);\n\t\tlong mid = (left+right)/2;\n\t\tif(Math.pow(mid, 2) > N ) return binsearchN2(left, mid-1, N);\n\t\telse {\n\t\t\t//\u7121\u9650\u30eb\u30fc\u30d7\u3092\u9632\u3050\u3000\u518d\u8d77\u3059\u308b\u6642\u306f\u5fc5\u305a\u3001\u63a2\u7d22\u7bc4\u56f2\u304c\uff11\u4ee5\u4e0a\u5c0f\u3055\u304f\u306a\u308b\n\t\t\tif(Math.pow(mid+1, 2) > N) return (long) Math.pow(mid, 2) ;\n\t\t\telse return binsearchN2(mid+1,right, N);\n\t\t}\n\t}\n\t\n\tpublic static void B() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tSystem.out.println(binsearchN2(0,N,N));\n\t}\n\n\t// B\u3092\u4e2d\u5fc3\u306b\u3057\u3066\u4e8c\u5206\u63a2\u7d22\u3057\u3066A\u3068C\u306e\u6570\u3092\u639b\u3051\u5408\u308f\u305b\u308b\n\t//\u3000A\u3092\u4e2d\u5fc3\u3068\u3059\u308b\u3068\u3001O(N^2)\n\t\n\t// B\u3092\u8d85\u3048\u306a\u3044\u8981\u7d20\u6570\u3092\u8fd4\u3059\n\tpublic static void C() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tdouble[] A=new double[N],  C = new double[N];\n\t\tint[] B=new int[N];\n\t\tfor(int i=0;i<N;i++) {\n\t\t\tA[i] = sc.nextDouble();\n\t\t}\n\t\tfor(int i=0;i<N;i++) {\n\t\t\tB[i] = sc.nextInt();\n\t\t}\n\t\tfor(int i=0;i<N;i++) {\n\t\t\tC[i] = sc.nextDouble();\n\t\t}\n\t\tArrays.sort(A);\n\t\tArrays.sort(B);\n\t\tArrays.sort(C);\n\t\tlong sum = 0;\n\t\tfor(int i=0;i<N;i++) {\n\t\t\tdouble b = B[i];\n\t\t\tsum += numlessB(A,b)*(long)numlargerB(C,b);\n\t\t}\n\t\tSystem.out.println(sum);\n\t\t\n\t}\n\t//B\u3088\u308a\u3082\u5c0f\u3055\u3044\u8981\u7d20\u306e\u6570\u3000==B\u306f\u542b\u307e\u306a\u3044 B\u3092\u5c11\u3057\u305a\u3089\u3059\n\tpublic static int numlessB(double[] A, double B){\n\t\tint idx = Arrays.binarySearch(A, B-0.1);\n\t\treturn -idx-1;\n\t}\n\tpublic static int numlargerB(double[] A, double B) {\n\t\tint idx = Arrays.binarySearch(A, B+0.1);\n\t\treturn A.length-(-idx-1);\n\t}\n}\n", "code2": "N = 1000000\n\nsieve = Array.new(N + 1, 0)\n2.upto(Math.sqrt(N).to_i) do |i|\n  next if sieve[i].nonzero?\n  2.upto(N / i) {|j| sieve[i * j] = 1}\nend\n\nnum = (2..N).select {|i| sieve[i].zero?}\n\nuntil (n = $<.gets.to_i).zero?\n  co = 0\n  num.each do |a|\n    b = n - a\n    break if a > b\n    co += 1 if sieve[b].zero?\n  end\n  puts co\nend\n", "label": 0, "name1": "s892418502.java", "name2": "s789375060.rb"}, {"id": 373, "code1": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)924844033;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint ai = io.nextInt();\n\t\t\tint ao = io.nextInt();\n\t\t\tint at = io.nextInt();\n\t\t\tint aj = io.nextInt();\n\t\t\tint al = io.nextInt();\n\t\t\tint as = io.nextInt();\n\t\t\tint az = io.nextInt();\n\t\t\t\n\t\t\tlong ans = 0;\n\t\t\t\n\t\t\tint cnt = aj % 2 + al % 2 + ai % 2;\n\t\t\tif (cnt >= 2) {\n\t\t\t\tif (aj > 0 && al > 0 && ai > 0) {\n\t\t\t\t\tai--;\n\t\t\t\t\taj--;\n\t\t\t\t\tal--;\n\t\t\t\t\tans += 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += ao;\n\t\t\tans += ai / 2 * 2;\n\t\t\tans += aj / 2 * 2;\n\t\t\tans += al / 2 * 2;\n\t\t\t\n\t\t\tio.out.println(ans);\n\t\t}\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n", "code2": "a = gets.split.map(&:to_i)\nans = a[1]\nif (a[0]%2)+(a[3]%2)+(a[4]%2) >= 2 && [a[0], a[3], a[4]].min > 0\n  ans += 3\n  a[0] -= 1\n  a[3] -= 1\n  a[4] -= 1\nend\n\nans += (a[0] / 2) * 2\nans += (a[3] / 2) * 2\nans += (a[4] / 2) * 2\n\nputs ans", "label": 1, "name1": "s961512992.java", "name2": "s995460361.rb"}, {"id": 97, "code1": "import java.util.*;\n\npublic class Main {\n\tvoid solve() {\n\t\tScanner scan = new Scanner(System.in);\n\t\tlong n = scan.nextLong();\n\t\tlong k = scan.nextLong();\n\t\tif(n % k == 0) {\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\t\tn %= k;\n\t\tSystem.out.println(Math.min(n, k - n));\n\t\tscan.close();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\n}\n", "code2": "n, k = gets.rstrip.split(\" \").map { |c| c.to_i}\n\nif n < (n-k).abs then\n  puts n\n  exit\nend\n  \ndiv = n / k\na = n - div*k\nb = a - k\n\nputs [a.abs, b.abs].min", "label": 1, "name1": "s393030652.java", "name2": "s822166626.rb"}, {"id": 548, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main{\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint unko=sc.nextInt();\n\t\tboolean ike=false;\n\t\tint N=0;\n\t\tfor(int i=0; i<=500; i++) {\n\t\t\tif(unko==i*(i+1)/2) {\n\t\t\t\tike=true;\n\t\t\t\tN=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(unko<i*(i+1)/2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ike) {\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\tSystem.out.println(N+1);\n\t\t\tint[][] ary=new int[N+1][N];\n\t\t\tint[] kaz=new int[N+2];\n\t\t\tfor(int i=0; i<=N; i++) {\n\t\t\t\tfor(int j=0; j<N; j++) {\n\t\t\t\t\tary[i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<=N+1; i++) {\n\t\t\t\tkaz[i]=0;\n\t\t\t}\n\t\t\tint counter=1;\n\t\t\tfor(int i=1; i<=N+1; i++) {\n\t\t\t\tfor(int j=1; j<i; j++) {\n\t\t\t\t\tary[i-1][kaz[i-1]]=counter;\n\t\t\t\t\tkaz[i-1]++;\n\t\t\t\t\tary[j-1][kaz[j-1]]=counter;\n\t\t\t\t\tkaz[j-1]++;\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tString buri=\"\";\n\t\t\tfor(int i=0; i<N+1; i++) {\n\t\t\t\tburi=Arrays.toString(ary[i]);\n\t\t\t\tburi=buri.replaceAll(\",\",\"\");\n\t\t\t\tburi=buri.replace(\"[\",\" \");\n\t\t\t\tburi=buri.replace(\"]\",\"\");\n\t\t\t\tSystem.out.println(N+buri);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t}\n}", "code2": "blood = [\"A\", \"B\", \"AB\", \"O\"]\narray = Array.new(4).map{ |i| i=0 }\nwhile s = gets\n  i = blood.index(s.split(\",\")[1].chomp)\n  array[i] += 1\nend\narray.each{ |i| puts i }", "label": 0, "name1": "s468399402.java", "name2": "s356822078.rb"}, {"id": 126, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        int count = Integer.valueOf(reader.readLine());\n        String s = reader.readLine();\n\n        long[][] dp = new long[count][count];\n        dp[0][0] = 1;\n        long modulo = 1_000_000_007;\n\n        for (int i = 1; i < count; ++i) {\n            if (s.charAt(i - 1) == '<') {\n                dp[i][0] = 0;\n                for (int j = 1; j <= i; ++j) {\n                    dp[i][j] = dp[i][j - 1] + dp[i - 1][j - 1];\n                    dp[i][j] %= modulo;\n                }\n            } else {\n                dp[i][i] = 0;\n                for (int j = i - 1; j >= 0; --j) {\n                    dp[i][j] = dp[i][j + 1] + dp[i - 1][j];\n                    dp[i][j] %= modulo;\n                }\n            }\n        }\n\n        long res = 0;\n        for (int i = 0; i < count; ++i) {\n            res += dp[count - 1][i];\n            res %= modulo;\n        }\n        System.out.println(res);\n    }\n}\n", "code2": "d=*1..gets.to_i;gets.bytes{|c|x=0;N=d.pop;d.map!{|a|x+=-c%3*N+a*=1-c%3;x%=10**9+7}};p N", "label": 1, "name1": "s833810272.java", "name2": "s201614079.rb"}, {"id": 413, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n + 2];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tsc.close();\n\n\t\tint sum = 0;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsum += Math.abs(a[i] - a[i + 1]);\n\t\t}\n\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tSystem.out.println(sum + Math.abs(a[i- 1] - a[i + 1])\n\t\t\t\t\t- Math.abs(a[i] - a[i + 1]) - Math.abs(a[i] - a[i - 1]));\n\t\t}\n\t}\n}\n", "code2": "n = gets.to_i\na = gets.split.map(&:to_i).unshift(0).push(0)\nsum = 0\n(n+1).times do |i|\n    sum += (a[i]-a[i+1]).abs\nend\n\nn.times do |i|\n    puts sum-(a[i+1]-a[i]).abs-(a[i+2]-a[i+1]).abs+(a[i]-a[i+2]).abs\nend", "label": 1, "name1": "s784073174.java", "name2": "s272051244.rb"}, {"id": 997, "code1": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nclass Main {\n    static final int MOD = 1000000007;\n    static final int INF = 1 << 30;\n\n    Main() {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.next();\n        for (int i=1; i < s.length(); i++) {\n            String a = s.substring(0, (s.length()-i)/2);\n            String b = s.substring((s.length()-i)/2,s.length()-i);\n            if(a.equals(b)){\n                System.err.println(a);\n                System.out.println(s.length()-i);\n                return;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main();\n    }\n}\n", "code2": "n = gets.chomp.to_i\nt, a = gets.chomp.split.map(&:to_i)\narr = gets.chomp.split.map(&:to_i)\nsa = 10 ** 8\nind = 0\narr.length.times do |i|\n\ttemp = (a - (t - arr[i] * 0.006)).abs\n\tif sa > temp\n\t\tsa = temp\n\t\tind = i\n\tend\nend\nputs ind + 1\n\n", "label": 0, "name1": "s734506720.java", "name2": "s154979799.rb"}, {"id": 929, "code1": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tint mod = 1000000007;\n\t\tlong[][] res =  guessLeaned(1000000007, \n\t\t\t\t1, 4, 16, 84, 516, 3696, 30096, 275040, 2786400, 31000320, 375736320, 928152292\n\t\t\t\t);\n\t\t\n\t\tlong[] u = {1, 4, 16};\n\t\tfor(int i = 3;i <= n;i++){\n\t\t\tlong v = f(res, u, i, mod);\n\t\t\tfor(int j = 0;j < 2;j++){\n\t\t\t\tu[j] = u[j+1];\n\t\t\t}\n\t\t\tu[2] = v;\n\t\t}\n\t\tout.println(u[0]);\n\t}\n\t\n\tpublic static long f(long[][] ged, long[] prevs, long x, int mod)\n\t{\n\t\tint n = ged.length;\n\t\tassert prevs.length == n-1;\n\t\tx -= n-1;\n\t\t\n\t\tlong s = 0;\n\t\tlong tar = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tlong co = 0;\n\t\t\tfor(int j = ged[i].length-1;j >= 0;j--){\n\t\t\t\tco = (co * x + ged[i][j]) % mod;\n\t\t\t}\n\t\t\tif(i < n-1){\n\t\t\t\ts += co * prevs[i];\n\t\t\t\ts %= mod;\n\t\t\t}else{\n\t\t\t\ttar = co;\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong ret = -invl(tar, mod) * s % mod;\n\t\tif(ret < 0)ret += mod;\n\t\treturn ret;\n\t}\n\t\n\tpublic static long[][] guessLeaned(int mod, long... a)\n\t{\n\t\tint n = a.length;\n\t\t\n\t\t// #formula >= #variable\n\t\t// n-r+2 >= r(r+1)/2\n\t\tfor(int r = n;r >= 1;r--){\n\t\t\tif(n-r+2 < r*(r+1)/2)continue;\n\t\t\tint[][] M = new int[n-r+2][r*(r+1)/2];\n\t\t\tfor(int i = 0;i < n-r+1;i++){\n\t\t\t\tint p = 0;\n\t\t\t\tfor(int j = 0;j < r;j++){\n\t\t\t\t\tlong prod = 1;\n\t\t\t\t\tfor(int k = 0;k <= r-j-1;k++){\n\t\t\t\t\t\tM[i][p++] = (int)(prod*a[i+j]%mod);\n\t\t\t\t\t\tprod = prod * i % mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tM[n-r+1][0] = 1;\n\t\t\t\n\t\t\tint[] v = new int[n-r+2];\n\t\t\tv[n-r+1] = 1;\n\t\t\t\n\t\t\tResult res = gaussElimination(M, v, mod);\n\t\t\tif(res.exists){\n\t\t\t\tlong[][] ret = new long[r][];\n\t\t\t\tint p = 0;\n\t\t\t\tfor(int i = 0;i < r;i++){\n\t\t\t\t\tret[i] = new long[r-i];\n\t\t\t\t\tfor(int j = 0;j < r-i;j++){\n\t\t\t\t\t\tret[i][j] = res.sol[p++];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic static Result gaussElimination(int[][] M, int[] v, int mod)\n\t{\n\t\tint n = M.length, m = M[0].length;\n\t\tint[] head = new int[n];\n\t\t\n\t\t// if not needed, comment out.\n\t\tfor(int[] row : M){\n\t\t\tfor(int i = 0;i < row.length;i++){\n\t\t\t\trow[i] %= mod;\n\t\t\t\tif(row[i] < 0)row[i] += mod;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Forward Elimination\n\t\tint row = 0;\n\t\tfor(int col = 0;col < m;col++){\n\t\t\t// select pivot\n\t\t\tboolean pivotFound = false;\n\t\t\tout:\n\t\t\tfor(int prow = row;prow < n;prow++){\n\t\t\t\tif(M[prow][col] != 0){\n\t\t\t\t\t// pivot found\n\t\t\t\t\tif(prow != row){\n\t\t\t\t\t\t// swap rows\n\t\t\t\t\t\tfor(int k = 0;k < m;k++){\n\t\t\t\t\t\t\tint u = M[prow][k]; M[prow][k] = M[row][k]; M[row][k] = u;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint dum = v[prow]; v[prow] = v[row]; v[row] = dum;\n\t\t\t\t\t}\n\t\t\t\t\tpivotFound = true;\n\t\t\t\t\tbreak out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!pivotFound)continue;\n\t\t\thead[row] = col;\n\t\t\t\n\t\t\t// diag to 1\n\t\t\tlong imul = invl(M[row][col], mod);\n\t\t\tfor(int k = 0;k < m;k++){\n\t\t\t\tM[row][k] = (int)(M[row][k] * imul % mod);\n\t\t\t}\n\t\t\tv[row] = (int)(v[row] * imul % mod);\n\t\t\t\n\t\t\tfor(int j = row+1;j < n;j++){\n\t\t\t\tif(M[j][col] != 0){\n\t\t\t\t\tlong mul = mod-M[j][col];\n\t\t\t\t\tfor(int k = col;k < m;k++){\n\t\t\t\t\t\tM[j][k] = (int)((M[j][k] + M[row][k] * mul) % mod);\n\t\t\t\t\t}\n\t\t\t\t\tv[j] = (int)((v[j] + v[row] * mul) % mod);\n\t\t\t\t}\n\t\t\t}\n\t\t\trow++;\n\t\t}\n\t\t\n\t\tResult ret = new Result();\n\t\tret.mat = M;\n\t\tfor(int i = row;i < n;i++){\n\t\t\tif(v[i] != 0){\n\t\t\t\tret.rank = row;\n\t\t\t\tret.exists = false;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = row-1;i >= 0;i--){\n\t\t\tfor(int j = i-1;j >= 0;j--){\n\t\t\t\tif(M[j][head[i]] != 0){\n\t\t\t\t\tlong mul = mod-M[j][head[i]];\n\t\t\t\t\tfor(int k = head[i];k < m;k++){\n\t\t\t\t\t\tM[j][k] = (int)((M[j][k] + M[i][k] * mul) % mod);\n\t\t\t\t\t}\n\t\t\t\t\tv[j] = (int)((v[j] + v[i] * mul) % mod);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] retv = new int[m];\n\t\tfor(int i = 0;i < row;i++){\n\t\t\tretv[head[i]] = v[i];\n\t\t}\n\t\t\n\t\tret.sol = retv;\n\t\tret.rank = row;\n\t\tret.exists = true;\n\t\treturn ret;\n\t}\n\t\n\tpublic static class Result\n\t{\n\t\tpublic int[][] mat;\n\t\tpublic int[] sol;\n\t\tpublic int rank;\n\t\tpublic boolean exists;\n\t}\n\t\n\tpublic static long invl(long a, long mod) {\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\treturn p < 0 ? p + mod : p;\n\t}\n\n\n\t\n\tpublic static long C(int n, int r, int mod, int[][] fif) {\n\t\tif (n < 0 || r < 0 || r > n)\n\t\t\treturn 0;\n\t\treturn (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n\t}\n\n\t\n\tpublic static int[][] enumFIF(int n, int mod) {\n\t\tint[] f = new int[n + 1];\n\t\tint[] invf = new int[n + 1];\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i] = (int) ((long) f[i - 1] * i % mod);\n\t\t}\n\t\tlong a = f[n];\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\tinvf[n] = (int) (p < 0 ? p + mod : p);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tinvf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n\t\t}\n\t\treturn new int[][] { f, invf };\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n", "code2": "n,*a=`dd`.split.map &:to_i;p (1..2*n).bsearch(&->x{b=a.map{|e|e<x};1.upto(n){|i|[-1,1].map{|f|return x if b[n+i*f-1]==x=b[n+i*f-f-1]}};b[0]})-1", "label": 0, "name1": "s195205493.java", "name2": "s095757920.rb"}, {"id": 429, "code1": "import java.util.*;\n\npublic class Main {\n\tpublic static HashMap<String,HashSet<String>> map;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tmap = new HashMap<String, HashSet<String>>();\n\t\t\tString first = null;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tString[] s = sc.next().split(\":\");\n\t\t\t\tif(i == 0) first = s[0];\n\t\t\t\ts[1] = s[1].replaceAll(\"\\\\.\", \"\");\n\t\t\t\tString[] ss = s[1].split(\",\");\n\t\t\t\tmap.put(s[0], new HashSet<String>());\n\t\t\t\tfor(String tmp : ss){\n\t\t\t\t\tmap.get(s[0]).add(tmp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(String si : map.keySet()){\n\t\t\t\tfor(String sj : map.keySet()){\n\t\t\t\t\tif(map.get(si).contains(sj)){\n\t\t\t\t\t\tmap.get(si).remove(sj);\n\t\t\t\t\t\tmap.get(si).addAll(map.get(sj));\n\t\t\t\t\t}\n\t\t\t\t\tif(map.get(sj).contains(si)){\n\t\t\t\t\t\tmap.get(sj).remove(si);\n\t\t\t\t\t\tmap.get(sj).addAll(map.get(si));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(map.get(first).size());\n\t\t}\n\t}\n/*\n\tpublic static HashSet<String> solve(String group){\n\t\tfor(String s : map.get(group)){\n\n\t\t}\n\n\t}\n\t*/\n}", "code2": "def find(x, root)\n  return unless @group[x]\n  return true if @group[x].include?(root)\n  @group[x].each do |m|\n    return true if find(m, root)\n  end\n  false\nend\n\nwhile n = gets.to_i\n  break if n == 0\n  root = ''\n  @group = {}\n  n.times do |i|\n    g, m = gets.split(':')\n    root = g if i == 0\n    ms = m[0..-3].split(',')\n    ms.each{ |m| @group[m] ||= []; @group[m] << g }\n  end\n  cnt = 0\n  leaf = @group.keys\n  @group.values.each{ |vs| vs.each{ |v| leaf.delete(v) } }\n  leaf.each do |name|\n    if find(name, root)\n      cnt += 1\n    end\n  end\n  p cnt\nend", "label": 1, "name1": "s038642140.java", "name2": "s748086673.rb"}, {"id": 166, "code1": "import java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tchar[] s = sc.next().toCharArray();\n\t\tStack<Character> st = new Stack<>();\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < s.length; i++) {\n\t\t\tif (s[i] == 'T') {\n\t\t\t\tif (st.isEmpty()) cnt++;\n\t\t\t\telse st.pop();\n\t\t\t} else {\n\t\t\t\tst.push('S');\n\t\t\t}\n\t\t}\n\t\tcnt += st.size();\n\t\tSystem.out.println(cnt);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}", "code2": "r=0;gets.bytes.map{|c|c>83?r<0&&r+=1:r-=1};p~r*2", "label": 1, "name1": "s350666247.java", "name2": "s239261496.rb"}, {"id": 86, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tint[] num = new int[4];\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tString st =sc.nextLine().split(\",\")[1];\n\t\t\tif(st.equals(\"A\")){\n\t\t\t\tnum[0]++;\n\t\t\t}else if(st.equals(\"B\")){\n\t\t\t\tnum[1]++;\n\t\t\t}else if(st.equals(\"AB\")){\n\t\t\t\tnum[2]++;\n\t\t\t}else if(st.equals(\"O\")){\n\t\t\t\tnum[3]++;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < num.length ; i++){\n\t\t\tSystem.out.println(num[i]);\n\t\t}\n\t\tsc.close();\n\t}\n}", "code2": "h=Hash.new(0)\n$<.map{|l|h[l.strip.split(?,)[1]]+=1}\np h[?A],h[?B],h[\"AB\"],h[?O]", "label": 1, "name1": "s769605617.java", "name2": "s836086969.rb"}, {"id": 260, "code1": "import java.util.*;\n \nclass Main{\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n \n        String S = sc.next();\n        String T = sc.next();\n        int ls = S.length();\n        int lt = T.length();\n        String a = \"?\";\n\n        if(ls<lt){\n            System.out.println(\"UNRESTORABLE\");\n            return;\n        }\n        int x = -1;\n        for(int i=0; i<=ls-lt; i++){\n            if(S.charAt(i)==T.charAt(0) || S.charAt(i)==a.charAt(0)){\n                for(int j=0; j<lt; j++){\n                    if(S.charAt(i+j)!=T.charAt(j) && S.charAt(i+j)!=a.charAt(0)){\n                        break;\n                    }\n                    if(j==lt-1){\n                        x = i;\n                    }\n                }\n            }\n        }\n        if(x==-1){\n            System.out.println(\"UNRESTORABLE\");\n            return;\n        }\n        else if(ls==lt){\n            S = T;\n            System.out.println(S);\n            return;\n        }\n        else if(x==0){\n            S = T + S.substring(lt);\n        }\n        else if(x!=0){\n            if(x+lt-1==ls){\n                S = S.substring(0, x) + T;\n            }\n            else{\n                S = S.substring(0, x) + T + S.substring(x + lt);\n            }\n        }\n        String st = \"\";\n        for(int i=0; i<ls; i++){\n            if(S.charAt(i)==a.charAt(0)){\n                st += \"a\";\n            }\n            else{\n                st += String.valueOf((char)S.charAt(i));\n            }\n        }\n        System.out.println(st);\n    }\n}", "code2": "s = gets.chomp\nt = gets.chomp\n\nans = nil\n(s.length - t.length + 1).times do |i|\n    sr = s.dup\n    result = true\n    (t.length).times do |j|\n        if s[i+j] == '?' || s[i+j] == t[j]\n            sr[i+j] = t[j]\n        else\n            result = false\n            break\n        end\n    end\n    if result\n        sr.gsub!('?', 'a')\n        ans ||= sr\n        ans = sr if ans > sr\n    end\nend\n\nputs ans || 'UNRESTORABLE'", "label": 1, "name1": "s748827885.java", "name2": "s810348721.rb"}, {"id": 654, "code1": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint cnt(int s,int g,int cnt,int xy[][],int n){\n\t\tint result = 0;\n\t\tint c[] = new int [n+1];\n\t\tint d[] = new int [n+1];\n\t\tc[s] = 1;\n\t\tif(s == g && cnt > 0)result = 1;\n\t\tfor(int i = 1;i < cnt;i++){\n\t\t\tfor(int j = 1;j < n+1;j++){\n\t\t\t\tfor(int k = 1;k < n+1;k++){\n\t\t\t\t\tif(xy[j][k] == 1 && c[j] == i){\n\t\t\t\t\t\td[k] = i + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 1;j < n+1;j++){\n\t\t\t\tc[j] = d[j];\n\t\t\t}\n\t\t\tif(c[g] > 0){\n\t\t\t\tresult = c[g];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(i == 101){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tvoid doIt() { \n\t\tint n = sc.nextInt();\n\t\tint xy[][] = new int [n+1][n+1];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint r1 = sc.nextInt();\n\t\t\tint k1 = sc.nextInt();\n\t\t\tfor(int j = 0;j < k1;j++){\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\txy[r1][t] = 1;\n\t\t\t}\n    \t }\n\t\tint p = sc.nextInt();\n\t\tfor(int i = 0;i < p;i++){\n\t\t\tint s = sc.nextInt();\n\t\t\tint d = sc.nextInt();\n\t\t\tint TTL = sc.nextInt();\n\t\t\tint ans = cnt(s,d,TTL,xy,n);\n\t\t\tif(ans == 0){\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t//\u4e2d\u8eab\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\tSystem.out.print(xy[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t*/\n     }\n    public static void main(String[] args) {\n    \t// TODO Auto-generated method stub\n    \tnew Main().doIt();\n    }\n}", "code2": "n = gets.to_i\na = gets.chomp.split(' ').map(&:to_i)\n\ncnt = 0\n\na.each_with_index do |num,idx|\n    if idx+1 < num\n        if a[num-1] == idx+1\n            cnt+=1\n        end\n    end\nend\n\nputs cnt", "label": 0, "name1": "s130494609.java", "name2": "s867955134.rb"}, {"id": 936, "code1": "    import java.io.*;\n    import java.util.*;\n\n    public class Main {\n        public static void main(String[] args) throws IOException {\n            FastReader scan = new FastReader();\n            //PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(\"taming.out\")));\n            PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n            Task solver = new Task();\n            //int t = scan.nextInt();\n            int t = 1;\n            for(int i = 1; i <= t; i++) solver.solve(i, scan, out);\n            out.close();\n        }\n        static class Task {\n            boolean[][] matrix;\n            boolean[][] vis;\n            public void solve(int testNumber, FastReader sc, PrintWriter pw){\n                int n = sc.nextInt();\n                int m = sc.nextInt();\n                matrix = new boolean[n][m];\n                vis = new boolean[n][m];\n                long sum = 0;\n                for(int i=0;i<n;i++){\n                    String str = sc.nextLine();\n                    for(int j=0;j<m;j++){\n                        matrix[i][j]=(str.charAt(j)=='#');\n                    }\n                }\n                for(int i=0;i<n;i++){\n                    for(int j=0;j<m;j++){\n                        if(!vis[i][j]){\n                            int[] x = dfs(i,j,matrix[i][j]);\n                            sum+=((long)(x[0]))*x[1];\n                        }\n                    }\n                }\n                pw.println(sum);\n            }\n            public int[] dfs (int x, int y, boolean c){\n                int[] dx = {-1,1,0,0};\n                int[] dy = {0,0,-1,1};\n                if(x<0||y<0||x>=matrix.length||y>=matrix[0].length||vis[x][y]||matrix[x][y]!=c){\n                    return new int[]{0,0};\n                }\n                int a = 0;\n                int b = 0;\n                vis[x][y]=true;\n                if(c){\n                    a++;\n                }\n                else{\n                    b++;\n                }\n                for(int i=0;i<4;i++){\n                    int[] tt = dfs(x+dx[i],y+dy[i],!c);\n                    a+=tt[0];\n                    b+=tt[1];\n                }\n                return new int[]{a,b};\n            }\n        }\n        static class tup implements Comparable<tup> {\n            int a, b;\n            tup() {\n            }\n            ;\n\n\n\n            tup(int a, int b) {\n                this.a=a;\n                this.b=b;\n            }\n\n            @Override\n            public int compareTo(tup o2) {\n                return 0;\n            }\n        }\n        static void shuffle(long[] a) {\n            Random get = new Random();\n            for (int i = 0; i < a.length; i++) {\n                int r = get.nextInt(a.length);\n                long temp = a[i];\n                a[i] = a[r];\n                a[r] = temp;\n            }\n        }\n        static void shuffle(int[] a) {\n            Random get = new Random();\n            for (int i = 0; i < a.length; i++) {\n                int r = get.nextInt(a.length);\n                int temp = a[i];\n                a[i] = a[r];\n                a[r] = temp;\n            }\n        }\n        static void shuffle(int[] a,int l, int rb) {\n            Random get = new Random();\n            for (int i = l; i < rb; i++) {\n                int r = get.nextInt(a.length);\n                int temp = a[i];\n                a[i] = a[r];\n                a[r] = temp;\n            }\n        }\n        static class FastReader {\n            BufferedReader br;\n            StringTokenizer st;\n\n            public FastReader() {\n                br = new BufferedReader(new InputStreamReader(System.in));\n            }\n\n            public FastReader(String s) throws FileNotFoundException {\n                br = new BufferedReader(new FileReader(new File(s)));\n            }\n\n            String next() {\n                while (st == null || !st.hasMoreElements()) {\n                    try {\n                        st = new StringTokenizer(br.readLine());\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n                return st.nextToken();\n            }\n\n            int nextInt() {\n                return Integer.parseInt(next());\n            }\n\n            long nextLong() {\n                return Long.parseLong(next());\n            }\n\n            double nextDouble() {\n                return Double.parseDouble(next());\n            }\n\n            String nextLine() {\n                String str = \"\";\n                try {\n                    str = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                return str;\n            }\n        }\n\n    }", "code2": "start = Time.now\nD = gets.to_i\n@c = gets.split.map(&:to_i)\n@s = Array.new D\nD.times do |i|\n  @s[i] = gets.split.map(&:to_i)\nend\n\nt = Array.new D\nscore = 0\nlast = Array.new 26, 0\nD.times do |i|\n  best = -99999999999\n  res = nil\n  base_c = 0\n  26.times do |t|\n    base_c += (i - last[t] + 1) * @c[t]\n  end\n  \n  26.times do |t|\n    diff = @s[i][t]\n    diff -= base_c\n    diff += @c[t] * (i - last[t] + 1)\n\n    if diff > best\n      best = diff\n      res = t\n    end\n  end\n  score +=  best\n  last[res] = i + 1\n  t[i] = res\nend\n\n@q = Array.new\ndef calc_pena t\n  kei = Array.new(26, (1+D)*D/2)\n  last = Array.new(26, 0)\n  t.each_with_index do |_t, i|\n    kei[_t] -= (i+1 - last[_t]) * (D - i)\n    last[_t] = i + 1\n  end\n  res = 0\n  26.times do |i|\n    res += kei[i] * @c[i]\n  end\n  res\nend\npena = calc_pena(t)\nbase_score = score + pena\n\nwhile(Time.now - start < 1.9) do\n  100.times do\n    new_t = t.dup\n    new_base_score = base_score\n    (rand(D)+1).times do\n      d = rand(D)\n      old = new_t[d]\n      rep = rand(26)\n      new_t[d] = rep\n      new_base_score = new_base_score - @s[d][old] + @s[d][rep]\n    end\n\n    new_pena = calc_pena(new_t)\n    if new_base_score - new_pena > base_score - pena\n      t = new_t\n      base_score = new_base_score\n      pena = new_pena\n    end\n  end\nend\nt.each do |_t|\n  puts _t + 1\nend", "label": 0, "name1": "s881420756.java", "name2": "s577016088.rb"}, {"id": 179, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[][] field;\n\tstatic String[][] dp;\n\tstatic int h,w;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = cin.nextInt();\n\t\t\th = cin.nextInt();\n\t\t\tif(w+h==0)break;\n\t\t\tfield=new int[h][w];\n\t\t\tdp=new String[h][w];\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tString s = cin.next();\n\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\tdp[i][j]=\"\";\n\t\t\t\t\tif(Character.isDigit(s.charAt(j))){\n\t\t\t\t\t\tfield[i][j]=s.charAt(j)-'0';\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tfield[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i<w;i++){\n\t\t\t\tif(i==0){\n\t\t\t\t\tif(field[0][i]<=0){\n\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdp[0][i]=\"\"+field[0][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(field[0][i]==-1){\n\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(!dp[0][i-1].equals(\"0\")&&!dp[0][i-1].equals(\"\")){\n\t\t\t\t\t\t\tdp[0][i]=dp[0][i-1]+field[0][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[0][i]=\"\"+field[0][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tif(i==0){\n\t\t\t\t\tif(field[i][0]<=0){\n\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdp[i][0]=\"\"+field[i][0];\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(field[i][0]==-1){\n\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(!dp[i-1][0].equals(\"0\")&&!dp[i-1][0].equals(\"\")){\n\t\t\t\t\t\t\tdp[i][0]=dp[i-1][0]+field[i][0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i][0]=\"\"+field[i][0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tString ans=\"0\";\n\t\t\tfor(int i = 1;i<h;i++){\n\t\t\t\tfor(int j = 1;j<w;j++){\n\t\t\t\t\tif(field[i][j]==-1)continue;\n\t\t\t\t\tString s1=dp[i-1][j]+field[i][j];\n\t\t\t\t\tString s2=dp[i][j-1]+field[i][j];\n\t\t\t\t\tString s3=field[i][j]+\"\";\n\t\t\t\t\tif(big(s1,s2)>=0){\n\t\t\t\t\t\tif(big(s1,s3)>=0){\n\t\t\t\t\t\t\tdp[i][j]=s1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i][j]=s3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(big(s2,s3)>=0){\n\t\t\t\t\t\t\tdp[i][j]=s2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i][j]=s3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\twhile(dp[i][j].charAt(0)=='0'&&dp[i][j].length()>1){\n\t\t\t\t\t\tdp[i][j]=dp[i][j].substring(1,dp[i][j].length());\n\t\t\t\t\t}\n\t\t\t\t\tif(big(dp[i][j],ans)>0){\n\t\t\t\t\t\tans=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\tif(big(dp[i][j],ans)>0){\n\t\t\t\t\t\tans=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//output();\n\t\t\tSystem.out.println(ans);\n\t\t}\n\n\t}\n\tstatic int big(String s1,String s2){\n\t\tif(s1.length()==s2.length()){\n\t\t\treturn s1.compareTo(s2);\n\t\t}\n\t\treturn s1.length()-s2.length();\n\t}\n\tstatic void output(){\n\t\tfor(int i = 0;i<h;i++){\n\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\tSystem.out.print(dp[i][j]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n}", "code2": "def isalpha(c)\n  c.to_i.to_s != c\nend\n\ndef search(x, y, w, h, mat, values)\n  q = []\n  q << [x, y]\n  until q.empty?\n    px, py = q.shift\n    [[0, 1], [1, 0]].each do |mx, my|\n      x = px + mx; y = py + my\n      if x < w && y < h && mat[y][x]\n        if (old = values[y][x]) < (now = (values[py][px].to_s + mat[y][x]).to_i)\n          values[y][x] = now\n          q << [x, y] if old == 0\n        end\n      end\n    end\n  end\n  values\nend\n\ndef solve(w, h, mat)\n  values = h.times.map{ [0] * w }\n  h.times do |y|\n    w.times do |x|\n      if mat[y][x]\n        values[y][x] = mat[y][x].to_i if mat[y][x].to_i > values[y][x]\n        values = search(x, y, w, h, mat, values)\n      end\n    end\n  end\n  values.flatten.max\nend\n\n\nwhile l = gets\n  w, h = l.split.map(&:to_i)\n  break if w == 0 && h == 0\n  mat = h.times.map { gets.chomp }\n  mat.map!{ |m| m.split('').map{ |c| isalpha(c) ? false : c } }\n  puts solve(w, h, mat)\nend", "label": 1, "name1": "s061375468.java", "name2": "s437743864.rb"}, {"id": 817, "code1": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\n\t\tint n = sc.nextInt();\n\n\t\tint a[] = new int[n];\n\t\tint b[] = new int[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tb[i] = sc.nextInt();\n\t\t}\n\n\t\tlong ba = 0;\n\t\tlong ab = 0;\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (b[i] > a[i]) {\n\t\t\t\tba += (b[i] - a[i]) / 2;\n\t\t\t} else {\n\t\t\t\tab += (a[i] - b[i]);\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tSystem.out.println(ab <= ba ? \"Yes\" : \"No\");\n\t}\n}\n", "code2": "a, b, c = gets.split.map(&:to_i)\n\nputs (a==b && a==c && b == c) || (a != b && a != c && c != b) ? \"No\": \"Yes\"", "label": 0, "name1": "s582242118.java", "name2": "s674156319.rb"}, {"id": 981, "code1": "import java.util.Scanner;\n\nclass Main {\n    private static boolean[] calcPrimeTable(int n) {\n        boolean[] table = new boolean[n + 1];\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (!table[i]) {\n                for (int j = i + i; j <= n; j += i) {\n                    table[j] = true;\n                }\n            }\n        }\n        return table;\n    }\n\n    private static void solve() {\n        boolean[] table = calcPrimeTable(1000000);\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            int n = scanner.nextInt();\n            int counter = 0;\n            if (n == 0) {\n                break;\n            }\n            for (int i = 2; i <= n / 2; i++) {\n                if (!table[i] && !table[n - i]) {\n                    counter++;\n                }\n            }\n            System.out.println(counter);\n        }\n    }\n\n    public static void main(String... args) {\n        solve();\n    }\n}", "code2": "n,*a=`dd`.split.map &:to_i;a.sort!;r=0;b=[0]+n.times.map{|j|a[j]*(-1)**j%24};s=24;n.times{|j|(j+1..n).each{|k|s=[s,(b[j]-b[k])%24,(b[k]-b[j])%24].min}};r=[r,s].max;p r", "label": 0, "name1": "s735863296.java", "name2": "s643709986.rb"}, {"id": 563, "code1": "import java.util.*;\n\npublic class Main{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    long n = sc.nextLong();\n    long k = sc.nextLong();\n\n    long a = n % k;\n    long b = Math.abs(a - k);\n\n    if(a>b){\n      System.out.println(b);\n    }else{\n      System.out.println(a);\n    }\n\n\n  }\n}", "code2": "#! /usr/bin/env ruby\n\nabc = gets.split(\" \")\n\na = abc[0].to_i\nb = abc[1].to_i\nc = abc[2].to_i\n\n\n\n\nif( (a <= c && b >= c) || (a >= c && b <= c) )\n\n    puts \"Yes\"\n  else\n    puts \"No\" \nend", "label": 0, "name1": "s483882254.java", "name2": "s075380624.rb"}, {"id": 199, "code1": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\npublic class Main {\n\tstatic final long C =  1000000007;\n\tstatic final int CY = 1000000000;\n\tstatic final int INF = Integer.MAX_VALUE/2;\n\tStringBuilder sb;\n\t//\u30bb\u30c3\u30c8\n\tclass Set<F,S> {\n\t\tF f;\n\t\tS s;\n\t\tSet(F f, S s) {this.f = f;this.s = s;}\n\t}\n\tpublic void calc() {\n\t\tsb = new StringBuilder();\n\n\n\t\tIO sc = new IO();\n\n\t\tint n = sc.nextInt();\n\t\tint[] t = sc.nextIntArray(n);\n\t\tint[] a = sc.nextIntArray(n);\n\n\n\t\tlong ans = 1;\n\t\t//BigInteger bi = new BigInteger(\"1\");\n\t\tint[] min = new int[n];\n\t\tint[] max = new int[n];\n\t\tArrays.fill(min, 1);\n\t\tArrays.fill(max, INF);\n\t\tint b = -1, nb = -1;\n\t\tfor (int i=0; i < n; i++) {\n\t\t\t//System.out.println(\"t\" + i);\n\t\t\tint ni = n-1-i;\n\t\t\tif (b != t[i]) {\n\t\t\t\tmax[i] = Math.min(max[i],t[i]);\n\t\t\t\tmin[i] = Math.max(min[i],t[i]);\n\t\t\t\tb = t[i];\n\t\t\t}else {\n\t\t\t\tmax[i] = Math.min(max[i],t[i]);\n\t\t\t}\n\t\t\tif (nb != a[ni]) {\n\t\t\t\tmax[ni] = Math.min(max[ni],a[ni]);\n\t\t\t\tmin[ni] = Math.max(min[ni],a[ni]);\n\t\t\t\tnb = a[ni];\n\t\t\t}else {\n\t\t\t\tmax[ni] = Math.min(max[ni],a[ni]);\n\t\t\t}\n\n\t\t}\n\n\t\tfor (int i=0; i < n; i++) {\n\t\t\t//System.out.println(min[i] + \":\" + max[i]);\n\t\t\tif (max[i] - min[i] < 0) {\n\t\t\t\tSystem.out.println(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tans *= max[i] - min[i] +1;\n\t\t\tans %= C;\n\t\t\t//bi = bi.multiply(new BigInteger((max[i] - min[i] +1)+\"\" ));\n\n\t\t}\n\n\n\t\tSystem.out.println(ans);\n\t}\n\n\n\tpublic static void main(String[] args) {\n\t\tMain main = new Main();\n\t\tmain.calc();\n\n\t}\n}\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}\n\n", "code2": "M=10**9+7\ngets\nhw=0;t=gets.split.map{|s|[hw<hw=h=s.to_i,h]}\nhw=0;a=gets.split.reverse.map{|s|[hw<hw=h=s.to_i,h]}.reverse\np t.zip(a).reduce(1){|p,((f1,h1),(f2,h2))|\n  break 0 if f1&&f2&&h1!=h2 || f1&&!f2&&h1>h2 || !f1&&f2&&h1<h2\n  !f1&&!f2 ? p*[h1,h2].min%M : p\n}\n", "label": 1, "name1": "s145899300.java", "name2": "s443550692.rb"}, {"id": 155, "code1": "import java.io.*;\nimport java.util.*;\n \npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n \n    static class TaskD {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n \n            int N = in.nextInt();\n            for (int i = 0; i < N; i++) {\n                long A = in.nextLong();\n                long B = in.nextLong();\n \n                long a = Math.min(A, B);\n                long b = Math.max(A, B);\n \n                long ans = 2L * (a - 1) + przedzial(a, b);\n \n                out.println(ans);\n            }\n        }\n \n        private long przedzial(long a, long b) {\n            if (a == b || a + 1 == b) {\n                return 0;\n            }\n \n            return 1L + szukaj(a + 1, b - 2, a * b);\n        }\n \n        private long szukaj(long a, long b, long LIMIT) {\n            if (a > b) return 0;\n            if (a == b) {\n                return a * b < LIMIT ? 1 : 0;\n            }\n            long lo = a, hi = b;\n            while (lo + 1 < hi) {\n                long m = lo + (hi - lo) / 2;\n                if (m * m >= LIMIT) {\n                    hi = m;\n                } else {\n                    lo = m;\n                }\n            }\n            long ans1 = 1 + 2L * (lo - 1 - a + 1);\n            long ans2 = 0;\n            if (lo * (lo + 1) < LIMIT) {\n                ans2 = 2L * (lo - a + 1);\n            }\n            return Math.max(ans1, ans2);\n        }\n    }\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n    }\n}", "code2": "gets.to_i.times{\n\ta,b=gets.split.map &:to_i\n\tt=a*b\n\ts=Math.sqrt(t).to_i\n\tr=2*s-2\n\tr-=1 if s*s==t\n\tr+=1 if s*(s+1)<t\n\tr+=1 if a==b\n\tp r\n}", "label": 1, "name1": "s546530291.java", "name2": "s605229317.rb"}, {"id": 962, "code1": "import java.util.*;\npublic class Main {\n\n\tpublic static void main(String[] args) {\t\t\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt(), C = sc.nextInt();\n\t\tint D[][] = new int[C][C];\n\t\tint c[][] = new int[N][N];\n\t\t\n\t\tfor(int i=0;i<C;i++) {\n\t\t\tfor(int j=0;j<C;j++) {\n\t\t\t\tD[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\t\n\t\t//\u30ef\u30fc\u30b7\u30e3\u30eb\u30d5\u30ed\u30a4\u30c9\n//\t\tfor(int k=0;k<C;k++) {\n//\t\t\tfor(int i=0;i<C;i++) {\n//\t\t\t\tfor(int j=0;j<C;j++) {\n//\t\t\t\t\tD[i][j]=Math.min(D[i][j], D[i][k]+D[k][j]);\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n\t\t\n\t\tfor(int i=0;i<N;i++) {\n\t\t\tfor(int j=0;j<N;j++) {\n\t\t\t\tc[i][j] = sc.nextInt()-1;//0index\n\t\t\t}\n\t\t}\n\t\tsc.close(); \n\t\t\n\t\tint costSum0[] = new int[C]; //%3==0\n\t\tint costSum1[] = new int[C];\n\t\tint costSum2[] = new int[C];\n\t\t\n\t\tfor(int color=0;color<C;color++) {\n\t\t\tfor(int i=0;i<N;i++) {\n\t\t\t\tfor(int j=0;j<N;j++) {\n\t\t\t\t\tint nowColor = c[i][j];\n\t\t\t\t\tif((i+j)%3==0) costSum0[color] += D[nowColor][color];\n\t\t\t\t\tif((i+j)%3==1) costSum1[color] += D[nowColor][color];\n\t\t\t\t\tif((i+j)%3==2) costSum2[color] += D[nowColor][color];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = Integer.MAX_VALUE/2;\n\t\t//\u4f59\u308a\uff11\u306e\u3068\u3053\u308d\u5168\u901a\u308a\n\t\tfor(int i=0;i<C;i++) {\n\t\t\tfor(int j=0;j<C;j++) {\n\t\t\t\tfor(int k=0;k<C;k++) {\n\t\t\t\t\tif(i==j||j==k||k==i)continue;\n\t\t\t\t\tint sum = costSum0[i]+costSum1[j]+costSum2[k];\n\t\t\t\t\tans = Math.min(ans,sum);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}", "code2": "n = gets.to_i\nas = gets.chomp.split.map(&:to_i).sort\nbs = gets.chomp.split.map(&:to_i).sort\ncs = gets.chomp.split.map(&:to_i).sort\n\ncnt = 0\n\nbs.each do |b|\n  a_idx = as.bsearch_index{|x| x >= b} || n\n  c_idx = cs.bsearch_index{|x| x > b} || n\n  cnt += a_idx * (n - c_idx) \nend\n\nputs cnt\n", "label": 0, "name1": "s992887092.java", "name2": "s704220285.rb"}, {"id": 485, "code1": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int a[][] = new int[n][n];\n\n        for (int i = 0; i < m; i++) {\n            int t1 = in.nextInt() - 1;\n            int t2 = in.nextInt() - 1;\n            a[t1][t2] = 1;\n            a[t2][t1] = 1;\n        }\n        List<Integer> order = new ArrayList<>();\n        order.add(0);\n        List<Integer> remain = new ArrayList<>();\n        for (int i = 1; i < n; i++) {\n            remain.add(i);\n        }\n        System.out.println(f(order, remain, a));\n    }\n\n    static int f(List<Integer> order, List<Integer> remain, int edges[][]) {\n        if (remain.size() == 0) {\n            int cur = order.get(0);\n            int next;\n            for (int p = 1; p < order.size(); p++) {\n                next = order.get(p);\n                if (edges[cur][next] == 1 || edges[next][cur] == 1) {\n                    cur = next; \n                } else {\n                    return 0;\n                }\n            }\n            return 1;\n        }\n\n        int total = 0;\n        for (int p = 0; p < remain.size(); p++) {\n            order.add(remain.get(p));\n            remain.remove(p);\n            total += f(order, remain, edges);\n            remain.add(p, order.get(order.size() - 1));\n            order.remove(order.size() - 1);\n        }\n        return total;\n    }\n}", "code2": "n, m = gets.chomp.split.map(&:to_i)\nab = []\nm.times do |i|\n  ab[i] = gets.chomp.split.map(&:to_i)\nend\n\ncnt = 0\na = (1..n).to_a.permutation.to_a\na.each do |way|\n  next if way[0] != 1\n  judge = true\n  (n-1).times do |i|\n    unless ab.include?([way[i], way[i+1]].sort)\n      judge = false\n      break\n    end\n  end\n  cnt += 1 if judge\nend\n\nputs cnt", "label": 1, "name1": "s216336518.java", "name2": "s152899724.rb"}, {"id": 125, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.IntStream;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMain main = new Main();\n\t\tmain.solve();\n\t}\n\n\tprivate void solve() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tint[] a = new int[N];\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\ta[j] = sc.nextInt();\n\t\t}\n\t\tboolean[] dp = new boolean[K + 1];\n\t\tfor (int i = 0; i <= K; i++) {\n\t\t\tboolean isWin = false;\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (a[j] <= i && !dp[i - a[j]]) {\n\t\t\t\t\tisWin = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i] = isWin;\n\t\t}\n\t\tSystem.out.println(dp[K] ? \"First\" : \"Second\");\n\t}\n\n\tclass Scanner {\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int index;\n\t\tprivate int length;\n\n\t\tpublic Scanner(InputStream in) {\n\t\t\tthis.in = in;\n\t\t}\n\n\t\tprivate boolean isPrintableChar(int c) {\n\t\t\treturn '!' <= c && c <= '~';\n\t\t}\n\n\t\tprivate boolean isDigit(int c) {\n\t\t\treturn '0' <= c && c <= '9';\n\t\t}\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (index < length) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tlength = in.read(buffer);\n\t\t\t\t\tindex = 0;\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\treturn length > 0;\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[index])) {\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\treturn hasNextByte() ? buffer[index++] : -1;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) {\n\t\t\t\tthrow new RuntimeException(\"no input\");\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) {\n\t\t\t\tthrow new RuntimeException(\"no input\");\n\t\t\t}\n\t\t\tlong value = 0L;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tif (isDigit(b)) {\n\t\t\t\t\tvalue = value * 10 + (b - '0');\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn minus ? -value : value;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n\n\tinterface CombCalculator {\n\t\tlong comb(int n, int m);\n\t}\n\n\tinterface MobiusFunction {\n\t\tint get(int n);\n\t}\n\n\t/**\n\t * \u30e1\u30d3\u30a6\u30b9\u95a2\u6570\u3092\u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9\u3063\u307d\u304f\u524d\u8a08\u7b97\u3059\u308b\u30af\u30e9\u30b9\u3067\u3059\u3002\n\t * \u8a08\u7b97\u91cf\u306fO(1)\u3067\u3001\u524d\u8a08\u7b97\u3067O(N logN)\u3067\u3059\u3002\n\t */\n\tclass SieveMobiusFunction implements MobiusFunction {\n\t\tint size;\n\t\tint[] mobiusFunctionValues;\n\n\t\tpublic SieveMobiusFunction(int size) {\n\t\t\tthis.size = size;\n\t\t\tmobiusFunctionValues = new int[size];\n\n\t\t\tmobiusFunctionValues[0] = 0;\n\t\t\tmobiusFunctionValues[1] = 1;\n\t\t\tfor (int i = 2; i < size; i++) {\n\t\t\t\tmobiusFunctionValues[i] = 1;\n\t\t\t}\n\t\t\tfor (int i = 2; i * i < size; i++) {\n\t\t\t\tfor (int k = 1; i * i * k < size; k++) {\n\t\t\t\t\tmobiusFunctionValues[i * i * k] *= 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 2; i < size; i++) {\n\t\t\t\tif (mobiusFunctionValues[i] == 1) {\n\t\t\t\t\tfor (int k = 1; i * k < size; k++) {\n\t\t\t\t\t\tmobiusFunctionValues[i * k] *= -2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mobiusFunctionValues[i] > 1) {\n\t\t\t\t\tmobiusFunctionValues[i] = 1;\n\t\t\t\t}\n\t\t\t\tif (mobiusFunctionValues[i] < -1) {\n\t\t\t\t\tmobiusFunctionValues[i] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int get(int n) {\n\t\t\tif (n > size) {\n\t\t\t\tthrow new RuntimeException(\"n is greater than size.\");\n\t\t\t}\n\t\t\tif (n < 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn mobiusFunctionValues[n];\n\t\t}\n\t}\n\n\t/**\n\t * \u30e1\u30d3\u30a6\u30b9\u95a2\u6570\u3092\u5b9a\u7fa9\u901a\u308a\u8a08\u7b97\u3059\u308b\u30af\u30e9\u30b9\u3067\u3059\u3002\n\t * \u8a08\u7b97\u91cf\u306fO(logN)\u3067\u3059\u3002\n\t */\n\tclass PrimeFactorizationMobiusFunction implements MobiusFunction {\n\t\t@Override\n\t\tpublic int get(int n) {\n\t\t\tif (n <= 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (n == 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tint num = 0;\n\t\t\tfor (int i = 2; i < n; i++) {\n\t\t\t\tif (n % i == 0) {\n\t\t\t\t\tn /= i;\n\t\t\t\t\tnum++;\n\t\t\t\t\tif (n % i == 0) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn num % 2 == 0 ? -1 : 1;\n\t\t}\n\t}\n\n\t/**\n\t * \u7d44\u307f\u5408\u308f\u305b\u8a08\u7b97\u3092\u968e\u4e57\u306e\u5024\u3067\u884c\u3046\u30af\u30e9\u30b9\u3067\u3059(MOD\u5bfe\u5fdc)\n\t * \u968e\u4e57\u3068\u305d\u306e\u9006\u5143\u306f\u524d\u8a08\u7b97\u3057\u3066\u30c6\u30fc\u30d6\u30eb\u306b\u683c\u7d0d\u3057\u307e\u3059\u3002\n\t * C(N, N) % M \u306e\u8a08\u7b97\u91cf\u306f O(1)\u3001 \u524d\u8a08\u7b97\u3067O(max(N, logM))\u3067\u3059\u3002\n\t * size\u30921e8\u3088\u308a\u5927\u304d\u3044\u5024\u3067\u5b9f\u884c\u3059\u308b\u3068MLE\u306e\u5371\u967a\u6027\u304c\u3042\u308a\u307e\u3059\u3002\n\t * \u307e\u305f\u7d20\u6570\u4ee5\u5916\u306eMOD\u306b\u306f\u5bfe\u5fdc\u3057\u3066\u3044\u307e\u305b\u3093(\u9006\u5143\u306e\u8a08\u7b97\u306b\u7d20\u6570\u306e\u5270\u4f59\u74b0\u306e\u6027\u8cea\u3092\u5229\u7528\u3057\u3066\u3044\u308b\u305f\u3081)\u3002\n\t */\n\tclass FactorialTableCombCalculator implements CombCalculator {\n\t\tint size;\n\t\tlong[] factorialTable;\n\t\tlong[] inverseFactorialTable;\n\t\tlong mod;\n\n\t\tpublic FactorialTableCombCalculator(int size, long mod) {\n\t\t\tthis.size = size;\n\t\t\tfactorialTable = new long[size + 1];\n\t\t\tinverseFactorialTable = new long[size + 1];\n\t\t\tthis.mod = mod;\n\n\t\t\tfactorialTable[0] = 1L;\n\t\t\tfor (int i = 1; i <= size; i++) {\n\t\t\t\tfactorialTable[i] = (factorialTable[i - 1] * i) % mod;\n\t\t\t}\n\t\t\tinverseFactorialTable[size] = inverse(factorialTable[size], mod);\n\t\t\tfor (int i = size - 1; i >= 0; i--) {\n\t\t\t\tinverseFactorialTable[i] = (inverseFactorialTable[i + 1] * (i + 1)) % mod;\n\t\t\t}\n\t\t}\n\n\t\tprivate long inverse(long n, long mod) {\n\t\t\treturn pow(n, mod - 2, mod);\n\t\t}\n\n\t\tprivate long pow(long n, long p, long mod) {\n\t\t\tif (p == 0) {\n\t\t\t\treturn 1L;\n\t\t\t}\n\t\t\tlong half = pow(n, p / 2, mod);\n\t\t\tlong ret = (half * half) % mod;\n\t\t\tif (p % 2 == 1) {\n\t\t\t\tret = (ret * n) % mod;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic long comb(int n, int m) {\n\t\t\tif (n > size) {\n\t\t\t\tthrow new RuntimeException(\"n is greater than size.\");\n\t\t\t}\n\t\t\tif (n < 0 || m < 0 || n < m) {\n\t\t\t\treturn 0L;\n\t\t\t}\n\t\t\treturn (((factorialTable[n] * inverseFactorialTable[m]) % mod) * inverseFactorialTable[n - m]) % mod;\n\t\t}\n\t}\n\n\t/**\n\t * \u7d44\u307f\u5408\u308f\u305b\u8a08\u7b97\u3092\u30c6\u30fc\u30d6\u30eb\u3067\u5b9f\u88c5\u3057\u305f\u30af\u30e9\u30b9\u3067\u3059(MOD\u5bfe\u5fdc)\n\t * \u524d\u8a08\u7b97\u3067O(N^2), comb\u306fO(1)\u3067\u5b9f\u884c\u3067\u304d\u307e\u3059\n\t * size\u30922 * 1e4\u3088\u308a\u5927\u304d\u3044\u5024\u3067\u5b9f\u884c\u3059\u308b\u3068MLE\u306e\u5371\u967a\u6027\u304c\u3042\u308a\u307e\u3059\n\t */\n\tclass TableCombCalculator implements CombCalculator {\n\t\tlong[][] table;\n\t\tint size;\n\n\t\tpublic TableCombCalculator(int size, long mod) {\n\t\t\tthis.size = size;\n\t\t\ttable = new long[size + 1][];\n\n\t\t\ttable[0] = new long[1];\n\t\t\ttable[0][0] = 1L;\n\t\t\tfor (int n = 1; n <= size; n++) {\n\t\t\t\ttable[n] = new long[n + 1];\n\t\t\t\ttable[n][0] = 1L;\n\t\t\t\tfor (int m = 1; m < n; m++) {\n\t\t\t\t\ttable[n][m] = (table[n - 1][m - 1] + table[n - 1][m]) % mod;\n\t\t\t\t}\n\t\t\t\ttable[n][n] = 1L;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic long comb(int n, int m) {\n\t\t\tif (n > size) {\n\t\t\t\tthrow new RuntimeException(\"n is greater than size.\");\n\t\t\t}\n\t\t\tif (n < 0 || m < 0 || n < m) {\n\t\t\t\treturn 0L;\n\t\t\t}\n\t\t\treturn table[n][m];\n\t\t}\n\t}\n\n\tinterface Graph {\n\t\tvoid link(int from, int to, long cost);\n\t\tOptional<Long> getCost(int from, int to);\n\t\tint getVertexNum();\n\t}\n\n\tinterface FlowResolver {\n\t\tlong maxFlow(int from, int to);\n\t}\n\n\t/**\n\t * \u30b0\u30e9\u30d5\u306e\u884c\u5217\u306b\u3088\u308b\u5b9f\u88c5\n\t * \u63a5\u70b9\u6570\u306e\u5927\u304d\u3044\u30b0\u30e9\u30d5\u3067\u4f7f\u3046\u3068MLE\u3067\u6b7b\u306b\u305d\u3046\n\t */\n\tclass ArrayGraph implements Graph {\n\t\tprivate Long[][] costArray;\n\t\tprivate int vertexNum;\n\n\t\tpublic ArrayGraph(int n) {\n\t\t\tcostArray = new Long[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tcostArray[i] = new Long[n];\n\t\t\t}\n\t\t\tvertexNum = n;\n\t\t}\n\n\t\t@Override\n\t\tpublic void link(int from, int to, long cost) {\n\t\t\tcostArray[from][to] = new Long(cost);\n\t\t}\n\n\t\t@Override\n\t\tpublic Optional<Long> getCost(int from, int to) {\n\t\t\treturn Optional.ofNullable(costArray[from][to]);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getVertexNum() {\n\t\t\treturn vertexNum;\n\t\t}\n\t}\n\n\t/**\n\t * DFS(\u6df1\u3055\u512a\u5148\u63a2\u7d22)\u306b\u3088\u308b\u5b9f\u88c5\n\t * \u8a08\u7b97\u91cf\u306fO(E*MaxFlow)\u306e\u306f\u305a (E:\u8fba\u306e\u6570, MaxFlow:\u6700\u5927\u30d5\u30ed\u30fc)\n\t */\n\tclass DfsFlowResolver implements FlowResolver {\n\t\tprivate Graph graph;\n\t\tpublic DfsFlowResolver(Graph graph) {\n\t\t\tthis.graph = graph;\n\t\t}\n\n\t\t/**\n\t\t * \u6700\u5927\u30d5\u30ed\u30fc(\u6700\u5c0f\u30ab\u30c3\u30c8)\u3092\u6c42\u3081\u308b\n\t\t * @param from \u59cb\u70b9(source)\u306eID\n\t\t * @param to \u7d42\u70b9(target)\u306eID\n\t\t * @return \u6700\u5927\u30d5\u30ed\u30fc(\u6700\u5c0f\u30ab\u30c3\u30c8)\n\t\t */\n\t\tpublic long maxFlow(int from, int to) {\n\t\t\tlong sum = 0L;\n\t\t\tlong currentFlow;\n\t\t\tdo {\n\t\t\t\tcurrentFlow = flow(from, to, Long.MAX_VALUE / 3, new boolean[graph.getVertexNum()]);\n\t\t\t\tsum += currentFlow;\n\t\t\t} while (currentFlow > 0);\n\t\t\treturn sum;\n\t\t}\n\n\t\t/**\n\t\t * \u30d5\u30ed\u30fc\u306e\u5b9f\u884c \u30b0\u30e9\u30d5\u306e\u66f4\u65b0\u3082\u884c\u3046\n\t\t * @param from \u73fe\u5728\u3044\u308b\u7bc0\u70b9\u306eID\n\t\t * @param to \u7d42\u70b9(target)\u306eID\n\t\t * @param current_flow \u3053\u3053\u307e\u3067\u306e\u6d41\u91cf\n\t\t * @param passed \u65e2\u306b\u901a\u3063\u305f\u7bc0\u70b9\u304b\u5426\u304b\u3092\u683c\u7d0d\u3057\u305f\u914d\u5217\n\t\t * @return \u7d42\u70b9(target)\u306b\u6d41\u3057\u305f\u6d41\u91cf/\u623b\u308a\u306e\u30b0\u30e9\u30d5\u306e\u6d41\u91cf\n\t\t */\n\t\tprivate long flow(int from, int to, long current_flow, boolean[] passed) {\n\t\t\tpassed[from] = true;\n\t\t\tif (from == to) {\n\t\t\t\treturn current_flow;\n\t\t\t}\n\t\t\tfor (int id = 0; id < graph.getVertexNum(); id++) {\n\t\t\t\tif (passed[id]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tOptional<Long> cost = graph.getCost(from, id);\n\t\t\t\tif (cost.orElse(0L) > 0) {\n\t\t\t\t\tlong nextFlow = current_flow < cost.get() ? current_flow : cost.get();\n\t\t\t\t\tlong returnFlow = flow(id, to, nextFlow, passed);\n\t\t\t\t\tif (returnFlow > 0) {\n\t\t\t\t\t\tgraph.link(from, id, cost.get() - returnFlow);\n\t\t\t\t\t\tgraph.link(id, from, graph.getCost(id, from).orElse(0L) + returnFlow);\n\t\t\t\t\t\treturn returnFlow;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0L;\n\t\t}\n\t}\n\n\t/**\n\t * 1-indexed\u306eBIT\u914d\u5217\n\t */\n\tclass BinaryIndexedTree {\n\t\tprivate long[] array;\n\n\t\tpublic BinaryIndexedTree(int size) {\n\t\t\tthis.array = new long[size + 1];\n\t\t}\n\n\t\t/**\n\t\t * \u6307\u5b9a\u3057\u305f\u8981\u7d20\u306b\u5024\u3092\u52a0\u7b97\u3059\u308b\n\t\t * \u8a08\u7b97\u91cf\u306fO(logN)\n\t\t * @param index \u52a0\u7b97\u3059\u308b\u8981\u7d20\u306e\u6dfb\u5b57\n\t\t * @param value \u52a0\u7b97\u3059\u308b\u91cf\n\t\t */\n\t\tpublic void add(int index, long value) {\n\t\t\tfor (int i = index; i < array.length; i += (i & -i)) {\n\t\t\t\tarray[i] += value;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * 1\u301c\u6307\u5b9a\u3057\u305f\u8981\u7d20\u307e\u3067\u306e\u548c\u3092\u53d6\u5f97\u3059\u308b\n\t\t * \u8a08\u7b97\u91cf\u306fO(logN)\n\t\t * @param index \u548c\u306e\u7d42\u7aef\u3068\u306a\u308b\u8981\u7d20\u306e\u6dfb\u5b57\n\t\t * @return 1\u301cindex\u307e\u3067\u306e\u548c\n\t\t */\n\t\tpublic long getSum(int index) {\n\t\t\tlong sum = 0L;\n\t\t\tfor (int i = index; i > 0; i -= (i & -i)) {\n\t\t\t\tsum += array[i];\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\n\t/**\n\t * 1-indexed\u306e2\u6b21\u5143BIT\u914d\u5217\n\t */\n\tclass BinaryIndexedTree2D {\n\t\tprivate long[][] array;\n\n\t\tpublic BinaryIndexedTree2D(int size1, int size2) {\n\t\t\tthis.array = new long[size1 + 1][];\n\t\t\tfor (int i = 1; i <= size1; i++) {\n\t\t\t\tthis.array[i] = new long[size2 + 1];\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * \u6307\u5b9a\u3057\u305f\u8981\u7d20\u306b\u5024\u3092\u52a0\u7b97\u3059\u308b\n\t\t * \u8a08\u7b97\u91cf\u306fO(logN * logN)\n\t\t * @param index1 \u52a0\u7b97\u3059\u308b\u8981\u7d20\u306e1\u6b21\u5143\u76ee\u306e\u6dfb\u5b57\n\t\t * @param index2 \u52a0\u7b97\u3059\u308b\u8981\u7d20\u306e2\u6b21\u5143\u76ee\u306e\u6dfb\u5b57\n\t\t * @param value \u52a0\u7b97\u3059\u308b\u91cf\n\t\t */\n\t\tpublic void add(int index1, int index2, long value) {\n\t\t\tfor (int i1 = index1; i1 < array.length; i1 += (i1 & -i1)) {\n\t\t\t\tfor (int i2 = index2; i2 < array.length; i2 += (i2 & -i2)) {\n\t\t\t\t\tarray[i1][i2] += value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * (1,1)\u301c\u6307\u5b9a\u3057\u305f\u8981\u7d20\u307e\u3067\u306e\u77e9\u5f62\u548c\u3092\u53d6\u5f97\u3059\u308b\n\t\t * \u8a08\u7b97\u91cf\u306fO(logN * logN)\n\t\t * @param index1 \u548c\u306e\u7d42\u7aef\u3068\u306a\u308b\u8981\u7d20\u306e1\u6b21\u5143\u76ee\u306e\u6dfb\u5b57\n\t\t * @param index2 \u548c\u306e\u7d42\u7aef\u3068\u306a\u308b\u8981\u7d20\u306e2\u6b21\u5143\u76ee\u306e\u6dfb\u5b57\n\t\t * @return (1,1)\u301c(index1,index2)\u307e\u3067\u306e\u77e9\u5f62\u548c\n\t\t */\n\t\tpublic long getSum(int index1, int index2) {\n\t\t\tlong sum = 0L;\n\t\t\tfor (int i1 = index1; i1 > 0; i1 -= (i1 & -i1)) {\n\t\t\t\tfor (int i2 = index2; i2 > 0; i2 -= (i2 & -i2)) {\n\t\t\t\t\tsum += array[i1][i2];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\n\tinterface UnionFind {\n\t\tvoid union(int A, int B);\n\t\tboolean judge(int A, int B);\n\t\tSet<Integer> getSet(int id);\n\t}\n\n\t/**\n\t * ArrayUnionFind\u306e\u62e1\u5f35\n\t * MapSet\u3067\u6839\u306e\u6dfb\u5b57\u304b\u3089\u6839\u306b\u3076\u3089\u4e0b\u304c\u308b\u9802\u70b9\u306e\u96c6\u5408\u304c\u53d6\u5f97\u3067\u304d\u308b\u3088\u3046\u306b\u3057\u305f\n\t * getSet\u30e1\u30bd\u30c3\u30c9\u3092O(logN * logN)\u306b\u843d\u3068\u305b\u3066\u3044\u308b\u306f\u305a\n\t * \u305f\u3060\u3057union\u30e1\u30bd\u30c3\u30c9\u306f2\u500d\u306e\u8a08\u7b97\u91cf\u306b\u306a\u3063\u3066\u3044\u308b\u306e\u3067\u6ce8\u610f(\u30aa\u30fc\u30c0\u30fc\u306f\u5909\u308f\u3089\u306a\u3044\u306f\u305a)\n\t */\n\tclass SetUnionFind extends ArrayUnionFind {\n\t\tMap<Integer, Set<Integer>> map;\n\t\tpublic SetUnionFind(int size) {\n\t\t\tsuper(size);\n\t\t\tmap = new HashMap<>();\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tmap.put(i, new HashSet<>());\n\t\t\t\tmap.get(i).add(i);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tprotected void unionTo(int source, int dest) {\n\t\t\tsuper.unionTo(source, dest);\n\t\t\tmap.get(dest).addAll(map.get(source));\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<Integer> getSet(int id) {\n\t\t\treturn map.get(root(id));\n\t\t}\n\t}\n\n\t/**\n\t * \u914d\u5217\u306b\u3088\u308bUnionFind\u306e\u5b9f\u88c5\n\t * getSet\u30e1\u30bd\u30c3\u30c9\u306fO(NlogN)\u306a\u306e\u3067TLE\u306b\u6ce8\u610f\n\t */\n\tclass ArrayUnionFind implements UnionFind {\n\t\tint[] parent;\n\t\tint[] rank;\n\t\tint size;\n\t\tpublic ArrayUnionFind(int size) {\n\t\t\tparent = new int[size];\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tparent[i] = i;\n\t\t\t}\n\t\t\trank = new int[size];\n\t\t\tthis.size = size;\n\t\t}\n\n\t\t@Override\n\t\tpublic void union(int A, int B) {\n\t\t\tint rootA = root(A);\n\t\t\tint rootB = root(B);\n\t\t\tif (rootA != rootB) {\n\t\t\t\tif (rank[rootA] < rank[rootB]) {\n\t\t\t\t\tunionTo(rootA, rootB);\n\t\t\t\t} else {\n\t\t\t\t\tunionTo(rootB, rootA);\n\t\t\t\t\tif (rank[rootA] == rank[rootB]) {\n\t\t\t\t\t\trank[rootA]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprotected void unionTo(int source, int dest) {\n\t\t\tparent[source] = dest;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean judge(int A, int B) {\n\t\t\treturn root(A) == root(B);\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<Integer> getSet(int id) {\n\t\t\tSet<Integer> set = new HashSet<>();\n\t\t\tIntStream.range(0, size).filter(i -> judge(i, id)).forEach(set::add);\n\t\t\treturn set;\n\t\t}\n\n\t\tprotected int root(int id) {\n\t\t\tif (parent[id] == id) {\n\t\t\t\treturn id;\n\t\t\t}\n\t\t\tparent[id] = root(parent[id]);\n\t\t\treturn parent[id];\n\t\t}\n\t}\n\n\t/**\n\t * \u7d20\u6570\u306e\u30e6\u30fc\u30c6\u30a3\u30ea\u30c6\u30a3\n\t */\n\tclass PrimeNumberUtils {\n\t\tboolean[] isPrimeArray;\n\t\tList<Integer> primes;\n\n\t\t/**\n\t\t * \u7d20\u6570\u5224\u5b9a\u306e\u4e0a\u9650\u3068\u306a\u308b\u5024\u3092\u6307\u5b9a\u3057\u3066\u30e6\u30fc\u30c6\u30a3\u30ea\u30c6\u30a3\u3092\u521d\u671f\u5316\n\t\t * @param limit \u7d20\u6570\u5224\u5b9a\u306e\u4e0a\u9650(\u3053\u306e\u5024\u4ee5\u4e0a\u304c\u7d20\u6570\u3067\u3042\u308b\u304b\u5224\u5b9a\u3057\u306a\u3044)\n\t\t */\n\t\tpublic PrimeNumberUtils(int limit) {\n\t\t\tif (limit > 10000000) {\n\t\t\t\tSystem.err.println(\"\u4e0a\u9650\u306e\u5024\u304c\u9ad8\u3059\u304e\u308b\u305f\u3081\u7d20\u6570\u30e6\u30fc\u30c6\u30a3\u30ea\u30c6\u30a3\u306e\u521d\u671f\u5316\u3067TLE\u3059\u308b\u53ef\u80fd\u6027\u304c\u5927\u5909\u9ad8\u3044\u3067\u3059\");\n\t\t\t}\n\t\t\tprimes = new ArrayList<>();\n\t\t\tisPrimeArray = new boolean[limit];\n\t\t\tif (limit > 2) {\n\t\t\t\tprimes.add(2);\n\t\t\t\tisPrimeArray[2] = true;\n\t\t\t}\n\n\t\t\tfor (int i = 3; i < limit; i += 2) {\n\t\t\t\tif (isPrime(i, primes)) {\n\t\t\t\t\tprimes.add(i);\n\t\t\t\t\tisPrimeArray[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic List<Integer> getPrimeNumberList() {\n\t\t\treturn primes;\n\t\t}\n\n\t\tpublic boolean isPrime(int n) {\n\t\t\treturn isPrimeArray[n];\n\t\t}\n\n\t\tprivate boolean isPrime(int n, List<Integer> primes) {\n\t\t\tfor (int prime : primes) {\n\t\t\t\tif (n % prime == 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (prime > Math.sqrt(n)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tinterface BitSet {\n\t\tvoid set(int index, boolean bit);\n\t\tboolean get(int index);\n\t\tvoid shiftRight(int num);\n\t\tvoid shiftLeft(int num);\n\t\tvoid or(BitSet bitset);\n\t\tvoid and(BitSet bitset);\n\t}\n\n\t/**\n\t * Long\u306e\u914d\u5217\u306b\u3088\u308bBitSet\u306e\u5b9f\u88c5\n\t * get/set\u306fO(1)\n\t * shift/or/and\u306fO(size / 64)\n\t */\n\tclass LongBit implements BitSet {\n\t\tlong[] bitArray;\n\n\t\tpublic LongBit(int size) {\n\t\t\tbitArray = new long[((size + 63) / 64)];\n\t\t}\n\n\t\t@Override\n\t\tpublic void set(int index, boolean bit) {\n\t\t\tint segment = index / 64;\n\t\t\tint inIndex = index % 64;\n\t\t\tif (bit) {\n\t\t\t\tbitArray[segment] |= 1L << inIndex;\n\t\t\t} else {\n\t\t\t\tbitArray[segment] &= ~(1L << inIndex);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean get(int index) {\n\t\t\tint segment = index / 64;\n\t\t\tint inIndex = index % 64;\n\t\t\treturn (bitArray[segment] & (1L << inIndex)) != 0L;\n\t\t}\n\n\t\t@Override\n\t\tpublic void shiftRight(int num) {\n\t\t\tint shiftSeg = num / 64;\n\t\t\tint shiftInI = num % 64;\n\t\t\tfor (int segment = 0; segment < bitArray.length; segment++) {\n\t\t\t\tint sourceSeg = segment + shiftSeg;\n\t\t\t\tif (sourceSeg < bitArray.length) {\n\t\t\t\t\tbitArray[segment] = bitArray[sourceSeg] >>> shiftInI;\n\t\t\t\t\tif (shiftInI > 0 && sourceSeg + 1 < bitArray.length) {\n\t\t\t\t\t\tbitArray[segment] |= bitArray[sourceSeg + 1] << (64 - shiftInI);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbitArray[segment] = 0L;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void shiftLeft(int num) {\n\t\t\tint shiftSeg = num / 64;\n\t\t\tint shiftInI = num % 64;\n\t\t\tfor (int segment = bitArray.length - 1; segment >= 0; segment--) {\n\t\t\t\tint sourceSeg = segment - shiftSeg;\n\t\t\t\tif (sourceSeg >= 0) {\n\t\t\t\t\tbitArray[segment] = bitArray[sourceSeg] << shiftInI;\n\t\t\t\t\tif (shiftInI > 0 && sourceSeg > 0) {\n\t\t\t\t\t\tbitArray[segment] |= bitArray[sourceSeg - 1] >>> (64 - shiftInI);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbitArray[segment] = 0L;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic long getLong(int segment) {\n\t\t\treturn bitArray[segment];\n\t\t}\n\n\t\t@Override\n\t\tpublic void or(BitSet bitset) {\n\t\t\tif (!(bitset instanceof LongBit)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int segment = 0; segment < bitArray.length; segment++) {\n\t\t\t\tbitArray[segment] |= ((LongBit)bitset).getLong(segment);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void and(BitSet bitset) {\n\t\t\tif (!(bitset instanceof LongBit)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int segment = 0; segment < bitArray.length; segment++) {\n\t\t\t\tbitArray[segment] &= ((LongBit)bitset).getLong(segment);\n\t\t\t}\n\t\t}\n\t}\n\n}", "code2": "N,K=gets.chomp.split.map(&:to_i)\na=gets.chomp.split.map(&:to_i)\ndp=Array.new(K+1,false)\n\na[0].upto(K) do |i|\n  a.each do |v|\n    break if i - v < 0\n    if dp[i - v] == false\n      dp[i] = true\n      break\n    end\n  end\nend\n\nputs dp[K] ? \"First\" : \"Second\"", "label": 1, "name1": "s208804589.java", "name2": "s756877531.rb"}, {"id": 335, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n    private static int[] arr;\n\n    public static void main(String[] args) {\n\n        Scanner scanner = new Scanner(System.in);\n        String input = scanner.nextLine();\n        arr = Arrays.stream(input.split(\"\")).mapToInt(Integer::parseInt).toArray();\n\n        long sum = calc(0, arr.length - 1);\n        System.out.println(sum);\n    }\n\n    private static long calc(int position, int end) {\n        if (position > end) return 0;\n\n        long tmp = 0;\n        for (int i = position; i < end; i++) {\n            tmp += toInt(position, i) * Math.pow(2, (end - i - 1)) + calc(i + 1, end);\n        }\n        tmp += toInt(position, end);\n        return tmp;\n    }\n\n    private static long toInt(int start, int end) {\n        if (start == end) {\n//            System.out.println(\"start: \" + start + \" end: \" + end + \" -> \" + arr[start]);\n            return arr[start];\n        }\n\n        long tmp = 0;\n        for (int i = start; i <= end; i++) {\n            tmp += arr[i] * Math.pow(10, (end - i));\n        }\n//        System.out.println(\"start: \" + start + \" end: \" + end + \" -> \" + tmp);\n        return tmp;\n    }\n}", "code2": "s = gets.chomp.chars\nsum = 0\n['', '+'].repeated_permutation(s.size-1).each do |array|\n  sum += eval(s.zip(array).join)\nend\n\nputs sum", "label": 1, "name1": "s752481979.java", "name2": "s545852610.rb"}, {"id": 593, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint[] abc = new int[3];\n\t\tArrays.setAll(abc, i -> sc.nextInt());\n\t\tArrays.sort(abc);\n\t\t\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tint dif = abc[2] - abc[i];\n\t\t\tint quo = dif / 2;\n\t\t\tcnt += quo;\n\t\t\tabc[i] += 2 * quo;\n\t\t}\n\t\t\n\t\tArrays.sort(abc);\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tabc[2 - i] -= abc[0];\n\t\t}\n\t\t\n\t\tfor (int i : abc) {\n\t\t\tcnt += i;\n\t\t}\n\t\t\n\t\tSystem.out.println(cnt);\n\t}\t\n}\n", "code2": "q=gets.to_i\nq.times{\n  a,b=gets.split.map(&:to_i)\n  s=a*b\n  c=Math.sqrt(s).to_i\n  c-=1 if c**2==s\n  if a==b\n    p 2*a-2\n  else\n    p c*(c+1)>=s ? 2*c-2:2*c-1\n  end\n}\n", "label": 0, "name1": "s839188761.java", "name2": "s038330329.rb"}, {"id": 856, "code1": "import java.util.*;\n\npublic class Main{\n\t\n\t// a < b\n\tpublic static int gcv(int a, int b){\n\t\tif(b % a == 0){\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tint mod = b % a;\n\t\t\n\t\treturn gcv(mod, a);\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tScanner scan = new Scanner(System.in);\n\t\tLinkedList<Integer> monsters = new LinkedList<>();\n\t\t\n\t\t// input\n\t\tint num = scan.nextInt();\n\t\tfor(int i = 0; i < num; i++){\n\t\t\tmonsters.add(scan.nextInt());\n\t\t}\n\t\t\n\t\t// check\n\t\tCollections.sort(monsters);\n\t\twhile(monsters.size() > 1){\n\t\t\tmonsters.push(gcv( monsters.pop(), monsters.pop()));\n\t\t}\n\t\t\n\t\t// answer\n\t\tSystem.out.println(monsters.pop());\n\t}\n}", "code2": "n,m=gets.chomp.split(\" \").map{|s| s.to_i}\np=[]\ns=[]\nfor i in 0..m-1\n  p[i],s[i]=gets.chomp.split(\" \")\n  p[i]=p[i].to_i\nend\nt=[]\nfor i in 0..m-1\n  if t[p[i]].nil?\n    t[p[i]]=[1,0] if s[i]==\"AC\"\n    t[p[i]]=[0,1] if s[i]==\"WA\"\n  else\n    if t[p[i]][0]==0\n      if s[i]==\"AC\"\n        t[p[i]][0]=1\n      else s[i]==\"WA\"\n        t[p[i]][1]+=1\n      end\n    end\n  end\nend\n\nac=0\nwa=0\nfor i in 0..n\n  if !t[i].nil?\n    if t[i][0]==1\n      ac+=1\n      wa+=t[i][1]\n    end\n  end\nend\nprint \"#{ac} #{wa}\"", "label": 0, "name1": "s591174716.java", "name2": "s134805528.rb"}, {"id": 681, "code1": "import java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc= new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint count=0;\n\t\t\tint n=sc.nextInt();\n\t\t\tint x=sc.nextInt();\n\t\t\tif(n==0 && x==0) break;\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=i+1;j<=n;j++){\n\t\t\t\t\tfor(int k=j+1;k<=n;k++){\n\t\t\t\t\t\tif(i+j+k == x) count++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}", "code2": "array =[]\nfor i in (0..2)\n  array[i]=gets.split(\" \").map{|a| a.to_i}\nend\nanswer =\"YES\"\nfor i in(1..4)\n  num =0\n  array.each{|a|\n  if a.include?(i) then\n    num +=1\n  end\n  if num ==3\n    answer = \"NO\"\n  end\n  }\nend\nputs answer\n", "label": 0, "name1": "s030330226.java", "name2": "s124375185.rb"}, {"id": 115, "code1": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        int c = sc.nextInt();\n\n        int min = Math.min(a, b);\n        int max = Math.max(a, b);\n        \n        boolean ans = false;\n        if (min < c && c < max)\n            ans = true;\n        System.out.println(ans ? \"Yes\" : \"No\");\n    }\n}", "code2": "a, b, c = gets.chomp.split.map(&:to_i)\nmsg = (a < b && a < c && c < b) || (b < a && b < c && c < a) ? \"Yes\" : \"No\"\nputs msg", "label": 1, "name1": "s912321420.java", "name2": "s427997233.rb"}, {"id": 424, "code1": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tString s;\n\t\t\tString[][] a = new String[n][];\n\t\t\tint p;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\ts = sc.next().replaceAll(\":\", \" \").replaceAll(\",\", \" \");\n\t\t\t\ta[i] = s.split(\" \");\n\t\t\t\tp = a[i].length-1;\n\t\t\t\ta[i][p] = a[i][p].substring(0,a[i][p].length()-1);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<String> list = new ArrayList<String>();\n\t\t\tfor(int i=1;i<a[0].length;i++) list.add(a[0][i]);\n\t\t\t\n\t\t\tboolean flag;\n\t\t\twhile(true){\n\t\t\t\tflag = false;\n\t\t\t\tfor(int i=1;i<n;i++){\n\t\t\t\t\tif(list.contains(a[i][0])==true){\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tlist.remove(list.indexOf(a[i][0]));\n\t\t\t\t\t\tfor(int j=1;j<a[i].length;j++){\n\t\t\t\t\t\t\tif(list.contains(a[i][j])==false) list.add(a[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag==false) break;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(list.size());\n\t\t}\t\n\t}\t\n}", "code2": "def find(x, root)\n  return unless @group[x]\n  return true if @group[x].include?(root)\n  @group[x].each do |m|\n    return true if find(m, root)\n  end\n  false\nend\n\nwhile n = gets.to_i\n  break if n == 0\n  root = ''\n  @group = {}\n  n.times do |i|\n    g, m = gets.split(':')\n    root = g if i == 0\n    ms = m[0..-3].split(',')\n    ms.each{ |m| @group[m] ||= []; @group[m] << g }\n  end\n  cnt = 0\n  @group.keys.each do |name|\n    if find(name, root) && !@group.values.flatten.include?(name)\n      cnt += 1\n    end\n  end\n  p cnt\nend", "label": 1, "name1": "s663814901.java", "name2": "s172002341.rb"}, {"id": 576, "code1": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n    \tScanner sc = new Scanner(System.in);\n      \tint A,B,C;\n      \tA = sc.nextInt();\n      \tB = sc.nextInt();\n      \tC = sc.nextInt();\n      \tif ((A < C && C < B) || (B < C && C < A)) {\n            \tSystem.out.print(\"Yes\");\n        }  else {\n        \tSystem.out.print(\"No\");\n        }   \n    }\n}", "code2": "d=*1..gets.to_i;gets.bytes{|c|x=0;N=d.pop;d.map!{|a|x+=-c%3*N+a*=1-c%3;x%=10**9+7}};p N", "label": 0, "name1": "s403728510.java", "name2": "s201614079.rb"}, {"id": 880, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tchar a=scan.next().charAt(0);\n\t\tchar b=scan.next().charAt(0);\n\t\tif(a=='H' && b!='D') System.out.println(\"H\");\n\t\telse if(b=='H' && a!='D') System.out.println(\"H\");\n\t\telse if(a=='D' && b=='D') System.out.println(\"H\");\n\t\telse System.out.println(\"D\");\n\t}\n\n}\n", "code2": "k = gets.to_i\na, b = gets.split.map &:to_i\nputs ((b/k==(a-1)/k) ? :NG : :OK)", "label": 0, "name1": "s111953334.java", "name2": "s407890190.rb"}, {"id": 526, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Optional;\nimport java.util.OptionalDouble;\nimport java.util.stream.DoubleStream;\nimport java.util.stream.Stream;\n\npublic class Main {\n\n  public static void main(String[] args) throws IOException {\n    \n    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {\n\n      String line;\n      String[] lines;\n      double[] s;\n      while( !(line = br.readLine()).equals(\"0\") ){\n\n        int n = Integer.parseInt(line);\n        lines = br.readLine().split(\" \");\n\n        s =\n          Stream.of(lines)\n            .mapToDouble(Double::parseDouble)\n            .toArray();\n        \n        double dm =\n          Arrays.stream(s)\n            .average()\n          .getAsDouble();\n\n        double result =\n        Arrays.stream(s)\n          .map(d -> Math.pow((d-dm),2) / n)\n          .sum();\n\n        System.out.printf(\"%.8f\\n\" , Math.sqrt(result));\n      }\n    }\n  }\n}\n", "code2": "def main(argv)\n  n = gets.chomp.to_i\n  a = gets.chomp.split(' ').map(&:to_i)\n\n  as = [[]]\n  prev = a[0]\n  n.times do |i|\n    if prev != a[i] then\n      as.push([a[i]])\n      prev = a[i]\n    else\n      as[as.size - 1].push(a[i])\n    end\n  end\n  \n  puts as.map{|a| a.size / 2}.reduce(:+).to_s\nend\n\nif self.to_s == 'main' then\n  main(ARGV)\nend", "label": 0, "name1": "s757478171.java", "name2": "s355654198.rb"}, {"id": 891, "code1": "class Main {\n\tpublic static void main(String args[]){\n\t\tfor(int i=0;i<1000;i++){\n\t\t\tSystem.out.println(\"Hello World\");\n\t\t}\n\t}\n}", "code2": "def ascan; gets.split.map(&:to_i);end\n\nn,m = ascan\n\nt = m*1900 + (n-m)*100\np (2**m)*t\n", "label": 0, "name1": "s780087873.java", "name2": "s059115863.rb"}, {"id": 9, "code1": "import java.util.*;\n\npublic class Main{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n\n    String[] s = sc.next().split(\"\");\n    int l =  s.length;\n    int count =0;\n    for(int i=0; i<l; i++){\n      if(s[i].equals(\"U\")||s[i].equals(\"D\")){\n        count +=1;\n        continue;\n      }\n\n\n      if(i%2==0){\n        if(s[i].equals(\"R\")){\n          count += 1;\n        }\n      }else{\n        if(s[i].equals(\"L\")){\n          count += 1;\n        }\n      }\n    }\n    if(count == l){\n      System.out.println(\"Yes\");\n    }else{\n      System.out.println(\"No\");\n    }\n\n\n\n\n  }\n}", "code2": "s = gets.chomp.split(\"\")\nflag = 1\n\ns.size.times do |i|\n    if (i + 1) % 2 == 0 && s[i] == \"R\"\n        flag = 0\n        break\n    elsif (i + 1) % 2 == 1 && s[i] == \"L\"\n        flag = 0\n        break\n    end\nend\n\nif flag == 0\n    puts \"No\"\nelse\n    puts \"Yes\"\nend\n", "label": 1, "name1": "s855266906.java", "name2": "s337975959.rb"}, {"id": 726, "code1": "import java.util.*;\nclass Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String S[] = sc.next().split(\"\");\n    \n    int n = (int)Math.pow(2, S.length - 1);\n    \n    long total = 0;\n    for (int i = 0; i < n; i++) {\n      String s = S[0];\n      \n      for (int j = 0; j < S.length - 1; j++) {\n        if ((1&i>>j) == 1) {\n          total += Long.parseLong(s);\n          s = S[j + 1];\n        } else {\n          s += S[j + 1];\n        }\n      }\n      total += Long.parseLong(s);\n    }\n    System.out.println(total);\n  }\n}", "code2": "x, y = gets.split.map &:to_i\ncnt = 0\nwhile x <= y\n  y >>= 1\n  cnt += 1\nend\np cnt\n", "label": 0, "name1": "s109985040.java", "name2": "s741410088.rb"}, {"id": 765, "code1": "//\u0083\\\u0081[\u0083g\u0082\u00b7\u0082\u00e9\u0083v\u0083\u008d\u0083O\u0083\u0089\u0083\u0080\u0081i\u0082\u008e\u0082\u00cc\u0092l\u0082\u00cd1,000,000\u0088\u00c8\u0089\u00ba\u0081j\nimport java.util.*;\npublic class Main {\n\n\tpublic void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tTreeSet<Integer> set = new TreeSet<Integer>();\n\t\tTreeMap<Integer,Integer> map = new TreeMap<Integer, Integer>();\n\n\t\tfor(int i=0; i < n; i++){\n\t\t\tint temp = sc.nextInt();\n\t\t\tif( set.contains(temp)){\n\t\t\t\tif(map.containsKey(temp)){\n\t\t\t\t\tmap.put(temp, map.get(temp) + 1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmap.put(temp, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tset.add(temp);\n\t\t\t}\n\t\t}\n\t\tfor(int num: set){\n\t\t\tif(map.containsKey(num)){\n\t\t\t\tfor(int i=0; i < map.get(num);i++){\n\t\t\t\t\tSystem.out.print(num + \" \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(num == set.last()){\n\t\t\t\tSystem.out.println(num);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.print(num + \" \");\n\t\t\t}\n\n\t\t}\n\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doIt();\n\n\t}\n\n}", "code2": "n=gets.to_i\na=gets.split.map(&:to_i)\na.unshift 0\na.push 0\nsum=a.each_cons(2).map{|x,y|(x-y).abs}.inject(:+)\na.each_cons(3){|x,y,z|puts sum+(x-z).abs-(x-y).abs-(y-z).abs}", "label": 0, "name1": "s012590995.java", "name2": "s365262629.rb"}, {"id": 313, "code1": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        // \u6574\u6570\u306e\u5165\u529b\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        int c = sc.nextInt();\n        // \u51fa\u529b\n        int o = c-a+b;\n        System.out.println(o > 0 ? o : 0);\n    }\n}", "code2": "A, B, C = gets.split.map(&:to_i)\nrest = A - B\nif rest >= C\n  puts '0'\nelse\n  puts(C - rest)\nend\n", "label": 1, "name1": "s598978529.java", "name2": "s187353051.rb"}, {"id": 695, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint N = scan.nextInt();\n\t\tint M = scan.nextInt();\n\n\t\tint[] X = new int[M];\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tX[i] = scan.nextInt();\n\t\t}\n\n\t\tscan.close();\n\t\t\n\t\tif(M <= N) {\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tArrays.sort(X);\n\t\t\n\t\tint distance[] = new int[M-1];\n\t\tfor(int i=0; i<M-1; i++) {\n\t\t\tdistance[i] = X[i+1] - X[i];\n\t\t}\n\t\t\n\t\tArrays.sort(distance);\n\t\t\n\t\tint sum = 0;\n\t\tfor(int i=0; i<(M-N); i++) {\n\t\t\tsum+=distance[i];\n\t\t}\n\t\tSystem.out.println(sum);\n\n\n\t}\n\n}", "code2": "A, B, C = gets.split.map(&:to_i)\n\nif B+C < A\n  puts 0\nelse\n  puts (B+C) - A\nend", "label": 0, "name1": "s564605710.java", "name2": "s890378071.rb"}, {"id": 165, "code1": "import java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tchar[] s = sc.next().toCharArray();\n\t\tStack<Character> st = new Stack<>();\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < s.length; i++) {\n\t\t\tif (s[i] == 'T') {\n\t\t\t\tif (st.isEmpty()) cnt++;\n\t\t\t\telse st.pop();\n\t\t\t} else {\n\t\t\t\tst.push('S');\n\t\t\t}\n\t\t}\n\t\tcnt += st.size();\n\t\tSystem.out.println(cnt);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}", "code2": "X = gets.chomp\n\nchars = Array.new(X.size) {0}\nsp = 0\n\ndecrease = 0\nX.chars.each_with_index do |s, i|\n  if s == 'S'\n    sp += 1\n  else\n    next if sp == 0\n    sp -= 1\n    decrease += 1\n  end\nend\n\nputs X.size - decrease * 2\n", "label": 1, "name1": "s350666247.java", "name2": "s860052839.rb"}, {"id": 148, "code1": "import java.util.*;\npublic class Main {\n\tint n;\n\tint[] num;\n\tScanner stdin =new Scanner(System.in);\n\t\n\tvoid Solve(){\n\t\tnum=new int[21000000];\n\t\twhile(true){\n\t\t\tn=stdin.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tSystem.out.println(findPrime(n+1,2*n));\n\t\t}\n\t\t\n\t}\n\tint findPrime(int a,int b){\n\t\tint count=0;\n\t\tfor(int i=a;i<=b;i++){\n\t\t\tif(judgePrime(i)) count++;\n\t\t}\n\t\t\n\t\treturn count;\n\t}\n\t\n\tboolean judgePrime(int p){\n\t\tif(num[p]==1) return true;\n\t\tif(num[p]==-1) return false;\n\t\t\n\t\tif(p<4){\n\t\t\tnum[p]=1;\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\tif(p%2==0){\n\t\t\t\tnum[p]=-1;\n\t\t\t\treturn false; \n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=3;i<p;i++){\n\t\t\t\tif(p%i==0){\n\t\t\t\t\tnum[p]=-1;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tnum[p]=1;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\t\n\t\n\tpublic static void main(String args[]){\n\t\tMain m=new Main();\n\t\tm.Solve();\n\t}\n\t\n}", "code2": "require 'prime'\nwhile n = gets.to_i\n  break if n == 0\n  p Prime.each(2 * n).drop_while{ |p| p <= n }.size\nend", "label": 1, "name1": "s726742249.java", "name2": "s276322945.rb"}, {"id": 773, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int N = sc.nextInt();\n        int[] a = new int[N];\n        for (int i=0; i<N; i++) {\n            a[i] = sc.nextInt();\n        }\n\n        int[] ans = solve(N, a);\n\n        for (int i=0; i<N; i++) {\n            System.out.println(ans[i]);\n        }\n    }\n\n    private static int[] solve(int N, int[] a) {\n        int[] ans = new int[N];\n        int total = Math.abs(a[0]) + Math.abs(a[N-1]);\n\n        for (int i=0; i<N-1; i++) {\n            total += Math.abs(a[i+1] - a[i]);\n        }\n\n        for (int i=0; i<N; i++) {\n            ans[i] = total;\n\n            if (i == 0) {\n                if (0 <= a[i] && a[i] <= a[i+1]\n                        || a[i+1] <= a[i] && a[i] <= 0) {\n//                    System.err.println(\"ans[\" + i + \"] : skip\");\n                    continue;\n                }\n                ans[i] = total - Math.abs(a[i] - 0) - Math.abs(a[i] - a[i+1]) + Math.abs(a[i+1] - 0);\n//                System.err.println(\"ans[\" + i + \"] = \" + ans[i]);\n            } else if (i == N-1) {\n                if (0 <= a[i] && a[i] <= a[i-1]\n                        || a[i-1] <= a[i] && a[i] <= 0) {\n//                    System.err.println(\"ans[\" + i + \"] : skip\");\n                    continue;\n                }\n\n                ans[i] = total - Math.abs(a[i] - 0) - Math.abs(a[i] - a[i-1]) + Math.abs(a[i-1] - 0);\n//                System.err.println(\"ans[\" + i + \"] = \" + ans[i]);\n            }\n            else if (a[i-1] <= a[i] && a[i] <= a[i+1]\n                    || a[i+1] <= a[i] && a[i] < a[i-1]) {\n//                System.err.println(\"ans[\" + i + \"] : skip\");\n                continue;\n            } else {\n                ans[i] = total - Math.abs(a[i] - a[i-1]) - Math.abs(a[i] - a[i+1]) + Math.abs(a[i+1] - a[i-1]);\n//                System.err.println(\"ans[\" + i + \"] = \" + ans[i]);\n            }\n        }\n\n        return ans;\n    }\n}", "code2": "require 'set'\nloop do\n    n = gets.to_i\n    break if n == 0\n    g = n.times.map{gets.chomp}\n    h = Hash.new(Array.new)\n    f = \"\"\n    g.each_with_index do |s,i|\n        s = s.gsub(\"\\.\",\"\").split(\":\")\n        h[s[0]] = s[1].split(\",\")\n        f = s[0] if i == 0\n    end\n    t = h.to_a[0][0]\n    ans = Set.new\n    a = h[t]\n    while !a.empty?\n        a2 = Set.new\n        a.each do |m|\n            if h.has_key?(m)\n                h[m].each do |mm|\n                    a2.add(mm)\n                end\n            else\n                ans.add(m)\n            end\n        end\n        a = a2.to_a\n    end\n    p ans.size\nend", "label": 0, "name1": "s919464469.java", "name2": "s639565910.rb"}, {"id": 340, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        PrintWriter out = new PrintWriter(System.out);\n        InputStreamScanner in = new InputStreamScanner(System.in);\n        new Main().solve(in, out);\n        out.flush();\n    }\n\n    private void solve(InputStreamScanner in, PrintWriter out) {\n        String s = in.next();\n\n        long t = 0;\n        for (int i = 0; i < 1 << (s.length() - 1); i++) {\n            int p = 0;\n            for (int j = 0; j < s.length() - 1; j++) {\n                if ((1 & i >> j) == 1) {\n                    t += Long.parseLong(s.substring(p, j + 1));\n                    p = j + 1;\n                }\n            }\n            t += Long.parseLong(s.substring(p));\n        }\n\n        out.println(t);\n    }\n\n    static class InputStreamScanner {\n\n        private InputStream in;\n\n        private byte[] buf = new byte[1024];\n        private int len = 0;\n        private int off = 0;\n\n        InputStreamScanner(InputStream in)\t{\n            this.in = in;\n        }\n\n        String next() {\n            StringBuilder sb = new StringBuilder();\n            for (int b = skip(); !isSpace(b);){\n                sb.appendCodePoint(b);\n                b = read();\n            }\n            return sb.toString();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        char nextChar() {\n            return (char)skip();\n        }\n\n        int skip() {\n            for (int b; (b = read()) != -1;) {\n                if (!isSpace(b)) {\n                    return b;\n                }\n            }\n            return -1;\n        }\n\n        private boolean isSpace(int c) {\n            return c < 33 || c > 126;\n        }\n\n        private int read() {\n            if (len == -1) {\n                throw new InputMismatchException(\"End of Input\");\n            }\n            if (off >= len){\n                off = 0;\n                try {\n                    len = in.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException(e.getMessage());\n                }\n                if (len <= 0) {\n                    return -1;\n                }\n            }\n            return buf[off++];\n        }\n    }\n}", "code2": "def calc(s,num)\n  if num == 0\n    arr = s.split('+')\n    sum = 0\n    arr.each do |a|\n      sum += a.to_i\n    end\n    \n    return sum\n    \n  end\n  \n  return calc(s.clone.insert(num,'+'),num-1) + calc(s,num-1)\n  \nend\n\ns = gets.chomp\n\nnum = s.size()\n\nputs calc(s,num-1)", "label": 1, "name1": "s838868939.java", "name2": "s068686514.rb"}, {"id": 857, "code1": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String... args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        ArrayList<Integer> list = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            list.add(scanner.nextInt());\n        }\n        list.sort((val1, val2) -> val1 - val2);\n        int b = list.get(0);\n        for (int i = 1; i < list.size(); i++) {\n            int a = list.get(i);\n            int r = a % b;\n            while (r != 0) {\n                a = b;\n                b = r;\n                r = a % b;\n            }\n        }\n        System.out.println(b);\n    }\n}", "code2": "n=gets.to_i;m=1\nfor i in 2..n+1 do\n    m=m*i\nend\np m+2\nfor i in 2..n+1 do\n    p i\nend", "label": 0, "name1": "s333010125.java", "name2": "s199593134.rb"}, {"id": 354, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n\t\treturn (int) nl;\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n}\npublic class Main {\n\tstatic FastScanner scan=new FastScanner();\n\tstatic Scanner scanner=new Scanner(System.in);\n\tstatic long mod=1000000007;\n\tstatic double eps=0.0000000001;\n\tstatic int big=Integer.MAX_VALUE;\n\tstatic long gcd (long a, long b) {return b>0?gcd(b,a%b):a;}\n\tstatic long lcm (long a, long b) {return a*b/gcd(a,b);}\n\tstatic int max(int a,int b) {return a>b?a:b;}\n\tstatic int min(int a,int b) {return a<b?a:b;}\n\tstatic long factorial(int i) {return i==1?1:i*factorial(i-1);}\n\tstatic int lower_bound(int a[],int key) {\n\t\tint low=0,high=a.length;\n\t\twhile(low<high) {\n\t\t\tint mid=((high-low)/2)+low;\n\t\t\tif(a[mid]<=key)low=mid+1;\n\t\t\telse high=mid;\n\t\t}\n\t\treturn high;\n\t}\n\tstatic int upper_bound(int a[],int key) {\n\t\tint low=0,high=a.length;\n\t\twhile(low<high) {\n\t\t\tint mid=((high-low)/2)+low;\n\t\t\tif(a[mid]<key)low=mid+1;\n\t\t\telse high=mid;\n\t\t}\n\t\treturn high;\n\t}\n\tstatic boolean isPrime (long n) {\n\t\tif (n==2) return true;\n\t\tif (n<2 || n%2==0) return false;\n\t\tdouble d = Math.sqrt(n);\n\t\tfor (int i=3; i<=d; i+=2)if(n%i==0){return false;}\n\t\treturn true;\n\t}\n\tstatic int upper_division(int a,int b) {\n\t\tif(a%b==0) {\n\t\t\treturn a/b;\n\t\t}\n\t\telse {\n\t\t\treturn a/b+1;\n\t\t}\n\t}\n\tstatic long lupper_division(long a,long b) {\n\t\tif(a%b==0) {\n\t\t\treturn a/b;\n\t\t}\n\t\telse {\n\t\t\treturn a/b+1;\n\t\t}\n\t}\n\tstatic long lmax(long a,long b) {return Math.max(a, b);}\n\tstatic long lmin(long a,long b) {return Math.min(a, b);}\n\tstatic int[] setArray(int a) {\n\t\tint b[]=new int[a];\n\t\tfor(int i=0;i<a;i++) {\n\t\t\tb[i]=scan.nextInt();\n\t\t}\n\t\treturn b;\n\t}\n\tstatic long[] lsetArray(int a) {\n\t\tlong b[]=new long[a];\n\t\tfor(int i=0;i<a;i++) {\n\t\t\tb[i]=scan.nextLong();\n\t\t}\n\t\treturn b;\n\t}\n\tstatic String reverce(String str) {\n\t\tString strr=\"\";\n\t\tfor(int i=str.length()-1;i>=0;i--) {\n\t\t\tstrr+=str.charAt(i);\n\t\t}\n\t\treturn strr;\n\t}\n\tpublic static void printArray(char[] ch) {\n\t\tfor(int i=0;i<ch.length-1;i++) {\n\t\t\tSystem.out.print(ch[i]+\" \");\n\t\t}\n\t\tSystem.out.println(ch[ch.length-1]);\n\t}\n\tpublic static int[][] doublesort(int[][]a) {\n\t\tArrays.sort(a,(x,y)->Integer.compare(x[0],y[0]));\n\t\treturn a;\n\t}\n\tstatic long modpow(long x,long n,long mo) {\n\t\tlong sum=1;\n\t\twhile(n>0) {\n\t\t\tif((n&1)==1) {\n\t\t\t\tsum=sum*x%mo;\n\t\t\t}\n\t\t\tx=x*x%mo;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn sum;\n\t}\n\tpublic static char[] revch(char ch[]) {\n\t\tchar ret[]=new char[ch.length];\n\t\tfor(int i=ch.length-1,j=0;i>=0;i--,j++) {\n\t\t\tret[j]=ch[i];\n\t\t}\n\t\treturn ret;\n\t}\n\tpublic static int[] revint(int ch[]) {\n\t\tint ret[]=new int[ch.length];\n\t\tfor(int i=ch.length-1,j=0;i>=0;i--,j++) {\n\t\t\tret[j]=ch[i];\n\t\t}\n\t\treturn ret;\n\t}\n\tpublic static void warshall_floyd(int v[][],int n) {\n\t\tfor(int k=0;k<n;k++)\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t\tv[i][j]=min(v[i][j],v[i][k]+v[k][j]);\n\t}\n\tpublic static void main(String[] args) {\n\t\tlong a=scan.nextLong();\n\t\tlong b=scan.nextLong();\n\t\tint cnt=0;\n\t\tlong now=a;\n\t\twhile(now<=b) {\n\t\t\tcnt++;\n\t\t\tnow*=2;\n\t\t}\n\t\tSystem.out.println(cnt);\n\t}\n}", "code2": "eval'X,Y='+`tr ' ' ,`;p (Y/X).bit_length", "label": 1, "name1": "s941851054.java", "name2": "s262263338.rb"}, {"id": 156, "code1": "/**\n * Created at 16:38 on 2019-08-27\n */\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n  static FastScanner sc = new FastScanner();\n  static Output out = new Output(System.out);\n\n  static final int[] dx = {0, 1, 0, -1};\n  static final int[] dy = {-1, 0, 1, 0};\n\n  static final long MOD = (long) (1e9 + 7);\n  static final long INF = Long.MAX_VALUE / 2;\n\n  public static class Solver {\n    public Solver() {\n\n      int Q = sc.nextInt();\n\n      for (int q=0; q<Q; q++) {\n        long A = sc.nextLong();\n        long B = sc.nextLong();\n        long P = A * B;\n\n        long sqrt = sqrt(P-1);\n\n        long ans = 2*sqrt;\n\n        if (Math.min(A, B) <= sqrt) ans--; //\u9ad8\u6a4b\u541b\u3068\u540c\u3058\u9806\u4f4d\u306b\u306a\u3063\u3066\u3044\u308b\u3082\u306e\u3092\u9664\u304f\n        if (sqrt * (sqrt+1) > P-1) ans--; //\u30c0\u30d6\u30eb\u30ab\u30a6\u30f3\u30c8\u3057\u3066\u3044\u308b\u3082\u306e\u3092\u9664\u304f(x == y \u306e\u3068\u304d)\n\n        out.println(ans);\n      }\n\n\n    }\n\n    long sqrt(long n) {\n      long res = (long)Math.floor(Math.sqrt(n));\n      while (res * res > n) res--;\n      while ((res+1) * (res+1) <= n) res++;\n      return res;\n    }\n\n  }\n\n  public static void main(String[] args) {\n    new Solver();\n    out.flush();\n  }\n\n  static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int N, boolean oneBased) {\n      if (oneBased) {\n        int[] array = new int[N + 1];\n        for (int i = 1; i <= N; i++) {\n          array[i] = sc.nextInt();\n        }\n        return array;\n      } else {\n        int[] array = new int[N];\n        for (int i = 0; i < N; i++) {\n          array[i] = sc.nextInt();\n        }\n        return array;\n      }\n    }\n\n    public long[] nextLongArray(int N, boolean oneBased) {\n      if (oneBased) {\n        long[] array = new long[N + 1];\n        for (int i = 1; i <= N; i++) {\n          array[i] = sc.nextLong();\n        }\n        return array;\n      } else {\n        long[] array = new long[N];\n        for (int i = 0; i < N; i++) {\n          array[i] = sc.nextLong();\n        }\n        return array;\n      }\n    }\n  }\n\n  static class Output extends PrintWriter {\n\n    public Output(PrintStream ps) {\n      super(ps);\n    }\n\n    public void print(int[] a, String separator) {\n      for (int i = 0; i < a.length; i++) {\n        if (i == 0) print(a[i]);\n        else print(separator + a[i]);\n      }\n      println();\n    }\n\n    public void print(long[] a, String separator) {\n      for (int i = 0; i < a.length; i++) {\n        if (i == 0) print(a[i]);\n        else print(separator + a[i]);\n      }\n      println();\n    }\n\n    public void print(String[] a, String separator) {\n      for (int i = 0; i < a.length; i++) {\n        if (i == 0) print(a[i]);\n        else print(separator + a[i]);\n      }\n      println();\n    }\n\n    public void print(ArrayList a, String separator) {\n      for (int i = 0; i < a.size(); i++) {\n        if (i == 0) print(a.get(i));\n        else print(separator + a.get(i));\n      }\n      println();\n    }\n  }\n\n}\n", "code2": "#!/usr/bin/env ruby\n\nrequire 'set'\n\nclass Hash\n  def push(key, value)\n    self[key] = [] if self[key] == nil\n    self[key].push(value)\n  end\nend\n\nclass Array\n  def lower_bound(value)\n    left = -1;\n    right = self.length;\n    while left + 1 < right\n      mid = left + (right - left) / 2;\n      if self[mid] >= value\n        right = mid\n      else\n        left = mid\n      end\n    end\n    right\n  end\n\n  def unique\n    res = [self.first]\n    each_cons(2) do |a, b|\n      if a != b\n        res.push(b)\n      end\n    end\n    res\n  end\nend\n\ndef get_ints\n  gets.chomp.split.map(&:to_i)\nend\n\ndef get_ints_minus_one\n  get_ints.map { |x| x - 1 }\nend\n\ndef get_int\n  gets.chomp.to_i\nend\n\nQ = get_int\nQ.times do |i|\n  a, b = get_ints\n\n  if a == b\n    puts 2 * (a-1)\n    next\n  end\n  min = [a, b].min\n  max = [a, b].max\n\n  ab = a * b\n\n  high = max - 1\n  low = min\n  while high - low > 1\n    mid = low + (high - low) / 2\n\n    if mid ** 2 >= ab\n      high = mid\n    else\n      low = mid\n    end\n  end\n\n  high, low = [high, low].max, [high, low].min\n  rest = if high * high < ab\n    high + high - min - 1\n  elsif high * low < ab\n    high + low - min - 1\n  else\n    low + low - min - 1\n  end\n\n  puts min - 1 + rest\n\n  # ab = a * b\n  # b_down = (ab/(a+1)).then { |x| x * (a+1) == ab ? x - 1 : x }\n  # b_down_amari = b - b_down - 1\n  #\n  # a_down = (ab/(b+1)).then { |x| x * (b+1) == ab ? x - 1 : x }\n  # a_down_amari = a - a_down - 1\n  #\n  # binding.pry if a == 22\n  # puts b_down + a_down + [a_down_amari, b_down_amari].min\nend\n", "label": 1, "name1": "s001351994.java", "name2": "s516108110.rb"}, {"id": 573, "code1": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n    \tScanner sc = new Scanner(System.in);\n      \tint A,B,C;\n      \tA = sc.nextInt();\n      \tB = sc.nextInt();\n      \tC = sc.nextInt();\n      \tif ((A < C && C < B) || (B < C && C < A)) {\n            \tSystem.out.print(\"Yes\");\n        }  else {\n        \tSystem.out.print(\"No\");\n        }   \n    }\n}", "code2": "eval\"(*D),K,*A=\"+`dd`.split*?,;puts D[K.times{D<<A.all?{|a|!D[-a]}}]?:Second: :First", "label": 0, "name1": "s403728510.java", "name2": "s678851692.rb"}, {"id": 205, "code1": "\nimport static java.lang.Math.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic int modP = 1000000007;\n\n\tstatic class TaskX {\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tint n = in.nextInt();\n\t\t\tlong[] t = in.nextLongArray(n), a = in.nextLongArray(n);\n\n\t\t\tlong[] tCalc = new long[n];\n\t\t\tArrays.fill(tCalc, -1);\n\n\t\t\tlong[] aCalc = new long[n];\n\t\t\tArrays.fill(aCalc, -1);\n\n\t\t\tlong[] tDef = new long[n];\n\t\t\tlong[] aDef = new long[n];\n\n\t\t\tlong tMax = -1, aMax = -1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (tMax < t[i]) {\n\t\t\t\t\ttMax = t[i];\n\t\t\t\t\ttDef[i] = t[i];\n\t\t\t\t} else {\n\t\t\t\t\ttCalc[i] = tMax;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = n-1; i >= 0; i--) {\n\t\t\t\tif (aMax < a[i]) {\n\t\t\t\t\taMax = a[i];\n\t\t\t\t\taDef[i] = a[i];\n\t\t\t\t} else {\n\t\t\t\t\taCalc[i] = aMax;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (aCalc[i] == -1 && tCalc[i] == -1) {\n\t\t\t\t\tif (aDef[i] != tDef[i]) {\n\t\t\t\t\t\tout.println(0);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else if (aCalc[i] == -1) {\n\t\t\t\t\tif (aDef[i] > tCalc[i]) {\n\t\t\t\t\t\tout.println(0);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else if (tCalc[i] == -1) {\n\t\t\t\t\tif (tDef[i] > aCalc[i]) {\n\t\t\t\t\t\tout.println(0);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong ans = 1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (tCalc[i] == -1 || aCalc[i] == -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tans = ans * min(aCalc[i],tCalc[i]) % modP;\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\n\t}\n\n}\n", "code2": "eval\"N,*T=#{`tr \u0001-! ,`}0\"\nz=1\nN.times{|i|a,b=T[N+i,2]\nz*=[[[a,t=T[i]].min,0,-1[a-t]][s=T[i-1]<=>t],0,(s%3-1)[t-a]][b<=>a]\nz%=10**9+7}\np z", "label": 1, "name1": "s083135979.java", "name2": "s222734626.rb"}, {"id": 694, "code1": "import java.util.*;\npublic class Main {\n        static Scanner sc = new Scanner(System.in);\n        static void myout(Object t){System.out.println(t);}//standard output\n        static void myerr(Object t){System.err.println(t);}//standard error\n        static String getStr(){return sc.next();}\n        static int getInt(){return Integer.parseInt(getStr());}\n        static long getLong(){return Long.parseLong(getStr());}\n        static boolean isNext(){return sc.hasNext();}\n        static String[] mySplit(String str){return str.split(\"\");}\n        public static void main(String[] args){\n          int N = getInt();\n          int M = getInt();\n          if(N >= M){\n            myout(0);\n            return;\n          }\n          long output = 0;\n          ArrayList<Integer> list = new ArrayList<Integer>(M);\n          for(int i = 0; i < M; i++){\n            list.add(getInt());\n          }\n          Collections.sort(list);\n          //myout(list);\n          PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\n          for(int i = 1; i < M; i++){\n            pq.add(Math.abs(list.get(i)-list.get(i-1)));\n          }\n          for(int i = 0; i < N-1; i++){\n            pq.poll();\n          }\n          while(pq.size() != 0){\n            output += pq.poll();\n          }\n          myout(output);\n        }\n        //\u4fbf\u5229\u30e1\u30bd\u30c3\u30c9\u8ffd\u52a0\u67a0\u3053\u3053\u304b\u3089\n\n        //\u4fbf\u5229\u30e1\u30bd\u30c3\u30c9\u8ffd\u52a0\u67a0\u3053\u3053\u307e\u3067\n}\n", "code2": "module AtCoder\n  class DSU\n    def initialize(n = 0)\n      @n = n\n      @parent_or_size = Array.new(n, -1)\n    end\n\n    def merge(a, b)\n      x, y = leader(a), leader(b)\n      return x if x == y\n\n      x, y = y, x if -@parent_or_size[x] < -@parent_or_size[y]\n      @parent_or_size[x] += @parent_or_size[y]\n      @parent_or_size[y] = x\n    end\n\n    def same(a, b)\n      leader(a) == leader(b)\n    end\n\n    def leader(a)\n      return a if @parent_or_size[a] < 0\n\n      @parent_or_size[a] = leader(@parent_or_size[a])\n    end\n\n    def size(a)\n      -@parent_or_size[leader(a)]\n    end\n\n    def groups\n      @n.times.group_by { |i| leader(i) }.values\n    end\n  end\nend\n\nn, m = gets.split.map!(&:to_i)\n\ndsu = AtCoder::DSU.new(n + 1)\nm.times do\n  a, b = gets.split.map!(&:to_i)\n  dsu.merge(a, b)\nend\n\nputs dsu.groups.size - 2\n", "label": 0, "name1": "s460372083.java", "name2": "s989552174.rb"}, {"id": 584, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        int count = Integer.valueOf(reader.readLine());\n        String s = reader.readLine();\n\n        long[][] dp = new long[count][count];\n        dp[0][0] = 1;\n        long modulo = 1_000_000_007;\n\n        for (int i = 1; i < count; ++i) {\n            if (s.charAt(i - 1) == '<') {\n                dp[i][0] = 0;\n                for (int j = 1; j <= i; ++j) {\n                    dp[i][j] = dp[i][j - 1] + dp[i - 1][j - 1];\n                    dp[i][j] %= modulo;\n                }\n            } else {\n                dp[i][i] = 0;\n                for (int j = i - 1; j >= 0; --j) {\n                    dp[i][j] = dp[i][j + 1] + dp[i - 1][j];\n                    dp[i][j] %= modulo;\n                }\n            }\n        }\n\n        long res = 0;\n        for (int i = 0; i < count; ++i) {\n            res += dp[count - 1][i];\n            res %= modulo;\n        }\n        System.out.println(res);\n    }\n}\n", "code2": "a, b, c = gets().chomp.split(\"\\s\").map{|x| x.to_i}\n\nl = [a, b, c].sort()\n\ndiff1 = l[2] - l[0]\ndiff2 = l[2] - l[1]\n\nr = diff2\nrem = diff1 - diff2\n\nif rem.even?\n  r += rem / 2\n  puts r\n  exit()\nend\n\nr += rem / 2 + 1\nr += 1\n\nputs r\n", "label": 0, "name1": "s833810272.java", "name2": "s904033547.rb"}, {"id": 555, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tint[] num = new int[4];\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tString st =sc.nextLine().split(\",\")[1];\n\t\t\tif(st.equals(\"A\")){\n\t\t\t\tnum[0]++;\n\t\t\t}else if(st.equals(\"B\")){\n\t\t\t\tnum[1]++;\n\t\t\t}else if(st.equals(\"AB\")){\n\t\t\t\tnum[2]++;\n\t\t\t}else if(st.equals(\"O\")){\n\t\t\t\tnum[3]++;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < num.length ; i++){\n\t\t\tSystem.out.println(num[i]);\n\t\t}\n\t\tsc.close();\n\t}\n}", "code2": "n,k = gets.split.map(&:to_i)\np [n%k, k-n%k].min\n", "label": 0, "name1": "s769605617.java", "name2": "s519723899.rb"}, {"id": 194, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n  public static void main(String[] args) {\n\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    long[] a = new long[n];\n\n    for (int i = 0; i < n; i++) {\n      a[i] = sc.nextInt();\n    }\n\n    Arrays.sort(a); // \u6607\u9806\n    long sum = a[n - 1];\n\n    if (n == 2) {\n      System.out.println(sum);\n    } else {\n      if (n % 2 == 1) {\n        int num = n / 2;\n        sum += a[n - num - 1];\n        for (int i = n - num; i < n - 1; i++) {\n          sum += 2 * a[i];\n        }\n        System.out.println(sum);\n      } else {\n        int num = n / 2;\n        for (int i = n - num; i < n - 1; i++) {\n          sum += 2 * a[i];\n        }\n        System.out.println(sum);\n      }\n    }\n\n  }\n}", "code2": "n = gets.to_i\na = gets.chomp.split.map &:to_i\na.sort!.reverse!\n\nans = a[0]\ncount = 1\n\na[1..-1].each_with_index do |v|\n  break if count >= n - 1 \n  ans += v\n  count += 1\n  break if count >= n - 1\n  ans += v\n  count += 1\nend\n\np ans\n", "label": 1, "name1": "s266436818.java", "name2": "s887528547.rb"}, {"id": 117, "code1": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\t\n\tpublic static void main(String[] args) {\n\t\tFastScanner scanner=new FastScanner();\n\t\tint n=scanner.nextInt(),k=scanner.nextInt();\n\t\tint a[]=scanner.readArray(n);\n\t\t\n\t\tboolean dp[]=new boolean[k+1];\n//\t\tArrays.fill(dp, true);\n//\t\tdp[0]=false;\n\t\t\n\t\tfor(int stones=0;stones<=k;stones++) {\n\t\t\tfor(int j:a)\n\t\t\t\tif(j<=stones&&!dp[stones-j]) dp[stones]=true;\n\t\t}\n\t\tif(dp[k]) System.out.println(\"First\");\n\t\telse System.out.println(\"Second\");\n\t\n\t\t\n\t\t\n\n\t}\n\tstatic class FastScanner{\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\t\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tdouble nextDoubel() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tint [] readArray(int n) {\n\t\t\tint a[]=new int[n];\n\t\t\tfor(int i=0;i<n;i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\t\n\t}\n\n}\n\n", "code2": "eval\"(*D),K,*A=\"+`dd`.split*?,;puts D[K.times{D<<A.all?{|a|!D[-a]}}]?:Second: :First", "label": 1, "name1": "s041813111.java", "name2": "s678851692.rb"}, {"id": 336, "code1": "import java.util.*;\nclass Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String S[] = sc.next().split(\"\");\n    \n    int n = (int)Math.pow(2, S.length - 1);\n    \n    long total = 0;\n    for (int i = 0; i < n; i++) {\n      String s = S[0];\n      \n      for (int j = 0; j < S.length - 1; j++) {\n        if ((1&i>>j) == 1) {\n          total += Long.parseLong(s);\n          s = S[j + 1];\n        } else {\n          s += S[j + 1];\n        }\n      }\n      total += Long.parseLong(s);\n    }\n    System.out.println(total);\n  }\n}", "code2": "$s = gets.chomp\n$result = 0\n\ndef calc(idxs)\n  sum = 0\n  start = 0\n  idxs.each do |idx|\n    sum += $s[start..(idx-1)].to_i\n    start = idx\n  end\n  return sum + $s[start..($s.size-1)].to_i\nend\n\ndef explore(idx=0, idxs=[])\n  if idx == $s.size-1 then\n    $result += calc(idxs)\n  else\n    explore(idx+1, idxs)\n    explore(idx+1, idxs + [idx+1])\n  end\nend\n\nexplore()\nputs $result", "label": 1, "name1": "s109985040.java", "name2": "s268035195.rb"}, {"id": 924, "code1": "import java.util.*;\nimport java.lang.*;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint N = sc.nextInt();\n\t\tint[] s = new int[N+1];\n\t\tint total = 0;\n\t\tfor( int i=1; i<=N; i++ ){\n\t\t\ts[i] = sc.nextInt();\n\t\t\ttotal += s[i];\n\t\t}\n\t\tArrays.sort(s);\n\t\tint ans = 0;\n\t\tint dis = 0;\n\t\tint a = 1;\n\t\tint b = 0;\n\t\tfor( int i=1; i<=N; i++ ){\n\t\t\tif( s[i]%10!=0 ){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( i==N ){\n\t\t\t\tans = 0;\n\t\t\t\tb = 1;\n\t\t\t}\n\t\t}\n\t\tif( total%10!=0 ){\n\t\t\tans = total;\n\t\t}else if(b==0){\n\t\t\tfor( int i=1; i<=N; i++ ){\n\t\t\t\tif( s[i]%10!=0 ){\n\t\t\t\t\tans = total - s[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n", "code2": "h,w = gets.split.map(&:to_i)\nused = Array.new(h).map{Array.new(w,false)}\ns = h.times.map{gets.chomp}\nans = 0\nh.times do |i|\n    w.times do |j|\n        next if used[i][j]\n        q = [[i,j]]\n        used[i][j] = true\n        a = b = 0\n        if s[i][j] == \".\"\n            a += 1\n        else\n            b += 1\n        end\n        while q.any?\n            x,y = q.shift\n            if x != 0 && s[x][y] != s[x-1][y] && !used[x-1][y]\n                q.push([x-1,y])\n                used[x-1][y] = true\n                if s[x-1][y] == \".\"\n                    a += 1\n                else\n                    b += 1\n                end\n            end\n            if x != h-1 && s[x][y] != s[x+1][y] && !used[x+1][y]\n                q.push([x+1,y])\n                used[x+1][y] = true\n                if s[x+1][y] == \".\"\n                    a += 1\n                else\n                    b += 1\n                end\n            end\n            if y != 0 && s[x][y] != s[x][y-1] && !used[x][y-1]\n                q.push([x,y-1])\n                used[x][y-1] = true\n                if s[x][y-1] == \".\"\n                    a += 1\n                else\n                    b += 1\n                end\n            end\n            if y != w-1 && s[x][y] != s[x][y+1] && !used[x][y+1]\n                q.push([x,y+1])\n                used[x][y+1] = true\n                if s[x][y+1] == \".\"\n                    a += 1\n                else\n                    b += 1\n                end\n            end\n        end\n        ans += a*b\n    end\nend\nputs ans", "label": 0, "name1": "s551116804.java", "name2": "s085625093.rb"}, {"id": 905, "code1": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class Main {\n\n\tprivate static final String NO = \"No\";\n\tprivate static final String YES = \"Yes\";\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\tprivate List<Integer>[] g;\n\n\tprivate static final long MOD = 998244353;\n\tprivate static final int INF = Integer.MAX_VALUE;\n\n\tvoid solve() {\n\t\tint T = 1;\n\t\tfor (int i = 0; i < T; i++)\n\t\t\tsolve(i);\n\t}\n\n\tvoid solve(int T) {\n\t\tint n = ni();\n\t\twhile (!isPrime(n))\n\t\t\tn++;\n\t\tout.println(n);\n\t}\n\n\tprivate boolean isPrime(int n) {\n\t\tfor (int i = 2; i <= Math.sqrt(n); i++)\n\t\t\tif (n % i == 0)\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t// a^b\n\tlong power(long a, long b) {\n\t\tlong x = 1, y = a;\n\t\twhile (b > 0) {\n\t\t\tif (b % 2 != 0) {\n\t\t\t\tx = (x * y) % MOD;\n\t\t\t}\n\t\t\ty = (y * y) % MOD;\n\t\t\tb /= 2;\n\t\t}\n\t\treturn x % MOD;\n\t}\n\n\tprivate long gcd(long a, long b) {\n\t\twhile (a != 0) {\n\t\t\tlong tmp = b % a;\n\t\t\tb = a;\n\t\t\ta = tmp;\n\t\t}\n\t\treturn b;\n\t}\n\n\tvoid run() throws Exception {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\tif (!INPUT.isEmpty())\n\t\t\ttr(System.currentTimeMillis() - s + \"ms\");\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\tprivate boolean vis[];\n\n\tprivate int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != '\n\t\t\t\t\t\t\t\t\t// ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n) {\n\t\t\tif (!(isSpaceChar(b)))\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate List<Integer> na2(int n) {\n\t\tList<Integer> a = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta.add(ni());\n\t\treturn a;\n\t}\n\n\tprivate int[][] na(int n, int m) {\n\t\tint[][] a = new int[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = na(m);\n\t\treturn a;\n\t}\n\n\tprivate int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate long[] nl(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate long[][] nl(int n, int m) {\n\t\tlong[][] a = new long[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nl(m);\n\t\treturn a;\n\t}\n\n\tprivate long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}", "code2": "player = {}\n%w[a b c].each { |a| player[a] = gets.chomp.chars.reverse }\n\nwinner = ''\nturn = 'a'\nloop do\n  if player[turn].empty?\n    winner = turn\n    break\n  end\n\n  turn = player[turn].pop\nend\nputs winner.upcase\n", "label": 0, "name1": "s541097399.java", "name2": "s025363057.rb"}, {"id": 728, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tprivate void solve() {\n\t\tScanner io = new Scanner(System.in);\n\t\tint N = io.nextInt();\n\t\tint M = io.nextInt();\n\t\tboolean[] medium = new boolean[N];\n\t\tboolean[] ableToN = new boolean[N];\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint a = io.nextInt()-1;\n\t\t\tint b = io.nextInt()-1;\n\t\t\tif(a==0) medium[b] = true;\n\t\t\tif(b==0) medium[a] = true;\n\t\t\tif(a==N-1) ableToN[b] = true;\n\t\t\tif(b==N-1) ableToN[a] = true;\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(medium[i] && ableToN[i]){\n\t\t\t\tSystem.out.println(\"POSSIBLE\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"IMPOSSIBLE\");\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\n}", "code2": "x, y = gets.split.map(&:to_i)\n\nlast = x * (y / x)\nl = 0\n\nloop do\n  l += 1\n  a = x * 2 ** l\n\n  break if a > last\nend\n\nputs l\n", "label": 0, "name1": "s464102860.java", "name2": "s356215569.rb"}, {"id": 361, "code1": "import java.util.Scanner;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tprivate static final int INF = (int)1e9;\n\n\tstatic class Pair {\n\t\tint first;\n\t\tint second;\n\n\t\tpublic Pair(int first, int second) {\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn first + second;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\tif (other instanceof Pair) {\n\t\t\t\tPair p = (Pair)other;\n\n\t\t\t\treturn p.first == first && p.second == second;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner in = new Scanner(System.in)) {\n\t\t\tint n = in.nextInt();\n\t\t\tList<Integer>[] g = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tg[i] = new ArrayList<>();\n\n\t\t\tint m = in.nextInt();\n\t\t\tint r = in.nextInt();\n\t\t\tMap<Pair, Integer> dist = new HashMap<>();\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint f = in.nextInt();\n\t\t\t\tint t = in.nextInt();\n\t\t\t\tint w = in.nextInt();\n\n\t\t\t\tg[f].add(t);\n\t\t\t\tdist.put(new Pair(f, t), w);\n\t\t\t}\n\n\t\t\tdijkstra(g, n, dist, r);\n\t\t} catch (Exception ex) {\n\t\t\tthrow new RuntimeException(ex);\n\t\t}\n\t}\n\n\tpublic static void dijkstra(List<Integer> g[], int n, Map<Pair, Integer> dist, int s) {\n\t\tint[] d = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\td[i] = INF;\n\n\t\td[s] = 0;\n\t\tPriorityQueue<Pair> pq = new PriorityQueue<>((x, y) -> x.second-y.second);\n\t\tpq.add(new Pair(s, 0));\n\n\t\twhile (!pq.isEmpty()) {\n\t\t\tPair p = pq.remove();\n\n\t\t\tfor (int v : g[p.first]) {\n\t\t\t\tint dd = d[p.first] + dist.get(new Pair(p.first, v));\n\t\t\t\tif (dd < d[v]) {\n\t\t\t\t\td[v] = dd;\n\t\t\t\t\tpq.add(new Pair(v, d[v]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (d[i] == INF)\n\t\t\t\tSystem.out.println(\"INF\");\n\t\t\telse\n\t\t\t\tSystem.out.println(d[i]);\n\t\t}\n\t}\n}", "code2": "def dijkstra(g, s)\n  def enq(pq, val)\n    pq << val\n    cd = pq.size\n    pr = cd / 2\n    until pr.zero? || (pq[pr - 1] <=> pq[cd - 1]) < 0\n      pq[pr - 1], pq[cd - 1] = pq[cd - 1], pq[pr - 1]\n      cd = pr\n      pr = cd / 2\n    end\n  end\n\n  def deq(pq)\n    pq[0], pq[-1] = pq[-1], pq[0]\n    rs = pq.delete_at(-1)\n    unless pq.empty?\n      pr = 1\n      cd = [pr * 2, pr * 2 + 1].select { |i| pq[i - 1] }.min_by { |i| pq[i - 1] }\n      until cd.nil? || (pq[pr - 1] <=> pq[cd - 1]) < 0\n        pq[pr - 1], pq[cd - 1] = pq[cd - 1], pq[pr - 1]\n        pr = cd\n        cd = [pr * 2, pr * 2 + 1].select { |i| pq[i - 1] }.min_by { |i| pq[i - 1] }\n      end\n    end\n    rs\n  end\n\n  pq = []\n  d = Array.new(g.size) { Float::INFINITY }\n  d[s] = 0\n  enq(pq, [0, s])\n\n  until pq.empty?\n    v_cost, v = deq(pq)\n    next if d[v] < v_cost\n    g[v].each do |e|\n      if d[e.to] > d[v] + e.cost\n        d[e.to] = d[v] + e.cost\n        enq(pq, [d[e.to], e.to])\n      end\n    end\n  end\n\n  d\nend\n\nEdge = Struct.new('Edge', :to, :cost)\n\nv, e, r = gets.split.map(&:to_i)\ng = Array.new(v) { [] }\ne.times do\n  s, t, d = gets.split.map(&:to_i)\n  g[s] << Edge.new(t, d)\nend\n\ndijkstra(g, r).each do |sum|\n  puts (sum == Float::INFINITY ? 'INF' : sum)\nend", "label": 1, "name1": "s004699498.java", "name2": "s716711304.rb"}, {"id": 85, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tint[] num = new int[4];\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tString st =sc.nextLine().split(\",\")[1];\n\t\t\tif(st.equals(\"A\")){\n\t\t\t\tnum[0]++;\n\t\t\t}else if(st.equals(\"B\")){\n\t\t\t\tnum[1]++;\n\t\t\t}else if(st.equals(\"AB\")){\n\t\t\t\tnum[2]++;\n\t\t\t}else if(st.equals(\"O\")){\n\t\t\t\tnum[3]++;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < num.length ; i++){\n\t\t\tSystem.out.println(num[i]);\n\t\t}\n\t\tsc.close();\n\t}\n}", "code2": "count = {\n  \"A\"  => 0,\n  \"B\"  => 0,\n  \"AB\" => 0,\n  \"O\"  => 0\n}\n\nwhile line = gets\n  data = line.chomp.split(\",\")\n  count[data[1]] += 1\nend\n\nputs count[\"A\"]\nputs count[\"B\"]\nputs count[\"AB\"]\nputs count[\"O\"]", "label": 1, "name1": "s769605617.java", "name2": "s431000983.rb"}, {"id": 710, "code1": "import java.util.*;\n\npublic class Main {\n  public static long MOD = (long)Math.pow(10, 6) + 3;\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    long[] kai = new long[(int)MOD];\n//    long[] inkai = new long[(int)MOD];\n//    long[] in = new long[(int)MOD];\n    kai[0] = 1;\n    kai[1] = 1;\n//    inkai[0] = 1;\n//    inkai[1] = 1;\n//    in[1] = 1;\n    for(long i = 2; i < MOD; i++) {\n      kai[(int)i] = (i * kai[(int)i - 1]) % MOD;\n//      inkai[(int)i] = func(kai[(int)i], MOD - 2);\n//      in[(int)i] = func(i, MOD - 2);\n    }\n    int q = sc.nextInt();\n    for(int i = 0; i < q; i++) {\n      long x = sc.nextLong();\n      long d = sc.nextLong();\n      long n = sc.nextLong();\n      long ans = 0;\n      if(d == 0) {\n        if(x == 0) {\n          ans = 0;\n        } else {\n          ans = func(x, n % (MOD - 1));\n        }\n      } else {\n        long inv = func(d, MOD - 2);\n        x = (x * inv) % MOD;\n        if(x == 0) {\n          ans = 0;\n        } else {\n          if((int)(x + n - 1) >= MOD) {\n            ans = 0;\n          } else {\n            long t = func(d, n % (MOD - 1));\n            long invkai = func(kai[(int)x - 1], MOD - 2);\n            ans = (((kai[(int)(x + n - 1)] * invkai) % MOD) * t) % MOD;\n          }\n        }\n      }\n      System.out.println(ans);\n    }\n  }\n  public static long func(long a, long x) {\n    if(x == 0) return 1;\n    if(x >= 1) {\n      if(x % 2 == 0) {\n        long t = func(a, x / 2);\n        return (t * t) % MOD;\n      } else {\n        long t = func(a, x - 1);\n        return (a * t) % MOD;\n      }\n    }\n    return 0;\n  } \n}", "code2": "a, b, c = gets.chomp.split.map(&:to_i)\n\nputs [a, b, c].sort.take(2).inject(&:+)\n", "label": 0, "name1": "s406339057.java", "name2": "s756092498.rb"}, {"id": 714, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author cunbidun\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        EProductOfArithmeticProgression solver = new EProductOfArithmeticProgression();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EProductOfArithmeticProgression {\n        private static final int MOD = (int) 1e6 + 3;\n        private InputReader in;\n        private PrintWriter out;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            this.in = in;\n            this.out = out;\n            int q = in.nextInt();\n\n            int[] fac = new int[MOD + 1];\n            int[] inv = new int[MOD + 1];\n            fac[0] = 1;\n            inv[0] = Op.inv(1, MOD);\n            for (int i = 1; i <= MOD; i++) {\n                fac[i] = Op.mulMod(fac[i - 1], i, MOD);\n                inv[i] = Op.inv(fac[i], MOD);\n            }\n\n            while (q-- > 0) {\n                int x = in.nextInt();\n                int d = in.nextInt();\n                int n = in.nextInt();\n                if (d == 0) {\n                    out.println(Op.powMod(x, n, MOD));\n                    continue;\n                }\n                x = Op.mulMod(x, Op.inv(d, MOD), MOD);\n                int ans;\n                if (x + n - 1 >= MOD || x == 0) ans = 0;\n                else\n                    ans = Op.mulMod(fac[x + n - 1], inv[x - 1], MOD);\n                out.println(Op.mulMod(ans, Op.powMod(d, n, MOD), MOD));\n            }\n        }\n\n    }\n\n    static class Op {\n        public static int mulMod(int x, int y, int MOD) {\n            return (int) (((long) x * y) % MOD);\n        }\n\n        public static int powMod(int x, long p, int MOD) {\n            if (p == 0) return 1;\n            int t = powMod(x, p / 2, MOD);\n            if ((p & 1) == 1)\n                return mulMod(mulMod(t, t, MOD), x, MOD);\n            return mulMod(t, t, MOD);\n        }\n\n        public static int inv(int x, int MOD) {\n            return powMod(x, MOD - 2, MOD);\n        }\n\n    }\n\n    static class InputReader extends InputStream {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private static boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n", "code2": "def main\n  s = ARGF.gets.chomp\n\n  # + \u3092\u5165\u308c\u3089\u308c\u308b\u5834\u6240\u306e\u6570\n  n = s.length - 1\n\n  sum = 0\n  # 2^n     = 1 << n\n  0.upto((1 << n) - 1) do |mask|\n    # puts \"mask = #{mask}\"\n    last_idx = 0\n    0.upto(n-1) do |i|\n      if mask[i] == 1\n        # '+'\u3092 i\u756a\u76ee \u3068 i+1\u756a\u76ee\u306e\u9593\u306b\u5165\u308c\u308b\n        part = s.slice(last_idx, i - last_idx + 1)\n        # puts part\n        sum += part.to_i\n        last_idx = i+1\n      end\n    end\n    last_part = s.slice(last_idx..-1)\n    # puts last_part\n    sum += last_part.to_i\n  end\n\n  puts sum\nend\n\nif __FILE__ == $0\n  main\nend\n", "label": 0, "name1": "s606724970.java", "name2": "s267462480.rb"}, {"id": 182, "code1": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tString str = scanner.nextLine();\n\t\tString[] ab = str.split(\" \");\n\t\tint a = Integer.parseInt(ab[0]);\n\t\tint b = Integer.parseInt(ab[1]);\n\t\tif (a > b) {\n\t\t\tSystem.out.println(a - 1);\n\t\t}else {\n\t\t\tSystem.out.println(a);\n\t\t}\n\t\t\n\t\tscanner.close();\n\n\t}\n\n}\n", "code2": "a,b=gets.split.map &:to_i;p a-(a>b ? 1 : 0)", "label": 1, "name1": "s957138694.java", "name2": "s514721505.rb"}, {"id": 537, "code1": "import java.util.*;\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int x = 0, y = 0; \n\tstatic String second;\n\tstatic int second_ = 0;\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO \u30c4\u7be0\u30a5\u30c4\u7763\u30e7\u30c4\u9752\u30ab\u30c4\u9752\u30e3\u30c4\u3064\u30a6\u30c4\u3065\u30a7\u30c4\u3064\u30b9\u30c4\u03b4\u30bd\u30c4\u30c3\u30c4\u30c9\u30c4\u30fb\u30c4\u30b9\u30c4\u30bf\u30c4\u30d6\n\t\tread();\t\n\t\tslove();\n\t\t\n\t}\n\tstatic boolean read(){\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tsecond = sc.next();\n\t\t\tsecond_ = second_ + Integer.parseInt(second);\n\t\t}\n\t\t//System.out.println(second_);\n\t\treturn true;\n\t}\n\tstatic void slove(){\n\t\tx = second_/60;\n\t\ty = second_ % 60;\n\t\tSystem.out.println(x);\n\t\tSystem.out.println(y);\n\t}\n}", "code2": "puts (1..$_.to_i).map{a,b,c=gets.split.map &:to_i;[a,b+c]}.max_by{|i,j|j}*\" \"while gets>=?1", "label": 0, "name1": "s543682667.java", "name2": "s404961830.rb"}, {"id": 177, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[][] field;\n\tstatic String[][] dp;\n\tstatic int h,w;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = cin.nextInt();\n\t\t\th = cin.nextInt();\n\t\t\tif(w+h==0)break;\n\t\t\tfield=new int[h][w];\n\t\t\tdp=new String[h][w];\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tString s = cin.next();\n\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\tdp[i][j]=\"\";\n\t\t\t\t\tif(Character.isDigit(s.charAt(j))){\n\t\t\t\t\t\tfield[i][j]=s.charAt(j)-'0';\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tfield[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i<w;i++){\n\t\t\t\tif(i==0){\n\t\t\t\t\tif(field[0][i]<=0){\n\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdp[0][i]=\"\"+field[0][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(field[0][i]==-1){\n\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(!dp[0][i-1].equals(\"0\")&&!dp[0][i-1].equals(\"\")){\n\t\t\t\t\t\t\tdp[0][i]=dp[0][i-1]+field[0][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[0][i]=\"\"+field[0][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tif(i==0){\n\t\t\t\t\tif(field[i][0]<=0){\n\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdp[i][0]=\"\"+field[i][0];\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(field[i][0]==-1){\n\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(!dp[i-1][0].equals(\"0\")&&!dp[i-1][0].equals(\"\")){\n\t\t\t\t\t\t\tdp[i][0]=dp[i-1][0]+field[i][0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i][0]=\"\"+field[i][0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tString ans=\"0\";\n\t\t\tfor(int i = 1;i<h;i++){\n\t\t\t\tfor(int j = 1;j<w;j++){\n\t\t\t\t\tif(field[i][j]==-1)continue;\n\t\t\t\t\tString s1=dp[i-1][j]+field[i][j];\n\t\t\t\t\tString s2=dp[i][j-1]+field[i][j];\n\t\t\t\t\tString s3=field[i][j]+\"\";\n\t\t\t\t\tif(big(s1,s2)>=0){\n\t\t\t\t\t\tif(big(s1,s3)>=0){\n\t\t\t\t\t\t\tdp[i][j]=s1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i][j]=s3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(big(s2,s3)>=0){\n\t\t\t\t\t\t\tdp[i][j]=s2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i][j]=s3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\twhile(dp[i][j].charAt(0)=='0'&&dp[i][j].length()>1){\n\t\t\t\t\t\tdp[i][j]=dp[i][j].substring(1,dp[i][j].length());\n\t\t\t\t\t}\n\t\t\t\t\tif(big(dp[i][j],ans)>0){\n\t\t\t\t\t\tans=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\tif(big(dp[i][j],ans)>0){\n\t\t\t\t\t\tans=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//output();\n\t\t\tSystem.out.println(ans);\n\t\t}\n\n\t}\n\tstatic int big(String s1,String s2){\n\t\tif(s1.length()==s2.length()){\n\t\t\treturn s1.compareTo(s2);\n\t\t}\n\t\treturn s1.length()-s2.length();\n\t}\n\tstatic void output(){\n\t\tfor(int i = 0;i<h;i++){\n\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\tSystem.out.print(dp[i][j]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n}", "code2": "loop do\n    w, h = gets.split.map(&:to_i)\n    break if w == 0 && h == 0\n    c = h.times.map{gets.strip}\n    dp = Array.new(h).map{Array.new(w,0)}\n    max = 0\n    c.each_with_index do |r,i|\n        r.each_char.with_index do |ch, j|\n            next if ch.to_s.match(/[A-Z]/)\n            if i == 0\n                if j == 0\n                    dp[i][j] = ch.to_i\n                else\n                    dp[i][j] = (dp[i][j-1].to_s + ch).to_i\n                end\n            else\n                if j == 0\n                    dp[i][j] = (dp[i-1][j].to_s + ch).to_i\n                else\n                    dp[i][j] = ([dp[i-1][j], dp[i][j-1]].max.to_s + ch).to_i\n                end\n            end\n        end\n        max = [max, dp[i].max].max\n    end\n    puts max\nend", "label": 1, "name1": "s061375468.java", "name2": "s260108293.rb"}, {"id": 995, "code1": "import java.util.*;\npublic class Main{\n\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        String s = sc.next();\n        String ss =s.substring(0,s.length()-1);\n        int len = ss.length();\n        \n        for(int i =0;i<len;i++){\n            if(ss.length()%2==0){\n                String s1=ss.substring(0,(ss.length()/2));\n                String s2=ss.substring(ss.length()/2,ss.length());\n                if(s1.equals(s2)){\n                    System.out.println(ss.length());\n                    break;\n                }\n            }\n            ss = ss.substring(0,ss.length()-1);\n        }\n    }\n}\n\n\n\n\n", "code2": "N, T, A, *H = gets(p).split.map &:to_i\np H.map.with_index(1){|h, i|[(A - (T - h*0.006)).abs, i]}.min[1]", "label": 0, "name1": "s456132043.java", "name2": "s610653651.rb"}, {"id": 985, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic boolean p[];\n\tpublic static void main(String[] args) {\n\t\t// TODO \u30c4\u7be0\u30a5\u30c4\u7763\u30e7\u30c4\u9752\u30ab\u30c4\u9752\u30e3\u30c4\u3064\u30a6\u30c4\u3065\u30a7\u30c4\u3064\u30b9\u30c4\u03b4\u30bd\u30c4\u30c3\u30c4\u30c9\u30c4\u30fb\u30c4\u30b9\u30c4\u30bf\u30c4\u30d6\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n,i,count;\n\t\twhile(true){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tcount=0;\n\t\t\tp=new boolean[n];\n\t\t\tArrays.fill(p, true);\n\t\t\tp[0]=p[1]=false;\n\t\t\tprime(p,n);\n\n\t\t\tfor(i=n-1;1<=i/2;i--){\n\t\t\t\tif(p[i]){\n\t\t\t\t\tif(i!=n-i){\n\t\t\t\t\t\tp[i]=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(p[n-i]){\n\t\t\t\t\t\tp[n-i]=false;\n\t\t\t\t\t\t//System.out.printf(\"%d %d\\n\",i,n-i);\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\tstatic void prime(boolean p[],int n){\n\t\tint i,j;\n\t\tfor(i=2;i<n;i++){\n\t\t\tif(p[i]){\n\t\t\t\tfor(j=2*i;j<n;j+=i){\n\t\t\t\t\tp[j]=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "code2": "s=gets.chomp\np (~-s.size/2).downto(0).find{|i|s[0,i]==s[i,i]}*2", "label": 0, "name1": "s079698951.java", "name2": "s080878381.rb"}, {"id": 129, "code1": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable {\n\tFastReader scn;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\n\tvoid solve() {\n\t\tint n = scn.nextInt(), mod = (int) 1e9 + 7;\n\t\tchar[] cmp = scn.next().toCharArray();\n\t\t\n\t\tint[][] dp = new int[n + 1][n + 1];\n\t\tdp[1][1] = 1;\n\t\t\n\t\tfor(int len = 2; len <= n; len++) {\n\t\t\tint[] pref = new int[n + 1];\n\t\t\tfor(int i = 1; i <= n; i++) {\n\t\t\t\tpref[i] = (pref[i - 1] + dp[len - 1][i]) % mod;\n\t\t\t}\n\t\t\tfor(int curr = 1; curr <= len; curr++) {\n\t\t\t\tint L, R;\n\t\t\t\tif(cmp[len - 2] == '<') {\n\t\t\t\t\tL = 1;\n\t\t\t\t\tR = curr - 1;\n\t\t\t\t} else {\n\t\t\t\t\tL = curr;\n\t\t\t\t\tR = n;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(L <= R) {\n\t\t\t\t\tdp[len][curr] += (pref[R] - pref[L - 1]);\n\t\t\t\t\tif(dp[len][curr] >= mod) {\n\t\t\t\t\t\tdp[len][curr] -= mod;\n\t\t\t\t\t} else if(dp[len][curr] < 0) {\n\t\t\t\t\t\tdp[len][curr] += mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor(int curr = 1; curr <= n; curr++) {\n\t\t\tans += dp[n][curr];\n\t\t\tif(ans >= mod) {\n\t\t\t\tans -= mod;\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t}\n\n\tpublic void run() {\n\t\tlong time = System.currentTimeMillis();\n\t\tboolean oj = true;\n\t\tout = new PrintWriter(System.out);\n\t\tscn = new FastReader(oj);\n\t\tsolve();\n\t\tout.flush();\n\t\tif (!oj) {\n\t\t\tSystem.out.println(Arrays.deepToString(new Object[] { System.currentTimeMillis() - time + \" ms\" }));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"Main\", 1 << 26).start();\n\t}\n\n\tclass FastReader {\n\t\tInputStream is;\n\n\t\tpublic FastReader(boolean onlineJudge) {\n\t\t\tis = onlineJudge ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\t}\n\n\t\tpublic FastReader() {\n\t\t\tis = System.in;\n\t\t}\n\n\t\tbyte[] inbuf = new byte[1024];\n\t\tpublic int lenbuf = 0, ptrbuf = 0;\n\n\t\tint readByte() {\n\t\t\tif (lenbuf == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (ptrbuf >= lenbuf) {\n\t\t\t\tptrbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn inbuf[ptrbuf++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tint skip() {\n\t\t\tint b;\n\t\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t\t;\n\t\t\treturn b;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tchar nextChar() {\n\t\t\treturn (char) skip();\n\t\t}\n\n\t\tString next() {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile ((!isSpaceChar(b) || b == ' ')) { // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tchar[] next(int n) {\n\t\t\tchar[] buf = new char[n];\n\t\t\tint b = skip(), p = 0;\n\t\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t\t}\n\n\t\tint nextInt() {\n\t\t\tint num = 0, b;\n\t\t\tboolean minus = false;\n\t\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\tlong num = 0;\n\t\t\tint b;\n\t\t\tboolean minus = false;\n\t\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tchar[][] nextMatrix(int n, int m) {\n\t\t\tchar[][] map = new char[n][];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next(m);\n\t\t\treturn map;\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tint[][] IndIntArray(int n) {\n\t\t\tint[][] a = new int[n][];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = new int[] { nextInt(), i };\n\t\t\treturn a;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tint[][] next2DInt(int n, int m) {\n\t\t\tint[][] arr = new int[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[][] next2DLong(int n, int m) {\n\t\t\tlong[][] arr = new long[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextLongArray(m);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] shuffle(int[] arr) {\n\t\t\tRandom r = new Random();\n\t\t\tfor (int i = 1, j; i < arr.length; i++) {\n\t\t\t\tj = r.nextInt(i);\n\t\t\t\tint c = arr[i];\n\t\t\t\tarr[i] = arr[j];\n\t\t\t\tarr[j] = c;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] shuffle(long[] arr) {\n\t\t\tRandom r = new Random();\n\t\t\tfor (int i = 1, j; i < arr.length; i++) {\n\t\t\t\tj = r.nextInt(i);\n\t\t\t\tlong c = arr[i];\n\t\t\t\tarr[i] = arr[j];\n\t\t\t\tarr[j] = c;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] uniq(int[] arr) {\n\t\t\tarr = scn.shuffle(arr);\n\t\t\tArrays.sort(arr);\n\t\t\tint[] rv = new int[arr.length];\n\t\t\tint pos = 0;\n\t\t\trv[pos++] = arr[0];\n\t\t\tfor (int i = 1; i < arr.length; i++) {\n\t\t\t\tif (arr[i] != arr[i - 1]) {\n\t\t\t\t\trv[pos++] = arr[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Arrays.copyOf(rv, pos);\n\t\t}\n\n\t\tlong[] uniq(long[] arr) {\n\t\t\tarr = scn.shuffle(arr);\n\t\t\tArrays.sort(arr);\n\t\t\tlong[] rv = new long[arr.length];\n\t\t\tint pos = 0;\n\t\t\trv[pos++] = arr[0];\n\t\t\tfor (int i = 1; i < arr.length; i++) {\n\t\t\t\tif (arr[i] != arr[i - 1]) {\n\t\t\t\t\trv[pos++] = arr[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Arrays.copyOf(rv, pos);\n\t\t}\n\n\t\tint[] reverse(int[] arr) {\n\t\t\tint l = 0, r = arr.length - 1;\n\t\t\twhile (l < r) {\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tarr[r] = arr[l] ^ arr[r];\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tl++;\n\t\t\t\tr--;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] reverse(long[] arr) {\n\t\t\tint l = 0, r = arr.length - 1;\n\t\t\twhile (l < r) {\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tarr[r] = arr[l] ^ arr[r];\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tl++;\n\t\t\t\tr--;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] compress(int[] arr) {\n\t\t\tint n = arr.length;\n\t\t\tint[] rv = Arrays.copyOf(arr, n);\n\t\t\trv = uniq(rv);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = Arrays.binarySearch(rv, arr[i]);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] compress(long[] arr) {\n\t\t\tint n = arr.length;\n\t\t\tlong[] rv = Arrays.copyOf(arr, n);\n\t\t\trv = uniq(rv);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = Arrays.binarySearch(rv, arr[i]);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\t}\n}", "code2": "d=*1..gets.to_i;\ngets.chop.bytes{|c|\n\tx=0;n=d.pop;\n\td.map!{|a|x=(x+n*c[1]+(1-c%3)*a).%10**9+7}\n}\np *d", "label": 1, "name1": "s976963924.java", "name2": "s587396214.rb"}, {"id": 877, "code1": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int a = Integer.parseInt(sc.next());\n        int b = Integer.parseInt(sc.next());\n        int c = Integer.parseInt(sc.next());\n        int x = Integer.parseInt(sc.next());\n        int y = Integer.parseInt(sc.next());\n\n        long ans = Long.MAX_VALUE;\n\n        for (int i = 0; i <= Math.max(x*2, y*2); i+=2) {\n          long tmp = c*i + a*(Math.max(0,x-i/2)) + b*(Math.max(0,y-i/2));\n          ans = Math.min(tmp, ans);   \n        }\n\n        System.out.println(ans);\n        sc.close();\n    }\n}", "code2": "k = gets.to_i\na, b = gets.split.map &:to_i\nputs ((b/k==(a-1)/k) ? :NG : :OK)", "label": 0, "name1": "s740047463.java", "name2": "s407890190.rb"}, {"id": 771, "code1": "import java.util.Scanner;\n\npublic class Main {\n  private static Scanner sc;\n\n  public static void main(String[] args) {\n    sc = new Scanner(System.in);\n    new Main().solve();\n  }\n\n  private void solve() {\n    int N = sc.nextInt();\n    int[] a = new int[N + 2];\n    for (int i = 0; i < N; i++) {\n      a[i + 1] = sc.nextInt();\n    }\n    int sum = 0;\n    for (int i = 0; i <= N; i++) {\n      sum += Math.abs(a[i] - a[i + 1]);\n    }\n\n    for (int i = 0; i < N; i++) {\n      System.out.println(sum - Math.abs(a[i] - a[i + 1]) - Math.abs(a[i + 2] - a[i + 1]) + Math.abs(a[i] - a[i + 2]));\n    }\n  }\n}\n", "code2": "n = gets.to_i\nx = gets.to_i\n(n - 1).times do\n  x = x.lcm(gets.to_i)\nend\nputs x", "label": 0, "name1": "s142792447.java", "name2": "s903706562.rb"}, {"id": 141, "code1": "import java.io.IOException;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\nimport java.io.PrintWriter;\n\n@SuppressWarnings(\"unchecked\")\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        final String s;\n\n        try (\n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(System.in))) {\n            s = reader.readLine();\n        }\n\n        PrintWriter out = new PrintWriter(System.out);\n\n        final String[] sl = s.split(\" \");\n        int A = Integer.parseInt(sl[0]);\n        int B = Integer.parseInt(sl[1]);\n        int C = Integer.parseInt(sl[2]);\n\n        int max = Math.max(A, Math.max(B, C));\n\n        int sum = 3 * max - A - B - C;\n\n        int ans;\n\n        if (sum % 2 == 0) ans = sum / 2;\n        else ans = (int)Math.ceil((double)sum / 2) + 1;\n\n        out.println(ans);\n\n        out.flush();\n    }\n}\n", "code2": "array = gets.split(\" \").map { |e| e.to_i }\n\nguki = [0,0,0] #\u4e09\u3064\u306e\u5076\u5947\u3092\u8abf\u3079\u308b\nki = 0\nfor i in 0..2 do\n  if array[i]%2 == 1\n    guki[i] = 1\n    ki += 1\n  end\nend\n\ncount = 0\n\nif ki == 1 #\u5076\u5947\u3092\u63c3\u3048\u308b\n  for i in 0..2 do\n    if guki[i] == 0\n      array[i] += 1\n    end\n  end\n  count += 1\nelsif ki == 2\n  for i in 0..2 do\n    if guki[i] == 1\n      array[i] += 1\n    end\n  end\n  count += 1\nend\n\nmax = array.max #\u3044\u3061\u3070\u3093\u5927\u304d\u3044\u306e\u306b\u5408\u308f\u305b\u308b\nfor i in 0..2 do\n  if array[i] < max\n    count += (max - array[i]) / 2\n  end\nend\n\nputs count\n", "label": 1, "name1": "s588342457.java", "name2": "s981224172.rb"}, {"id": 610, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() { return Double.parseDouble(next());}\n}\npublic class Main {\n\tstatic FastScanner stdIn=new FastScanner();\n\tpublic static void main(String[] args) {\n\t\tString X=stdIn.next();\n\t\tint N=X.length();\n\t\tint s=0,t=0,ans=N;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tchar a=X.charAt(i);\n\t\t\tif(a=='S')\n\t\t\t\ts++;\n\t\t\telse{\n\t\t\t\tif(s!=0){\n\t\t\t\t\tans-=2;\n\t\t\t\t\ts--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n", "code2": "$x=0\n$y=0\n$bord = []\n$cnt = 0\n\n\ndef calc()\n\n\tmax = 0\n\tfor i in 0..$x-1\n\t\tfor j in 0..$y-1\n\t\t\tif $bord[j][i] != -1 then\n\t\t\t\tif j > 0 then\n\t\t\t\t\tup = $bord[j-1][i]\n\t\t\t\telse\n\t\t\t\t\tup = -1\n\t\t\t\tend\n\t\t\t\n\t\t\t\tif i > 0 then\n\t\t\t\t\tleft = $bord[j][i-1]\n\t\t\t\telse\n\t\t\t\t\tleft = -1\n\t\t\t\tend\n\n\t\t\t\n\t\t\t\tif up > left and up != -1 then\n\t\t\t\t\t$bord[j][i] += up * 10\n\t\t\t\t\t\n\t\t\t\telsif left != -1 then\n\t\t\t\t\t$bord[j][i] += left * 10\n\t\t\t\tend\n\t\t\t\tif $bord[j][i] > max then\n\t\t\t\t\tmax = $bord[j][i]\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn max\nend\n\t\nloop{\n\tline = gets\n\tif line==nil then\n\t\tbreak\n\tend\n\tsp = line.split(nil)\n\t\n\tif sp.count() != 2 then\n\t\tbreak\n\telse\n\t\t$x = sp[0].to_i()\n\t\t$y = sp[1].to_i()\n\t\tif $x == 0 and $y == 0 then\n\t\t\tbreak\n\t\tend\n\t\t\n\t\tsx = 0\n\t\tsy = 0\n\t\t$cnt = 1 \n\t\t$bord = Array.new($y).map{Array.new($x,0)}\n\t\tfor i in 0..$y-1\n\t\t\tline = gets\n\t\t\tfor j in 0..$x-1\n\t\t\t\ttmp = -1\n\t\t\t\tif line[j] =~ /\\d/ then\n\t\t\t\t\ttmp = line[j].to_i() \n\t\t\t\tend\n\t\t\t\t$bord[i][j] = tmp\n\t\t\tend\n\t\tend\n\t\tprint calc()\n\t\tprint(\"\\n\")\n\tend\n}", "label": 0, "name1": "s724983945.java", "name2": "s033677438.rb"}, {"id": 805, "code1": "/*\n *           AUTHOR: Maria Theresa M. Padayhag\n *             DATE: 20160326\n *  PRE-REQUIREMENT: JDK 1.8\n */\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.time.*;\nimport java.time.format.TextStyle;\nimport java.util.Locale;\n\nclass DayIndentifier\n{\n\tLocalDate date = null;\n\t\n\tpublic \tDayIndentifier( String inMonth, String inDay )\n\t{\n\t\t// NumberFormatException might be thrown here\n\t\t// but it will be handled by the caller.\n\t\tint month = Integer.parseInt( inMonth );\n\t\tint day   = Integer.parseInt( inDay );\n\t\t\n\t\t// DateTimeException might be thrown here\n\t\t// but it will be handled by the caller.\n\t\tdate = LocalDate.of( 2004, month, day );\n\t}\n\t\n\tpublic String getDayOfWeek()\n\t{\n\t\t// NullPointerException might be thrown here\n\t\t// but it will handled by the caller.\n\t\treturn date.getDayOfWeek().getDisplayName(TextStyle.FULL, Locale.ENGLISH);\n\t}\n}\n\npublic class Main\n{\n\tpublic static boolean toExit( String[] dataset )\n\t{\n\t\tfor(String data: dataset)\n\t\t{\n\t\t\tif(data.equals(\"0\"))\n\t\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic static void main( String args[] ) throws IOException\n\t{\n\t\tBufferedReader br = new BufferedReader( new InputStreamReader( System.in ) );\n\t\tString input;\n\t\tString dataset[];\n\t\tDayIndentifier di;\n\t\t\n\t\tREAD: \n\t\twhile( ( input = br.readLine() ) != null ) {\n\t\t\ttry {\n\t\t\t\tdataset = input.split(\" \");\n\t\t\t\n\t\t\t\tif( toExit( dataset ) ) {\n\t\t\t\t\tbreak READ;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif( dataset.length != 2 ) {\n\t\t\t\t\tSystem.out.println(\"Invalid input.\");\n\t\t\t\t\tcontinue READ;\n\t\t\t\t} \t\t\n\t\t\t\t\n\t\t\t\tdi = new DayIndentifier(dataset[0], dataset[1]);\n\t\t\t\tSystem.out.println( di.getDayOfWeek() );\n\t\t\t} catch( Exception e ) {\n\t\t\t\tSystem.out.println(\"Invalid input.\");\n\t\t\t\tcontinue READ;\n\t\t\t}\t\t\n\t\t}\n\t}\n}", "code2": "N = gets.to_i\nA = gets.split.map(&:to_i)\nB = gets.split.map(&:to_i)\n\nlimit = B.inject(:+) - A.inject(:+)\ncnt1 = 0\ncnt2 = 0\n\nA.zip(B).each do |a, b|\n  next if a == b\n\n  if a > b\n    cnt1 += a - b\n  else\n    cnt2 += ((b - a) / 2.0).ceil\n  end\nend\n\nif cnt1 <= limit && cnt2 <= limit\n  puts 'Yes'\nelse\n  puts 'No'\nend\n", "label": 0, "name1": "s944901694.java", "name2": "s143550502.rb"}, {"id": 57, "code1": "import java.util.*;\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int x = 0, y = 0; \n\tstatic String second;\n\tstatic int second_ = 0;\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO \u30c4\u7be0\u30a5\u30c4\u7763\u30e7\u30c4\u9752\u30ab\u30c4\u9752\u30e3\u30c4\u3064\u30a6\u30c4\u3065\u30a7\u30c4\u3064\u30b9\u30c4\u03b4\u30bd\u30c4\u30c3\u30c4\u30c9\u30c4\u30fb\u30c4\u30b9\u30c4\u30bf\u30c4\u30d6\n\t\tread();\t\n\t\tslove();\n\t\t\n\t}\n\tstatic boolean read(){\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tsecond = sc.next();\n\t\t\tsecond_ = second_ + Integer.parseInt(second);\n\t\t}\n\t\t//System.out.println(second_);\n\t\treturn true;\n\t}\n\tstatic void slove(){\n\t\tx = second_/60;\n\t\ty = second_ % 60;\n\t\tSystem.out.println(x);\n\t\tSystem.out.println(y);\n\t}\n}", "code2": "### main\n\nsec = 0\n4.times do\n  sec += gets.strip.to_i\nend\n\nputs sec / 60\nputs sec % 60", "label": 1, "name1": "s543682667.java", "name2": "s928347272.rb"}, {"id": 721, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint a = scanner.nextInt(),b = scanner.nextInt(),c = scanner.nextInt();\n\t\tint[] x = {a,b,c};\n\t\tArrays.sort(x);\n\t\tSystem.out.println(x[0]+x[1]);\n\t}\n\n}\n", "code2": "n,*z=$<.map &:split;y=z.to_h;puts\"#{z.all?{|a,b|a>?1||y[b]!=n[0]}?:IM:\"\"}POSSIBLE\"", "label": 0, "name1": "s134824979.java", "name2": "s984752060.rb"}, {"id": 253, "code1": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n\n        char[] s = sc.next().toCharArray();\n        char[] t = sc.next().toCharArray();\n\n        boolean isAns = false;\n        for (int i = s.length-1; i >= t.length-1; i--) {\n            char[] tmp = s.clone();\n            isAns = true;\n            for (int j = 0; j < t.length; j++) {\n                if (s[i-j] == t[t.length-1-j] || s[i-j] == '?') {\n                    tmp[i-j] = t[t.length-1-j];\n                } else {\n                    isAns = false;\n                    break;\n                }\n            }\n\n            if (isAns) {\n                s = tmp;\n                break;\n            }\n        }\n\n        if (isAns) {\n            for (char c : s)\n                System.out.print(c == '?' ? 'a' : c);\n        } else {\n            System.out.println(\"UNRESTORABLE\");\n        }\n    }\n\n    static class MyScanner {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in), 1 << 15);\n        StringTokenizer tokenizer;\n\n        String next() {\n            try {\n                while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                }\n            } catch (IOException ignored) {\n            }\n            return tokenizer.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}", "code2": "s = gets.chomp\nt = gets.chomp\nk = s.length - t.length + 1\ni = 0\nflag = false\nwhile i < k && !flag\n\tcp = s.clone\n\tcp[cp.length-t.length-i,t.length] = t\n\tcheck = true\n\t(cp.length).times do |j|\n\t\tcheck = false if s[j] != cp[j] && s[j] != \"?\"\n\tend\n\tflag = true if check\n\ti += 1\nend\nif flag\n\t(cp.length).times do |j|\n\t\tcp[j] = \"a\" if cp[j] == \"?\"\n\tend\n\tputs cp\nelse\n\tputs \"UNRESTORABLE\"\nend\n", "label": 1, "name1": "s842757542.java", "name2": "s763613339.rb"}, {"id": 32, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tMyInput in = new MyInput(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic long LINF = 1L << 55;\n\tstatic int MOD = 1000000007;\n\tstatic int[] mh4 = { 0, -1, 1, 0 };\n\tstatic int[] mw4 = { -1, 0, 0, 1 };\n\tstatic int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\tstatic int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n\tstatic class TaskX {\n\n\t\tpublic void solve(int testNumber, MyInput in, PrintWriter out) {\n\n\t\t\tint n = in.nextInt();\n\t\t\tlong a = in.nextLong(), b = in.nextLong();\n\t\t\tlong[] x = in.nextLongArray(n);\n\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\t\tans += Math.min(a * (x[i+1] - x[i]), b);\n\t\t\t}\n\t\t\tout.println(ans);\n\n\t\t}\n\t}\n\n\tstatic class MyInput {\n\t\tprivate final BufferedReader in;\n\t\tprivate static int pos;\n\t\tprivate static int readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500 * 8 * 2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic {\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tisDigit['0' + i] = true;\n\t\t\t}\n\t\t\tisDigit['-'] = true;\n\t\t\tisSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n\t\t\tisLineSep['\\r'] = isLineSep['\\n'] = true;\n\t\t}\n\n\t\tpublic MyInput(InputStream is) {\n\t\t\tin = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (pos >= readLen) {\n\t\t\t\tpos = 0;\n\t\t\t\ttry {\n\t\t\t\t\treadLen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException();\n\t\t\t\t}\n\t\t\t\tif (readLen <= 0) {\n\t\t\t\t\tthrow new MyInput.EndOfFileRuntimeException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buffer[pos++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\tint i = 0;\n\t\t\tint ret = 0;\n\t\t\tif (str[0] == '-') {\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t\tfor (; i < len; i++)\n\t\t\t\tret = ret * 10 + str[i] - '0';\n\t\t\tif (str[0] == '-') {\n\t\t\t\tret = -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\tint i = 0;\n\t\t\tlong ret = 0;\n\t\t\tif (str[0] == '-') {\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t\tfor (; i < len; i++)\n\t\t\t\tret = ret * 10 + str[i] - '0';\n\t\t\tif (str[0] == '-') {\n\t\t\t\tret = -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic char nextChar() {\n\t\t\twhile (true) {\n\t\t\t\tfinal int c = read();\n\t\t\t\tif (!isSpace[c]) {\n\t\t\t\t\treturn (char) c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic String nextString() {\n\t\t\treturn new String(nextChars());\n\t\t}\n\n\t\tpublic char[] nextChars() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\treturn Arrays.copyOf(str, len);\n\t\t}\n\n\t\tpublic char[][] next2DChars(int h, int w) {\n\t\t\tchar[][] s = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\ts[i] = nextChars();\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\n\t\tint reads(int len, boolean[] accept) {\n\t\t\ttry {\n\t\t\t\twhile (true) {\n\t\t\t\t\tfinal int c = read();\n\t\t\t\t\tif (accept[c]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (str.length == len) {\n\t\t\t\t\t\tchar[] rep = new char[str.length * 3 / 2];\n\t\t\t\t\t\tSystem.arraycopy(str, 0, rep, 0, str.length);\n\t\t\t\t\t\tstr = rep;\n\t\t\t\t\t}\n\t\t\t\t\tstr[len++] = (char) c;\n\t\t\t\t}\n\t\t\t} catch (MyInput.EndOfFileRuntimeException e) {\n\t\t\t}\n\t\t\treturn len;\n\t\t}\n\n\t\tpublic int[] nextIntArray(final int n) {\n\t\t\tfinal int[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArray1Index(final int n) {\n\t\t\tfinal int[] res = new int[n + 1];\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArrayDec(final int n) {\n\t\t\tfinal int[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(final int n) {\n\t\t\tfinal long[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray1Index(final int n) {\n\t\t\tfinal long[] res = new long[n + 1];\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArrayDec(final int n) {\n\t\t\tfinal long[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic double[] nextDoubleArray(int n) {\n\t\t\tdouble[] res = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextDouble();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\t}\n\n\t}\n\n}\n", "code2": "n,a,b = gets.split.map &:to_i\nz,*x = gets.split.map &:to_i\n\nans = 0\nx.each{|t|\n  w = (t-z)*a\n  w = b if w > b\n  ans += w\n  z = t\n}\n\np ans\n", "label": 1, "name1": "s004356600.java", "name2": "s327159753.rb"}, {"id": 789, "code1": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n\t\t\tint K = io.nextInt();\n\t\t\tint L = io.nextInt();\n\n\t\t\tUnionFind uf1 = new UnionFind(n);\n\t\t\tUnionFind uf2 = new UnionFind(n);\n\t\t\tUnionFind uf3 = new UnionFind(n);\n\t\t\t\n\t\t\tfor (int i = 0; i < K; i++) {\n\t\t\t\tint a = io.nextInt() - 1;\n\t\t\t\tint b = io.nextInt() - 1;\n\t\t\t\tuf1.union(a, b);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < L; i++) {\n\t\t\t\tint a = io.nextInt() - 1;\n\t\t\t\tint b = io.nextInt() - 1;\n\t\t\t\tuf2.union(a, b);\n\t\t\t}\n\n\t\t\tTreeSet<Integer>[] s1 = new TreeSet[n];\n\t\t\tTreeSet<Integer>[] s2 = new TreeSet[n];\n\t\t\tfor (int i = 0; i < n; i++) if (uf1.root(i) == i) {\n\t\t\t\tTreeSet<Integer> s = new TreeSet<>();\n\t\t\t\tfor (int j = i; j != -1; j = uf1.next[j]) { s.add(j); }\n\t\t\t\ts1[i] = s;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) if (uf2.root(i) == i) {\n\t\t\t\tTreeSet<Integer> s = new TreeSet<>();\n\t\t\t\tfor (int j = i; j != -1; j = uf2.next[j]) { s.add(j); }\n\t\t\t\ts2[i] = s;\n\t\t\t}\n\t\t\t\n\t\t\tint[] ans = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint r1 = uf1.root(i);\n\t\t\t\tint r2 = uf2.root(i);\n\n\t\t\t\tif (!s1[r1].contains(i)) continue;\n\n\t\t\t\tTreeSet<Integer> a = s1[r1].size() < s2[r2].size() ? s1[r1] : s2[r2];\n\t\t\t\tTreeSet<Integer> b = s1[r1].size() < s2[r2].size() ? s2[r2] : s1[r1];\n\t\t\t\tList<Integer> same = new ArrayList<>();\n\t\t\t\tfor (int t : a) {\n\t\t\t\t\tif (b.contains(t)) same.add(t);\n\t\t\t\t}\n\t\t\t\tfor (int t : same) {\n\t\t\t\t\ts1[r1].remove(t);\n\t\t\t\t\ts2[r2].remove(t);\n\t\t\t\t\tans[t] = same.size();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tprintArrayLn(ans);\n\t\t}\n\t}\n\t\n\tstatic\n\tclass UnionFind {\n\t\tprivate int[] data;\n\t\tprivate int[] next;\n\t\tprivate int[] last;\n\t\t\n\t\tpublic UnionFind(int size) {\n\t\t\tdata = new int[size];\n\t\t\tnext = new int[size];\n\t\t\tlast = new int[size];\n\t\t\tclear();\n\t\t}\n\t\t\n\t\tpublic void clear() {\n\t\t\tArrays.fill(data, -1);\n\t\t\tArrays.fill(next, -1);\n\t\t\tfor(int i = 0; i < last.length; i++) {\n\t\t\t\tlast[i] = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int root(int x) { return data[x] < 0 ? x : (data[x] = root(data[x])); }\n\t\t\n\t\tpublic void union(int x, int y) {\n\t\t\tif((x = root(x)) != (y = root(y))) {\n\t\t\t\tif(data[y] < data[x]) { final int t = x; x = y; y = t; }\n\t\t\t\tdata[x] += data[y];\n\t\t\t\tdata[y] = x;\n\t\t\t\tnext[last[x]] = y;\n\t\t\t\tlast[x] = last[y];\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic boolean same(int x, int y) { return root(x) == root(y); }\n\t\tpublic int size(int x) { return -data[root(x)]; }\n\t}\n\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n", "code2": "eval'*A=#'+`tr ' ' ,`\ns=m=10**9+7\nf=1\ni=0\np A.sum{i+=1\nf=f*i%m\n-_1+(_1+A[-i])*s+=i.pow(m-2,m)}*f%m", "label": 0, "name1": "s632399466.java", "name2": "s587168748.rb"}, {"id": 965, "code1": "import java.util.*;\npublic class Main {\n\n\tpublic static void main(String[] args) {\t\t\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt(), C = sc.nextInt();\n\t\tint D[][] = new int[C][C];\n\t\tint c[][] = new int[N][N];\n\t\t\n\t\tfor(int i=0;i<C;i++) {\n\t\t\tfor(int j=0;j<C;j++) {\n\t\t\t\tD[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\t\n\t\t//\u30ef\u30fc\u30b7\u30e3\u30eb\u30d5\u30ed\u30a4\u30c9\n//\t\tfor(int k=0;k<C;k++) {\n//\t\t\tfor(int i=0;i<C;i++) {\n//\t\t\t\tfor(int j=0;j<C;j++) {\n//\t\t\t\t\tD[i][j]=Math.min(D[i][j], D[i][k]+D[k][j]);\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n\t\t\n\t\tfor(int i=0;i<N;i++) {\n\t\t\tfor(int j=0;j<N;j++) {\n\t\t\t\tc[i][j] = sc.nextInt()-1;//0index\n\t\t\t}\n\t\t}\n\t\tsc.close(); \n\t\t\n\t\tint costSum0[] = new int[C]; //%3==0\n\t\tint costSum1[] = new int[C];\n\t\tint costSum2[] = new int[C];\n\t\t\n\t\tfor(int color=0;color<C;color++) {\n\t\t\tfor(int i=0;i<N;i++) {\n\t\t\t\tfor(int j=0;j<N;j++) {\n\t\t\t\t\tint nowColor = c[i][j];\n\t\t\t\t\tif((i+j)%3==0) costSum0[color] += D[nowColor][color];\n\t\t\t\t\tif((i+j)%3==1) costSum1[color] += D[nowColor][color];\n\t\t\t\t\tif((i+j)%3==2) costSum2[color] += D[nowColor][color];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = Integer.MAX_VALUE/2;\n\t\t//\u4f59\u308a\uff11\u306e\u3068\u3053\u308d\u5168\u901a\u308a\n\t\tfor(int i=0;i<C;i++) {\n\t\t\tfor(int j=0;j<C;j++) {\n\t\t\t\tfor(int k=0;k<C;k++) {\n\t\t\t\t\tif(i==j||j==k||k==i)continue;\n\t\t\t\t\tint sum = costSum0[i]+costSum1[j]+costSum2[k];\n\t\t\t\t\tans = Math.min(ans,sum);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}", "code2": "n, a, b = gets.split.map(&:to_i)\nh = n.times.map {gets.to_i}.sort_by{|e| -e}\n\nl = 1\nr = (h[0] + b - 1) / b\n\nwhile l != r\n    m = (l + r) / 2\n\n    t = 0\n    h.each do |e|\n        break if e <= b * m\n        t += (e - m * b + a - b - 1) / (a - b)\n        break if t > m\n    end\n\n    if t > m\n        l = m + 1\n    else\n        r = m\n    end\nend\n\np l", "label": 0, "name1": "s992887092.java", "name2": "s034006177.rb"}, {"id": 342, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tprivate void solve() {\n\t\tScanner io = new Scanner(System.in);\n\t\tint N = io.nextInt();\n\t\tint M = io.nextInt();\n\t\tboolean[] medium = new boolean[N];\n\t\tboolean[] ableToN = new boolean[N];\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint a = io.nextInt()-1;\n\t\t\tint b = io.nextInt()-1;\n\t\t\tif(a==0) medium[b] = true;\n\t\t\tif(b==0) medium[a] = true;\n\t\t\tif(a==N-1) ableToN[b] = true;\n\t\t\tif(b==N-1) ableToN[a] = true;\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(medium[i] && ableToN[i]){\n\t\t\t\tSystem.out.println(\"POSSIBLE\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"IMPOSSIBLE\");\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\n}", "code2": "n, m = gets.split.map(&:to_i)\nfst, snd = [], []\nm.times{\n  a, b = gets.split.map(&:to_i)\n  fst << b if a==1\n  snd << a if b==n\n}\nputs (fst & snd).empty? ? \"IMPOSSIBLE\" : \"POSSIBLE\"", "label": 1, "name1": "s464102860.java", "name2": "s938238267.rb"}, {"id": 42, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Optional;\nimport java.util.OptionalDouble;\nimport java.util.stream.DoubleStream;\nimport java.util.stream.Stream;\n\npublic class Main {\n\n  public static void main(String[] args) throws IOException {\n    \n    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {\n\n      String line;\n      String[] lines;\n      double[] s;\n      while( !(line = br.readLine()).equals(\"0\") ){\n\n        int n = Integer.parseInt(line);\n        lines = br.readLine().split(\" \");\n\n        s =\n          Stream.of(lines)\n            .mapToDouble(Double::parseDouble)\n            .toArray();\n        \n        double dm =\n          Arrays.stream(s)\n            .average()\n          .getAsDouble();\n\n        double result =\n        Arrays.stream(s)\n          .map(d -> Math.pow((d-dm),2) / n)\n          .sum();\n\n        System.out.printf(\"%.8f\\n\" , Math.sqrt(result));\n      }\n    }\n  }\n}\n", "code2": "res=Array.new\nloop do\nn=gets.to_i\nif n==0 then break end\nd=gets.split(' ').map(&:to_f)\nm=d.inject(0.00000){|r,i|r+=i}/d.size\ns=0\nd.each do |x|\n  s+=(x-m)*(x-m)\nend\nres.push(Math.sqrt(s/n))\nend\n\nres.each do |r|\n    printf(\"%f\\n\",r)\nend", "label": 1, "name1": "s757478171.java", "name2": "s936689019.rb"}, {"id": 514, "code1": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map.Entry;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nclass Main {\n    static final int MOD = 1000000007;\n    static final int INF = 1 << 30;\n\n    Main() {\n        Scanner sc = new Scanner(System.in);\n        long ans = 0;\n        long H = sc.nextLong();\n        long W = sc.nextLong();\n        if(H==1 || W==1){\n        System.out.println(1);\n        return;\n        }\n        long ht = H/2+H%2;\n        long hd = H/2;\n        long wt = W/2+W%2;\n        long wd = W/2;\n        ans += ht*wt;\n        ans += hd*wd;\n        System.out.println(ans);\n    }\n\n    public static void main(String[] args) {\n        new Main();\n    }\n}\n ", "code2": "\nn,a,b = gets.split.map(&:to_i)\nx = gets.split.map(&:to_i)\n\ncost = 0\nlast = x[0]\n\n(1...n).each{|i|\n    if (x[i]-last)*a < b\n        cost += (x[i]-last)*a\n    else\n        cost += b\n    end\n    last = x[i]\n}\n\np cost\n", "label": 0, "name1": "s490391243.java", "name2": "s273635362.rb"}, {"id": 529, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Optional;\nimport java.util.OptionalDouble;\nimport java.util.stream.DoubleStream;\nimport java.util.stream.Stream;\n\npublic class Main {\n\n  public static void main(String[] args) throws IOException {\n    \n    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {\n\n      String line;\n      String[] lines;\n      double[] s;\n      while( !(line = br.readLine()).equals(\"0\") ){\n\n        int n = Integer.parseInt(line);\n        lines = br.readLine().split(\" \");\n\n        s =\n          Stream.of(lines)\n            .mapToDouble(Double::parseDouble)\n            .toArray();\n        \n        double dm =\n          Arrays.stream(s)\n            .average()\n          .getAsDouble();\n\n        double result =\n        Arrays.stream(s)\n          .map(d -> Math.pow((d-dm),2) / n)\n          .sum();\n\n        System.out.printf(\"%.8f\\n\" , Math.sqrt(result));\n      }\n    }\n  }\n}\n", "code2": "### main\n\nsec = 0\n4.times do\n  sec += gets.strip.to_i\nend\n\nputs sec / 60\nputs sec % 60", "label": 0, "name1": "s757478171.java", "name2": "s928347272.rb"}, {"id": 448, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        BRemovingBlocks solver = new BRemovingBlocks();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BRemovingBlocks {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            long[] a = in.readLongArray(n);\n\n            Modulo.mod = MiscUtils.MOD7;\n\n            long[] s = new long[n];\n            s[0] = 1;\n            for (int i = 1; i < n; i++) {\n                s[i] = Modulo.add(s[i - 1], Modulo.rev(i + 1));\n            }\n\n            long ans = 0;\n            for (int i = 0; i < n; i++) {\n                long sum = Modulo.mlt(a[i], s[i] + s[n - 1 - i] - 1);\n                ans = Modulo.add(ans, sum);\n            }\n            for (int i = 1; i <= n; i++) ans = Modulo.mlt(ans, i);\n            out.printLine(ans);\n        }\n\n    }\n\n    static class Modulo {\n        public static long mod;\n        private long value;\n\n        public Modulo(long value) {\n            this.value = (value % mod + mod) % mod;\n        }\n\n        public static long add(long a, long b) {\n            return ((a + b) % mod + mod) % mod;\n        }\n\n        public static long mlt(long a, long b) {\n            return ((a % mod + mod) * (b % mod + mod)) % mod;\n        }\n\n        public static long rev(long a) {\n            //return pow(a, mod - 2);\n            return (Euclid.extgcd(a, mod, new long[3])[0] % mod + mod) % mod;\n        }\n\n        public String toString() {\n            return \"\" + value;\n        }\n\n    }\n\n    static class Euclid {\n        public static long[] extgcd(long a, long b, long[] is) {\n            if (a == 0) {\n                is[0] = 0;\n                is[1] = 1;\n                is[2] = b;\n            } else {\n                extgcd(b % a, a, is);\n                long x = is[1] - b / a * is[0];\n                is[1] = is[0];\n                is[0] = x;\n            }\n            return is;\n        }\n\n    }\n\n    static class MiscUtils {\n        public static final int MOD7 = (int) (1e9 + 7);\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public long[] readLongArray(int size) {\n            long[] array = new long[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readLong();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long readLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "code2": "class Integer\n  def mod_pow(n, mod)\n    x = self\n    res = 1\n\n    while n > 0\n      res = res * x % mod if n[0] == 1\n      x = x * x % mod\n      n >>= 1\n    end\n\n    res\n  end\n\n  def mod_inverse(mod)\n    mod_pow(mod - 2, mod)\n  end\nend\n\nN = gets.to_i\nA = gets.split.map(&:to_i)\nMOD = 10 ** 9 + 7\n\nRUI = []\n\nk = 1\n\n1.upto(N) do |i|\n  k = k * i % MOD\n\n  if i == 1\n    RUI << i.mod_inverse(MOD)\n  else\n    RUI << RUI.last + i.mod_inverse(MOD)\n  end\nend\n\nans = 0\n\nA.each_with_index do |a, i|\n  r = 0\n\n  r += RUI[i]\n  r += RUI[N - i - 1]\n\n  v = a * k * (r - 1.mod_inverse(MOD))\n\n  ans += v.to_i\n  ans %= MOD\nend\n\nputs ans\n", "label": 1, "name1": "s003754625.java", "name2": "s063449734.rb"}, {"id": 545, "code1": "import java.util.*;\nclass Main {\n\tstatic int n;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\tint maxDistance = 0;\n\t\t\tMap<Integer, Integer> map = new HashMap<Integer, Integer>(n);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tint d = sc.nextInt() + sc.nextInt();\n\t\t\t\tmap.put(d, p);\n\t\t\t\tmaxDistance = Math.max(d, maxDistance);\n\t\t\t}\n\t\t\tSystem.out.printf(\"%d %d\\n\", map.get(maxDistance), maxDistance);\n\t\t}\n\t}\n}", "code2": "blood = [\"A\", \"B\", \"AB\", \"O\"]\narray = Array.new(4).map{ |i| i=0 }\nwhile s = gets\n  i = blood.index(s.split(\",\")[1].chomp)\n  array[i] += 1\nend\narray.each{ |i| puts i }", "label": 0, "name1": "s188031790.java", "name2": "s356822078.rb"}, {"id": 723, "code1": "import java.util.*;\nclass Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String S[] = sc.next().split(\"\");\n    \n    int n = (int)Math.pow(2, S.length - 1);\n    \n    long total = 0;\n    for (int i = 0; i < n; i++) {\n      String s = S[0];\n      \n      for (int j = 0; j < S.length - 1; j++) {\n        if ((1&i>>j) == 1) {\n          total += Long.parseLong(s);\n          s = S[j + 1];\n        } else {\n          s += S[j + 1];\n        }\n      }\n      total += Long.parseLong(s);\n    }\n    System.out.println(total);\n  }\n}", "code2": "n, m = gets.split.map(&:to_i)\nfst, snd = [], []\nm.times{\n  a, b = gets.split.map(&:to_i)\n  fst << b if a==1\n  snd << a if b==n\n}\nputs (fst & snd).empty? ? \"IMPOSSIBLE\" : \"POSSIBLE\"", "label": 0, "name1": "s109985040.java", "name2": "s938238267.rb"}, {"id": 20, "code1": "import java.util.Scanner;\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\n\t\tlong h = stdIn.nextLong();\n\t\tlong w = stdIn.nextLong();\n\t\t\n\t\tlong cnt = 0;\n\t\tif(h==1 || w == 1) {\n\t\t\tSystem.out.println(1);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(h % 2 == 0 && w % 2 == 0) { //h\u5076\u6570\u3001w\u5076\u6570\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tcnt += w/2;\n\t\t\t}\n\t\t}else if(h % 2 == 0 && w % 2 != 0) { //h\u5076\u6570\u3001w\u5947\u6570\n\t\t\tfor(int i = 0; i < h ; i++) {\n\t\t\t\tif(i % 2 == 0) {\n\t\t\t\t\tcnt += (w+1)/2;\n\t\t\t\t}else {\n\t\t\t\t\tcnt += w/2;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( h % 2 != 0 && w % 2 == 0) { // h\u5947\u6570,w\u5076\u6570\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tcnt += w/2;\n\t\t\t}\n\t\t}else {                                //h\u5947\u6570,w\u5947\u6570\n\t\t\tfor(int i = 0; i < h ; i++) {\n\t\t\t\tif(i % 2 == 0) {\n\t\t\t\t\tcnt += (w+1)/2;\n\t\t\t\t}else {\n\t\t\t\t\tcnt += w/2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(cnt);\n\n\t}\n\n}\n", "code2": "H, W = gets.split.map(&:to_f)\nif H == 1 || W == 1 then\n  p 1\nelse\n  p (H*W / 2).ceil\nend\n\n", "label": 1, "name1": "s990691093.java", "name2": "s709033779.rb"}, {"id": 918, "code1": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception{\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tString A = br.readLine();\n\t\tString B = br.readLine();\n\t\tString C = br.readLine();\n\t\t\n\t\tint i=0,j=0,k=0;\n\t\tchar turn = 'a';\n\t\twhile(i<=A.length() && j<=B.length() && k<=C.length())\n\t\t{\n\t\t\tif(turn == 'a')\n\t\t\t{\n\t\t\t\tif(i == A.length())\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println('A');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tturn = A.charAt(i++);\n\t\t\t}\n\t\t\t\t\n\t\t\telse if(turn == 'b')\n\t\t\t{\n\t\t\t\tif(j == B.length())\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println('B');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tturn = B.charAt(j++);\n\t\t\t}\n\t\t\t\t\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(k == C.length())\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println('C');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tturn = C.charAt(k++);\n\t\t\t}\n\t\t}\n\t}\n}\n", "code2": "N=gets.to_i\nM=10**9+7\ns=0\n*F=I=[r=1,1]\n*R=I\n2.upto(N){|i|I<<z=M/i*-I[M%i]%M;F<<r=r*i%M;R<<z*R[-1]%M;i<-~N/2||i>=N||s+=F[-2]*r*R[2*i-N]%M}\np N>2?(r-s)%M: 1\n###############################################\n###############################################\n###############################################\n###############################################\n###############################################", "label": 0, "name1": "s420347453.java", "name2": "s632402521.rb"}, {"id": 78, "code1": "import java.io.*;\nimport java.util.*;\nimport static java.lang.System.out;\n\npublic class Main {\n    static MyReader in = new MyReader();\n\n    public static void main(String[] args) {\n        int N = in.i();\n        int k = ((int)Math.sqrt(1 + 8 * N) + 1) / 2;\n        out.println(k * (k - 1) / 2 == N ? solve(k) : \"No\");\n    }\n\n    static String solve(int k) {\n        StringBuilder sb = new StringBuilder(\"Yes\\n\");\n        sb.append(k).append('\\n');\n\n        for (int i = 1; i < k; i++) {\n            sb.append(k - 1).append(' ');\n\n            int t = 1 + i * (i - 1) / 2;\n            for (int j = 1; j < i; j++) {\n                sb.append(t++).append(' ');\n            }\n\n            for (int j = i; j < k; j++) {\n                sb.append(t).append(' ');\n                t += j;\n            }\n            sb.append('\\n');\n        }\n\n        sb.append(k - 1).append(' ');\n        int t = 1;\n        for (int i = 2; i <= k; i++) {\n            sb.append(t).append(' ');\n            t += i;\n        }\n\n        return sb.toString();\n    }\n}\n\nclass MyReader extends BufferedReader {\n    char[] cbuf = new char[1024];\n    int head = 0;\n    int tail = 0;\n\n    MyReader() {\n        super(new InputStreamReader(System.in));\n    }\n\n    char next() {\n        if (head == tail) {\n            try {\n                tail = super.read(cbuf, 0, cbuf.length);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            head = 0;\n        }\n        return cbuf[head++];\n    }\n\n    void back() {\n        head--;\n    }\n\n    boolean minus() {\n        boolean minus;\n        while (true) {\n            char c = next();\n            if (!isDelimiter(c)) {\n                if (!(minus = c == '-')) back();\n                return minus;\n            }\n        }\n    }\n\n    void skip() {\n        while (isDelimiter(next()));\n        back();\n    }\n\n    char[] s(int N) {\n        char[] cbuf = new char[N];\n        read(cbuf, 0, N);\n        return cbuf;\n    }\n\n    public int read(char[] cbuf, int off, int len) {\n        skip();\n        int i;\n        for (i = 0; i < cbuf.length; i++) {\n            char c = next();\n            if (isDelimiter(c)) {\n                break;\n            }\n            cbuf[i] = c;\n        }\n        return i;\n    }\n\n    boolean isDelimiter(char c) {\n        return c == ' ' || c == '\\n' || c == '\\r';\n    }\n\n    int i() {\n        boolean minus = minus();\n        int n = 0;\n        while (true) {\n            int k = next() - '0';\n            if (k < 0 || 9 < k) break;\n            n = 10 * n + k;\n        }\n        return minus ? -n : n;\n    }\n\n    int[] ii(final int N) {\n        int[] a = new int[N];\n        for (int j = 0; j < a.length; j++) a[j] = i();\n        return a;\n    }\n\n    long l() {\n        boolean minus = minus();\n        long n = 0;\n        while (true) {\n            int k = next() - '0';\n            if (k < 0 || 9 < k) break;\n            n = 10 * n + k;\n        }\n        return minus ? -n : n;\n    }\n}\n", "code2": "N = gets.to_i\nh = {}\n1.upto(1.0/0){|i|\n  edge = i * (i - 1) / 2\n  h[edge] = i\n  break if edge > 10**5\n}\n\nif !h[N]\n  puts:No\n  exit\nend\n\nvortex = h[N]\nedges = vortex.times.map{[]}\nn = 1\nvortex.times{|i|\n  i.times{|j|\n    edges[i] << n\n    edges[j] << n\n    n += 1\n  }\n}\nputs:Yes\np vortex\nedges.each{|e|\n  puts [e.size, *e]* \" \"\n}\n", "label": 1, "name1": "s799940458.java", "name2": "s612660257.rb"}, {"id": 35, "code1": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // Your code here!\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long a = sc.nextLong();\n        long b = sc.nextLong();\n        long[] array = new long[n];\n        for (int i = 0; i < n; i++) {\n            array[i] = sc.nextLong();\n        }\n        \n        long ans = 0;\n        for (int i = 1; i < n; i++) {\n            long dis = array[i] - array[i-1];\n            if (dis * a < b) {\n                ans += dis * a;\n            } else {\n                ans += b;\n            }\n        }\n        \n        System.out.println(ans);\n    }\n}", "code2": "N, A, B = gets.split.map &:to_i\nx = gets.split.map &:to_i\na = 0\nx.each_cons 2 do |c, n|\n    a += (t=(n-c)*A) < B ? t : B\nend\n\np a", "label": 1, "name1": "s129000734.java", "name2": "s891670277.rb"}, {"id": 469, "code1": "import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long[] a = new long[n];\n        long[] b = new long[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextLong();\n        }\n        for (int i = 0; i < n; i++) {\n            b[i] = sc.nextLong();\n        }\n        long sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += b[i] - a[i];\n        }\n\n        long cnt = 0;\n        for (int i = 0; i < n; i++) {\n            if (a[i] < b[i]) {\n                cnt += (b[i] - a[i] + 1) / 2;\n            }\n        }\n        if (cnt <= sum) {\n            System.out.println(\"Yes\");\n            return;\n        }\n        System.out.println(\"No\");\n    }\n}\n", "code2": "N = gets.to_i\nA = gets.split.map(&:to_i)\nB = gets.split.map(&:to_i)\n\nlimit = B.inject(:+) - A.inject(:+)\ncnt1 = 0\ncnt2 = 0\n\nA.zip(B).each do |a, b|\n  next if a == b\n\n  if a > b\n    cnt1 += a - b\n  else\n    cnt2 += ((b - a) / 2.0).ceil\n  end\nend\n\nif cnt1 <= limit && cnt2 <= limit\n  puts 'Yes'\nelse\n  puts 'No'\nend\n", "label": 1, "name1": "s202753514.java", "name2": "s143550502.rb"}, {"id": 867, "code1": "import java.io.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.util.*;\n\nclass Main{public static void main(String[] args){new Solver();}}\n\nclass Solver{\n\tScanReader reader=new ScanReader(System.in);\n\tPrintWriter writer=new PrintWriter(System.out);\n\tSolver(){main(); writer.flush();}\n\t\n\tvoid main(){\n\t\tBigInteger m=BigInteger.ONE;\n\t\tfor(int i=0;i<1500;i++)\n\t\t\tm=m.multiply(BigInteger.valueOf(i+2));\n\t\tm=m.add(BigInteger.valueOf(2));\n\t\t\n\t\twhile(reader.hasNext()){\n\t\t\tint n=Integer.parseInt(reader.next());\n\t\t\tSystem.out.println(m);\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tSystem.out.println(i+2);\n\t\t}\n\t}\n}\n\nclass ScanReader{\n\tBufferedReader br;\n\tStringTokenizer st;\n\tpublic ScanReader(InputStream in){\n\t\tbr=new BufferedReader(new InputStreamReader(in));\n\t\tst=null;\n\t}\n\tpublic boolean hasNext(){\n\t\twhile(st==null || !st.hasMoreTokens()){\n\t\t\ttry{\n\t\t\t\tif(!br.ready())\n\t\t\t\t\treturn false;\n\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t\tcatch(IOException e){\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tpublic String nextLine(){\n\t\thasNext();\n\t\treturn st.nextToken(\"\");\n\t}\n\tpublic String next(){\n\t\thasNext();\n\t\treturn st.nextToken();\n\t}\n}", "code2": "def cin\n  gets.split.map(&:to_i)\nend\n\na, b, c, x, y = cin\nans1, ans2, ans3 = 0\nmin, max = [x, y].minmax\n\nans1 = c * max * 2\nans2 = if x >= y\n         c * min * 2 + a * (x - y)\n       else\n         c * min * 2 + b * (y - x)\n       end\n\nans3 = a * x + b * y\nputs [ans1, ans2, ans3].min\n", "label": 0, "name1": "s499130776.java", "name2": "s125556838.rb"}, {"id": 951, "code1": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        String ns = sc.next();\n        int count = 0;\n        for(int i = 0; i < 4; i++){\n            if(ns.charAt(i) == '2') count++;\n        }\n        \n        System.out.println(count);\n    }\n}\n", "code2": "n, m, k = gets.split.map(&:to_i)\n\nputs (0..n).any?{|i| (0..m).any?{|j| m*i+n*j-2*i*j==k}} ? \"Yes\" : \"No\"", "label": 0, "name1": "s382305590.java", "name2": "s891763589.rb"}, {"id": 591, "code1": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        List<Integer> abc = new ArrayList<>();\n        abc.add(sc.nextInt());\n        abc.add(sc.nextInt());\n        abc.add(sc.nextInt());\n        Collections.sort(abc);\n\n        int count = 0;\n        int diff21 = abc.get(2) - abc.get(1);\n        abc.set(0, abc.get(0) + diff21);\n        abc.set(1, abc.get(1) + diff21);\n        count += diff21;\n\n        int diff10 = abc.get(1) - abc.get(0);\n        if (diff10 % 2 == 0) {\n            count += diff10 / 2;\n        } else {\n            count += (diff10 + 1) / 2 + 1;\n        }\n        System.out.println(count);\n    }\n\n}\n", "code2": "require 'prime'\nwhile n = gets.to_i\n  break if n == 0\n  p Prime.each.lazy.take_while{ |p| p <= 2 * n }.drop_while{ |p| p <= n }.to_a.size\nend", "label": 0, "name1": "s664157474.java", "name2": "s057981665.rb"}, {"id": 486, "code1": "\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int A = scanner.nextInt();\n        int B = scanner.nextInt();\n        int C = scanner.nextInt();\n\n        if ((A == B && A != C) || (A == C && A != B) || (B == C &&  A != B)) {\n            System.out.println(\"Yes\");\n        } else {\n            System.out.println(\"No\");\n        }\n    }\n}\n", "code2": "a = gets.split.map(&:to_i)\nputs a.uniq.size == 2 ? \"Yes\" : \"No\"\n", "label": 1, "name1": "s748781959.java", "name2": "s479750293.rb"}, {"id": 656, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n    static class FS {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            return hasNextByte() ? buffer[ptr++] : -1;\n        }\n\n        private boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        private void skipUnprintable() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        }\n\n        public boolean hasNext() {\n            skipUnprintable();\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n    }\n\n    static int[] np;\n    static int n;\n\n    public static void main(String[] args) throws Exception {\n        FS fs = new FS();\n//        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n//        String s = bf.readLine();\n//        int n = Integer.parseInt(s.substring(0, s.indexOf(' ')));//n packages\n//        int k = Integer.parseInt(s.substring(s.indexOf(' '), s.length()));//k trucks\n        n = fs.nextInt();\n        int k = fs.nextInt();\n\n\n        np = new int[n];\n        int max = 0;\n        for (int i = 0; i < n; i++) {\n\n            np[i] = fs.nextInt();\n            max = max < np[i] ? np[i] : max;\n        }\n        int p = 0;\n        int resids = 0;\n\n        int maxInt = 10000 *100000;\n        int minInt = max-1;\n        int mid = (maxInt + minInt) / 2;\n        while (maxInt - minInt > 1) {\n            int v = checkN(mid);\n            if (v > k) minInt = mid;\n            else maxInt = mid;\n\n            mid = (maxInt + minInt) / 2;\n        }\n        System.out.println(maxInt);\n    }\n\n    private static int checkN(int p) {\n        int resids = p;\n        int ink = 1;//\u5f53\u524d\u5df2\u7528\u5361\u8f66\n        for (int i = 0; i < n; i++) {\n            int j = np[i];\n            if (resids >= j) {\n                resids -= j;\n            } else {\n                ink++;\n                resids = p;\n                i--;\n            }\n        }\n        return ink;\n    }\n}\n", "code2": "n=gets.to_i\na=gets.chomp.split.map(&:to_i)\ns=0\na.each_with_index{|x, i|\n    if a[x-1] == i+1\n        s+=1\n    end\n}\nputs s/2\n", "label": 0, "name1": "s272482227.java", "name2": "s156669970.rb"}, {"id": 229, "code1": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint cnt(int s,int g,int cnt,int xy[][],int n){\n\t\tint result = 0;\n\t\tint c[] = new int [n+1];\n\t\tint d[] = new int [n+1];\n\t\tc[s] = 1;\n\t\tif(s == g && cnt > 0)result = 1;\n\t\tfor(int i = 1;i < cnt;i++){\n\t\t\tfor(int j = 1;j < n+1;j++){\n\t\t\t\tfor(int k = 1;k < n+1;k++){\n\t\t\t\t\tif(xy[j][k] == 1 && c[j] == i){\n\t\t\t\t\t\td[k] = i + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 1;j < n+1;j++){\n\t\t\t\tc[j] = d[j];\n\t\t\t}\n\t\t\tif(c[g] > 0){\n\t\t\t\tresult = c[g];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(i == 101){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tvoid doIt() { \n\t\tint n = sc.nextInt();\n\t\tint xy[][] = new int [n+1][n+1];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint r1 = sc.nextInt();\n\t\t\tint k1 = sc.nextInt();\n\t\t\tfor(int j = 0;j < k1;j++){\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\txy[r1][t] = 1;\n\t\t\t}\n    \t }\n\t\tint p = sc.nextInt();\n\t\tfor(int i = 0;i < p;i++){\n\t\t\tint s = sc.nextInt();\n\t\t\tint d = sc.nextInt();\n\t\t\tint TTL = sc.nextInt();\n\t\t\tint ans = cnt(s,d,TTL,xy,n);\n\t\t\tif(ans == 0){\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t//\u4e2d\u8eab\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\tSystem.out.print(xy[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t*/\n     }\n    public static void main(String[] args) {\n    \t// TODO Auto-generated method stub\n    \tnew Main().doIt();\n    }\n}", "code2": "Infinity = 1000000\n\ndef dijkstra graph, s\n  n = graph.size\n  dist = Array.new(n, Infinity)\n  visited = Array.new(n, false)\n  dist[s] = 0\n  loop do\n    min = -1\n    sd = Infinity\n    n.times do |i|\n      if (! visited[i]) && dist[i] < sd\n        min = i\n        sd = dist[i]\n      end\n    end\n    break if min == -1\n    visited[min] = true\n    graph[min].each do |node|\n      newLen = dist[min] + 1\n      if(newLen < dist[node])\n        dist[node] = newLen\n      end\n    end\n  end\n  dist\nend\n\n#\u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u53d6\u5f97\nn = $stdin.gets.to_i\ngraph = Array.new(n).map{Array.new}\nn.times do\n  input = $stdin.gets.split(\" \").map(&:to_i)\n  input[1].times do |t|\n    graph[input[0] - 1] << input[t + 2] - 1\n  end\nend\n\n#\u30d1\u30b1\u30c3\u30c8\u51e6\u7406\n$stdin.gets.to_i.times do\n  s, d, v = $stdin.gets.split(\" \").map(&:to_i)\n  dist = dijkstra(graph, s - 1)\n  if dist[d - 1] + 1 <= v\n    puts dist[d - 1] + 1\n  else\n    puts \"NA\"\n  end\nend", "label": 1, "name1": "s130494609.java", "name2": "s718030625.rb"}, {"id": 353, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.util.NoSuchElementException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author HBonsai\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CMultipleGift solver = new CMultipleGift();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CMultipleGift {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            long X = in.nextLong();\n            long Y = in.nextLong();\n            int ans = 1;\n            long A = X;\n            while (A <= Y) {\n                A *= 2;\n                if (A > Y) break;\n                ans++;\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class FastScanner implements Closeable {\n        private final InputStream in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        public FastScanner(InputStream in) {\n            this.in = in;\n        }\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        public boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n            return hasNextByte();\n        }\n\n        public long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        public void close() {\n            try {\n                in.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n}\n\n", "code2": "X,Y = $stdin.gets.chomp.split(\" \").map{ |a| a.to_i }\nputs (Y/X).to_s(2).size", "label": 1, "name1": "s947131740.java", "name2": "s056155066.rb"}, {"id": 268, "code1": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Random;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        try (BufferedInputStream in = new BufferedInputStream(System.in);\n             PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out))) {\n\n            _Scanner sc = new _Scanner(in);\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            int c = sc.nextInt();\n            int k = sc.nextInt();\n\n            if (a + b >= k) {\n                out.println(Math.min(k, a));\n            } else {\n                out.println(a - (k - a - b));\n            }\n        }\n    }\n\n    private static void reverse(int[] vs) {\n        for (int i = 0; i < vs.length / 2; i++) {\n            swap(vs, i, vs.length - 1 - i);\n        }\n    }\n\n    static class _Scanner {\n        InputStream is;\n        _Scanner(InputStream is) {\n            this.is = is;\n        }\n        byte[] bb = new byte[1 << 15];\n        int k, l;\n        byte getc() {\n            try {\n                if (k >= l) {\n                    k = 0;\n                    l = is.read(bb);\n                    if (l < 0) return -1;\n                }\n                return bb[k++];\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        byte skip() {\n            byte b;\n            while ((b = getc()) <= 32)\n                ;\n            return b;\n        }\n\n        int nextInt() {\n            int n = 0;\n            int sig = 1;\n            for (byte b = skip(); b > 32; b = getc()) {\n                if (b == '-') {\n                    sig = -1;\n                } else {\n                    n = n * 10 + b - '0';\n                }\n            }\n            return sig * n;\n        }\n\n        long nextLong() {\n            long n = 0;\n            long sig = 1;\n            for (byte b = skip(); b > 32; b = getc()) {\n                if (b == '-') {\n                    sig = -1;\n                } else {\n                    n = n * 10 + b - '0';\n                }\n            }\n            return sig * n;\n        }\n\n        public String next() {\n            StringBuilder sb = new StringBuilder();\n            for (int b = skip(); b > 32; b = getc()) {\n                sb.append(((char) b));\n            }\n            return sb.toString();\n        }\n    }\n\n    private static void shuffle(int[] ar) {\n        Random rnd = new Random();\n        for (int i = 0; i < ar.length; i++) {\n            int j = i + rnd.nextInt(ar.length - i);\n            swap(ar, i, j);\n        }\n    }\n\n    private static void shuffle(Object[] ar) {\n        Random rnd = new Random();\n        for (int i = 0; i < ar.length; i++) {\n            int j = i + rnd.nextInt(ar.length - i);\n            swap(ar, i, j);\n        }\n    }\n\n    private static void swap(int[] ar, int i, int j) {\n        int t = ar[i];\n        ar[i] = ar[j];\n        ar[j] = t;\n    }\n\n    private static void swap(Object[] ar, int i, int j) {\n        Object t = ar[i];\n        ar[i] = ar[j];\n        ar[j] = t;\n    }\n\n\n}\n", "code2": "cards = gets.split(' ').map!(&:to_i)\n# i = 1\n# max = 0\n# a = cards[0] + cards[1]\n# while i <= cards[0] && i <= cards[3]\n#     max = max + 1\n#     i = i + 1\n# end\n# while i <= cards[0] + cards[1] && i <= cards[3]\n#     i = i + 1\n# end\n# while i <= cards[0] + cards[1] + cards[2] && i <= cards[3]\n#     max = max - 1\n#     i = i + 1\n# end\ncase\nwhen cards[3] <= cards[0]\n    puts cards[3]\nwhen cards[3] <= cards[0] + cards[1]\n    puts cards[0]\nelse cards[3] > cards[0] + cards[1]\n    puts (cards[0] - (cards[3] - cards[0] - cards[1]))\nend", "label": 1, "name1": "s673107340.java", "name2": "s837052627.rb"}, {"id": 402, "code1": "import java.io.FileNotFoundException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tMaxHeapSort maxheap = new MaxHeapSort(new int[] {});\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tmaxheap.add(a[i]);\n\t\t}\n\t\ta = maxheap.sortedArray();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tSystem.out.print(a[i] + (i == n - 1 ? \"\\n\" : \" \"));\n\t\t}\n\t}\n\n\tclass MaxHeapSort {\n\t\tint n;\n\t\tint[] v;\n\n\t\tpublic MaxHeapSort(int[] v_) {\n\t\t\tif (v_.length > 1_000_000)\n\t\t\t\tthrow new AssertionError();\n\t\t\tv = Arrays.copyOf(v_, 1_000_000);\n\t\t\tn = v_.length;\n\t\t\tfor (int i = n; i >= 0; --i) {\n\t\t\t\tmaxHeapify(i);\n\t\t\t}\n\t\t}\n\n\t\tvoid add(int val) {\n\t\t\tv[n] = val;\n\t\t\tint cur = n;\n\t\t\t++n;\n\t\t\twhile (cur > 0) {\n\t\t\t\tcur = (cur - 1) / 2;\n\t\t\t\tmaxHeapify(cur);\n\t\t\t}\n\t\t}\n\n\t\tint[] sortedArray() {\n\t\t\tint sz = n;\n\t\t\tint[] ret = new int[sz];\n\t\t\tfor (int i = 0; i < sz; ++i) {\n\t\t\t\tret[sz - 1 - i] = poll();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tint poll() {\n\t\t\tint ret = v[0];\n\t\t\tv[0] = v[n - 1];\n\t\t\tv[n - 1] = ret;\n\t\t\t--n;\n\t\t\tmaxHeapify(0);\n\t\t\treturn ret;\n\t\t}\n\n\t\tvoid maxHeapify(int cur) {\n\t\t\tif (2 * cur + 1 >= n)\n\t\t\t\treturn;\n\t\t\tif (v[cur] >= v[2 * cur + 1] && (2 * cur + 2 >= n || v[cur] >= v[2 * cur + 2])) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint dst = -1;\n\t\t\tif (2 * cur + 2 >= n || v[2 * cur + 1] >= v[2 * cur + 2]) {\n\t\t\t\tdst = 2 * cur + 1;\n\t\t\t} else {\n\t\t\t\tdst = 2 * cur + 2;\n\t\t\t}\n\t\t\tint tmp = v[cur];\n\t\t\tv[cur] = v[dst];\n\t\t\tv[dst] = tmp;\n\t\t\tmaxHeapify(dst);\n\t\t}\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}", "code2": "gets\nputs gets.split.map(&:to_i).sort.join \" \"", "label": 1, "name1": "s534493670.java", "name2": "s947283729.rb"}, {"id": 234, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n    static class FS {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            return hasNextByte() ? buffer[ptr++] : -1;\n        }\n\n        private boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        private void skipUnprintable() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        }\n\n        public boolean hasNext() {\n            skipUnprintable();\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n    }\n\n    static int[] np;\n    static int n;\n\n    public static void main(String[] args) throws Exception {\n        FS fs = new FS();\n//        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n//        String s = bf.readLine();\n//        int n = Integer.parseInt(s.substring(0, s.indexOf(' ')));//n packages\n//        int k = Integer.parseInt(s.substring(s.indexOf(' '), s.length()));//k trucks\n        n = fs.nextInt();\n        int k = fs.nextInt();\n\n\n        np = new int[n];\n        int max = 0;\n        for (int i = 0; i < n; i++) {\n\n            np[i] = fs.nextInt();\n            max = max < np[i] ? np[i] : max;\n        }\n        int p = 0;\n        int resids = 0;\n\n        int maxInt = 10000 *100000;\n        int minInt = max-1;\n        int mid = (maxInt + minInt) / 2;\n        while (maxInt - minInt > 1) {\n            int v = checkN(mid);\n            if (v > k) minInt = mid;\n            else maxInt = mid;\n\n            mid = (maxInt + minInt) / 2;\n        }\n        System.out.println(maxInt);\n    }\n\n    private static int checkN(int p) {\n        int resids = p;\n        int ink = 1;//\u5f53\u524d\u5df2\u7528\u5361\u8f66\n        for (int i = 0; i < n; i++) {\n            int j = np[i];\n            if (resids >= j) {\n                resids -= j;\n            } else {\n                ink++;\n                resids = p;\n                i--;\n            }\n        }\n        return ink;\n    }\n}\n", "code2": "def nosereru?(p, k, a)\n    sum = 0\n    cnt = 1\n    for i in 0..a.length-1\n        return false if a[i] > p\n        # printf(\"%d\u756a\u76ee\u306e\u7a4d\u307f\u8377\u3000\u91cd\u91cf%d\\n\", i, a[i])\n        sum += a[i]\n        # printf(\"\u7a4d\u307f\u8377\u5408\u8a08 %d\\n\", sum)\n        if sum > p then\n            # printf(\"\u7a4d\u8f09\u91cf\u30aa\u30fc\u30d0\u30fc (\u7a4d\u8f09\u91cf = %d)\\n\", p)\n            cnt += 1\n            # printf(\"\\n\u30c8\u30e9\u30c3\u30af%d\u53f0\u76ee\u958b\u59cb\\n\", cnt)\n            sum = a[i]\n            # printf(\"\u7a4d\u307f\u8377\u5408\u8a08 %d\\n\", sum)\n        end\n    end\n    if cnt <= k then\n        # printf(\"%d\u53f0\u4ee5\u4e0b\u3067\u7a4d\u8f09\u53ef\u80fd\\n\\n\", k)\n        return true\n    else\n        # printf(\"%d\u53f0\u4ee5\u4e0b\u3067\u306f\u7a4d\u8f09\u4e0d\u53ef\\n\\n\", k)\n        return false\n    end\nend\n\nn, k = gets.split.map(&:to_i)\na = []\nn.times{\n    a.push(gets.to_i)\n}\n\nleft = 0\nright = 100000*10000\n# printf(\"\u691c\u8a0e\u5bfe\u8c61 \u306f %s \u301c %s\\n\", left, right)\n\nuntil right == left\n    mid = (left + right) / 2\n    # printf(\"mid = %d\u3067\u691c\u8a0e\\n\", mid)\n    if nosereru?(mid, k, a) then\n        right = mid\n        # printf(\"\u691c\u8a0e\u5bfe\u8c61 \u306f %s \u301c %s\\n\", left, right)\n    else\n        left = mid + 1\n        # printf(\"\u691c\u8a0e\u5bfe\u8c61 \u306f %s \u301c %s\\n\", left, right)\n    end\nend\n\nputs right\n", "label": 1, "name1": "s272482227.java", "name2": "s891158890.rb"}, {"id": 761, "code1": "import java.util.Scanner;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    long a = sc.nextLong();\n    long b = sc.nextLong();\n    long c;\n    long x = sc.nextLong();\n    if(a%x == 0) {\n      c = a / x -1;\n    }else {\n      c = a / x;\n    }\n    System.out.println(b/x-c);\n  }\n}\n", "code2": "n = gets.to_i\na = gets.split.map(&:to_i)\nsum = x = 0\na << 0\n\na.each do |e|\n  sum += (x - e).abs\n  x = e\nend\n\ndef d(x, y)\n  (x - y).abs\nend\n\nn.times do |i|\n  puts sum - d(a[i], a[i - 1]) - d(a[i + 1], a[i]) + d(a[i - 1], a[i + 1])\nend", "label": 0, "name1": "s320140275.java", "name2": "s135141866.rb"}, {"id": 302, "code1": "import java.util.*;\n\npublic class Main {\n    \n    public static boolean[] alr;\n    \n    public static List<List<Integer>> list = new ArrayList<>();\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        alr = new boolean[N];\n        for (int i = 0; i < N; i++) {\n            list.add(new ArrayList<>());\n        }\n        for (int i = 0; i < M; i++) {\n            int A = sc.nextInt()-1;\n            int B = sc.nextInt()-1;\n            list.get(A).add(B);\n            list.get(B).add(A);\n        }\n        long count = 0;\n        for (int i = 0; i < list.size(); i++) {\n            if (alr[i]) {\n                continue;\n            } else {\n                alr[i] = true;\n                count++;\n            }\n            List<Integer> lst = list.get(i);\n            count(lst);\n        }\n        System.out.println(count-1);\n    }\n    \n    private static void count(List<Integer> lst) {\n        int friends = 0;\n        for (Integer i : lst) {\n            if (alr[i]) {\n                continue;\n            } else {\n                alr[i] = true;\n            }           \n            count(list.get(i));\n        }\n    }\n}\n", "code2": "class UnionFind\n    def initialize(size)\n        @rank = Array.new(size, 0)\n        @parent = Array.new(size, &:itself)\n    end\n  \n    def unite(id_x, id_y)\n        x_parent = get_parent(id_x)\n        y_parent = get_parent(id_y)\n        return if x_parent == y_parent\n    \n        if @rank[x_parent] > @rank[y_parent]\n            @parent[y_parent] = x_parent\n        else\n            @parent[x_parent] = y_parent\n            @rank[y_parent] += 1 if @rank[x_parent] == @rank[y_parent]\n        end\n    end\n  \n    def get_parent(id_x)\n        @parent[id_x] == id_x ? id_x : (@parent[id_x] = get_parent(@parent[id_x]))\n    end\n  \n    def same_parent?(id_x, id_y)\n        get_parent(id_x) == get_parent(id_y)\n    end\nend\n\nn, m = gets.chomp.split.map(&:to_i)\nuf = UnionFind.new(n)\nm.times do\n    a, b = gets.chomp.split.map(&:to_i)\n    uf.unite(a-1, b-1)\nend\n\nh = Hash.new(0)\nhoge = []\n\nn.times do |i|\n    tmp = uf.get_parent(i)\n    hoge << tmp\n    h[tmp] += 1\nend\n\nputs h.size-1", "label": 1, "name1": "s602301737.java", "name2": "s039827889.rb"}, {"id": 201, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        CTwoAlpinists solver = new CTwoAlpinists();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CTwoAlpinists {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            long[] t = in.readLongArray(n);\n            long[] a = in.readLongArray(n);\n\n            long[] max = new long[n];\n            long[] actual = new long[n];\n\n            {\n                for (int i = 0; i < n; i++) {\n                    max[i] = Math.min(t[i], a[i]);\n                }\n            }\n\n            {\n                long prev = 0;\n                for (int i = 0; i < n; i++) {\n                    if (t[i] > prev) {\n                        if (t[i] > max[i]) {\n                            out.printLine(0);\n                            return;\n                        }\n                        actual[i] = t[i];\n                        prev = t[i];\n                    }\n                }\n            }\n\n            {\n                long prev = 0;\n                for (int i = n - 1; i >= 0; i--) {\n                    if (a[i] > prev) {\n                        if (a[i] > max[i]) {\n                            out.printLine(0);\n                            return;\n                        }\n                        actual[i] = a[i];\n                        prev = a[i];\n                    }\n                }\n            }\n\n            long ans = 1;\n            for (int i = 0; i < n; i++) {\n                if (actual[i] != 0) continue;\n                ans = (ans * max[i]) % MiscUtils.MOD7;\n            }\n\n            out.printLine(ans);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public long[] readLongArray(int size) {\n            long[] array = new long[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readLong();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long readLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class MiscUtils {\n        public static final int MOD7 = (int) (1e9 + 7);\n\n    }\n}\n\n", "code2": "M=10**9+7\ngets\nhw=0;t=gets.split.map{|s|[hw<hw=h=s.to_i,h]}\nhw=0;a=gets.split.reverse.map{|s|[hw<hw=h=s.to_i,h]}.reverse\np t.zip(a).reduce(1){|p,((f1,h1),(f2,h2))|\n  break 0 if f1&&f2&&h1!=h2 || f1&&!f2&&h1>h2 || !f1&&f2&&h1<h2\n  !f1&&!f2 ? p*[h1,h2].min%M : p\n}\n", "label": 1, "name1": "s071160485.java", "name2": "s443550692.rb"}, {"id": 271, "code1": "import java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);  \n\t\twhile(true){\n\t\t\t    int n=sc.nextInt();\n\t\t\t    int x=sc.nextInt();\n\t\t\t    if(n==0&&x==0)break;\n\t\t\t    int cnt=0;\n\t\t\t    for(int i=1;i<=n;i++){\n\t\t\t        for(int j=i+1;j<=n;j++){\n\t\t\t            for(int k=j+1;k<=n;k++){\n\t\t\t                if(i+j+k==x)cnt++;\n\t\t\t            }\n\t\t\t        }\n\t\t\t    }\n\t\t\t    System.out.println(cnt);\n\t\t}\n\t}\n}", "code2": "require 'scanf'\nwhile true\ninput = scanf(\"%d %d\")\nn = input[0];\nx = input[1];\nif n == 0 && x == 0\nbreak\nend\ncnt = 0\nfor r in 1...n+1\nfor c in r + 1...n+1\nfor f in c + 1...n+1\nif r + c + f == x\ncnt += 1\nend\nend\nend\nend\nputs cnt\nend", "label": 1, "name1": "s954202209.java", "name2": "s364906499.rb"}, {"id": 16, "code1": "import java.util.*;\n \nclass Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    \n    String s = sc.next();\n    boolean a = true, b = true;\n \n    for(int i=0;i<s.length();i+=2){\n        if(s.charAt(i) == 'L'){\n            a = false;\n            break;\n        }\n    }\n    \n    for(int i=1;i<s.length();i+=2){\n        if (!a){break;}\n        if(s.charAt(i) == 'R'){\n            b = false;\n            break;\n        }\n    }\n    \n    if(a&&b){System.out.println(\"Yes\");}\n    else{System.out.println(\"No\");}\n  }\n}", "code2": "s_array = gets.chomp.split(\"\")\n\nret = \"Yes\"\ns_array.each_with_index do |e, i|\n    if i.odd?\n        if ![\"L\", \"U\", \"D\"].include?(e)\n            ret = \"No\"\n            break\n        end\n    else\n        if ![\"R\", \"U\", \"D\"].include?(e)\n            ret = \"No\"\n            break\n        end\n    end\nend\n\nputs ret", "label": 1, "name1": "s301964893.java", "name2": "s814130091.rb"}, {"id": 82, "code1": "import java.util.Scanner;\n\nclass Main\n{\n\tpublic static void main(String args[])\n\t{\n\t\tScanner sc = new Scanner(System.in).useDelimiter(\"[,\\n]\");\n\t\t\n\t\tint a = 0;\n\t\tint b = 0;\n\t\tint o = 0;\n\t\tint ab = 0;\n\t\t\n\t\twhile (sc.hasNext())\n\t\t{\n\t\t\tsc.nextInt();\n\t\t\tString str = sc.next();\n\t\t\tif (str.equals(\"A\"))\n\t\t\t{\n\t\t\t\ta++;\n\t\t\t}\n\t\t\telse if (str.equals(\"B\"))\n\t\t\t{\n\t\t\t\tb++;\n\t\t\t}\n\t\t\telse if (str.equals(\"O\"))\n\t\t\t{\n\t\t\t\to++;\n\t\t\t}\n\t\t\telse if (str.equals(\"AB\"))\n\t\t\t{\n\t\t\t\tab++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(a);\n\t\tSystem.out.println(b);\n\t\tSystem.out.println(ab);\n\t\tSystem.out.println(o);\n\t}\n}", "code2": "h=Hash.new(0)\n$<.map{|l|h[l.chop.split(?,)[1]]+=1}\np h[?A],h[?B],h[\"AB\"],h[?O]", "label": 1, "name1": "s541319729.java", "name2": "s471451546.rb"}, {"id": 351, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.util.NoSuchElementException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author HBonsai\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CMultipleGift solver = new CMultipleGift();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CMultipleGift {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            long X = in.nextLong();\n            long Y = in.nextLong();\n            int ans = 1;\n            long A = X;\n            while (A <= Y) {\n                A *= 2;\n                if (A > Y) break;\n                ans++;\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class FastScanner implements Closeable {\n        private final InputStream in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        public FastScanner(InputStream in) {\n            this.in = in;\n        }\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        public boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n            return hasNextByte();\n        }\n\n        public long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        public void close() {\n            try {\n                in.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n}\n\n", "code2": "x, y = gets.split.map &:to_i\ncnt = 0\nwhile x <= y\n  y >>= 1\n  cnt += 1\nend\np cnt\n", "label": 1, "name1": "s947131740.java", "name2": "s741410088.rb"}, {"id": 239, "code1": "import java.util.*;\nimport java.io.*;\n\nclass Main {\n    static int searchP(long p,int[] ws){\n        int count = 1;\n        int sum = 0; \n        for(int i = 0; i < ws.length; i++){\n            if(sum + ws[i] <= p) {\n            sum += ws[i];\n            } else {\n                count++;\n                if(ws[i] <= p){\n                sum = ws[i];\n                } else{\n                    count += 99999;\n                }\n            }\n        }\n        return count;\n    }\n    static long solve(long p, int[] ws, long k){\n        long right = p;\n        long left = 0;\n        long mid;\n        while(right - left > 1) {\n            mid = (left + right) / 2;\n            int v = searchP(mid,ws);\n            if(k >= v) {\n                right = mid;\n            } else {\n               left = mid;\n                \n            }\n        }\n    return right;\n    }\n    public static void main(String...args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        \n        String[] info = br.readLine().split(\" \");\n        int n = Integer.parseInt(info[0]);\n        int k = Integer.parseInt(info[1]);\n        int[] ws = new int[n];\n        for(int i = 0; i < n; i++) {\n            ws[i] = Integer.parseInt(br.readLine());\n        }\n        long p = 100000 * 10000;\n        System.out.println(solve(p,ws,k));\n        \n    }\n}\n\n\n\n", "code2": "n, k = gets.split( \" \" ).map { |val| val.to_i }\nw = []\nmaxW = sumW = 0\nn.times {\n\tnum = gets.to_i\n\tsumW += num\n\tw.push( num )\n\tmaxW = num if maxW < num\n}\n\nminP = 0\nif 1 == k\n\tminP = sumW\nelsif n == k\n\tminP = maxW\nelse\n\tleft = maxW\n\tright = 100000*10000\n\twhile left <= right\n\t\tmiddle = ( left+right ).div( 2 )\n\t\ttruckCnt = i = loadings = 0\n\n\t\twhile i < n\n\t\t\tloadings += w[i]\n\t\t\tif middle < loadings\n\t\t\t\ttruckCnt += 1\n\t\t\t\tbreak if k < truckCnt+1\n\t\t\t\tloadings = w[i]\n\t\t\tend\n\t\t\ti += 1\n\t\tend\n\t\t( minP = middle ) if truckCnt+1 <= k\n\t\t\n\t\tif k < truckCnt+1\n\t\t\tleft = middle + 1\t\t\n\t\telse\n\t\t\tright = middle - 1\n\t\tend\n\tend\nend\n\nputs( minP )", "label": 1, "name1": "s705576178.java", "name2": "s210429617.rb"}, {"id": 470, "code1": "import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long[] a = new long[n];\n        long[] b = new long[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextLong();\n        }\n        for (int i = 0; i < n; i++) {\n            b[i] = sc.nextLong();\n        }\n        long sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += b[i] - a[i];\n        }\n\n        long cnt = 0;\n        for (int i = 0; i < n; i++) {\n            if (a[i] < b[i]) {\n                cnt += (b[i] - a[i] + 1) / 2;\n            }\n        }\n        if (cnt <= sum) {\n            System.out.println(\"Yes\");\n            return;\n        }\n        System.out.println(\"No\");\n    }\n}\n", "code2": "#input of int(split by space)\ndef get_i()\n  return gets.chomp.split(\" \").map(&:to_i)\nend\n#input of float(split by space)\ndef get_f()\n  return gets.chomp.split(\" \").map(&:to_f)\nend\n#input of string(split by space)\ndef get()\n  return gets.chomp.split(\" \")\nend\n#input of string(split per one character)\ndef get_nsp()\n  return gets.chomp.split(\"\")\nend\n#yes or no decision\ndef yn_judge(bool,y=\"Yes\",n=\"No\")\n  return bool ? y : n \nend\n#create of array\ndef array(size1,init=nil,size2=-1)\n  if size2==-1\n    return Array.new(size1){init}\n  else\n    return Array.new(size2){Array.new(size1){init}}\n  end\nend\n\ndef max(a,b)\n    return a>b ? a : b\nend\n\ndef min(a,b)\n    return a>b ? b : a\nend\n\nINF=Float::INFINITY\n\nN=gets.to_i\na=get_i\nb=get_i\nadd=0\nN.times do|i|\n    if a[i]>b[i]\n        add+=a[i]-b[i]\n    end\nend\nN.times do|i|\n  if a[i]<b[i]\n      r=(b[i]-a[i])/2\n      add-=r\n  end\nend\nif add>0\n    puts \"No\"\nelse\n    puts \"Yes\"\nend", "label": 1, "name1": "s202753514.java", "name2": "s323281467.rb"}, {"id": 184, "code1": "import java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint a = scan.nextInt();\n\t\tint b = scan.nextInt();\n\t\tscan.close();\n\t\tint ans = 12;\n\t\tif(b >= a) {\n\t\t\tans = a;\n\t\t}else {\n\t\t\tans = a - 1;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n", "code2": "a,b=gets.split.map &:to_i;p a-(a>b ? 1 : 0)", "label": 1, "name1": "s648355489.java", "name2": "s514721505.rb"}, {"id": 677, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint A = sc.nextInt();\n\t\tint B = sc.nextInt();\n\t\tint C = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tint res = 0;\n\t\tres+=Math.min(A, K);\n\t\tK -= res;\n\t\tif(K==0) {\n\t\t\tSystem.out.println(res);\n\t\t\tSystem.exit(0);\n\t\t}\n\t\tK-=B;\n\t\tif(K>0) {\n\t\t\tres-=Math.min(K, C);\n\t\t}\n\t\tSystem.out.println(res);\n\n\t}\n}", "code2": "arr = [0,0,0,0,0]\n3.times do |i|\n  a,b = gets.chomp.split(\" \").map(&:to_i)\n  arr[a] += 1\n  arr[b] += 1\nend\nprint arr.max < 3 ? \"YES\" : \"NO\"", "label": 0, "name1": "s649759516.java", "name2": "s043774656.rb"}, {"id": 735, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n\t\treturn (int) nl;\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n}\npublic class Main {\n\tstatic FastScanner scan=new FastScanner();\n\tstatic Scanner scanner=new Scanner(System.in);\n\tstatic long mod=1000000007;\n\tstatic double eps=0.0000000001;\n\tstatic int big=Integer.MAX_VALUE;\n\tstatic long gcd (long a, long b) {return b>0?gcd(b,a%b):a;}\n\tstatic long lcm (long a, long b) {return a*b/gcd(a,b);}\n\tstatic int max(int a,int b) {return a>b?a:b;}\n\tstatic int min(int a,int b) {return a<b?a:b;}\n\tstatic long factorial(int i) {return i==1?1:i*factorial(i-1);}\n\tstatic int lower_bound(int a[],int key) {\n\t\tint low=0,high=a.length;\n\t\twhile(low<high) {\n\t\t\tint mid=((high-low)/2)+low;\n\t\t\tif(a[mid]<=key)low=mid+1;\n\t\t\telse high=mid;\n\t\t}\n\t\treturn high;\n\t}\n\tstatic int upper_bound(int a[],int key) {\n\t\tint low=0,high=a.length;\n\t\twhile(low<high) {\n\t\t\tint mid=((high-low)/2)+low;\n\t\t\tif(a[mid]<key)low=mid+1;\n\t\t\telse high=mid;\n\t\t}\n\t\treturn high;\n\t}\n\tstatic boolean isPrime (long n) {\n\t\tif (n==2) return true;\n\t\tif (n<2 || n%2==0) return false;\n\t\tdouble d = Math.sqrt(n);\n\t\tfor (int i=3; i<=d; i+=2)if(n%i==0){return false;}\n\t\treturn true;\n\t}\n\tstatic int upper_division(int a,int b) {\n\t\tif(a%b==0) {\n\t\t\treturn a/b;\n\t\t}\n\t\telse {\n\t\t\treturn a/b+1;\n\t\t}\n\t}\n\tstatic long lupper_division(long a,long b) {\n\t\tif(a%b==0) {\n\t\t\treturn a/b;\n\t\t}\n\t\telse {\n\t\t\treturn a/b+1;\n\t\t}\n\t}\n\tstatic long lmax(long a,long b) {return Math.max(a, b);}\n\tstatic long lmin(long a,long b) {return Math.min(a, b);}\n\tstatic int[] setArray(int a) {\n\t\tint b[]=new int[a];\n\t\tfor(int i=0;i<a;i++) {\n\t\t\tb[i]=scan.nextInt();\n\t\t}\n\t\treturn b;\n\t}\n\tstatic long[] lsetArray(int a) {\n\t\tlong b[]=new long[a];\n\t\tfor(int i=0;i<a;i++) {\n\t\t\tb[i]=scan.nextLong();\n\t\t}\n\t\treturn b;\n\t}\n\tstatic String reverce(String str) {\n\t\tString strr=\"\";\n\t\tfor(int i=str.length()-1;i>=0;i--) {\n\t\t\tstrr+=str.charAt(i);\n\t\t}\n\t\treturn strr;\n\t}\n\tpublic static void printArray(char[] ch) {\n\t\tfor(int i=0;i<ch.length-1;i++) {\n\t\t\tSystem.out.print(ch[i]+\" \");\n\t\t}\n\t\tSystem.out.println(ch[ch.length-1]);\n\t}\n\tpublic static int[][] doublesort(int[][]a) {\n\t\tArrays.sort(a,(x,y)->Integer.compare(x[0],y[0]));\n\t\treturn a;\n\t}\n\tstatic long modpow(long x,long n,long mo) {\n\t\tlong sum=1;\n\t\twhile(n>0) {\n\t\t\tif((n&1)==1) {\n\t\t\t\tsum=sum*x%mo;\n\t\t\t}\n\t\t\tx=x*x%mo;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn sum;\n\t}\n\tpublic static char[] revch(char ch[]) {\n\t\tchar ret[]=new char[ch.length];\n\t\tfor(int i=ch.length-1,j=0;i>=0;i--,j++) {\n\t\t\tret[j]=ch[i];\n\t\t}\n\t\treturn ret;\n\t}\n\tpublic static int[] revint(int ch[]) {\n\t\tint ret[]=new int[ch.length];\n\t\tfor(int i=ch.length-1,j=0;i>=0;i--,j++) {\n\t\t\tret[j]=ch[i];\n\t\t}\n\t\treturn ret;\n\t}\n\tpublic static void warshall_floyd(int v[][],int n) {\n\t\tfor(int k=0;k<n;k++)\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t\tv[i][j]=min(v[i][j],v[i][k]+v[k][j]);\n\t}\n\tpublic static void main(String[] args) {\n\t\tlong a=scan.nextLong();\n\t\tlong b=scan.nextLong();\n\t\tint cnt=0;\n\t\tlong now=a;\n\t\twhile(now<=b) {\n\t\t\tcnt++;\n\t\t\tnow*=2;\n\t\t}\n\t\tSystem.out.println(cnt);\n\t}\n}", "code2": "class PriorityQueue\n  def initialize(&comp)\n    @heap = []\n    @node_num = 0\n    if block_given?\n      @comp = comp\n    else\n      @comp = Proc.new { |x, y| x <= y }\n    end\n  end\n  attr_reader :heap\n \n  def push(x)\n    i = @node_num # self node number\n    @node_num += 1\n    while i > 0\n      par = (i - 1) / 2 # parent's node number\n      break if @comp.call(@heap[par], x) # \u9006\u8ee2\u3057\u3066\u306a\u3044\u306a\u3089\u629c\u3051\u308b\n      # \u89aa\u30ce\u30fc\u30c9\u3092\u4e0b\u308d\u3057\u3066\u81ea\u5206\u3092\u4e0a\u306b\n      @heap[i] = @heap[par]\n      i = par\n    end\n    @heap[i] = x\n  end\n \n  alias_method(:<<, :push)\n \n  def pop\n    # \u6700(\u5c0f|\u5927)\u5024\n    ret = @heap[0]\n    # \u6839\u306b\u3082\u3063\u3066\u304f\u308b\u5024\n    @node_num -= 1\n    x = @heap[@node_num]\n    # \u6839\u304b\u3089\u4e0b\u308d\u3057\u3066\u3044\u304f\n    i = 0\n    while i * 2 + 1 < @node_num\n      # \u5b50\u3069\u3046\u3057\u3092\u6bd4\u8f03\n      a, b = i * 2 + 1, i * 2 + 2\n      a = b if b < @node_num && @comp.call(@heap[b], @heap[a])\n      break unless @comp.call(@heap[a], x)\n      @heap[i] = @heap[a]\n      i = a\n    end\n    @heap[i] = x\n    ret\n  end\n \n  def get\n    @node_num == 0 ? nil : @heap[0]\n  end\n \n  def empty?\n    get.nil?\n  end\nend\n\n\n\n#\n# dijkstra\n#   O(|E|log|V|)\n#   \u96a3\u63a5\u8868\u73fe\u30b0\u30e9\u30d5graph, \u59cb\u70b9start, inf\n#\ndef dijkstra(graph, start, inf = Float::INFINITY)\n  vertex_num = graph.size\n  que = PriorityQueue.new { |x, y| x[0] <= y[0] }\n  dist = Array.new(vertex_num, inf)\n  dist[start] = 0\n  que.push([0, start])\n  while !que.empty?\n    d, v = que.pop\n    next if dist[v] < d\n    graph[v].size.times do |i|\n      # e is an instance of Edge\n      #   Edge = Struct.new(:to, :cost)\n      e = graph[v][i]\n      if dist[e.to] > dist[v] + e.cost\n        dist[e.to] = dist[v] + e.cost\n        que.push([dist[e.to], e.to])\n      end\n    end\n  end\n  return dist\nend\n\n\n\nEdge = Struct.new(:to, :cost)\nv, e, r = gets.split.map(&:to_i)\ng = Array.new(v) { [] }\ne.times do |i|\n  s, t, d = gets.split.map(&:to_i)\n  g[s] << Edge.new(t, d)\nend\nputs dijkstra(g, r).map { |x| x == Float::INFINITY ? \"INF\" : x }\n", "label": 0, "name1": "s941851054.java", "name2": "s468156306.rb"}, {"id": 18, "code1": "import java.util.Scanner;\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\n\t\tlong h = stdIn.nextLong();\n\t\tlong w = stdIn.nextLong();\n\t\t\n\t\tlong cnt = 0;\n\t\tif(h==1 || w == 1) {\n\t\t\tSystem.out.println(1);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(h % 2 == 0 && w % 2 == 0) { //h\u5076\u6570\u3001w\u5076\u6570\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tcnt += w/2;\n\t\t\t}\n\t\t}else if(h % 2 == 0 && w % 2 != 0) { //h\u5076\u6570\u3001w\u5947\u6570\n\t\t\tfor(int i = 0; i < h ; i++) {\n\t\t\t\tif(i % 2 == 0) {\n\t\t\t\t\tcnt += (w+1)/2;\n\t\t\t\t}else {\n\t\t\t\t\tcnt += w/2;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( h % 2 != 0 && w % 2 == 0) { // h\u5947\u6570,w\u5076\u6570\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tcnt += w/2;\n\t\t\t}\n\t\t}else {                                //h\u5947\u6570,w\u5947\u6570\n\t\t\tfor(int i = 0; i < h ; i++) {\n\t\t\t\tif(i % 2 == 0) {\n\t\t\t\t\tcnt += (w+1)/2;\n\t\t\t\t}else {\n\t\t\t\t\tcnt += w/2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(cnt);\n\n\t}\n\n}\n", "code2": "h,w = gets.split.map(&:to_i)\nif h == 1 || w == 1\n  p 1\nelsif h.odd?\n  p w * (h-1) / 2 + (w+1)/2\nelse\n  p w * h / 2\nend", "label": 1, "name1": "s990691093.java", "name2": "s213238625.rb"}, {"id": 255, "code1": "import java.io.File;\nimport java.io.IOException;\nimport java.util.*;\n \npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\t//File file = new File(\"input.txt\");\n\t\t//Scanner in = new Scanner(file);\n\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\t\n\t\tString SS = in.next();\n\t\tString T = in.next();\n\t\t\n\t\tint index = SS.length() - T.length();\n\t\t\n\t\twhile(index >= 0){\n\t\t\tString s = SS.substring(index, index + T.length());\n\t\t\t\n\t\t\tboolean tf = true;\n\t\t\tfor(int i = 0; i < T.length(); i++){\n\t\t\t\tif(s.charAt(i) != '?' && s.charAt(i) != T.charAt(i)){\n\t\t\t\t\ttf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(tf){\n\t\t\t\tSS = new StringBuilder(SS).replace(index, index + s.length(), T).toString();\n\t\t\t\tSS = SS.replace('?', 'a');\n\t\t\t\tSystem.out.println(SS);\n\t\t\t\treturn;\n\t\t\t}else{\n\t\t\t\tindex--;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"UNRESTORABLE\");\n\t}\n}", "code2": "s = gets.chomp\nt = gets.chomp\nk = s.length - t.length + 1\ni = 0\nflag = false\nwhile i < k && !flag\n\tcp = s.clone\n\tcp[cp.length-t.length-i,t.length] = t\n\tcheck = true\n\t(cp.length).times do |j|\n\t\tcheck = false if s[j] != cp[j] && s[j] != \"?\"\n\tend\n\tflag = true if check\n\ti += 1\nend\nif flag\n\t(cp.length).times do |j|\n\t\tcp[j] = \"a\" if cp[j] == \"?\"\n\tend\n\tputs cp\nelse\n\tputs \"UNRESTORABLE\"\nend\n", "label": 1, "name1": "s419255365.java", "name2": "s763613339.rb"}, {"id": 740, "code1": "import java.util.Scanner;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tprivate static final int INF = (int)1e9;\n\n\tstatic class Pair {\n\t\tint first;\n\t\tint second;\n\n\t\tpublic Pair(int first, int second) {\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn first + second;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\tif (other instanceof Pair) {\n\t\t\t\tPair p = (Pair)other;\n\n\t\t\t\treturn p.first == first && p.second == second;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner in = new Scanner(System.in)) {\n\t\t\tint n = in.nextInt();\n\t\t\tList<Integer>[] g = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tg[i] = new ArrayList<>();\n\n\t\t\tint m = in.nextInt();\n\t\t\tint r = in.nextInt();\n\t\t\tMap<Pair, Integer> dist = new HashMap<>();\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint f = in.nextInt();\n\t\t\t\tint t = in.nextInt();\n\t\t\t\tint w = in.nextInt();\n\n\t\t\t\tg[f].add(t);\n\t\t\t\tdist.put(new Pair(f, t), w);\n\t\t\t}\n\n\t\t\tdijkstra(g, n, dist, r);\n\t\t} catch (Exception ex) {\n\t\t\tthrow new RuntimeException(ex);\n\t\t}\n\t}\n\n\tpublic static void dijkstra(List<Integer> g[], int n, Map<Pair, Integer> dist, int s) {\n\t\tint[] d = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\td[i] = INF;\n\n\t\td[s] = 0;\n\t\tPriorityQueue<Pair> pq = new PriorityQueue<>((x, y) -> x.second-y.second);\n\t\tpq.add(new Pair(s, 0));\n\n\t\twhile (!pq.isEmpty()) {\n\t\t\tPair p = pq.remove();\n\n\t\t\tfor (int v : g[p.first]) {\n\t\t\t\tint dd = d[p.first] + dist.get(new Pair(p.first, v));\n\t\t\t\tif (dd < d[v]) {\n\t\t\t\t\td[v] = dd;\n\t\t\t\t\tpq.add(new Pair(v, d[v]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (d[i] == INF)\n\t\t\t\tSystem.out.println(\"INF\");\n\t\t\telse\n\t\t\t\tSystem.out.println(d[i]);\n\t\t}\n\t}\n}", "code2": "ai, ao, at, aj, al, as, az = gets.split.map(&:to_i)\ntmp = ai/2*2 + aj/2*2 + al/2*2\nif [ai, aj, al].min > 0\n    ai -= 1\n    aj -= 1\n    al -= 1\n    tmp2 = ai/2*2 + aj/2*2 + al/2*2 + 3\n    tmp = [tmp, tmp2].max\nend\nputs ao + tmp", "label": 0, "name1": "s004699498.java", "name2": "s077778491.rb"}, {"id": 1000, "code1": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint t = sc.nextInt();\n\t\t\tif(t==0)break;\n\t\t\tint n = sc.nextInt();\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tt += (sc.nextInt() - sc.nextInt());\n\t\t\t}\n\t\t\t\n\t\t\tif(t<=0) System.out.println(\"OK\");\n\t\t\telse System.out.println(t);\n\t\t}\n\t}\t\n}", "code2": "n = gets.chomp.to_i\nt, a = gets.chomp.split.map(&:to_i)\narr = gets.chomp.split.map(&:to_i)\nsa = 10 ** 8\nind = 0\narr.length.times do |i|\n\ttemp = (a - (t - arr[i] * 0.006)).abs\n\tif sa > temp\n\t\tsa = temp\n\t\tind = i\n\tend\nend\nputs ind + 1\n\n", "label": 0, "name1": "s277904709.java", "name2": "s154979799.rb"}, {"id": 707, "code1": "import java.io.*;\nimport java.util.StringTokenizer;\n\npublic final class Main{\n    public static void main(String[] args){\n        FastScanner stdIn = new FastScanner(System.in);\n        long a = stdIn.nextLong();\n        long b = stdIn.nextLong();\n        long c = stdIn.nextLong();\n\n        if(c-(a-b)<0){\n            System.out.println(0);\n        }else{\n            System.out.println(c-(a-b));\n        }\n    }\n}\n\nclass FastScanner {\n    private BufferedReader reader = null;\n    private StringTokenizer tokenizer = null;\n\n    public FastScanner(InputStream in) {\n        reader = new BufferedReader(new InputStreamReader(in));\n        tokenizer = null;\n    }\n\n    public String next() {\n        if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public String nextLine() {\n        if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        return tokenizer.nextToken(\"\\n\");\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n    \n    public long nextInt() {\n        return Integer.parseInt(next());\n    }\n\n}\n", "code2": "a, b, c = gets.chomp.split.map(&:to_i)\n\nputs [a, b, c].sort.take(2).inject(&:+)\n", "label": 0, "name1": "s641134227.java", "name2": "s756092498.rb"}, {"id": 138, "code1": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        List<Integer> abc = new ArrayList<>();\n        abc.add(sc.nextInt());\n        abc.add(sc.nextInt());\n        abc.add(sc.nextInt());\n        Collections.sort(abc);\n\n        int count = 0;\n        int diff21 = abc.get(2) - abc.get(1);\n        abc.set(0, abc.get(0) + diff21);\n        abc.set(1, abc.get(1) + diff21);\n        count += diff21;\n\n        int diff10 = abc.get(1) - abc.get(0);\n        if (diff10 % 2 == 0) {\n            count += diff10 / 2;\n        } else {\n            count += (diff10 + 1) / 2 + 1;\n        }\n        System.out.println(count);\n    }\n\n}\n", "code2": "#!/usr/bin/env ruby\n\nrequire 'set'\n\nclass Hash\n  def push(key, value)\n    self[key] = [] if self[key] == nil\n    self[key].push(value)\n  end\nend\n\nclass Array\n  def lower_bound(value)\n    left = -1;\n    right = self.length;\n    while left + 1 < right\n      mid = left + (right - left) / 2;\n      if self[mid] >= value\n        right = mid\n      else\n        left = mid\n      end\n    end\n    right\n  end\n\n  def unique\n    res = [self.first]\n    each_cons(2) do |a, b|\n      if a != b\n        res.push(b)\n      end\n    end\n    res\n  end\nend\n\ndef get_ints\n  gets.chomp.split.map(&:to_i)\nend\n\ndef get_ints_minus_one\n  get_ints.map { |x| x - 1 }\nend\n\ndef get_int\n  gets.chomp.to_i\nend\n\nA, B, C = get_ints\n\nsum = A + B + C\nstock = [A, B, C].max * 3\n\nwaru = (stock - sum)/2\namari = (stock - sum) % 2\n\nputs waru + (amari == 1 ? 2 : 0)\n", "label": 1, "name1": "s664157474.java", "name2": "s046246097.rb"}, {"id": 8, "code1": "import java.util.*;\n\nclass Main{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    String N = sc.next();\n    int sum = 0;\n    for(int i = 0;i<N.length();i++){\n      sum+=Integer.parseInt(N.substring(i,i+1));\n      sum=sum%9;\n    }\n    if(sum == 0){\n      System.out.println(\"Yes\");\n    }else{\n      System.out.println(\"No\");\n    }\n  }\n}", "code2": "n = gets.to_i\n#puts n\nif(n%9 == 0)\n\tputs \"Yes\"\nelse\n\tputs \"No\"\nend\n", "label": 1, "name1": "s788833633.java", "name2": "s086510326.rb"}, {"id": 106, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        double[] a = new double[]{sc.nextDouble(), sc.nextDouble(), sc.nextDouble()};\n        System.out.println(a[0] * a[1] * Math.sin((Math.PI / 180) * a[2]) / 2.0);\n        System.out.println(\n            a[0] + a[1] + Math.sqrt(a[0] * a[0] + a[1] * a[1] - 2 * a[0] * a[1] * Math.cos(Math.PI / 180 * a[2])));\n        System.out.println(a[1] * Math.sin(Math.PI / 180 * a[2]));\n    }\n}", "code2": "a, b, C = gets.split.map(&:to_i)\nrad = C * Math::PI / 180\n\nh = b * Math.sin(rad)\ns = a * h / 2\n\nc =  Math.sqrt(a ** 2 + b ** 2 - 2 * a * b * Math.cos(rad))\nl = a + b + c\n\nputs s\nputs l\nputs h", "label": 1, "name1": "s203375488.java", "name2": "s610004516.rb"}, {"id": 214, "code1": "import java.util.*;\npublic class Main{\n    public static void main(String args[]) {\n        Scanner cin = new Scanner(System.in);\n        while(cin.hasNext()){\n        \tint n = cin.nextInt();\n        \tint[][] vote = readMatrix(cin,n,2);\n        \tSystem.out.println(getNum(vote,n));\n        }\n    }\n    public static long getNum(int[][] vote, int n){\n    \tlong[] result={vote[0][0],vote[0][1]};\n    \tlong result1;\n    \tfor(int i=1;i<n;i++){\n    \t\tresult1 = result[1];\n    \t\tif(result[0]>vote[i][0]){\n    \t\t\tif(result[0]%vote[i][0]!=0) result[0] += vote[i][0]-result[0]%vote[i][0];\n    \t\t}else{result[0]=vote[i][0];}\n    \t\tresult[1] = result[0]/vote[i][0]*vote[i][1];\n    \t\tif(result1>result[1]){\n    \t\t\tresult[1] = result1;\n    \t\t\tif(result[1]%vote[i][1]!=0) result[1] += vote[i][1]-result[1]%vote[i][1];\n    \t\t\t result[0] = result[1]/vote[i][1]*vote[i][0];\n    \t\t}\n    \t}\n    \treturn result[0]+result[1];\n    }\n    public static int[][] readMatrix(Scanner in,int n,int m){\n    \tint[][] mtx = new int[n][m];\n    \tfor(int i=0;i<n;i++){\n    \t\tfor(int j=0;j<m;j++){\n    \t\t\tmtx[i][j] = in.nextInt();\n    \t\t}\n    \t}\n    \treturn mtx;\n    }\n    \n}", "code2": "n = gets.to_i\nta = 1\naa = 1\n\nn.times{\n  t,a = gets.split.map &:to_i\n  x = [(ta+(t-1))/t, (aa+(a-1))/a].max\n  ta = t*x\n  aa = a*x\n}\n\np ta+aa\n", "label": 1, "name1": "s502019413.java", "name2": "s479644097.rb"}, {"id": 621, "code1": "import java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint a = scan.nextInt();\n\t\tint b = scan.nextInt();\n\t\tscan.close();\n\t\tint ans = 12;\n\t\tif(b >= a) {\n\t\t\tans = a;\n\t\t}else {\n\t\t\tans = a - 1;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n", "code2": "gets\na = gets.chomp.split.map(&:to_i)\na = a.sort.reverse\n\ncount = 0\n\n(a.count - 1).times do |i|\n  count += a[((i + 1) / 2.0).to_i]\nend\n\np count\n", "label": 0, "name1": "s648355489.java", "name2": "s913271199.rb"}, {"id": 518, "code1": "import java.util.*;\nimport java.io.*;\n\nimport static java.lang.System.in;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long A = sc.nextLong();\n        long B = sc.nextLong();\n        long[] x = new long[n];\n        for(int i=0;i<n;i++) x[i]=sc.nextLong();\n        long ans= 0;\n        for(int i=0;i<n-1;i++){\n            ans += Math.min(A*(x[i+1]-x[i]),B);\n        }\n        PrintWriter out = new PrintWriter(System.out);\n        out.println(ans);\n        out.flush();\n    }\n}\n", "code2": "include Math\nwhile n = gets.to_i\n  break if n == 0\n  s = gets.split.map(&:to_f)\n  m = s.map.inject(:+) / n\n  sum = 0\n  s.each { |v| sum +=((v-m) ** 2)}\n  puts sqrt(sum /n)\nend", "label": 0, "name1": "s316016733.java", "name2": "s839318707.rb"}, {"id": 489, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    private static class FastScanner {\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        public String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        int array[] = new int[3], num = 0;\n        int count = 0;\n\n        while (count < 3) {\n            num = sc.nextInt();\n            if (0 < num && num < 10) {\n                array[count] = num;\n                count++;\n            }\n        }\n\n\n        for (int i = 0; i < 3; i++) {\n            for (int j = i + 1; j < 3; j++) {\n                if (array[i] == array[j]) {\n                    count = count - 1;\n                }\n            }\n        }\n        if (count == 2) {\n            System.out.print(\"Yes\");\n        } else {\n            System.out.print(\"No\");\n        }\n    }\n}\n", "code2": "a, b, c = gets.split.map(&:to_i)\n\nputs (a==b && a==c && b == c) || (a != b && a != c && c != b) ? \"No\": \"Yes\"", "label": 1, "name1": "s136290389.java", "name2": "s674156319.rb"}, {"id": 587, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        int count = Integer.valueOf(reader.readLine());\n        String s = reader.readLine();\n\n        long[][] dp = new long[count][count];\n        dp[0][0] = 1;\n        long modulo = 1_000_000_007;\n\n        for (int i = 1; i < count; ++i) {\n            if (s.charAt(i - 1) == '<') {\n                dp[i][0] = 0;\n                for (int j = 1; j <= i; ++j) {\n                    dp[i][j] = dp[i][j - 1] + dp[i - 1][j - 1];\n                    dp[i][j] %= modulo;\n                }\n            } else {\n                dp[i][i] = 0;\n                for (int j = i - 1; j >= 0; --j) {\n                    dp[i][j] = dp[i][j + 1] + dp[i - 1][j];\n                    dp[i][j] %= modulo;\n                }\n            }\n        }\n\n        long res = 0;\n        for (int i = 0; i < count; ++i) {\n            res += dp[count - 1][i];\n            res %= modulo;\n        }\n        System.out.println(res);\n    }\n}\n", "code2": "primes = []\n2.upto(123456*2){|x|\n    prime = true\n    2.upto(Math.sqrt(x)){|y|\n        if x % y == 0\n            prime = false\n            break\n        end\n    }\n    primes << x if prime\n}\n\narr = Array.new(123456 * 2 + 1 , 0)\nprimes.each{|prime| arr[prime] = 1}\n1.upto(arr.length - 1){|i| arr[i] += arr[i - 1]}\n\nwhile true\n    n = gets.to_i\n    break if n == 0\n    puts arr[n * 2] - arr[n]\nend\n", "label": 0, "name1": "s833810272.java", "name2": "s199415764.rb"}, {"id": 904, "code1": "import java.util.*;\n\nclass Main{\n    public static void main(String[] args){\n        \n        Scanner sc = new Scanner(System.in);\n\n        int x = sc.nextInt();\n        if(x==3 || x==2){\n            System.out.println(x);\n            return;\n        }\n        if(x==1){\n            System.out.println(2);\n            return;\n        }\n\n        for(int i=0; i<=100003; i++){\n            for(int j=2; j*j<=x+i; j++){\n                if((x+i)%j==0){\n                    break;\n                }\n                if((j+1)*(j+1)>x+i){\n                    System.out.println(x + i);\n                    return;\n                }\n            }\n        }\n    }\n}", "code2": "h, w = gets.split.map(&:to_i)\na = h.times.map { gets.chomp }\ns = a.join(\"\")\ncnt = {}\n?a.upto(?z) { |c| cnt[c] = s.count(c) }\n\nif w == 1\n  if h.odd?\n    puts cnt.values.select { |x| x.odd? }.size == 1 ? \"Yes\" : \"No\"\n  else\n    puts cnt.values.select { |x| x.odd? }.size == 0 ? \"Yes\" : \"No\"\n  end\nelse\n  if h.even? && w.even?\n    puts cnt.values.select { |x| x % 4 != 0 }.size == 0 ? \"Yes\" : \"No\"\n  elsif h.odd? && w.odd?\n    ume = 0\n    ?a.upto(?z) do |c|\n      if cnt[c] >= 4 && (h - 1) * (w - 1) > ume\n        ume += (cnt[c] / 4) * 4\n        cnt[c] -= (cnt[c] / 4) * 4\n        if (h - 1) * (w - 1) < ume\n          cnt[c] += ume - (h - 1) * (w - 1)\n          ume = (h - 1) * (w - 1)\n        end\n      end\n    end\n    if ume != (h - 1) * (w - 1)\n      puts \"No\"\n      exit\n    end\n    puts cnt.values.select { |x| x.odd? }.size == 1 ? \"Yes\" : \"No\"\n  else\n    ume = 0\n    t = h.odd? ? w : h\n    ?a.upto(?z) do |c|\n      if cnt[c] >= 4 && h * w - t > ume\n        ume += (cnt[c] / 4) * 4\n        cnt[c] -= (cnt[c] / 4) * 4\n        if h * w - t < ume\n          cnt[c] += ume - h * w - t\n          ume = h * w - t\n        end\n      end\n    end\n    if ume != h * w - t\n      puts \"No\"\n      exit\n    end\n    puts cnt.values.select { |x| x.odd? }.size == 0 ? \"Yes\" : \"No\"\n  end\nend\n", "label": 0, "name1": "s443254620.java", "name2": "s670958543.rb"}, {"id": 870, "code1": "import java.io.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.util.*;\n\nclass Main{public static void main(String[] args){new Solver();}}\n\nclass Solver{\n\tScanReader reader=new ScanReader(System.in);\n\tPrintWriter writer=new PrintWriter(System.out);\n\tSolver(){main(); writer.flush();}\n\t\n\tvoid main(){\n\t\tBigInteger m=BigInteger.ONE;\n\t\tfor(int i=0;i<1500;i++)\n\t\t\tm=m.multiply(BigInteger.valueOf(i+2));\n\t\tm=m.add(BigInteger.valueOf(2));\n\t\t\n\t\twhile(reader.hasNext()){\n\t\t\tint n=Integer.parseInt(reader.next());\n\t\t\tSystem.out.println(m);\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tSystem.out.println(i+2);\n\t\t}\n\t}\n}\n\nclass ScanReader{\n\tBufferedReader br;\n\tStringTokenizer st;\n\tpublic ScanReader(InputStream in){\n\t\tbr=new BufferedReader(new InputStreamReader(in));\n\t\tst=null;\n\t}\n\tpublic boolean hasNext(){\n\t\twhile(st==null || !st.hasMoreTokens()){\n\t\t\ttry{\n\t\t\t\tif(!br.ready())\n\t\t\t\t\treturn false;\n\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t\tcatch(IOException e){\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tpublic String nextLine(){\n\t\thasNext();\n\t\treturn st.nextToken(\"\");\n\t}\n\tpublic String next(){\n\t\thasNext();\n\t\treturn st.nextToken();\n\t}\n}", "code2": "a,b = gets.split(' ')\n\nif (a == 'H' && b == 'H') || (a == 'D' && b == 'D') \n  puts 'H'\nelse\n  puts 'D'\nend\n", "label": 0, "name1": "s499130776.java", "name2": "s829363993.rb"}, {"id": 841, "code1": "import java.util.Scanner;\n\npublic class Main {\n    static int selectSort(int[] data) {\n        int ret = 0, n = data.length;\n        for (int i = 0; i < n; ++i) {\n            int minJ = i;\n            for (int j = i; j < n; ++j) {\n                if (data[j] < data[minJ]) minJ = j;\n            }\n            if(minJ != i) {\n                ++ret;\n                int tmp = data[minJ];\n                data[minJ] = data[i];\n                data[i] = tmp;\n            }\n        }\n        return ret;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int n = scanner.nextInt();\n        int[] data = new int[n];\n\n        for (int i = 0; i < n; ++i) {\n            data[i] = scanner.nextInt();\n        }\n\n        int cnt = selectSort(data);\n        for (int i = 0; i < n; ++i) {\n            System.out.print(data[i]);\n            if (i != n - 1) System.out.print(\" \");\n        }\n        System.out.println();\n        System.out.println(cnt);\n    }\n}\n", "code2": "\nrtimes = []\n\n24.times.each do\n  rn, rt = gets.strip.split(\" \")\n  rtimes << [rn, rt.to_f]\nend\n\nsemifinals = []\nrests = []\n\nfor t in (0..2)\n  race = rtimes[(t * 8), 8].sort{|a, b| a[1] <=> b[1]}\n  semifinals << race.shift\n  semifinals << race.shift\n  rests += race\nend\n\nrests.sort!{|a, b| a[1] <=> b[1]}\nsemifinals << rests.shift\nsemifinals << rests.shift\n\nsemifinals.each{|rn, rt| printf(\"%s %.2f\\n\", rn, rt)}", "label": 0, "name1": "s945145574.java", "name2": "s012250587.rb"}, {"id": 859, "code1": "import java.util.*;\n\npublic class Main{\n\t\n\t// a < b\n\tpublic static int gcv(int a, int b){\n\t\tif(b % a == 0){\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tint mod = b % a;\n\t\t\n\t\treturn gcv(mod, a);\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tScanner scan = new Scanner(System.in);\n\t\tLinkedList<Integer> monsters = new LinkedList<>();\n\t\t\n\t\t// input\n\t\tint num = scan.nextInt();\n\t\tfor(int i = 0; i < num; i++){\n\t\t\tmonsters.add(scan.nextInt());\n\t\t}\n\t\t\n\t\t// check\n\t\tCollections.sort(monsters);\n\t\twhile(monsters.size() > 1){\n\t\t\tmonsters.push(gcv( monsters.pop(), monsters.pop()));\n\t\t}\n\t\t\n\t\t// answer\n\t\tSystem.out.println(monsters.pop());\n\t}\n}", "code2": "n = gets.to_i\nputs (1..n + 1).reduce(:*) + 2\n(2..n + 1).each(&method(:puts))", "label": 0, "name1": "s591174716.java", "name2": "s370225239.rb"}, {"id": 667, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tpublic void solve() {\n\t\tint N = nextInt();\n\t\tint[] a = new int[N];\n\t\tfor(int i = 0;i < N;i++){\n\t\t\ta[i] = nextInt() - 1;\n\t\t}\n\t\tboolean[] used = new boolean[N];\n\t\tint ans = 0;\n\t\tfor(int i = 0;i < N;i++){\n\t\t\tint x = a[i];\n\t\t\tint y = a[x];\n\t\t\tif(used[x])continue;\n\t\t\tif(used[y])continue;\n\t\t\tif(x == a[y] && y == a[x]){\n\t\t\t\tans++;\n\t\t\t\tused[x] = true;\n\t\t\t\tused[y] = true;\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}", "code2": "imput = gets.chomp.split(\" \")\n#puts imput\na = imput[0].to_i\nb = imput[1].to_i\nc = imput[2].to_i\nk = imput[3].to_i\n#puts a,b,c,k\nif (a >= k) then\n    puts k\nelse\n    if (a + b >= k) then\n        puts a\n    else\n        puts (a - (k-a-b))\n        #puts k\n    end\nend\n  ", "label": 0, "name1": "s188425538.java", "name2": "s251719998.rb"}, {"id": 812, "code1": "import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long[] a = new long[n];\n        long[] b = new long[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextLong();\n        }\n        for (int i = 0; i < n; i++) {\n            b[i] = sc.nextLong();\n        }\n        long sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += b[i] - a[i];\n        }\n\n        long cnt = 0;\n        for (int i = 0; i < n; i++) {\n            if (a[i] < b[i]) {\n                cnt += (b[i] - a[i] + 1) / 2;\n            }\n        }\n        if (cnt <= sum) {\n            System.out.println(\"Yes\");\n            return;\n        }\n        System.out.println(\"No\");\n    }\n}\n", "code2": "N, M = gets.split.map{|i|i.to_i}\nm = Array.new(N){Array.new(N){false}}\nM.times{\n    a, b = gets.split.map{|i|i.to_i - 1}\n    m[a][b] = true\n    m[b][a] = true\n}\n\nq = []\nq << [0]\ncount = 0\nuntil q.empty?\n    o = q.shift\n    if o.size == N\n        count += 1\n        next\n    end\n    n = o[-1]\n    N.times{|i|\n        next unless m[n][i]\n        next if o.include?(i)\n        q << (o + [i])\n    }\nend\nputs count\n", "label": 0, "name1": "s202753514.java", "name2": "s811488043.rb"}, {"id": 323, "code1": "\npublic class Main {\n\n  static int mod = 1000003;\n  static int[][] fif = enumFIF(mod * 3, mod);\n\n  private static void solve() {\n    int q = ni();\n\n    for (int i = 0; i < q; i++) {\n      int x = ni();\n      int d = ni();\n      int n = ni();\n      out.println(f(x, d, n));\n    }\n  }\n\n  private static long f(int x, int d, int n) {\n    if (x == 0) {\n      return 0;\n    } else if (d == 0) {\n      return pow(x, n, mod);\n    }\n\n    int y = (int) (x * invl(d, mod) % mod);\n    if (n >= mod || y % mod > (y + n - 1) % mod) {\n      return 0;\n    }\n\n    long z = fif[0][y + n - 1] * invl(fif[0][y - 1], mod) % mod;\n    z *= pow(d, n, mod);\n    z %= mod;\n\n    return z;\n  }\n\n  public static long pow(long a, long n, long mod) {\n    // a %= mod;\n    long ret = 1;\n    int x = 63 - Long.numberOfLeadingZeros(n);\n    for (; x >= 0; x--) {\n      ret = ret * ret % mod;\n      if (n << 63 - x < 0)\n        ret = ret * a % mod;\n    }\n    return ret;\n  }\n\n\n  public static int[][] enumFIF(int n, int mod) {\n    int[] f = new int[n + 1];\n    int[] invf = new int[n + 1];\n    f[0] = 1;\n    for (int i = 1; i <= n; i++) {\n      f[i] = (int) ((long) f[i - 1] * i % mod);\n    }\n    long a = f[n];\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    invf[n] = (int) (p < 0 ? p + mod : p);\n    for (int i = n - 1; i >= 0; i--) {\n      invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n    }\n    return new int[][] {f, invf};\n  }\n\n  public static long invl(long a, long mod) {\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    return p < 0 ? p + mod : p;\n  }\n\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n\n", "code2": "def powmod(b,r,mod)\n  a = 1\n  while r > 0\n    if r%2 == 1\n      a = a * b % mod\n    end\n    b = b * b % mod\n    r /= 2\n  end\n  a\nend\n \ndef invmod(f, mod)\n  powmod(f, mod-2, mod)\nend\n\n\nMod = 1000003\nfs = [1]\n(1...Mod).each{ |n|\n  fs << (fs[-1] * n % Mod)\n}\nQ = gets.to_i\nQ.times {\n  x,d,n = gets.split.map &:to_i\n  if d == 0\n    p powmod(x, n, Mod)\n    next\n  end\n\n  id = invmod(d, Mod)\n  b = x * id % Mod\n  if b+n-1 >= Mod\n    p 0\n    next\n  end\n  dn = powmod(d, n, Mod) \n  fact = fs[b+n-1]\n  invf = invmod(fs[b-1], Mod)\n  p dn * fact % Mod * invf % Mod\n}\n\n", "label": 1, "name1": "s606179301.java", "name2": "s618645207.rb"}, {"id": 190, "code1": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\n\nimport static java.util.Comparator.reverseOrder;\n\npublic class Main {\n\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n\n        List<Long> inputList = new ArrayList<Long>();\n        for(int i = 0; i < n ;i++) {\n            inputList.add(sc.nextLong());\n        }\n\n        /*\n        List<Integer> sortedList = inputList.stream().sorted(reverseOrder()).collect(Collectors.toList());\n        for(int a: sortedList) {\n            System.out.println(a);\n        }\n        */\n        List<Long> sortedList = inputList.stream().sorted(reverseOrder()).collect(Collectors.toList());\n        long result = sortedList.get(0);\n        int index = 1;\n        int count = 0;\n        for (int i = 0; i < n - 2 ; i++) {\n            result += sortedList.get(index);\n            count = count + 1;\n            if (count == 2) {\n                count = 0;\n                index = index + 1;\n            }\n        }\n        System.out.println(result);\n    }\n}", "code2": "N = gets.to_i\nA = gets.split.map(&:to_i).sort\n\nans = A.pop\n(N-2).times do |i|\n  ans += i.odd? ? A.pop : A[-1]\nend\nputs ans", "label": 1, "name1": "s542407178.java", "name2": "s029357848.rb"}, {"id": 251, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tpublic void solve() {\n\t\tint N = nextInt();\n\t\tint[] a = new int[N];\n\t\tfor(int i = 0;i < N;i++){\n\t\t\ta[i] = nextInt() - 1;\n\t\t}\n\t\tboolean[] used = new boolean[N];\n\t\tint ans = 0;\n\t\tfor(int i = 0;i < N;i++){\n\t\t\tint x = a[i];\n\t\t\tint y = a[x];\n\t\t\tif(used[x])continue;\n\t\t\tif(used[y])continue;\n\t\t\tif(x == a[y] && y == a[x]){\n\t\t\t\tans++;\n\t\t\t\tused[x] = true;\n\t\t\t\tused[y] = true;\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}", "code2": "n = gets.to_i\na = gets.split.map(&:to_i)\n\nans = 0\nn.times do |i|\n  ans += 1 if a[a[i]-1] == i+1\nend\n\nputs ans/2", "label": 1, "name1": "s188425538.java", "name2": "s492489803.rb"}, {"id": 131, "code1": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable {\n\tFastReader scn;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\n\tvoid solve() {\n\t\tint n = scn.nextInt(), mod = (int) 1e9 + 7;\n\t\tchar[] cmp = scn.next().toCharArray();\n\t\t\n\t\tint[][] dp = new int[n + 1][n + 1];\n\t\tdp[1][1] = 1;\n\t\t\n\t\tfor(int len = 2; len <= n; len++) {\n\t\t\tint[] pref = new int[n + 1];\n\t\t\tfor(int i = 1; i <= n; i++) {\n\t\t\t\tpref[i] = (pref[i - 1] + dp[len - 1][i]) % mod;\n\t\t\t}\n\t\t\tfor(int curr = 1; curr <= len; curr++) {\n\t\t\t\tint L, R;\n\t\t\t\tif(cmp[len - 2] == '<') {\n\t\t\t\t\tL = 1;\n\t\t\t\t\tR = curr - 1;\n\t\t\t\t} else {\n\t\t\t\t\tL = curr;\n\t\t\t\t\tR = n;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(L <= R) {\n\t\t\t\t\tdp[len][curr] += (pref[R] - pref[L - 1]);\n\t\t\t\t\tif(dp[len][curr] >= mod) {\n\t\t\t\t\t\tdp[len][curr] -= mod;\n\t\t\t\t\t} else if(dp[len][curr] < 0) {\n\t\t\t\t\t\tdp[len][curr] += mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor(int curr = 1; curr <= n; curr++) {\n\t\t\tans += dp[n][curr];\n\t\t\tif(ans >= mod) {\n\t\t\t\tans -= mod;\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t}\n\n\tpublic void run() {\n\t\tlong time = System.currentTimeMillis();\n\t\tboolean oj = true;\n\t\tout = new PrintWriter(System.out);\n\t\tscn = new FastReader(oj);\n\t\tsolve();\n\t\tout.flush();\n\t\tif (!oj) {\n\t\t\tSystem.out.println(Arrays.deepToString(new Object[] { System.currentTimeMillis() - time + \" ms\" }));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"Main\", 1 << 26).start();\n\t}\n\n\tclass FastReader {\n\t\tInputStream is;\n\n\t\tpublic FastReader(boolean onlineJudge) {\n\t\t\tis = onlineJudge ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\t}\n\n\t\tpublic FastReader() {\n\t\t\tis = System.in;\n\t\t}\n\n\t\tbyte[] inbuf = new byte[1024];\n\t\tpublic int lenbuf = 0, ptrbuf = 0;\n\n\t\tint readByte() {\n\t\t\tif (lenbuf == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (ptrbuf >= lenbuf) {\n\t\t\t\tptrbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn inbuf[ptrbuf++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tint skip() {\n\t\t\tint b;\n\t\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t\t;\n\t\t\treturn b;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tchar nextChar() {\n\t\t\treturn (char) skip();\n\t\t}\n\n\t\tString next() {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile ((!isSpaceChar(b) || b == ' ')) { // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tchar[] next(int n) {\n\t\t\tchar[] buf = new char[n];\n\t\t\tint b = skip(), p = 0;\n\t\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t\t}\n\n\t\tint nextInt() {\n\t\t\tint num = 0, b;\n\t\t\tboolean minus = false;\n\t\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\tlong num = 0;\n\t\t\tint b;\n\t\t\tboolean minus = false;\n\t\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tchar[][] nextMatrix(int n, int m) {\n\t\t\tchar[][] map = new char[n][];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next(m);\n\t\t\treturn map;\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tint[][] IndIntArray(int n) {\n\t\t\tint[][] a = new int[n][];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = new int[] { nextInt(), i };\n\t\t\treturn a;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tint[][] next2DInt(int n, int m) {\n\t\t\tint[][] arr = new int[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[][] next2DLong(int n, int m) {\n\t\t\tlong[][] arr = new long[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextLongArray(m);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] shuffle(int[] arr) {\n\t\t\tRandom r = new Random();\n\t\t\tfor (int i = 1, j; i < arr.length; i++) {\n\t\t\t\tj = r.nextInt(i);\n\t\t\t\tint c = arr[i];\n\t\t\t\tarr[i] = arr[j];\n\t\t\t\tarr[j] = c;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] shuffle(long[] arr) {\n\t\t\tRandom r = new Random();\n\t\t\tfor (int i = 1, j; i < arr.length; i++) {\n\t\t\t\tj = r.nextInt(i);\n\t\t\t\tlong c = arr[i];\n\t\t\t\tarr[i] = arr[j];\n\t\t\t\tarr[j] = c;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] uniq(int[] arr) {\n\t\t\tarr = scn.shuffle(arr);\n\t\t\tArrays.sort(arr);\n\t\t\tint[] rv = new int[arr.length];\n\t\t\tint pos = 0;\n\t\t\trv[pos++] = arr[0];\n\t\t\tfor (int i = 1; i < arr.length; i++) {\n\t\t\t\tif (arr[i] != arr[i - 1]) {\n\t\t\t\t\trv[pos++] = arr[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Arrays.copyOf(rv, pos);\n\t\t}\n\n\t\tlong[] uniq(long[] arr) {\n\t\t\tarr = scn.shuffle(arr);\n\t\t\tArrays.sort(arr);\n\t\t\tlong[] rv = new long[arr.length];\n\t\t\tint pos = 0;\n\t\t\trv[pos++] = arr[0];\n\t\t\tfor (int i = 1; i < arr.length; i++) {\n\t\t\t\tif (arr[i] != arr[i - 1]) {\n\t\t\t\t\trv[pos++] = arr[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Arrays.copyOf(rv, pos);\n\t\t}\n\n\t\tint[] reverse(int[] arr) {\n\t\t\tint l = 0, r = arr.length - 1;\n\t\t\twhile (l < r) {\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tarr[r] = arr[l] ^ arr[r];\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tl++;\n\t\t\t\tr--;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] reverse(long[] arr) {\n\t\t\tint l = 0, r = arr.length - 1;\n\t\t\twhile (l < r) {\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tarr[r] = arr[l] ^ arr[r];\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tl++;\n\t\t\t\tr--;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] compress(int[] arr) {\n\t\t\tint n = arr.length;\n\t\t\tint[] rv = Arrays.copyOf(arr, n);\n\t\t\trv = uniq(rv);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = Arrays.binarySearch(rv, arr[i]);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] compress(long[] arr) {\n\t\t\tint n = arr.length;\n\t\t\tlong[] rv = Arrays.copyOf(arr, n);\n\t\t\trv = uniq(rv);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = Arrays.binarySearch(rv, arr[i]);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\t}\n}", "code2": "d=*1..gets.to_i;\ngets.chop.bytes{|c|\n\tx=0;\n\td.map!{|a|x=(x+d[-1]*c[1]+(1-c%3)*a).%10**9+7}.pop\n}\np *d", "label": 1, "name1": "s976963924.java", "name2": "s005244405.rb"}, {"id": 437, "code1": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n\t\t\tint K = io.nextInt();\n\t\t\tint L = io.nextInt();\n\n\t\t\tUnionFind uf1 = new UnionFind(n);\n\t\t\tUnionFind uf2 = new UnionFind(n);\n\t\t\tUnionFind uf3 = new UnionFind(n);\n\t\t\t\n\t\t\tfor (int i = 0; i < K; i++) {\n\t\t\t\tint a = io.nextInt() - 1;\n\t\t\t\tint b = io.nextInt() - 1;\n\t\t\t\tuf1.union(a, b);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < L; i++) {\n\t\t\t\tint a = io.nextInt() - 1;\n\t\t\t\tint b = io.nextInt() - 1;\n\t\t\t\tuf2.union(a, b);\n\t\t\t}\n\n\t\t\tTreeSet<Integer>[] s1 = new TreeSet[n];\n\t\t\tTreeSet<Integer>[] s2 = new TreeSet[n];\n\t\t\tfor (int i = 0; i < n; i++) if (uf1.root(i) == i) {\n\t\t\t\tTreeSet<Integer> s = new TreeSet<>();\n\t\t\t\tfor (int j = i; j != -1; j = uf1.next[j]) { s.add(j); }\n\t\t\t\ts1[i] = s;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) if (uf2.root(i) == i) {\n\t\t\t\tTreeSet<Integer> s = new TreeSet<>();\n\t\t\t\tfor (int j = i; j != -1; j = uf2.next[j]) { s.add(j); }\n\t\t\t\ts2[i] = s;\n\t\t\t}\n\t\t\t\n\t\t\tint[] ans = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint r1 = uf1.root(i);\n\t\t\t\tint r2 = uf2.root(i);\n\n\t\t\t\tif (!s1[r1].contains(i)) continue;\n\n\t\t\t\tTreeSet<Integer> a = s1[r1].size() < s2[r2].size() ? s1[r1] : s2[r2];\n\t\t\t\tTreeSet<Integer> b = s1[r1].size() < s2[r2].size() ? s2[r2] : s1[r1];\n\t\t\t\tList<Integer> same = new ArrayList<>();\n\t\t\t\tfor (int t : a) {\n\t\t\t\t\tif (b.contains(t)) same.add(t);\n\t\t\t\t}\n\t\t\t\tfor (int t : same) {\n\t\t\t\t\ts1[r1].remove(t);\n\t\t\t\t\ts2[r2].remove(t);\n\t\t\t\t\tans[t] = same.size();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tprintArrayLn(ans);\n\t\t}\n\t}\n\t\n\tstatic\n\tclass UnionFind {\n\t\tprivate int[] data;\n\t\tprivate int[] next;\n\t\tprivate int[] last;\n\t\t\n\t\tpublic UnionFind(int size) {\n\t\t\tdata = new int[size];\n\t\t\tnext = new int[size];\n\t\t\tlast = new int[size];\n\t\t\tclear();\n\t\t}\n\t\t\n\t\tpublic void clear() {\n\t\t\tArrays.fill(data, -1);\n\t\t\tArrays.fill(next, -1);\n\t\t\tfor(int i = 0; i < last.length; i++) {\n\t\t\t\tlast[i] = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int root(int x) { return data[x] < 0 ? x : (data[x] = root(data[x])); }\n\t\t\n\t\tpublic void union(int x, int y) {\n\t\t\tif((x = root(x)) != (y = root(y))) {\n\t\t\t\tif(data[y] < data[x]) { final int t = x; x = y; y = t; }\n\t\t\t\tdata[x] += data[y];\n\t\t\t\tdata[y] = x;\n\t\t\t\tnext[last[x]] = y;\n\t\t\t\tlast[x] = last[y];\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic boolean same(int x, int y) { return root(x) == root(y); }\n\t\tpublic int size(int x) { return -data[root(x)]; }\n\t}\n\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n", "code2": "def inp() a=gets.chomp.split(\" \").map(&:to_i)end \ndef inpf() a=gets.chomp.split(\" \").map(&:to_f)end\ndef inps() a=gets.chomp.split(\" \")end  \ndef copy(a) Marshal.load(Marshal.dump(a)) end\ndef kaizyo(n)(n < 2)? 1 : (2..n).inject(:*) end\ndef scount(a) b = na(a.max+1); a.each{|n|b[n]+=1};return b end\ndef na(n=0,d=0) Array.new(n,d)end\ndef na2(n,m,d=0) Array.new(n){Array.new(m,d)}end\ndef na3(n,m,l,d=0) Array.new(n){Array.new(m){Array.new(l,d)}}end\nclass Uf\ndef initialize(n)\n  @r = na(n+1)\n  @a = (0...n).to_a\nend\ndef uf(x)\n  return x if (@a[x] == x)\n  @a[x] = uf(@a[x])\nend\ndef add(x,p)\n  root  = uf(x)\n  connect  = uf(p)\n  return if root == connect\n  if @r[root] > @r[connect]\n    @a[connect] = root\n  elsif @r[root] == @r[connect]\n    @a[connect] = root\n    @r[root] += 1\n  else\n    @a[root] = connect\n  end\nend\ndef ufj(x,p)\n   return uf(x) == uf(p) \nend\nend\nh = {}\nn,k,l = inp\na = Uf.new(n+1)\nb = Uf.new(n+1)\n(k).times do |i|\n  d = inp\n  a.add(d[0],d[1])\nend\n(l).times do |i|\n  d = inp\n  b.add(d[0],d[1])\nend\n(1..n).each do |i|\n  aa = a.uf(i)\n  bb = b.uf(i)\n  h[aa+n*bb] = 0 if(h[aa+n*bb] == nil)\n  h[aa+n*bb] += 1 \nend\n(1..n-1).each do |i|\n  aa = a.uf(i)\n  bb = b.uf(i)\n  print \"#{h[aa+n*bb]} \" \nend\naa = a.uf(n)\nbb = b.uf(n)\nputs h[aa+n*bb]\n=begin\nmax = c if max < c \n=end", "label": 1, "name1": "s632399466.java", "name2": "s266029074.rb"}, {"id": 331, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint a = scanner.nextInt(),b = scanner.nextInt(),c = scanner.nextInt();\n\t\tint[] x = {a,b,c};\n\t\tArrays.sort(x);\n\t\tSystem.out.println(x[0]+x[1]);\n\t}\n\n}\n", "code2": "a,b,c = gets.split.map(&:to_i)\nputs a+b+c - [a,b,c].max", "label": 1, "name1": "s134824979.java", "name2": "s564366262.rb"}, {"id": 601, "code1": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String args[]) {\n\tScanner sc = new Scanner(System.in);\n\n\twhile (true) {\n\t    int n = sc.nextInt();\n\t    int ans = 0;\n\t    if (n == 0) {\n\t\tbreak;\n\t    }\n\t    \n\t    ans = solve(n);\n\t    System.out.println(ans);\n\t}\n    }\n\n    public static int solve(int n) {\n\t//int max = 123456 * 2;\n\t//int prime[] = new prime[123456 * 2 + 1];\n\tboolean is_prime[] = new boolean[123456 * 2 + 1];\n\tint count = 0;\n\n\t//int p = 0;\n\tfor (int i = 0; i <= 2 * n; i++) {\n\t    is_prime[i] = true;\n\t}\n\n\tis_prime[0] = is_prime[1] = false;\n\tfor (int i = 2; i <= 2 * n; i++) {\n\t    if (is_prime[i]) {\n\t\t// prime[p++] = i;\n\t\tfor (int j = 2 * i; j <= 2 * n; j += i) {\n\t\t    is_prime[j] = false;\n\t\t}\n\t    }\n\t}\n\tfor (int i = n + 1; i <= 2 * n; i++) {\n\t    if (is_prime[i]) {\n\t\tcount++;\n\t    }\n\t}\n\t\n\treturn count;\n    }\n}", "code2": "X = gets.chomp\n\nchars = Array.new(X.size) {0}\nsp = 0\n\ndecrease = 0\nX.chars.each_with_index do |s, i|\n  if s == 'S'\n    sp += 1\n  else\n    next if sp == 0\n    sp -= 1\n    decrease += 1\n  end\nend\n\nputs X.size - decrease * 2\n", "label": 0, "name1": "s027703193.java", "name2": "s860052839.rb"}, {"id": 108, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint a = Integer.parseInt(sc.next());\n\t\tint b = Integer.parseInt(sc.next());\n\t\tint c = Integer.parseInt(sc.next());\n\n\t\tif (a < c && c < b || b < c && c < a){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t}else {\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t}\n}", "code2": "a, b, c = gets.chomp!.split(\" \").map!(&:to_i)\n\nputs ((a..b).include?(c)  || (b..a).include?(c)) ? \"Yes\" : \"No\"\n", "label": 1, "name1": "s898770223.java", "name2": "s629547340.rb"}, {"id": 759, "code1": "import java.util.*;\nimport java.lang.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        long a = sc.nextLong();\n        long b = sc.nextLong();\n        long x = sc.nextLong();\n        long countA = a ==0 ? 0 : (a-1)/x+1;\n        long countB = b/x+1;\n        System.out.println(countB-countA);\n\n    }\n}\n", "code2": "class Array\n  def merge_sort\n    return self if length <= 1\n    a, b = half.map(&:merge_sort)\n    merge(a, b)\n  end\n\n  def half\n    n = (length/2.0).floor\n    return self[0...n], self[n..(length-1)]\n  end\n\n  private\n\n  def merge(a, b)\n    result = []\n    while a.size > 0 || b.size > 0\n      result << if a.empty?\n                  b.shift\n                elsif b.empty?\n                  a.shift\n                elsif a.first < b.first\n                  a.shift\n                else\n                  b.shift\n                end\n    end\n    result\n  end\nend\n\nwhile n = gets.to_i\n  break if n == 0\n  puts gets.split(' ').map(&:to_i).merge_sort.join(' ')\nend", "label": 0, "name1": "s118772140.java", "name2": "s469802588.rb"}, {"id": 187, "code1": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\n\tprivate static Scanner sc;\n\tprivate static Printer pr;\n\n\tprivate static void solve() {\n\t\tint a = sc.nextInt();\n\t\tint b = sc.nextInt();\n\n\t\tif (b < a) {\n\t\t\ta--;\n\t\t}\n\n\t\tpr.println(a);\n\t}\n\n\t// ---------------------------------------------------\n\tpublic static void main(String[] args) {\n\t\tsc = new Scanner(INPUT == null ? System.in : new ByteArrayInputStream(INPUT.getBytes()));\n\t\tpr = new Printer(System.out);\n\n\t\tsolve();\n\n//\t\tpr.close();\n\t\tpr.flush();\n//\t\tsc.close();\n\t}\n\n\tstatic String INPUT = null;\n\n\tprivate static class Printer extends PrintWriter {\n\t\tPrinter(OutputStream out) {\n\t\t\tsuper(out);\n\t\t}\n\t}\n}\n", "code2": "a, b = gets.split.map(&:to_i)\nif b < a\n    puts a - 1\nelse\n    puts a\nend", "label": 1, "name1": "s998480605.java", "name2": "s251597929.rb"}, {"id": 195, "code1": "import java.util.*;\nimport java.io.*;\n\n\nclass Main {\n\n    public static void main(String[] args) throws IOException\n    {\n        PrintWriter out = new PrintWriter(System.out);\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        int n = Integer.parseInt(br.readLine());\n        Long arr[] = new Long[n];\n        StringTokenizer st1 = new StringTokenizer(br.readLine());\n        for(int i = 0 ; i < n ; i++)\n        {\n            arr[i] = Long.parseLong(st1.nextToken());\n        }\n        Arrays.sort(arr);\n        long sum = arr[n-1];\n        int ind = n-2;\n        for(int i = 0 ; i < n-2 ; i++)\n        {\n            sum += arr[ind];\n\n            if(i%2 != 0)\n                ind--;\n        }\n        out.println(sum);\n\n        out.flush();\n        out.close();\n\n    }\n\n    static class pair{\n        long x1;\n        long x2;\n\n        public pair(long x1 , long x2)\n        {\n            this.x1 = x1;\n            this.x2 = x2;\n        }\n\n    }\n\n}\n", "code2": "n=gets.to_i\na = gets.split.map(&:to_i).sort\na.unshift(0)\nsum = 0\n(1..n-1).each do |k|\n  sum += a[n-k/2]\nend\np sum\n", "label": 1, "name1": "s590431029.java", "name2": "s326126157.rb"}, {"id": 289, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint N = scan.nextInt();\n\t\tint M = scan.nextInt();\n\n\t\tint[] X = new int[M];\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tX[i] = scan.nextInt();\n\t\t}\n\n\t\tscan.close();\n\t\t\n\t\tif(M <= N) {\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tArrays.sort(X);\n\t\t\n\t\tint distance[] = new int[M-1];\n\t\tfor(int i=0; i<M-1; i++) {\n\t\t\tdistance[i] = X[i+1] - X[i];\n\t\t}\n\t\t\n\t\tArrays.sort(distance);\n\t\t\n\t\tint sum = 0;\n\t\tfor(int i=0; i<(M-N); i++) {\n\t\t\tsum+=distance[i];\n\t\t}\n\t\tSystem.out.println(sum);\n\n\n\t}\n\n}", "code2": "input = STDIN.read.split(\"\\n\").map{|l| l.split(\" \").map{|a| a.to_i}}\n\nN = input[0][0]\nM = input[0][1]\n\nX = input[1].sort\n\n\ndef main() \n    diffs = []\n\n    if N >= M \n        return 0\n    end\n\n    for i in 0..(M - 2)\n        d = X[i + 1] - X[i] \n        diffs.push([i, d])\n    end\n\n    ds = diffs.sort_by{|x| x[1]}.reverse.slice(0, N - 1).sort_by{|x| x[0]}\n    moves = 0\n\n    if ds.length > 0\n        for i in 0..(N - 1)\n            if i == 0\n                st = 0\n                ed = ds[i][0]\n            elsif i == (N - 1)\n                st = ds[i - 1][0] + 1\n                ed = M - 1\n            else\n                st = ds[i - 1][0] + 1\n                ed = ds[i][0]\n            end\n            moves = moves + (X[ed] - X[st]).abs\n        end\n    else\n        moves = (X.first - X.last).abs\n    end\n    return moves\nend\n\nputs main()", "label": 1, "name1": "s564605710.java", "name2": "s016750008.rb"}, {"id": 869, "code1": "import java.math.*;\nimport java.io.*;\n\n\nclass Main\n{\n    \n    public static void main(String args[])throws IOException\n    {\n\tBigInteger a = new BigInteger(\"1\");\n\tfor(int i=2;i<=1501;i++)\n\t    a = a.multiply(new BigInteger(Integer.toString(i)));\n\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));   \n\ta = a.add(new BigInteger(\"2\"));\n\tint n = Integer.parseInt(in.readLine());\n\tSystem.out.println(a);\n\tfor(int i=2;i<n+2;i++)\n\t    System.out.println(i);\n\n    }\n\n}", "code2": "a,b=gets.split\nc=a==?H\nc=!c if b==?D\nputs c ? ?H : ?D", "label": 0, "name1": "s566455859.java", "name2": "s287731219.rb"}, {"id": 930, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyScan in = new MyScan(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, MyScan in, PrintWriter out) {\n            int i = in.nextInt();\n\n            long[] md = new long[i];\n\n            int rm = i - 2;\n            int lx = i - 2;\n            while (rm >= 0) {\n                md[lx + 1] = Util.c(rm, lx);\n                rm -= 2;\n                lx--;\n            }\n            long res = 0;\n            long prev = 0;\n            for (int m = 1; m < i; m++) {\n                long cur = Util.fact(m) * Util.fact(i - m - 1) % Util._m;\n                cur = cur * (md[m]) % Util._m;\n\n\n                res += (cur - prev + Util._m) * m % Util._m;\n                prev = cur;\n\n            }\n\n\n            out.println(res % Util._m);\n\n        }\n\n    }\n\n    static class MyScan {\n        private final InputStream in;\n        private byte[] inbuf = new byte[1024];\n        public int lenbuf = 0;\n        public int ptrbuf = 0;\n\n        public MyScan(InputStream in) {\n            this.in = in;\n        }\n\n        private int readByte() {\n            if (lenbuf == -1) throw new InputMismatchException();\n            if (ptrbuf >= lenbuf) {\n                ptrbuf = 0;\n                try {\n                    lenbuf = in.read(inbuf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (lenbuf <= 0) return -1;\n            }\n            return inbuf[ptrbuf++];\n        }\n\n        public int nextInt() {\n            int num = 0, b;\n            boolean minus = false;\n            while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n\n            while (true) {\n                if (b >= '0' && b <= '9') {\n                    num = num * 10 + (b - '0');\n                } else {\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n    }\n\n    static class Util {\n        public static final long M07 = 1000_000_007;\n        public static long _m = M07;\n        private static long[] fact;\n        private static long[] inv;\n        private static long[] ifact;\n\n        public static void l() {\n            fact = new long[1000001];\n            inv = new long[1000001];\n            ifact = new long[1000001];\n            for (int s = 0; s < 2; s++) {\n                fact[s] = 1;\n                ifact[s] = 1;\n                inv[s] = 1;\n            }\n            inv[0] = 0;\n            for (int i = 2; i < inv.length; i++) {\n                inv[i] = (_m - (_m / i) * inv[(int) (_m % i)] % _m) % _m;\n            }\n            for (int i = 2; i < fact.length; i++) {\n                fact[i] = i * fact[i - 1] % _m;\n                ifact[i] = inv[i] * ifact[i - 1] % _m;\n            }\n        }\n\n        public static long c(int a, int b) {\n            if (fact == null) l();\n            return ifact[a] * ifact[b - a] % _m * fact[b] % _m;\n        }\n\n        public static long fact(int a) {\n            if (fact == null) l();\n            return fact[a];\n        }\n\n    }\n}\n\n", "code2": "n,*a=`dd`.split.map &:to_i\np (1...2*n).bsearch(&->x{\n\tb=a.map{|e|e<x}\n\t1.upto(n-1){|i|\n\t\treturn b[n+i-1] if b[n+i-1]==b[n+i-2]\n\t\treturn b[n-i-1] if b[n-i-1]==b[n-i-0]\n\t}\n\tb[0]\n})-1", "label": 0, "name1": "s881591663.java", "name2": "s377076296.rb"}, {"id": 390, "code1": "import java.util.*;\nimport java.lang.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        long a = sc.nextLong();\n        long b = sc.nextLong();\n        long x = sc.nextLong();\n        long countA = a ==0 ? 0 : (a-1)/x+1;\n        long countB = b/x+1;\n        System.out.println(countB-countA);\n\n    }\n}\n", "code2": "a,b,x=gets.split.map &:to_i\np b/x-(a-1)/x", "label": 1, "name1": "s118772140.java", "name2": "s453515568.rb"}, {"id": 770, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int N = sc.nextInt();\n        int[] a = new int[N];\n        for (int i=0; i<N; i++) {\n            a[i] = sc.nextInt();\n        }\n\n        int[] ans = solve(N, a);\n\n        for (int i=0; i<N; i++) {\n            System.out.println(ans[i]);\n        }\n    }\n\n    private static int[] solve(int N, int[] a) {\n        int[] ans = new int[N];\n        int total = Math.abs(a[0]) + Math.abs(a[N-1]);\n\n        for (int i=0; i<N-1; i++) {\n            total += Math.abs(a[i+1] - a[i]);\n        }\n\n        for (int i=0; i<N; i++) {\n            ans[i] = total;\n\n            if (i == 0) {\n                if (0 <= a[i] && a[i] <= a[i+1]\n                        || a[i+1] <= a[i] && a[i] <= 0) {\n//                    System.err.println(\"ans[\" + i + \"] : skip\");\n                    continue;\n                }\n                ans[i] = total - Math.abs(a[i] - 0) - Math.abs(a[i] - a[i+1]) + Math.abs(a[i+1] - 0);\n//                System.err.println(\"ans[\" + i + \"] = \" + ans[i]);\n            } else if (i == N-1) {\n                if (0 <= a[i] && a[i] <= a[i-1]\n                        || a[i-1] <= a[i] && a[i] <= 0) {\n//                    System.err.println(\"ans[\" + i + \"] : skip\");\n                    continue;\n                }\n\n                ans[i] = total - Math.abs(a[i] - 0) - Math.abs(a[i] - a[i-1]) + Math.abs(a[i-1] - 0);\n//                System.err.println(\"ans[\" + i + \"] = \" + ans[i]);\n            }\n            else if (a[i-1] <= a[i] && a[i] <= a[i+1]\n                    || a[i+1] <= a[i] && a[i] < a[i-1]) {\n//                System.err.println(\"ans[\" + i + \"] : skip\");\n                continue;\n            } else {\n                ans[i] = total - Math.abs(a[i] - a[i-1]) - Math.abs(a[i] - a[i+1]) + Math.abs(a[i+1] - a[i-1]);\n//                System.err.println(\"ans[\" + i + \"] = \" + ans[i]);\n            }\n        }\n\n        return ans;\n    }\n}", "code2": "N = gets.to_i\nT = readlines.map(&:to_i)\nputs T.inject {|r,t| r.lcm(t) }", "label": 0, "name1": "s919464469.java", "name2": "s946977011.rb"}, {"id": 310, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint a=scan.nextInt();\n\t\tint b=scan.nextInt();\n\t\tint c=scan.nextInt();\n\t\tint d=a-b;\n\t\tif(c-d>0) System.out.println(c-d);\n\t\telse System.out.println(\"0\");\n\n\t}\n\n}\n", "code2": "a,b,c=gets.split.map(&:to_i)\np [0, c-a+b].max", "label": 1, "name1": "s407931652.java", "name2": "s732080470.rb"}, {"id": 357, "code1": "import java.util.*;\nimport java.io.*;\n\npublic class Main implements Runnable {\n    public static void main(String[] args) {\n        Thread.setDefaultUncaughtExceptionHandler((t,e)->System.exit(1));\n        // keep stack\n        new Thread(null, new Main(), \"\", 16 * 1024 * 1024).start();\n    }\n    public void run() {\n        FastScanner sc = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        long X = sc.nextLong();\n        long Y = sc.nextLong();\n\n        long count = 1;\n        while(true) {\n            long A = X * 2;\n            if (Y < A) {\n                break;\n            }\n            X = A;\n            count++;\n        }\n        out.printf(\"%d\\n\", count);\n        out.flush();\n    }\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        } else {\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int readByte() {\n        if (hasNextByte()) {\n            return buffer[ptr++];\n        }\n        else {\n            return -1;\n        }\n    }\n\n    private static boolean isPrintableChar(int c) {\n        return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n        while (hasNextByte() && !isPrintableChar(buffer[ptr])) {\n            ptr++;\n        }\n    }\n\n    public boolean hasNext() {\n        skipUnprintable();\n        return hasNextByte();\n    }\n\n    public String next() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public int nextInt() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        int n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b)) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n\n    public long nextLong() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b)) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}", "code2": "X,Y = $stdin.gets.chomp.split(\" \").map{ |a| a.to_i }\nputs (Y/X).to_s(2).size", "label": 1, "name1": "s869503854.java", "name2": "s056155066.rb"}, {"id": 725, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n    private static int[] arr;\n\n    public static void main(String[] args) {\n\n        Scanner scanner = new Scanner(System.in);\n        String input = scanner.nextLine();\n        arr = Arrays.stream(input.split(\"\")).mapToInt(Integer::parseInt).toArray();\n\n        long sum = calc(0, arr.length - 1);\n        System.out.println(sum);\n    }\n\n    private static long calc(int position, int end) {\n        if (position > end) return 0;\n\n        long tmp = 0;\n        for (int i = position; i < end; i++) {\n            tmp += toInt(position, i) * Math.pow(2, (end - i - 1)) + calc(i + 1, end);\n        }\n        tmp += toInt(position, end);\n        return tmp;\n    }\n\n    private static long toInt(int start, int end) {\n        if (start == end) {\n//            System.out.println(\"start: \" + start + \" end: \" + end + \" -> \" + arr[start]);\n            return arr[start];\n        }\n\n        long tmp = 0;\n        for (int i = start; i <= end; i++) {\n            tmp += arr[i] * Math.pow(10, (end - i));\n        }\n//        System.out.println(\"start: \" + start + \" end: \" + end + \" -> \" + tmp);\n        return tmp;\n    }\n}", "code2": "x, y = gets.split.map(&:to_i)\n\nlast = x * (y / x)\nl = 0\n\nloop do\n  l += 1\n  a = x * 2 ** l\n\n  break if a > last\nend\n\nputs l\n", "label": 0, "name1": "s752481979.java", "name2": "s356215569.rb"}, {"id": 235, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n    static class FS {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            return hasNextByte() ? buffer[ptr++] : -1;\n        }\n\n        private boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        private void skipUnprintable() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        }\n\n        public boolean hasNext() {\n            skipUnprintable();\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n    }\n\n    static int[] np;\n    static int n;\n\n    public static void main(String[] args) throws Exception {\n        FS fs = new FS();\n//        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n//        String s = bf.readLine();\n//        int n = Integer.parseInt(s.substring(0, s.indexOf(' ')));//n packages\n//        int k = Integer.parseInt(s.substring(s.indexOf(' '), s.length()));//k trucks\n        n = fs.nextInt();\n        int k = fs.nextInt();\n\n\n        np = new int[n];\n        int max = 0;\n        for (int i = 0; i < n; i++) {\n\n            np[i] = fs.nextInt();\n            max = max < np[i] ? np[i] : max;\n        }\n        int p = 0;\n        int resids = 0;\n\n        int maxInt = 10000 *100000;\n        int minInt = max-1;\n        int mid = (maxInt + minInt) / 2;\n        while (maxInt - minInt > 1) {\n            int v = checkN(mid);\n            if (v > k) minInt = mid;\n            else maxInt = mid;\n\n            mid = (maxInt + minInt) / 2;\n        }\n        System.out.println(maxInt);\n    }\n\n    private static int checkN(int p) {\n        int resids = p;\n        int ink = 1;//\u5f53\u524d\u5df2\u7528\u5361\u8f66\n        for (int i = 0; i < n; i++) {\n            int j = np[i];\n            if (resids >= j) {\n                resids -= j;\n            } else {\n                ink++;\n                resids = p;\n                i--;\n            }\n        }\n        return ink;\n    }\n}\n", "code2": "n,k = gets.split.map(&:to_i)\nw = []\n(n).times do |i|\n  w[i] = gets.to_i\nend\nm = w.max\nans = (m..n*m).bsearch{|i|\n  count = 1\n  rest = i\n  for wi in w do\n    if rest >= wi\n      rest -= wi\n    else\n      count += 1\n      rest = i-wi\n    end\n  end\n  k >= count\n}\nprintf(\"%d\\n\",ans)\n", "label": 1, "name1": "s272482227.java", "name2": "s051438008.rb"}, {"id": 769, "code1": "import java.io.FileNotFoundException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tMaxHeapSort maxheap = new MaxHeapSort(new int[] {});\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tmaxheap.add(a[i]);\n\t\t}\n\t\ta = maxheap.sortedArray();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tSystem.out.print(a[i] + (i == n - 1 ? \"\\n\" : \" \"));\n\t\t}\n\t}\n\n\tclass MaxHeapSort {\n\t\tint n;\n\t\tint[] v;\n\n\t\tpublic MaxHeapSort(int[] v_) {\n\t\t\tif (v_.length > 1_000_000)\n\t\t\t\tthrow new AssertionError();\n\t\t\tv = Arrays.copyOf(v_, 1_000_000);\n\t\t\tn = v_.length;\n\t\t\tfor (int i = n; i >= 0; --i) {\n\t\t\t\tmaxHeapify(i);\n\t\t\t}\n\t\t}\n\n\t\tvoid add(int val) {\n\t\t\tv[n] = val;\n\t\t\tint cur = n;\n\t\t\t++n;\n\t\t\twhile (cur > 0) {\n\t\t\t\tcur = (cur - 1) / 2;\n\t\t\t\tmaxHeapify(cur);\n\t\t\t}\n\t\t}\n\n\t\tint[] sortedArray() {\n\t\t\tint sz = n;\n\t\t\tint[] ret = new int[sz];\n\t\t\tfor (int i = 0; i < sz; ++i) {\n\t\t\t\tret[sz - 1 - i] = poll();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tint poll() {\n\t\t\tint ret = v[0];\n\t\t\tv[0] = v[n - 1];\n\t\t\tv[n - 1] = ret;\n\t\t\t--n;\n\t\t\tmaxHeapify(0);\n\t\t\treturn ret;\n\t\t}\n\n\t\tvoid maxHeapify(int cur) {\n\t\t\tif (2 * cur + 1 >= n)\n\t\t\t\treturn;\n\t\t\tif (v[cur] >= v[2 * cur + 1] && (2 * cur + 2 >= n || v[cur] >= v[2 * cur + 2])) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint dst = -1;\n\t\t\tif (2 * cur + 2 >= n || v[2 * cur + 1] >= v[2 * cur + 2]) {\n\t\t\t\tdst = 2 * cur + 1;\n\t\t\t} else {\n\t\t\t\tdst = 2 * cur + 2;\n\t\t\t}\n\t\t\tint tmp = v[cur];\n\t\t\tv[cur] = v[dst];\n\t\t\tv[dst] = tmp;\n\t\t\tmaxHeapify(dst);\n\t\t}\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}", "code2": "def main()\n  n = gets.chomp.to_i\n  x = []\n  for i in 0..n-1 do\n     x << gets.chomp.to_i\n  end\n  puts x.inject(:lcm)\nend\n\nmain()", "label": 0, "name1": "s534493670.java", "name2": "s027645540.rb"}, {"id": 366, "code1": "\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.AbstractCollection;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Comparator;\nimport java.util.ArrayList;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author silviase\n */\npublic class Main {\n    \n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DijkstraVerify solver = new DijkstraVerify();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DijkstraVerify {\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            int source = in.nextInt();\n            Graph g = new Graph(n);\n            for (int i = 0; i < m; i++) {\n                g.addEdge(new Edge(in.nextInt(), in.nextInt(), in.nextInt()));\n            }\n            long[] d = g.dijkstra(source);\n            for (int i = 0; i < n; i++) {\n                if (d[i] > 1e15) out.println(\"INF\");\n                else out.println(d[i]);\n            }\n        }\n\n    }\n\n    static class Graph {\n        public int size;\n        public ArrayList<Edge>[] adj;\n        public int[] inDeg;\n        public int[] vertexCost;\n\n        @SuppressWarnings(\"unchecked\")\n        public Graph(int size) {\n            this.size = size;\n            adj = new ArrayList[size];\n            inDeg = new int[size];\n            vertexCost = new int[size];\n            for (int i = 0; i < size; i++) {\n                adj[i] = new ArrayList<>();\n            }\n        }\n\n        public void addEdge(Edge e) {\n            adj[e.from].add(e);\n            inDeg[e.to]++;\n        }\n\n        public long[] dijkstra(int from) {\n            long[] d = new long[size];\n            PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.comparing(e -> d[e]));\n            for (int i = 0; i < size; i++) {\n                d[i] = (i == from) ? 0 : (long) 1e18;\n                pq.add(i);\n            }\n            // System.out.println(Arrays.toString(pq.toArray()));\n            while (!pq.isEmpty()) {\n                int search = pq.poll();\n                // System.out.println(\"now: \" + search);\n                ArrayList<Edge> edges = adj[search];\n                for (Edge e : edges) {\n                    // System.out.println(e.toString());\n                    long cmp = d[search] + e.cost;\n                    if (d[e.to] > d[search] + e.cost) {\n                        // \u66f4\u65b0\u304c\u5165\u308b\n                        // \u51e6\u7406\u3092\u5165\u308c\u305f\u3044\u5834\u5408\u306f\u3053\u3053\u306b\u5165\u308c\u308b\n                        d[e.to] = d[search] + e.cost;\n                        pq.add(e.to);\n                    }\n                }\n                //  System.out.println(Arrays.toString(pq.toArray()));\n            }\n            return d;\n        }\n\n    }\n\n    static class Edge {\n        public int from;\n        public int to;\n        public long cost;\n\n        public Edge(int to) {\n            this.to = to;\n        }\n\n        public Edge(int to, long cost) {\n            this.to = to;\n            this.cost = cost;\n        }\n\n        public Edge(int from, int to, long cost) {\n            this.from = from;\n            this.to = to;\n            this.cost = cost;\n        }\n\n        public String toString() {\n            return \"Edge{\" +\n                    \"from=\" + from +\n                    \", to=\" + to +\n                    \", cost=\" + cost +\n                    '}';\n        }\n\n    }\n}\n\n\n", "code2": "class PriorityQueue\n  def initialize es = [], &block\n    block = proc { |a, b| a < b } unless block_given?\n    @fun = block\n    @tree = []\n    @n = 0\n\n    es.each do |e| enqueue e end\n  end\n\n  def enqueue e\n    @tree[@n] = e\n    i = @n\n    @n += 1\n    until i.zero?\n      j = (i-1)/2\n      if @fun.(@tree[i], @tree[j])\n        @tree[i], @tree[j] = @tree[j], @tree[i]\n        i = j\n      else\n        break\n      end\n    end\n    self\n  end\n\n  alias push enqueue\n  alias << enqueue\n  alias insert enqueue\n\n  def dequeue\n    return nil if @n.zero?\n    @n -= 1\n    @tree.first.tap do\n      @tree[0] = @tree.pop\n      i = 0\n      loop do\n        l = i*2+1\n        r = i*2+2\n        break if @tree[l].nil?\n        j =\n          if @tree[r].nil?\n            l\n          else\n            @fun.(@tree[r], @tree[l]) ? r : l\n          end\n        if @fun.(@tree[j], @tree[i])\n          @tree[i], @tree[j] = @tree[j], @tree[i]\n          i = j\n        else\n          break\n        end\n      end\n    end\n  end\n\n  alias pop dequeue\n  alias remove dequeue\n\n  def peek\n    @tree.first\n  end\n\n  alias first peek\n  alias top peek\n\n  def to_a\n    [].tap do |arr|\n      while e = dequeue\n        arr << e\n      end\n    end\n  end\n\n  def empty?\n    @n == 0\n  end\nend\n\nv, e, r = gets.split.map(&:to_i)\ng = Array.new(v) { [] }\ne.times do\n  s, t, d = gets.split.map(&:to_i)\n  g[s] << [t, d]\nend\n\narr = Array.new(v) { Float::INFINITY }\narr[r] = 0\n\npq = PriorityQueue.new([[r, 0]]) { |(_, a), (_, b)| a < b }\nwhile h = pq.pop\n  i, d1 = h\n  g[i].each do |j, d2|\n    next if arr[j] <= d1+d2\n    arr[j] =d1+d2\n    pq.push [j, d1+d2]\n  end\nend\n\nputs arr.map { |i| i == Float::INFINITY ? \"INF\" : i }\n", "label": 1, "name1": "s326905326.java", "name2": "s636190295.rb"}, {"id": 879, "code1": "import java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException{\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tString AtCoDeer = sc.next();\n\t\tString TopCoDeer = sc.next();\n\n\t\tif(AtCoDeer.equals(TopCoDeer)){\n\t\t\tSystem.out.println(\"H\");\n\t\t}else {\n\t\t\tSystem.out.println(\"D\");\n\t\t}\n\t}\n}\n", "code2": "k = gets.chomp.to_i\na, b = gets.chomp.split(\" \").map{|e|e.to_i}\n\ndef check(k,a,b)\n\tn = k\n\twhile n<=1000 do\n\t\tif a<=n && n<=b then return \"OK\" end\n\t\tn += k\n\tend\n\treturn \"NG\"\nend\n\nprint check(k,a,b)", "label": 0, "name1": "s574933896.java", "name2": "s182072052.rb"}, {"id": 376, "code1": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tstatic void solve() {\n\t\tlong i = ni(), o = ni(), t = ni(), j = ni(), l = ni(), s = ni(), z = ni();\n\t\tlong ans = 0;\n\t\tans += o;\n\t\t\n\t\t\n\t\tlong rem = i%2+j%2+l%2;\n\t\tif(i==0||j==0||l==0) {\n\t\t\tans += 2*(i/2 + j/2 + l/2);\n\t\t\tout.println(ans);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(rem<=1) {\n\t\t\tans += 2*(i/2 + j/2 + l/2);\n\t\t}\n\t\telse {\n\t\t\tans += 3;\n\t\t\ti--; j--;l--;\n\t\t\tans += 2*(i/2 + j/2 + l/2);\n\t\t}\n\t\tout.println(ans);\n\t\t\n\t}\n\n\t//constant\n\tstatic final long mod = (long) 1e9 + 7;\n\tstatic final int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };\n\tstatic final int[] dx8 = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\tstatic final int inf = Integer.MAX_VALUE / 2;\n\tstatic final long linf = Long.MAX_VALUE / 3;\n\tstatic final double dinf = Double.MAX_VALUE / 3;\n\tstatic final double eps = 1e-10;\n\tstatic final double pi = Math.PI;\n\tstatic StringBuilder sb = new StringBuilder();\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\t//libraries\n\tstatic void reverse(int ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tint t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(long ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tlong t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(double ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tdouble t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(char ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tchar t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic String getReverse(String s) {\n\t\tchar c[] = s.toCharArray();\n\t\treverse(c);\n\t\ts = String.valueOf(c);\n\t\treturn s;\n\t}\n\n\tstatic <T> void reverse(List<T> ls) {\n\t\tint sz = ls.size();\n\t\tfor (int i = 0; i < sz / 2; i++) {\n\t\t\tT t = ls.get(i);\n\t\t\tls.set(i, ls.get(sz - 1 - i));\n\t\t\tls.set(sz - 1 - i, t);\n\t\t}\n\t}\n\n\tstatic <T> void reverse(T[] ar) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tT t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void sbnl() {//StringBuilder\u306b\u6539\u884c\u6587\u5b57\u3092append\u3059\u308b\n\t\tsb.append(\"\\n\");\n\t}\n\n\tstatic int lowerBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int lowerBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int lowerBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int lowerBound(char[] a, char x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(char[] a, char x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(char[] a, char x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(char[] a, char x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic <T> int lowerBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) >= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) >= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) >= 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int upperBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) > 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) > 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) > 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int rupperBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) < 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) < 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) < 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int rlowerBound(List<T> ls, T x) {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) <= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) <= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) <= 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic int[] concat(int x, int arr[]) {\n\t\tint ret[] = new int[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 1, ret.length - 1);\n\t\tret[0] = x;\n\t\treturn ret;\n\t}\n\n\tstatic int[] concat(int arr[], int x) {\n\t\tint ret[] = new int[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 0, ret.length - 1);\n\t\tret[ret.length - 1] = x;\n\t\treturn ret;\n\t}\n\n\tstatic long[] concat(long x, long arr[]) {\n\t\tlong ret[] = new long[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 1, ret.length - 1);\n\t\tret[0] = x;\n\t\treturn ret;\n\t}\n\n\tstatic long[] concat(long arr[], long x) {\n\t\tlong ret[] = new long[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 0, ret.length - 1);\n\t\tret[ret.length - 1] = x;\n\t\treturn ret;\n\t}\n\n\tstatic int max(int x, int y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic int min(int x, int y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic int max(int x, int y, int z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic int min(int x, int y, int z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic long max(long x, long y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic long min(long x, long y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic long max(long x, long y, long z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic long min(long x, long y, long z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic double max(double x, double y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic double min(double x, double y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic double max(double x, double y, double z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic double min(double x, double y, double z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic void sort(int[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void sort(long[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void sort(double[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void sort(char[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void rsort(int[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tint tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void rsort(long[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tlong tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void rsort(double[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tdouble tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void rsort(char[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tchar tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void fill(int arr[], int x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(long arr[], long x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(boolean arr[], boolean x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(double arr[], double x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(int arr[][], int x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(long arr[][], long x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(double arr[][], double x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(boolean arr[][], boolean x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\t//MOD culc\n\tstatic long plus(long x, long y) {\n\t\tlong res = (x + y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long sub(long x, long y) {\n\t\tlong res = (x - y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long mul(long x, long y) {\n\t\tlong res = (x * y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long div(long x, long y) {\n\t\tlong res = x * pow(y, mod - 2) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long pow(long x, long y) {\n\t\tif (y < 0)\n\t\t\treturn 0;\n\t\tif (y == 0)\n\t\t\treturn 1;\n\t\tif (y % 2 == 1)\n\t\t\treturn (x * pow(x, y - 1)) % mod;\n\t\tlong root = pow(x, y / 2);\n\t\treturn root * root % mod;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\t//input\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static long[] nla(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n}\n", "code2": "I,O,_,J,L,_,_ = gets.split.map(&:to_i)\np O + I + J + L + case\n                  when [I,J,L].map{ |x| x % 2 }.uniq.size == 1; 0\n                  when [I,J,L].min > 0; -1\n                  when [I,J,L].count{ |x| x % 2 == 0 } == 2; -1\n                  else -2\n                  end", "label": 1, "name1": "s751122857.java", "name2": "s422289570.rb"}, {"id": 915, "code1": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception{\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tString A = br.readLine();\n\t\tString B = br.readLine();\n\t\tString C = br.readLine();\n\t\t\n\t\tint i=0,j=0,k=0;\n\t\tchar turn = 'a';\n\t\twhile(i<=A.length() && j<=B.length() && k<=C.length())\n\t\t{\n\t\t\tif(turn == 'a')\n\t\t\t{\n\t\t\t\tif(i == A.length())\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println('A');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tturn = A.charAt(i++);\n\t\t\t}\n\t\t\t\t\n\t\t\telse if(turn == 'b')\n\t\t\t{\n\t\t\t\tif(j == B.length())\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println('B');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tturn = B.charAt(j++);\n\t\t\t}\n\t\t\t\t\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(k == C.length())\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println('C');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tturn = C.charAt(k++);\n\t\t\t}\n\t\t}\n\t}\n}\n", "code2": "n = gets.chomp.to_i\ns = []\nssum = 0\nn.times do\n  x = gets.chomp.to_i\n  ssum += x\n  s << x\nend\n\ns.sort!\nif ssum % 10 == 0 then\n  while x = s.shift\n    if x % 10 != 0 then\n      puts ssum - x\n      exit\n    end\n  end\n  puts 0\nelse\n  puts ssum\nend\n", "label": 0, "name1": "s420347453.java", "name2": "s862645033.rb"}, {"id": 749, "code1": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\tboolean eof;\n\t\n\tlong go(long a, long b, long c) {\n\t\tif (a < 0 || b < 0 || c < 0) {\n\t\t\treturn Long.MIN_VALUE;\n\t\t}\n\t\t\n\t\treturn a + b + c - (a & 1) - (b & 1) - (c & 1);\n\t}\n\n\tvoid solve() throws IOException {\n\t\tlong i = nextLong();\n\t\tlong o = nextLong();\n\t\tlong t = nextLong();\n\t\tlong j = nextLong();\n\t\tlong l = nextLong();\n\t\tlong s = nextLong();\n\t\tlong z = nextLong();\n\t\t\n\t\tlong ans = o + Math.max(go(i, j, l), go(i - 1, j - 1, l - 1) + 3);\n\t\t\n\t\tout.println(ans);\n\t}\n\n\tMain() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e) {\n\t\t\t\teof = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\teof = true;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}", "code2": "class Problem\n  attr_accessor :a, :b, :n, :m, :h, :w, :x, :y, :s ,:t\n\n  def initialize\n    @a,@b,@x = gets.to_s.split.map{ |v| v.to_i }\n  end\n\n  def solve\n    count(b,x) - count(a-1,x)\n  end\n\n  def count(a,x)\n    a / x + 1\n  end\n\n  def show(ans)\n    puts ans\n  end\nend\n\nProblem.new.instance_eval do\n  show(solve)\nend\n", "label": 0, "name1": "s508741257.java", "name2": "s568523037.rb"}, {"id": 401, "code1": "//\u0083\\\u0081[\u0083g\u0082\u00b7\u0082\u00e9\u0083v\u0083\u008d\u0083O\u0083\u0089\u0083\u0080\u0081i\u0082\u008e\u0082\u00cc\u0092l\u0082\u00cd1,000,000\u0088\u00c8\u0089\u00ba\u0081j\nimport java.util.*;\npublic class Main {\n\n\tpublic void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tTreeSet<Integer> set = new TreeSet<Integer>();\n\t\tTreeMap<Integer,Integer> map = new TreeMap<Integer, Integer>();\n\n\t\tfor(int i=0; i < n; i++){\n\t\t\tint temp = sc.nextInt();\n\t\t\tif( set.contains(temp)){\n\t\t\t\tif(map.containsKey(temp)){\n\t\t\t\t\tmap.put(temp, map.get(temp) + 1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmap.put(temp, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tset.add(temp);\n\t\t\t}\n\t\t}\n\t\tfor(int num: set){\n\t\t\tif(map.containsKey(num)){\n\t\t\t\tfor(int i=0; i < map.get(num);i++){\n\t\t\t\t\tSystem.out.print(num + \" \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(num == set.last()){\n\t\t\t\tSystem.out.println(num);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.print(num + \" \");\n\t\t\t}\n\n\t\t}\n\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doIt();\n\n\t}\n\n}", "code2": "class Array\n  def merge_sort\n    tmp = self.dup\n    return tmp if tmp.length <= 1\n    a, b = self.half.map { |e| e.merge_sort }\n    merge(a, b)\n  end\n\n  def half\n    mid = length/2\n    return slice(0...mid), slice(mid..-1)\n  end\n\n  def merge(a, b)\n    res = []\n    until a.empty? && b.empty?\n      res <<\n          case\n            when a.empty? then b.shift\n            when b.empty? then a.shift\n            when a.first < b.first then a.shift\n            else b.shift\n          end\n    end\n    res\n  end\nend\n\nn = gets.to_i\nputs gets.chomp.split(' ').map(&:to_i).merge_sort.join(' ')", "label": 1, "name1": "s012590995.java", "name2": "s887500587.rb"}, {"id": 991, "code1": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tint[] a = na(n);\n\t\tint[] f = new int[13];\n\t\tf[0]++;\n\t\tfor(int v : a)f[v]++;\n\t\tif(f[0] >= 2 || f[12] >= 2){\n\t\t\tout.println(0);\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 1;i <= 11;i++){\n\t\t\tif(f[i] >= 3){\n\t\t\t\tout.println(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor(int i = 0;i < 1<<11;i++){\n\t\t\tboolean[] b = new boolean[25];\n\t\t\tb[0] = b[24] = true;\n\t\t\tif(f[12] > 0)b[12] = true;\n\t\t\tfor(int j = 0;j < 11;j++){\n\t\t\t\tif(f[j+1] == 2){\n\t\t\t\t\tb[j+1] = b[24-(j+1)] = true;\n\t\t\t\t}else if(f[j+1] == 1){\n\t\t\t\t\tif(i<<~j<0){\n\t\t\t\t\t\tb[24-(j+1)] = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tb[j+1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint min = 99;\n\t\t\tint pre = -99;\n\t\t\tfor(int j = 0;j <= 24;j++){\n\t\t\t\tif(b[j]){\n\t\t\t\t\tmin = Math.min(min, j-pre);\n\t\t\t\t\tpre = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = Math.max(ans, min);\n\t\t}\n\t\tout.println(ans);\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n", "code2": "### main\n\nwhile true\n  t = gets.strip.to_i\n  break if t == 0\n\n  n = gets.strip.to_i\n\n  sum = 0\n  n.times do\n    ts, tf = gets.strip.split(' ').map{|s| s.to_i}\n    sum += (tf - ts)\n  end\n\n  puts (sum >= t ? 'OK' : t - sum)\nend", "label": 0, "name1": "s709834289.java", "name2": "s837017781.rb"}, {"id": 224, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\n\npublic class Main {\n\n    static <T extends Comparable<? super T>> boolean nextPermutation(T[] sequence) {\n        int first = getFirst(sequence);\n        if (first == -1) return false;\n        int toSwap = sequence.length - 1;\n        while (sequence[first].compareTo(sequence[toSwap]) >= 0) --toSwap;\n        swap(sequence, first++, toSwap);\n        toSwap = sequence.length - 1;\n        while (first < toSwap) swap(sequence, first++, toSwap--);\n        return true;\n    }\n\n    static <T extends Comparable<? super T>> int getFirst(T[] sequence) {\n        for (int i = sequence.length - 2; i >= 0; --i)\n            if (sequence[i].compareTo(sequence[i + 1]) < 0) return i;\n        return -1;\n    }\n\n    static <T extends Comparable<? super T>> void swap(T[] sequence, int i, int j) {\n        T tmp = sequence[i];\n        sequence[i] = sequence[j];\n        sequence[j] = tmp;\n    }\n\n    public static void main(String[] args) {\n        FastScanner fs = new FastScanner();\n        int N = fs.nextInt();\n        Integer[] P = new Integer[N];\n        Integer[] Q = new Integer[N];\n        for (int i = 0; i < N; ++i) P[i] = fs.nextInt();\n        for (int i = 0; i < N; ++i) Q[i] = fs.nextInt();\n\n        Integer[] arr = new Integer[N];\n        for (int i = 0; i < N; ++i) arr[i] = i+1;\n\n        int cnt = 1, pNum = 0, qNum = 0;\n        do {\n            if (Arrays.toString(arr).equals(Arrays.toString(P))) pNum = cnt;\n            if (Arrays.toString(arr).equals(Arrays.toString(Q))) qNum = cnt;\n            ++cnt;\n        } while (nextPermutation(arr));\n\n        System.out.println(Math.abs(pNum - qNum));\n\n    }\n\n\n    static class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            }else{\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while(true){\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                }else if(b == -1 || !isPrintableChar(b)){\n                    return minus ? -n : n;\n                }else{\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        public int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        public double nextDouble() { return Double.parseDouble(next());}\n    }\n\n}", "code2": "$debug = false\nflag = ARGV.shift\nif flag == \"-d\"\n  $debug = true\nend\n\ndef dputs str\n  p str if $debug\nend\n\ndef max(n, m)\n  if n > m\n    return n\n  else\n    return m\n  end\nend\n\ndef min(n, m)\n  if n < m\n    return n\n  else\n    return m\n  end\nend\n\ndef gets_all_int\n  return gets.chomp.split.map{|v| v.to_i}\nend\n\n## start\nN = gets.to_i\nP = gets_all_int\nQ = gets_all_int\n\na = 0\nb = 0\nP.sort.permutation.to_a.each_with_index do |elm, i|\n  if elm == P\n    a = i\n    break\n  end\nend\n\nQ.sort.permutation.to_a.each_with_index do |elm, i|\n  if elm == Q\n    b = i\n    break\n  end\nend\n\nputs (a - b).abs", "label": 1, "name1": "s792830085.java", "name2": "s279076405.rb"}, {"id": 96, "code1": "import java.util.*;\n\npublic class Main {\n\tvoid solve() {\n\t\tScanner scan = new Scanner(System.in);\n\t\tlong n = scan.nextLong();\n\t\tlong k = scan.nextLong();\n\t\tif(n % k == 0) {\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\t\tn %= k;\n\t\tSystem.out.println(Math.min(n, k - n));\n\t\tscan.close();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\n}\n", "code2": "n,k=gets.split.map &:to_i\nn%=k\np [n,k-n].min", "label": 1, "name1": "s393030652.java", "name2": "s028993927.rb"}, {"id": 50, "code1": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic long LINF = 1L << 55;\n\tstatic int MOD = 1000000007;\n\tstatic int[] mh4 = { 0, -1, 1, 0 };\n\tstatic int[] mw4 = { -1, 0, 0, 1 };\n\tstatic int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\tstatic int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n\tstatic class TaskX {\n\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tint n = in.nextInt();\n\t\t\tint[] a = in.nextIntArray(n);\n\n\t\t\tint count = 0;\n\n\t\t\tfor (int l = 0, r = 0; l < n; l = r) {\n\t\t\t\twhile (r < n && a[l] == a[r]) {\n\t\t\t\t\tr++;\n\t\t\t\t}\n\t\t\t\tint len = r-l;\n\t\t\t\tcount += len/2;\n\t\t\t}\n\n\t\t\tout.println(count);\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\t}\n\n}\n", "code2": "a, b = $stdin.read.split(\"\\n\")\nb = b.split(\" \").map{|c| c.to_i}\na = a.to_i\nresult = 0\ni = 1\nloop do\n  break if i-1 >= a - 1\n  a1 = b[i-1]\n  a2 = b[i]\n  a3 = b[i+1]\n  if a1 == a2 || a3 == a2\n    if a1 == a2 && a1 == a2\n      b[i] = b[i] + 1\n      result += 1\n    elsif a1 == a2\n      b[i] = b[i+1] +  1\n      result += 1\n    elsif a2 == a3\n      b[i+1] = a2+b[i+2]\n      result += 1\n    end\n  end\n  i+=2\nend\nputs result", "label": 1, "name1": "s729269653.java", "name2": "s480254051.rb"}, {"id": 250, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tpublic void solve() {\n\t\tint N = nextInt();\n\t\tint[] a = new int[N];\n\t\tfor(int i = 0;i < N;i++){\n\t\t\ta[i] = nextInt() - 1;\n\t\t}\n\t\tboolean[] used = new boolean[N];\n\t\tint ans = 0;\n\t\tfor(int i = 0;i < N;i++){\n\t\t\tint x = a[i];\n\t\t\tint y = a[x];\n\t\t\tif(used[x])continue;\n\t\t\tif(used[y])continue;\n\t\t\tif(x == a[y] && y == a[x]){\n\t\t\t\tans++;\n\t\t\t\tused[x] = true;\n\t\t\t\tused[y] = true;\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}", "code2": "n = gets.to_i\na = gets.split.map(&:to_i)\n\np n.times.map{|i| (i+1 == a[a[i]-1])? 1:0}.inject(:+)/2\n", "label": 1, "name1": "s188425538.java", "name2": "s544447985.rb"}, {"id": 379, "code1": "// -*- coding: utf-8 -*-\n//import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream;\n    if (args.length > 0 && args[0].equals(\"devTesting\")) {\n      try {\n        inputStream = new FileInputStream(args[1]);\n      } catch(FileNotFoundException e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      inputStream = System.in;\n    }\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskC solver = new TaskC();\n    int testCase = 1;\n    solver.solve(1, in, out);\n    out.close();\n  }\n  \n  static class TaskC {\n    long h, w;\n    \n    void solve(int testNumber, InputReader in, PrintWriter out) {\n      h = in.nextInt();\n      w = in.nextInt();\n      char[][] superpost = new char[(int) h][];\n      for (int i = 0; i < h; ++i)\n        superpost[i] = in.next().toCharArray();\n      for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j)\n          if (i % 2 == 0 && j < w - 1 || j == 0 || superpost[i][j] == '#')\n            out.print('#');\n          else\n            out.print('.');\n        out.println();\n      }\n      out.println();\n      for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j)\n          if (i % 2 == 1 && j > 0 || j == w - 1 || superpost[i][j] == '#')\n            out.print('#');\n          else\n            out.print('.');\n          out.println();\n      }\n    }\n    \n  }\n      \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public boolean hasInput() {\n      try {\n        if (tokenizer != null && tokenizer.hasMoreTokens()) {\n          return true;\n        }\n        reader.mark(1);\n        int ch = reader.read();\n        if (ch != -1) {\n          reader.reset();\n          return true;\n        }\n        return false;\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n  }\n}\n", "code2": "#!/usr/bin/ruby\nh,w=gets.split.map(&:to_i)\nm=$<.map{|e|e.chomp[1..-2]}\n2.times{|i|h.times{|y|\n\tif i==0\n\t\tif y%2==0\n\t\t\tputs '#'*(w-1)+'.'\n\t\telse\n\t\t\tputs '#'+m[y]+'.'\n\t\tend\n\telse\n\t\tif y%2==0\n\t\t\tputs '.'+m[y]+'#'\n\t\telse\n\t\t\tputs '.'+'#'*(w-1)\n\t\tend\n\tend\n};puts}", "label": 1, "name1": "s133216279.java", "name2": "s030629079.rb"}, {"id": 648, "code1": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        Main main = new Main();\n        main.solve();\n    }\n\n    public void solve() {\n        Scanner scan = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n        int N = scan.nextInt();\n        List<Integer> candidate = new ArrayList<>();\n        for (int i = 1; i <= N; i++) {\n            candidate.add(i);\n        }\n        scan.nextLine();\n        String p = scan.nextLine();\n        String q = scan.nextLine();\n        List<List<Integer>> list = make(candidate);\n        List<String> strings = new ArrayList();\n        for (List<Integer> x : list) {\n            strings.add(x.stream().map(i -> i.toString()).collect(Collectors.joining(\" \")));\n        }\n        int len = strings.size();\n        int l = 0;\n        int r = 0;\n        for (int i = 0; i < len; i++) {\n            if (p.equals(strings.get(i))) {\n                l = i;\n            }\n            if (q.equals(strings.get(i))) {\n                r = i;\n            }\n        }\n        System.out.println(Math.abs(l - r));\n    }\n\n    public static List<List<Integer>> make(List<Integer> candidate) {\n        if (candidate.size() == 0) {\n            List<List<Integer>> empty = new ArrayList<>();\n            empty.add(new ArrayList<>());\n            return empty;\n        }\n\n        return candidate.stream().flatMap(i -> {\n            List<Integer> rest = new ArrayList<>(candidate);\n            rest.remove(i);\n            return make(rest).stream().map(list -> {\n                list.add(0, i);\n                return list;\n            });\n        }).collect(Collectors.toList());\n    }\n}\n", "code2": "def nosereru?(p, k, a)\n    sum = 0\n    cnt = 1\n    for i in 0..a.length-1\n        return false if a[i] > p\n        # printf(\"%d\u756a\u76ee\u306e\u7a4d\u307f\u8377\u3000\u91cd\u91cf%d\\n\", i, a[i])\n        sum += a[i]\n        # printf(\"\u7a4d\u307f\u8377\u5408\u8a08 %d\\n\", sum)\n        if sum > p then\n            # printf(\"\u7a4d\u8f09\u91cf\u30aa\u30fc\u30d0\u30fc (\u7a4d\u8f09\u91cf = %d)\\n\", p)\n            cnt += 1\n            # printf(\"\\n\u30c8\u30e9\u30c3\u30af%d\u53f0\u76ee\u958b\u59cb\\n\", cnt)\n            sum = a[i]\n            # printf(\"\u7a4d\u307f\u8377\u5408\u8a08 %d\\n\", sum)\n        end\n    end\n    if cnt <= k then\n        # printf(\"%d\u53f0\u4ee5\u4e0b\u3067\u7a4d\u8f09\u53ef\u80fd\\n\\n\", k)\n        return true\n    else\n        # printf(\"%d\u53f0\u4ee5\u4e0b\u3067\u306f\u7a4d\u8f09\u4e0d\u53ef\\n\\n\", k)\n        return false\n    end\nend\n\nn, k = gets.split.map(&:to_i)\na = []\nn.times{\n    a.push(gets.to_i)\n}\n\nleft = 0\nright = 100000*10000\n# printf(\"\u691c\u8a0e\u5bfe\u8c61 \u306f %s \u301c %s\\n\", left, right)\n\nuntil right == left\n    mid = (left + right) / 2\n    # printf(\"mid = %d\u3067\u691c\u8a0e\\n\", mid)\n    if nosereru?(mid, k, a) then\n        right = mid\n        # printf(\"\u691c\u8a0e\u5bfe\u8c61 \u306f %s \u301c %s\\n\", left, right)\n    else\n        left = mid + 1\n        # printf(\"\u691c\u8a0e\u5bfe\u8c61 \u306f %s \u301c %s\\n\", left, right)\n    end\nend\n\nputs right\n", "label": 0, "name1": "s162956680.java", "name2": "s891158890.rb"}, {"id": 977, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tlong a = sc.nextLong();\n\t\tlong b = sc.nextLong();\n\t\tlong[] h = new long[n];\n\t\tfor(int i = 0; i < n; i++) h[i] = sc.nextLong();\n\t\tlong l = 0, r = Integer.MAX_VALUE;\n\t\twhile(r - l != 1) {\n\t\t\tlong mid = (r + l) / 2;\n\t\t\tlong[] x = Arrays.copyOf(h, h.length);\n\t\t\tlong cnt = 0;\n\t\t\tfor(int i = 0; i < x.length; i++) {\n\t\t\t\tif(x[i] - b * mid <= 0) continue;\n\t\t\t\tcnt += ((x[i] - b * mid) + (a - b - 1)) / (a - b);\n\t\t\t}\n\t\t\tif(mid >= cnt) r = mid;\n\t\t\telse l = mid;\n\t\t}\n\t\tSystem.out.println(r);\n\t}\n}\n", "code2": "N = gets.to_i\nds = gets.split.map(&:to_i)\nhash = Hash.new(0)\nds.each{|d| hash[d] += 1}\nif hash[0] > 0 || hash.values.max >= 3\n    puts 0\n    exit\nend\n\ntz = [0, 24]\nrev = false\nhash.keys.sort.each do |i|\n    if hash[i] == 1\n        tz.push(rev ? 24-i : i)\n        rev = !rev\n    else\n        tz.push(i, 24-i)\n    end\nend\ntz.sort!\nputs (tz.length-1).times.map{|i| tz[i+1] - tz[i]}.min", "label": 0, "name1": "s073004253.java", "name2": "s521164035.rb"}, {"id": 317, "code1": "import java.util.*;\n\npublic class Main {\n  public static long MOD = (long)Math.pow(10, 6) + 3;\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    long[] kai = new long[(int)MOD];\n//    long[] inkai = new long[(int)MOD];\n//    long[] in = new long[(int)MOD];\n    kai[0] = 1;\n    kai[1] = 1;\n//    inkai[0] = 1;\n//    inkai[1] = 1;\n//    in[1] = 1;\n    for(long i = 2; i < MOD; i++) {\n      kai[(int)i] = (i * kai[(int)i - 1]) % MOD;\n//      inkai[(int)i] = func(kai[(int)i], MOD - 2);\n//      in[(int)i] = func(i, MOD - 2);\n    }\n    int q = sc.nextInt();\n    for(int i = 0; i < q; i++) {\n      long x = sc.nextLong();\n      long d = sc.nextLong();\n      long n = sc.nextLong();\n      long ans = 0;\n      if(d == 0) {\n        if(x == 0) {\n          ans = 0;\n        } else {\n          ans = func(x, n % (MOD - 1));\n        }\n      } else {\n        long inv = func(d, MOD - 2);\n        x = (x * inv) % MOD;\n        if(x == 0) {\n          ans = 0;\n        } else {\n          if((int)(x + n - 1) >= MOD) {\n            ans = 0;\n          } else {\n            long t = func(d, n % (MOD - 1));\n            long invkai = func(kai[(int)x - 1], MOD - 2);\n            ans = (((kai[(int)(x + n - 1)] * invkai) % MOD) * t) % MOD;\n          }\n        }\n      }\n      System.out.println(ans);\n    }\n  }\n  public static long func(long a, long x) {\n    if(x == 0) return 1;\n    if(x >= 1) {\n      if(x % 2 == 0) {\n        long t = func(a, x / 2);\n        return (t * t) % MOD;\n      } else {\n        long t = func(a, x - 1);\n        return (a * t) % MOD;\n      }\n    }\n    return 0;\n  } \n}", "code2": "o=->a,n{n<1?1:a**n[0]*o[a,n/2]**2%M}\nf=f=1,*(1..M=1000003).map{|i|f=f*i%M}\ngets\n$<.map{|s|x,d,n=s.split.map &:to_i\np d<1?o[x,n]:(u=f[n+t=x*o[d,M-2]%M-1])?u*o[f[t],M-2]*o[d,n]%M: 0}", "label": 1, "name1": "s406339057.java", "name2": "s369167080.rb"}, {"id": 41, "code1": "import java.util.Scanner;\npublic class Main { \n    public static void main(String[] args) {\n        try (Scanner sc = new Scanner(System.in)) { \n        while (true) { \n        int n = sc.nextInt(); \n            if (n == 0) { \n            break; \n            } \n            int[] scores = new int[n]; \n            for (int i = 0; i < scores.length; i++) { \n            scores[i] = sc.nextInt(); \n            } \n            double average = 0, variance = 0;\n            for(int i = 0; i < scores.length; i++){ \n                average += scores[i]; \n            } \n            average = average/n; \n            for(int i = 0; i < scores.length; i++){ \n                variance += (scores[i]-average)*(scores[i]-average); \n            }\n            variance = variance/n;\n            System.out.println(Math.sqrt(variance)); \n            } \n        } \n    }\n}\n", "code2": "#!/usr/bin/ruby\n# -*- coding: utf-8 -*-\n=begin\nITP1_10-C\n\nMath Functions - Standard Deviation\nTime Limit : 1 sec, Memory Limit : 65536 KB\n?\u00a8??????????\n\nn ????????????????????????????????\u00a7????????\u00b0???????????\u00b0???????\u00a8?????????\u00a3??????????????????????????????s1, s2 ... sn??\u00a8????????\u00a8??????????\u00a8??????????????\u00b1???????????????\u00b0????????????????????????\n\n??????????????????????????\u00a8????????\u00b0????????\u00a3?\u00b12?????\\???????????\u00a7???????????????\n\n?\u00b12 = (???ni=1(si - m)2)/n\n\n?????\u00a3?????\u00a3????????????????\u00a8???????????\u00b1??\u00a8?????????\nInput\n\n?????\u00b0??????????????????????????\\?????\u00a8??????????????????????????????????????????????????\\????????\u00a2?????\u00a7??????????????????\n\n???????????\u00b0 n\ns1 s2 ... sn\n\nn ??? 0 ?????\u00a8?????\\?????????????????\u00a8?????????\nOutput\n\n?????????????????????????????????????\u00a8?????????????????????????????????????????????????0.0001??\\????????????????????\u00a3???????????????\nConstraints\n\n    ??\\?????\u00a7??????????????? n ???1000????\u00b6????????????\u00a8????????????\n    0 ??? si ??? 100\n\nSample Input\n\n5\n70 80 100 90 20\n3\n80 80 80\n0\n\nSample Output\n\n27.85677655\n0.00000000\n\n=end\n\nclass Main\n  def initialize\n    fh = STDIN\n    while fh.gets do\n      n = $_.chomp.to_i\n      break if n==0 \n      fl = fh.gets.chomp.split.map{|x| x.to_f}\n      puts stddev(fl)\n    end\n  end\n\n  def stddev(f)\n    n = f.length\n    sum = f.inject(0.0){|acc,x| acc + x}\n    ave = sum / n\n    sq_sum = f.inject(0.0){|acc,x| acc + (x - ave)**2}\n    Math.sqrt(sq_sum / n) \n  end\nend\n\nif $0==__FILE__ then\n  Main.new()\nend", "label": 1, "name1": "s272580744.java", "name2": "s375636149.rb"}, {"id": 942, "code1": "import java.lang.reflect.Array;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static boolean check(int a,int b,int mid){\n        if(a <= mid && b <= mid || a > mid && b > mid)return true;\n        return false;\n    }\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        int array[] = new int[2 * n + 1];\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        for (int i = 1; i < 2 * n; i++)\n            array[i] = Integer.parseInt(st.nextToken());\n        array[0] = array[2 * n] = -1;\n        int infinity = (int) 1E9 + 5;\n        int low = 1;\n        int high = 2 * n;\n        TreeSet<Integer> zero;\n        TreeSet<Integer> ones;\n        while (low < high) {\n            int mid = (low + high) / 2;\n            int temp = -1;\n            zero = new TreeSet<>();\n            ones = new TreeSet<>();\n            ones.add(infinity);\n            ones.add(-infinity);\n            zero.add(infinity);\n            zero.add(-infinity);\n            for (int i = 1; i < 2 * n; i++) {\n                if (check(array[i],array[i - 1],mid) && i != 1) {\n                    //System.out.println(array[i] + \" \" + mid + \" \" + i);\n                    if (array[i] > mid) ones.add(i);\n                    else zero.add(i);\n                }\n                if (check(array[i],array[i + 1],mid) && i != 2*n - 1) {\n                    //System.out.println(array[i] + \" \" + mid + \" \" + i);\n                    if (array[i] > mid) ones.add(i);\n                    else zero.add(i);\n                }\n            }\n                int beforezero = zero.floor(n);\n                int afterzero = zero.ceiling(n);\n                int beforeone = ones.floor(n);\n                int afterone = ones.ceiling(n);\n                int beforemax = Math.max(beforeone, beforezero);\n                int aftermin = Math.min(afterone, afterzero);\n                int min = Math.min(aftermin - n, n - beforemax);\n                //System.out.println(\"1 \" + aftermin + \" \" + beforemax + \" \" + min + \" \" + beforezero + \" \" + afterzero + \" \" + beforeone + \" \" + afterone);\n                if (min == aftermin - n) {\n                    if (afterone < afterzero) temp = 1;\n                    else temp = 0;\n                }\n                if (min == n - beforemax) {\n                    if (beforeone < beforezero) temp = 0;\n                    else temp = 1;\n            }\n            if(min > n - 2){\n                if((n & 1) == 0)temp = (array[n] > mid) ? 0 : 1;\n                else temp = (array[n] > mid) ? 1 : 0;\n            }\n            //System.out.println(mid + \" \" + low + \" \" + high + \" \" + zero + \" \" + ones + \" \" + temp);\n            if (temp == 1) low = mid + 1;\n            else high = mid;\n        }\n        System.out.println(low);\n    }\n}", "code2": "puts gets.count('2')", "label": 0, "name1": "s535697054.java", "name2": "s996141713.rb"}, {"id": 919, "code1": "import java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\t// \u5165\u529b\n\t\tfinal String[] s = new String[3];\n\t\ttry(Scanner scan = new Scanner(System.in)) {\n\t\t\ts[0] = scan.next();\n\t\t\ts[1] = scan.next();\n\t\t\ts[2] = scan.next();\n\t\t}\n\t\t\n\t\tint[] index = {0, -1, -1};\n\t\t\n\n\t\tint next = 0;\n\t\twhile (s[next].length() > index[next]) {\n\t\t\tnext = (int) (s[next].charAt(index[next]) - 'a');\n\t\t\tindex[next]++;\n\t\t}\n\t\t\n\t\tchar result = (char) (next + 'A');\n\t\t\n\t\t// \u51fa\u529b\n\t\ttry (PrintWriter out = new PrintWriter(System.out)) {\n\t\t\tout.println(result);\n\t\t}\n\n\t}\n\n}\n", "code2": "N=gets.to_i;M=10**9+7;I=[1,1];*F=I;*R=I;2.upto(N){|i|I<<z=(M-M/i)*I[M%i]%M;F<<i*F[-1]%M;R<<z*R[-1]%M};r=F[N];(-~N/2...N).each{|i|r=(r-F[i-1]*R[2*i-N]*F[i])%M};p r", "label": 0, "name1": "s981758342.java", "name2": "s917510432.rb"}, {"id": 907, "code1": "import java.util.*;\n\nclass Main{\n    public static void main(String[] args){\n        \n        Scanner sc = new Scanner(System.in);\n\n        int x = sc.nextInt();\n        if(x==3 || x==2){\n            System.out.println(x);\n            return;\n        }\n        if(x==1){\n            System.out.println(2);\n            return;\n        }\n\n        for(int i=0; i<=100003; i++){\n            for(int j=2; j*j<=x+i; j++){\n                if((x+i)%j==0){\n                    break;\n                }\n                if((j+1)*(j+1)>x+i){\n                    System.out.println(x + i);\n                    return;\n                }\n            }\n        }\n    }\n}", "code2": "a = gets.chomp.split('')\nb = gets.chomp.split('')\nc = gets.chomp.split('')\n\ndef fin(x)\n  puts x\n  exit\nend\n\nt = 'a'\nloop do\n  case t\n  when 'a'\n    fin('A') if a.empty?\n    t = a.shift\n  when 'b'\n    fin('B') if b.empty?\n    t = b.shift\n  when 'c'\n    fin('C') if c.empty?\n    t = c.shift\n  end\nend", "label": 0, "name1": "s443254620.java", "name2": "s327342106.rb"}, {"id": 554, "code1": "import java.util.Scanner;\n\nclass Main\n{\n\tpublic static void main(String args[])\n\t{\n\t\tScanner sc = new Scanner(System.in).useDelimiter(\"[,\\n]\");\n\t\t\n\t\tint a = 0;\n\t\tint b = 0;\n\t\tint o = 0;\n\t\tint ab = 0;\n\t\t\n\t\twhile (sc.hasNext())\n\t\t{\n\t\t\tsc.nextInt();\n\t\t\tString str = sc.next();\n\t\t\tif (str.equals(\"A\"))\n\t\t\t{\n\t\t\t\ta++;\n\t\t\t}\n\t\t\telse if (str.equals(\"B\"))\n\t\t\t{\n\t\t\t\tb++;\n\t\t\t}\n\t\t\telse if (str.equals(\"O\"))\n\t\t\t{\n\t\t\t\to++;\n\t\t\t}\n\t\t\telse if (str.equals(\"AB\"))\n\t\t\t{\n\t\t\t\tab++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(a);\n\t\tSystem.out.println(b);\n\t\tSystem.out.println(ab);\n\t\tSystem.out.println(o);\n\t}\n}", "code2": "n,k=gets.split.map &:to_i\nr=n%k\nputs [r,k-r].min", "label": 0, "name1": "s541319729.java", "name2": "s492428229.rb"}, {"id": 178, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[][] field;\n\tstatic String[][] dp;\n\tstatic int h,w;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = cin.nextInt();\n\t\t\th = cin.nextInt();\n\t\t\tif(w+h==0)break;\n\t\t\tfield=new int[h][w];\n\t\t\tdp=new String[h][w];\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tString s = cin.next();\n\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\tdp[i][j]=\"\";\n\t\t\t\t\tif(Character.isDigit(s.charAt(j))){\n\t\t\t\t\t\tfield[i][j]=s.charAt(j)-'0';\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tfield[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i<w;i++){\n\t\t\t\tif(i==0){\n\t\t\t\t\tif(field[0][i]<=0){\n\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdp[0][i]=\"\"+field[0][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(field[0][i]==-1){\n\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(!dp[0][i-1].equals(\"0\")&&!dp[0][i-1].equals(\"\")){\n\t\t\t\t\t\t\tdp[0][i]=dp[0][i-1]+field[0][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[0][i]=\"\"+field[0][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tif(i==0){\n\t\t\t\t\tif(field[i][0]<=0){\n\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdp[i][0]=\"\"+field[i][0];\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(field[i][0]==-1){\n\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(!dp[i-1][0].equals(\"0\")&&!dp[i-1][0].equals(\"\")){\n\t\t\t\t\t\t\tdp[i][0]=dp[i-1][0]+field[i][0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i][0]=\"\"+field[i][0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tString ans=\"0\";\n\t\t\tfor(int i = 1;i<h;i++){\n\t\t\t\tfor(int j = 1;j<w;j++){\n\t\t\t\t\tif(field[i][j]==-1)continue;\n\t\t\t\t\tString s1=dp[i-1][j]+field[i][j];\n\t\t\t\t\tString s2=dp[i][j-1]+field[i][j];\n\t\t\t\t\tString s3=field[i][j]+\"\";\n\t\t\t\t\tif(big(s1,s2)>=0){\n\t\t\t\t\t\tif(big(s1,s3)>=0){\n\t\t\t\t\t\t\tdp[i][j]=s1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i][j]=s3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(big(s2,s3)>=0){\n\t\t\t\t\t\t\tdp[i][j]=s2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i][j]=s3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\twhile(dp[i][j].charAt(0)=='0'&&dp[i][j].length()>1){\n\t\t\t\t\t\tdp[i][j]=dp[i][j].substring(1,dp[i][j].length());\n\t\t\t\t\t}\n\t\t\t\t\tif(big(dp[i][j],ans)>0){\n\t\t\t\t\t\tans=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\tif(big(dp[i][j],ans)>0){\n\t\t\t\t\t\tans=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//output();\n\t\t\tSystem.out.println(ans);\n\t\t}\n\n\t}\n\tstatic int big(String s1,String s2){\n\t\tif(s1.length()==s2.length()){\n\t\t\treturn s1.compareTo(s2);\n\t\t}\n\t\treturn s1.length()-s2.length();\n\t}\n\tstatic void output(){\n\t\tfor(int i = 0;i<h;i++){\n\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\tSystem.out.print(dp[i][j]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n}", "code2": "loop {\n    w, h = gets.split.map &:to_i\n    break if w == 0\n    max = (1..h).map{ gets.split(\"\").map{|s| s =~ /\\d/ ? s.to_i : -1} }\n    \n    opt = 0 \n    (0..h-1).each{|i|\n        (0..w-1).each{|j|\n            next if max[i][j] < 0 \n            m = 0 \n            m = max[i-1][j] if i > 0 && max[i-1][j] > m \n            m = max[i][j-1] if j > 0 && max[i][j-1] > m \n            max[i][j] += 10 * m \n            opt = max[i][j] if max[i][j] > opt \n        }\n    }   \n    p opt \n}", "label": 1, "name1": "s061375468.java", "name2": "s661213064.rb"}, {"id": 784, "code1": "import java.util.*;\n\npublic class Main {\n\tpublic static HashMap<String,HashSet<String>> map;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tmap = new HashMap<String, HashSet<String>>();\n\t\t\tString first = null;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tString[] s = sc.next().split(\":\");\n\t\t\t\tif(i == 0) first = s[0];\n\t\t\t\ts[1] = s[1].replaceAll(\"\\\\.\", \"\");\n\t\t\t\tString[] ss = s[1].split(\",\");\n\t\t\t\tmap.put(s[0], new HashSet<String>());\n\t\t\t\tfor(String tmp : ss){\n\t\t\t\t\tmap.get(s[0]).add(tmp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(String si : map.keySet()){\n\t\t\t\tfor(String sj : map.keySet()){\n\t\t\t\t\tif(map.get(si).contains(sj)){\n\t\t\t\t\t\tmap.get(si).remove(sj);\n\t\t\t\t\t\tmap.get(si).addAll(map.get(sj));\n\t\t\t\t\t}\n\t\t\t\t\tif(map.get(sj).contains(si)){\n\t\t\t\t\t\tmap.get(sj).remove(si);\n\t\t\t\t\t\tmap.get(sj).addAll(map.get(si));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(map.get(first).size());\n\t\t}\n\t}\n/*\n\tpublic static HashSet<String> solve(String group){\n\t\tfor(String s : map.get(group)){\n\n\t\t}\n\n\t}\n\t*/\n}", "code2": "N, K, L = gets.split.map(&:to_i)\n\nroad = [*0..N]\nroad_r = Array.new(N + 1) { 1 }\n\nrail = [*0..N]\nrail_r = Array.new(N + 1) { 1 }\n\ndef root uf, i\n  uf[i] == i ? i : uf[i] = root(uf, uf[i])\nend\n\ndef set_union_find n, uf, rank\n  n.times do\n    x, y = gets.split.map(&:to_i)\n    x = root(uf, x)\n    y = root(uf, y)\n\n    next if x == y\n\n    if rank[x] > rank[y]\n      uf[y] = x\n    else\n      uf[x] = y\n      rank[y] += 1 if rank[x] == rank[y]\n    end\n  end\nend\n\nset_union_find K, road, road_r\nset_union_find L, rail, rail_r\n\nh = Hash.new {|h, k| h[k] = [] }\n(1..N).each do |i|\n  h[[root(road, i), root(rail, i)]] << i\nend\n\nresult = Array.new(N + 1) { 0 }\nh.values.each do |arr|\n  arr.each do |j|\n    result[j] = arr.size\n  end\nend\n\nputs (1..N).map {|i| result[i] }.join(' ')", "label": 0, "name1": "s038642140.java", "name2": "s244848536.rb"}, {"id": 338, "code1": "import java.util.*;\nclass Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String S[] = sc.next().split(\"\");\n    \n    int n = (int)Math.pow(2, S.length - 1);\n    \n    long total = 0;\n    for (int i = 0; i < n; i++) {\n      String s = S[0];\n      \n      for (int j = 0; j < S.length - 1; j++) {\n        if ((1&i>>j) == 1) {\n          total += Long.parseLong(s);\n          s = S[j + 1];\n        } else {\n          s += S[j + 1];\n        }\n      }\n      total += Long.parseLong(s);\n    }\n    System.out.println(total);\n  }\n}", "code2": "def calc(s,num)\n  if num == 0\n    arr = s.split('+')\n    sum = 0\n    arr.each do |a|\n      sum += a.to_i\n    end\n    \n    return sum\n    \n  end\n  \n  return calc(s.clone.insert(num,'+'),num-1) + calc(s,num-1)\n  \nend\n\ns = gets.chomp\n\nnum = s.size()\n\nputs calc(s,num-1)", "label": 1, "name1": "s109985040.java", "name2": "s068686514.rb"}, {"id": 625, "code1": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\n\tprivate static Scanner sc;\n\tprivate static Printer pr;\n\n\tprivate static void solve() {\n\t\tint a = sc.nextInt();\n\t\tint b = sc.nextInt();\n\n\t\tif (b < a) {\n\t\t\ta--;\n\t\t}\n\n\t\tpr.println(a);\n\t}\n\n\t// ---------------------------------------------------\n\tpublic static void main(String[] args) {\n\t\tsc = new Scanner(INPUT == null ? System.in : new ByteArrayInputStream(INPUT.getBytes()));\n\t\tpr = new Printer(System.out);\n\n\t\tsolve();\n\n//\t\tpr.close();\n\t\tpr.flush();\n//\t\tsc.close();\n\t}\n\n\tstatic String INPUT = null;\n\n\tprivate static class Printer extends PrintWriter {\n\t\tPrinter(OutputStream out) {\n\t\t\tsuper(out);\n\t\t}\n\t}\n}\n", "code2": "M=10**9+7\ngets\nhw=0;t=gets.split.map{|s|[hw<hw=h=s.to_i,h]}\nhw=0;a=gets.split.reverse.map{|s|[hw<hw=h=s.to_i,h]}.reverse\np t.zip(a).reduce(1){|p,((f1,h1),(f2,h2))|\n  break 0 if f1&&f2&&h1!=h2 || f1&&!f2&&h1>h2 || !f1&&f2&&h1<h2\n  !f1&&!f2 ? p*[h1,h2].min%M : p\n}\n", "label": 0, "name1": "s998480605.java", "name2": "s443550692.rb"}, {"id": 7, "code1": "import java.util.*;\n\nclass Main{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    String N = sc.next();\n    int sum = 0;\n    for(int i = 0;i<N.length();i++){\n      sum+=Integer.parseInt(N.substring(i,i+1));\n      sum=sum%9;\n    }\n    if(sum == 0){\n      System.out.println(\"Yes\");\n    }else{\n      System.out.println(\"No\");\n    }\n  }\n}", "code2": "puts gets.chomp.chars.map(&:to_i).sum % 9 == 0 ? 'Yes' : 'No'\n", "label": 1, "name1": "s788833633.java", "name2": "s010063752.rb"}, {"id": 325, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[] total = new int[3];\n\n\t\ttotal[0] = sc.nextInt();\n\t\ttotal[1] = sc.nextInt();\n\t\ttotal[2] = sc.nextInt();\n\n\t\tsc.close();\n\n\t\tArrays.sort(total);\n\n\t\tSystem.out.println(total[0] + total[1]);\n\t}\n}", "code2": "# coding: utf-8\nlines = $stdin.read\narray = lines.split(\"\\n\")\n\na = array[0].split(\" \")[0].to_i\nb = array[0].split(\" \")[1].to_i\nc = array[0].split(\" \")[2].to_i\n\nab = a+b\nbc = b+c\nca = c+a\n\narr = [ab, bc, ca].sort\n\nputs arr[0]\n", "label": 1, "name1": "s443302375.java", "name2": "s342762132.rb"}, {"id": 763, "code1": "\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scn = new Scanner(System.in);\n\n        long a = scn.nextLong(), b = scn.nextLong(), x = scn.nextLong();\n        long ans = 0;\n\n        ans = (b / x) - (a / x);\n\n        if(a % x == 0){\n            ans++;\n        }\n\n        System.out.println(ans);\n\n    }\n\n}", "code2": "n = gets.chomp.to_i\nt = gets.chomp.split(' ').map {|v| v.to_i}\nt.unshift(0)\nt.push(0)\n\not = Array.new(t.length, 0)\n\nall = 0\nfor i in 1...t.length do\n  v = t[i] - t[i - 1]\n  ot[i] = v\n  all += v.abs\nend\n\nfor i in 1...t.length - 1 do\n  f = all - ot[i].abs - ot[i + 1].abs\n  v = t[i + 1] - t[i - 1]\n  f += v.abs\n\n  puts f\nend\n\n\n", "label": 0, "name1": "s378055358.java", "name2": "s176193708.rb"}, {"id": 651, "code1": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint cnt(int s,int g,int cnt,int xy[][],int n){\n\t\tint result = 0;\n\t\tint c[] = new int [n+1];\n\t\tint d[] = new int [n+1];\n\t\tc[s] = 1;\n\t\tif(s == g && cnt > 0)result = 1;\n\t\tfor(int i = 1;i < cnt;i++){\n\t\t\tfor(int j = 1;j < n+1;j++){\n\t\t\t\tfor(int k = 1;k < n+1;k++){\n\t\t\t\t\tif(xy[j][k] == 1 && c[j] == i){\n\t\t\t\t\t\td[k] = i + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 1;j < n+1;j++){\n\t\t\t\tc[j] = d[j];\n\t\t\t}\n\t\t\tif(c[g] > 0){\n\t\t\t\tresult = c[g];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(i == 101){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tvoid doIt() { \n\t\tint n = sc.nextInt();\n\t\tint xy[][] = new int [n+1][n+1];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint r1 = sc.nextInt();\n\t\t\tint k1 = sc.nextInt();\n\t\t\tfor(int j = 0;j < k1;j++){\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\txy[r1][t] = 1;\n\t\t\t}\n    \t }\n\t\tint p = sc.nextInt();\n\t\tfor(int i = 0;i < p;i++){\n\t\t\tint s = sc.nextInt();\n\t\t\tint d = sc.nextInt();\n\t\t\tint TTL = sc.nextInt();\n\t\t\tint ans = cnt(s,d,TTL,xy,n);\n\t\t\tif(ans == 0){\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t//\u4e2d\u8eab\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\tSystem.out.print(xy[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t*/\n     }\n    public static void main(String[] args) {\n    \t// TODO Auto-generated method stub\n    \tnew Main().doIt();\n    }\n}", "code2": "def nosereru?(p, k, a)\n    sum = 0\n    cnt = 1\n    for i in 0..a.length-1\n        return false if a[i] > p\n        # printf(\"%d\u756a\u76ee\u306e\u7a4d\u307f\u8377\u3000\u91cd\u91cf%d\\n\", i, a[i])\n        sum += a[i]\n        # printf(\"\u7a4d\u307f\u8377\u5408\u8a08 %d\\n\", sum)\n        if sum > p then\n            # printf(\"\u7a4d\u8f09\u91cf\u30aa\u30fc\u30d0\u30fc (\u7a4d\u8f09\u91cf = %d)\\n\", p)\n            cnt += 1\n            # printf(\"\\n\u30c8\u30e9\u30c3\u30af%d\u53f0\u76ee\u958b\u59cb\\n\", cnt)\n            sum = a[i]\n            # printf(\"\u7a4d\u307f\u8377\u5408\u8a08 %d\\n\", sum)\n        end\n    end\n    if cnt <= k then\n        # printf(\"%d\u53f0\u4ee5\u4e0b\u3067\u7a4d\u8f09\u53ef\u80fd\\n\\n\", k)\n        return true\n    else\n        # printf(\"%d\u53f0\u4ee5\u4e0b\u3067\u306f\u7a4d\u8f09\u4e0d\u53ef\\n\\n\", k)\n        return false\n    end\nend\n\nn, k = gets.split.map(&:to_i)\na = []\nn.times{\n    a.push(gets.to_i)\n}\n\nleft = 0\nright = 100000*10000\n# printf(\"\u691c\u8a0e\u5bfe\u8c61 \u306f %s \u301c %s\\n\", left, right)\n\nuntil right == left\n    mid = (left + right) / 2\n    # printf(\"mid = %d\u3067\u691c\u8a0e\\n\", mid)\n    if nosereru?(mid, k, a) then\n        right = mid\n        # printf(\"\u691c\u8a0e\u5bfe\u8c61 \u306f %s \u301c %s\\n\", left, right)\n    else\n        left = mid + 1\n        # printf(\"\u691c\u8a0e\u5bfe\u8c61 \u306f %s \u301c %s\\n\", left, right)\n    end\nend\n\nputs right\n", "label": 0, "name1": "s130494609.java", "name2": "s891158890.rb"}, {"id": 885, "code1": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        try (Scanner s = new Scanner(System.in)) {\n            int k = s.nextInt();\n            int a = s.nextInt();\n            int b = s.nextInt();\n            int mod = a % k;\n            int d = b - a;\n            System.out.println((mod == 0 || (k - mod) <= d) ? \"OK\" : \"NG\");\n        }\n    }\n}\n", "code2": "1000.times do\n  puts \"Hello World\"\nend", "label": 0, "name1": "s970456058.java", "name2": "s077912847.rb"}, {"id": 436, "code1": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n\t\t\tint K = io.nextInt();\n\t\t\tint L = io.nextInt();\n\n\t\t\tUnionFind uf1 = new UnionFind(n);\n\t\t\tUnionFind uf2 = new UnionFind(n);\n\t\t\tUnionFind uf3 = new UnionFind(n);\n\t\t\t\n\t\t\tfor (int i = 0; i < K; i++) {\n\t\t\t\tint a = io.nextInt() - 1;\n\t\t\t\tint b = io.nextInt() - 1;\n\t\t\t\tuf1.union(a, b);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < L; i++) {\n\t\t\t\tint a = io.nextInt() - 1;\n\t\t\t\tint b = io.nextInt() - 1;\n\t\t\t\tuf2.union(a, b);\n\t\t\t}\n\n\t\t\tTreeSet<Integer>[] s1 = new TreeSet[n];\n\t\t\tTreeSet<Integer>[] s2 = new TreeSet[n];\n\t\t\tfor (int i = 0; i < n; i++) if (uf1.root(i) == i) {\n\t\t\t\tTreeSet<Integer> s = new TreeSet<>();\n\t\t\t\tfor (int j = i; j != -1; j = uf1.next[j]) { s.add(j); }\n\t\t\t\ts1[i] = s;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) if (uf2.root(i) == i) {\n\t\t\t\tTreeSet<Integer> s = new TreeSet<>();\n\t\t\t\tfor (int j = i; j != -1; j = uf2.next[j]) { s.add(j); }\n\t\t\t\ts2[i] = s;\n\t\t\t}\n\t\t\t\n\t\t\tint[] ans = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint r1 = uf1.root(i);\n\t\t\t\tint r2 = uf2.root(i);\n\n\t\t\t\tif (!s1[r1].contains(i)) continue;\n\n\t\t\t\tTreeSet<Integer> a = s1[r1].size() < s2[r2].size() ? s1[r1] : s2[r2];\n\t\t\t\tTreeSet<Integer> b = s1[r1].size() < s2[r2].size() ? s2[r2] : s1[r1];\n\t\t\t\tList<Integer> same = new ArrayList<>();\n\t\t\t\tfor (int t : a) {\n\t\t\t\t\tif (b.contains(t)) same.add(t);\n\t\t\t\t}\n\t\t\t\tfor (int t : same) {\n\t\t\t\t\ts1[r1].remove(t);\n\t\t\t\t\ts2[r2].remove(t);\n\t\t\t\t\tans[t] = same.size();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tprintArrayLn(ans);\n\t\t}\n\t}\n\t\n\tstatic\n\tclass UnionFind {\n\t\tprivate int[] data;\n\t\tprivate int[] next;\n\t\tprivate int[] last;\n\t\t\n\t\tpublic UnionFind(int size) {\n\t\t\tdata = new int[size];\n\t\t\tnext = new int[size];\n\t\t\tlast = new int[size];\n\t\t\tclear();\n\t\t}\n\t\t\n\t\tpublic void clear() {\n\t\t\tArrays.fill(data, -1);\n\t\t\tArrays.fill(next, -1);\n\t\t\tfor(int i = 0; i < last.length; i++) {\n\t\t\t\tlast[i] = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int root(int x) { return data[x] < 0 ? x : (data[x] = root(data[x])); }\n\t\t\n\t\tpublic void union(int x, int y) {\n\t\t\tif((x = root(x)) != (y = root(y))) {\n\t\t\t\tif(data[y] < data[x]) { final int t = x; x = y; y = t; }\n\t\t\t\tdata[x] += data[y];\n\t\t\t\tdata[y] = x;\n\t\t\t\tnext[last[x]] = y;\n\t\t\t\tlast[x] = last[y];\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic boolean same(int x, int y) { return root(x) == root(y); }\n\t\tpublic int size(int x) { return -data[root(x)]; }\n\t}\n\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n", "code2": "class Node\n  attr_accessor :parent, :rank\n  def initialize(n)\n    @parent = n\n    @rank = 0\n  end\nend\n\nclass UnionFindTree\n  def initialize(n)\n    @nodes = (0..n).map { |i| Node.new(i) }\n  end\n\n  def unite(a, b)\n    pa = find(a)\n    pb = find(b)\n    return if pa == pb\n\n    if @nodes[pa].rank < @nodes[pb].rank\n      @nodes[pb].parent = pa\n    else\n      @nodes[pa].parent = pb\n      @nodes[pa].rank += 1 if @nodes[pa].rank == @nodes[pb].rank\n    end\n  end\n\n  def find(x)\n    return x if @nodes[x].parent == x\n    @nodes[x].parent = find(@nodes[x].parent)\n  end\nend\n\nn,k,l = gets.split(\" \").map(&:to_i)\n\nroad = UnionFindTree.new(n)\n1.upto(k) do\n  x,y = gets.split(\" \").map(&:to_i)\n  road.unite(x,y)\nend\n\nrail = UnionFindTree.new(n)\n1.upto(l) do\n  x,y = gets.split(\" \").map(&:to_i)\n  rail.unite(x,y)\nend\n\npair = Array.new\nhash = Hash.new(0)\n1.upto(n) do |p|\n x = road.find(p)\n y = rail.find(p)\n key = [x,y]\n pair.push(key)\n \n hash[key] = hash[key] + 1\n  \nend\n\npair.each do |key|\n print hash[key], \" \"\nend\nprint \"\\n\"", "label": 1, "name1": "s632399466.java", "name2": "s211925773.rb"}, {"id": 481, "code1": "\n\nimport java.util.*;\nimport java.io.*;\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t\n\tScanner sc=new Scanner(System.in);\n\t     int n=sc.nextInt();\n\t     int m=sc.nextInt();\n\t     ArrayList<ArrayList<Integer>> a=new ArrayList<>();\nfor(int i=0;i<n;i++) {\n\ta.add(new ArrayList<Integer>());\n}\nfor(int j=0;j<m;j++) {\n\tint x=sc.nextInt()-1;\n\tint y=sc.nextInt()-1;\n\ta.get(x).add(y);\n\ta.get(y).add(x);\n}\nboolean vis[]=new boolean[n];\nans=0;\n\tSystem.out.println(dfs(a,0,vis,1,n));\n\t}\nstatic int ans=0;\t\n\tstatic int dfs(ArrayList<ArrayList<Integer>> a,int src,boolean vis[],int count,int n) {\n\t\tvis[src]=true;\n\t\tfor(int i:a.get(src)) {\n\t\t\tif(vis[i]==false) {\n\t\t\t\t\n\t\t\t\tdfs(a,i,vis,count+1,n);\n\t\t\t}\n\t\t}\n\t\tif(count==n) {\n\t\tans++;\n\t\tvis[src]=false;\n\t\t\t}else {\n\t\t\t\tvis[src]=false;\n\t\t\t}\n\t\t\n\t\treturn ans;\n\t}\n\tstatic int[] arr(int n,Scanner sc) {\n\t\tint a[]=new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i]=sc.nextInt();\n\t\t}\n\t\treturn a;\n}\n\n}\n", "code2": "require \"set\"\n\nn, m = gets.split(\" \").map(&:to_i)\nedges = {}\nnodes = Set.new\nm.times do |i|\n  a, b = gets.split(\" \").map(&:to_i)\n  edges[a] ||= []\n  edges[a] << b\n  edges[b] ||= []\n  edges[b] << a\n  nodes << a\n  nodes << b\nend\n\ndef one_line s, n, nodes, edges\n  # p \"[debug] set: #{s}, node: #{n}\"\n  new_s = s.clone\n  new_s << n\n  if new_s == nodes then\n    return 1\n  end\n\n  res = 0\n  ((edges[n] || []) - new_s.to_a).each do |b|\n    res += one_line new_s, b, nodes, edges\n  end\n  return res\nend\n\nputs one_line(Set.new, 1, nodes, edges)", "label": 1, "name1": "s658101216.java", "name2": "s002122536.rb"}, {"id": 504, "code1": "\nimport java.util.Scanner;\n\n/**\n * Created by enpingkuang on 2020/9/10 10:58 \u4e0b\u5348\n */\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String s = scanner.next();\n        long sum = 0;\n        int length = s.length();\n        for(int i = 0;i<length;i++){\n            sum += (s.charAt(i)-'0');\n        }\n        System.out.println(sum % 9==0?\"Yes\":\"No\");\n    }\n}\n", "code2": "h,w = gets.split.map(&:to_i)\nif h == 1 || w == 1\n  p 1\nelsif h.odd?\n  p w * (h-1) / 2 + (w+1)/2\nelse\n  p w * h / 2\nend", "label": 0, "name1": "s939687060.java", "name2": "s213238625.rb"}, {"id": 813, "code1": "import java.util.*;\n\npublic class Main{\n    public static void main(String args[]){\n        Scanner sc = new Scanner(System.in);\n        \n        int N = sc.nextInt();\n        int[] a = new int[N];\n        int[] b = new int[N];\n        for(int i = 0; i < N; i++)\n            a[i] = sc.nextInt();\n        for(int i = 0; i < N; i++)\n            b[i] = sc.nextInt();\n        sc.close();\n        long sum1 = 0;\n        long sum2 = 0;\n        for(int i = 0; i < N; i++){\n            if(a[i] > b[i]){\n                sum1 += (a[i]-b[i]);\n            } else {\n                sum2 += (b[i]-a[i])/2;\n            }\n        }\n        if(sum1 <= sum2)\n            System.out.println(\"Yes\");\n        else\n            System.out.println(\"No\");\n\n    }\n}", "code2": "N, M = gets.split.map(&:to_i)\nedges = M.times.map { gets.split.map(&:to_i) }\ngraph = Array.new(N) { [] }\nedges.each do |u, v|\n  u -= 1\n  v -= 1\n  graph[u].push(v)\n  graph[v].push(u)\nend\n\nrequire 'set'\ndef path_count(u, visited, graph)\n  return 1 if visited.size == N\n  ret = 0\n  graph[u].each do |v|\n    next if visited.include?(v)\n    new_visited = visited | Set.new([v])\n    ret += path_count(v, new_visited, graph)\n  end\n  ret\nend\nvisited = Set.new([0])\nans = path_count(0, visited, graph)\nputs ans", "label": 0, "name1": "s462003664.java", "name2": "s194005594.rb"}, {"id": 398, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String args[]){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tInteger[] num = new Integer[n];\n\t\tStringBuilder s = new StringBuilder(\"\");\n\t\tfor(int i=0;i<n;i++){\n\t\t\tnum[i] = scan.nextInt();\n\t\t}\n\t\tArrays.sort(num);\n\t\t\n\t\ts.append(num[0]);\n\t\tfor(int i=1;i<num.length;i++){\n\t\t\ts.append(\" \"+num[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(s);\n\t}\n}", "code2": "gets\nputs gets.split.map(&:to_i).sort.join \" \"", "label": 1, "name1": "s177932526.java", "name2": "s947283729.rb"}, {"id": 921, "code1": "import java.util.*;\nimport java.lang.*;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint N = sc.nextInt();\n\t\tint[] s = new int[N+1];\n\t\tint total = 0;\n\t\tfor( int i=1; i<=N; i++ ){\n\t\t\ts[i] = sc.nextInt();\n\t\t\ttotal += s[i];\n\t\t}\n\t\tArrays.sort(s);\n\t\tint ans = 0;\n\t\tint dis = 0;\n\t\tint a = 1;\n\t\tint b = 0;\n\t\tfor( int i=1; i<=N; i++ ){\n\t\t\tif( s[i]%10!=0 ){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( i==N ){\n\t\t\t\tans = 0;\n\t\t\t\tb = 1;\n\t\t\t}\n\t\t}\n\t\tif( total%10!=0 ){\n\t\t\tans = total;\n\t\t}else if(b==0){\n\t\t\tfor( int i=1; i<=N; i++ ){\n\t\t\t\tif( s[i]%10!=0 ){\n\t\t\t\t\tans = total - s[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n", "code2": "N=gets.to_i\nM=10**9+7\ns=0\n*F=I=[r=1,1]\n*R=I\n2.upto(N){|i|I<<z=M/i*-I[M%i]%M;F<<r=r*i%M;R<<z*R[-1]%M;i<-~N/2||i>=N||s+=F[-2]*r*R[2*i-N]%M}\np N>2?(r-s)%M: 1\n###############################################\n###############################################\n###############################################\n###############################################\n###############################################", "label": 0, "name1": "s551116804.java", "name2": "s632402521.rb"}, {"id": 958, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[]args) {\n\t\ttry(Scanner scan = new Scanner(System.in)){\n\n\t\t\tint N = scan.nextInt();\n\t\t\tint M = scan.nextInt();\n\t\t\tint K = scan.nextInt();\n\n\n\n\t\t\tint goukei = 0;\n\t\t\tint ok = 0;\n\t\t\tfor(int i = 0;i<=N;i++) {\n\t\t\t\tfor(int j = 0;j<=M;j++) {\n\t\t\t\t\tgoukei =  i*M+j*N-2*i*j;\n\t\t\t\t\tif(goukei==K) {\n\t\t\t\t\t\tok=1;break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(ok==1)System.out.println(\"Yes\");\n\t\t\telse System.out.println(\"No\");\n\n\t\t}\n\n\n\t}\n\n\n}\n", "code2": "N, C = gets.split.map(&:to_i)\nD = Array.new(C) { Array.new(C) }\nC.times do |i|\n  D[i] = gets.split.map(&:to_i)\nend\nGRID = Array.new(N) { Array.new(N) }\nN.times do |i|\n  GRID[i] = gets.split.map(&:to_i)\nend\n\ncost = Array.new(3) { Array.new(C) {0} }\n(1..C).each do |c|\n  (1..N).each do |x|\n    (1..N).each do |y|\n      cost[(x-1+y-1)%3][c-1] += D[GRID[x-1][y-1]-1][c-1]\n    end\n  end\nend\n\nans = 1 << 30\n(1..C).each do |c1|\n  (1..C).each do |c2|\n    next if c1 == c2\n    (1..C).each do |c3|\n      next if c2 == c3 || c1 == c3\n      ans = [ans, cost[0][c1-1] + cost[1][c2-1] + cost[2][c3-1]].min\n    end\n  end\nend\n\nputs ans\n", "label": 0, "name1": "s703141884.java", "name2": "s928332636.rb"}, {"id": 445, "code1": "import java.util.*;\nclass Main\n{\n    static long mod = 1000000007;\n    public static void main (String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long[] a = new long[n];\n        for(int i = 0; i < n; i++){\n            a[i] = sc.nextLong();\n        }\n        long[] b = new long[n+1];\n        b[0] = 0;\n        for(int i = 1; i <= n; i++){\n            b[i] = (b[i-1] + pow(i, mod - 2)) % mod;\n        }\n        long ans = 0;\n        for(int i = 0; i < n; i++){\n            ans += a[i] * (b[i+1] + b[n - i] - 1);\n            ans %= mod;\n        }\n        for(int i = 1; i <= n; i++){\n            ans *= i;\n            ans %= mod;\n        }\n        System.out.println(ans);\n    }\n    static long pow(long a, long p){\n        if(p == 0) return 1;\n        else if(p % 2 == 0){\n            long d = pow(a, p/2);\n            return d * d % mod;\n        }\n        else return pow(a, p-1) * a % mod;\n    }\n}", "code2": "n=gets.to_i\na=gets.split.map &:to_i\n\ndef pow(a,b,mod)\n  return 1 if b==0\n  return (a**b[0]*pow(a,b/2,mod)**2)%mod\nend\n\ndef inv(a,mod)\n  pow(a,mod-2,mod)\nend\n\nmod=10**9+7\n\nf=1\n1.upto(n){|i|f=f*i%mod}\n\nd=0,*(1..n).map{|j|f*inv(j,mod)%mod}\n\ns=d.dup\n1.upto(n){|i|s[i]+=s[i-1];s[i]%=mod}\n\nr=0\n\nn.times{|i|\n  #q=[1,*2..(n-i),*2..(i+1)].map{|j|ff/j}.reduce(:+)\n  q=f+s[n-i]-s[1]+s[i+1]-s[1]\n  r=(r+a[i]*q)%mod\n}\n\np r", "label": 1, "name1": "s041637006.java", "name2": "s199570329.rb"}, {"id": 700, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyScanner in = new MyScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        C solver = new C();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class C {\n        int N;\n        int M;\n\n        public void solve(int testNumber, MyScanner in, PrintWriter out) {\n            N = in.Int();\n            M = in.Int();\n            DSU dsu = new DSU(N);\n            for (int i = 0; i < M; i++) {\n                int A = in.Int() - 1;\n                int B = in.Int() - 1;\n                dsu.merge(A, B);\n            }\n            out.println(dsu.groups().size() - 1);\n        }\n\n    }\n\n    static class DSU {\n        private int n;\n        private int[] parentOrSize;\n\n        public DSU(int n) {\n            this.n = n;\n            this.parentOrSize = new int[n];\n            Arrays.fill(parentOrSize, -1);\n        }\n\n        int merge(int a, int b) {\n            if (!(0 <= a && a < n))\n                throw new IndexOutOfBoundsException(\"a=\" + a);\n            if (!(0 <= b && b < n))\n                throw new IndexOutOfBoundsException(\"b=\" + b);\n\n            int x = leader(a);\n            int y = leader(b);\n            if (x == y) return x;\n            if (-parentOrSize[x] < -parentOrSize[y]) {\n                int tmp = x;\n                x = y;\n                y = tmp;\n            }\n            parentOrSize[x] += parentOrSize[y];\n            parentOrSize[y] = x;\n            return x;\n        }\n\n        int leader(int a) {\n            if (parentOrSize[a] < 0) {\n                return a;\n            } else {\n                parentOrSize[a] = leader(parentOrSize[a]);\n                return parentOrSize[a];\n            }\n        }\n\n        ArrayList<ArrayList<Integer>> groups() {\n            int[] leaderBuf = new int[n];\n            int[] groupSize = new int[n];\n            for (int i = 0; i < n; i++) {\n                leaderBuf[i] = leader(i);\n                groupSize[leaderBuf[i]]++;\n            }\n            ArrayList<ArrayList<Integer>> result = new ArrayList<>(n);\n            for (int i = 0; i < n; i++) {\n                result.add(new ArrayList<>(groupSize[i]));\n            }\n            for (int i = 0; i < n; i++) {\n                result.get(leaderBuf[i]).add(i);\n            }\n            result.removeIf(ArrayList::isEmpty);\n            return result;\n        }\n\n    }\n\n    static class MyScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public MyScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    return null;\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int Int() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "code2": "a,b,c=gets.chomp.split.map(&:to_i)\nif c-(a-b)<0\n  puts \"0\"\nelse\n  puts c-(a-b)\nend\n\n", "label": 0, "name1": "s578903603.java", "name2": "s801690691.rb"}, {"id": 480, "code1": "\n\nimport java.util.*;\nimport java.io.*;\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t\n\tScanner sc=new Scanner(System.in);\n\t     int n=sc.nextInt();\n\t     int m=sc.nextInt();\n\t     ArrayList<ArrayList<Integer>> a=new ArrayList<>();\nfor(int i=0;i<n;i++) {\n\ta.add(new ArrayList<Integer>());\n}\nfor(int j=0;j<m;j++) {\n\tint x=sc.nextInt()-1;\n\tint y=sc.nextInt()-1;\n\ta.get(x).add(y);\n\ta.get(y).add(x);\n}\nboolean vis[]=new boolean[n];\nans=0;\n\tSystem.out.println(dfs(a,0,vis,1,n));\n\t}\nstatic int ans=0;\t\n\tstatic int dfs(ArrayList<ArrayList<Integer>> a,int src,boolean vis[],int count,int n) {\n\t\tvis[src]=true;\n\t\tfor(int i:a.get(src)) {\n\t\t\tif(vis[i]==false) {\n\t\t\t\t\n\t\t\t\tdfs(a,i,vis,count+1,n);\n\t\t\t}\n\t\t}\n\t\tif(count==n) {\n\t\tans++;\n\t\tvis[src]=false;\n\t\t\t}else {\n\t\t\t\tvis[src]=false;\n\t\t\t}\n\t\t\n\t\treturn ans;\n\t}\n\tstatic int[] arr(int n,Scanner sc) {\n\t\tint a[]=new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i]=sc.nextInt();\n\t\t}\n\t\treturn a;\n}\n\n}\n", "code2": "N, M = gets.split.map(&:to_i)\ngraph = Array.new(N + 1) { [] }\nM.times do\n  a, b = gets.split.map(&:to_i)\n  graph[a] << b\n  graph[b] << a\nend\n\nans = 0\n(2..N).to_a.permutation(N - 1).each do |p|\n  p.unshift(1)\n  ans += 1 if (1...N).all? { |i| graph[p[i - 1]].include?(p[i]) }\nend\nputs ans\n", "label": 1, "name1": "s658101216.java", "name2": "s112297491.rb"}, {"id": 520, "code1": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // Your code here!\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long a = sc.nextLong();\n        long b = sc.nextLong();\n        long[] array = new long[n];\n        for (int i = 0; i < n; i++) {\n            array[i] = sc.nextLong();\n        }\n        \n        long ans = 0;\n        for (int i = 1; i < n; i++) {\n            long dis = array[i] - array[i-1];\n            if (dis * a < b) {\n                ans += dis * a;\n            } else {\n                ans += b;\n            }\n        }\n        \n        System.out.println(ans);\n    }\n}", "code2": "while true do\n    n = gets.to_i\n    break if n == 0\n    array=gets.chomp.split(\" \").map(&:to_f)\n    average = array.inject(:+)/n\n    puts format(\"%0.5f\", (array.map {|e| (e-average)**2}.inject(:+)/n)**0.5)\nend\n", "label": 0, "name1": "s129000734.java", "name2": "s834861200.rb"}, {"id": 128, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        int count = Integer.valueOf(reader.readLine());\n        String s = reader.readLine();\n\n        long[][] dp = new long[count][count];\n        dp[0][0] = 1;\n        long modulo = 1_000_000_007;\n\n        for (int i = 1; i < count; ++i) {\n            if (s.charAt(i - 1) == '<') {\n                dp[i][0] = 0;\n                for (int j = 1; j <= i; ++j) {\n                    dp[i][j] = dp[i][j - 1] + dp[i - 1][j - 1];\n                    dp[i][j] %= modulo;\n                }\n            } else {\n                dp[i][i] = 0;\n                for (int j = i - 1; j >= 0; --j) {\n                    dp[i][j] = dp[i][j + 1] + dp[i - 1][j];\n                    dp[i][j] %= modulo;\n                }\n            }\n        }\n\n        long res = 0;\n        for (int i = 0; i < count; ++i) {\n            res += dp[count - 1][i];\n            res %= modulo;\n        }\n        System.out.println(res);\n    }\n}\n", "code2": "d=*1..gets.to_i;gets.chop.bytes{|c|x=0;n=d.pop;d.map!{|a|x=(x+-c%3*n+a*=1-c%3).%10**9+7}};p *d", "label": 1, "name1": "s833810272.java", "name2": "s665085996.rb"}, {"id": 562, "code1": "import java.util.*;\n\npublic class Main {\n\tvoid solve() {\n\t\tScanner scan = new Scanner(System.in);\n\t\tlong n = scan.nextLong();\n\t\tlong k = scan.nextLong();\n\t\tif(n % k == 0) {\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\t\tn %= k;\n\t\tSystem.out.println(Math.min(n, k - n));\n\t\tscan.close();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\n}\n", "code2": "a,b,c = gets.chomp.split.map(&:to_f)\n\ns = (a * b * Math.sin(c * Math::PI / 180)) * 0.5\nl = (a + b) + (a*a + b*b - 2*a*b*Math.cos(c * Math::PI / 180)) ** 0.5\nh = b * Math.sin(c * Math::PI / 180)\n\nputs s\nputs l\nputs h", "label": 0, "name1": "s393030652.java", "name2": "s128364594.rb"}, {"id": 888, "code1": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        try (Scanner s = new Scanner(System.in)) {\n            int k = s.nextInt();\n            int a = s.nextInt();\n            int b = s.nextInt();\n            int mod = a % k;\n            int d = b - a;\n            System.out.println((mod == 0 || (k - mod) <= d) ? \"OK\" : \"NG\");\n        }\n    }\n}\n", "code2": "def ascan; gets.split.map(&:to_i);end\n\nn,m = ascan\n\nt = m*1900 + (n-m)*100\np (2**m)*t\n", "label": 0, "name1": "s970456058.java", "name2": "s059115863.rb"}, {"id": 363, "code1": "import java.util.ArrayList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n/**\n * Created by shoya on 2017/04/12.\n */\npublic class Main {\n    public static void main(String... args) {\n        Scanner sc = new Scanner(System.in);\n        int V = sc.nextInt();\n        int E = sc.nextInt();\n        int r = sc.nextInt();\n        DijkstraClass dijkstra = new DijkstraClass(V, E, r);\n        for (int i = 0; i < E; i++) {\n            int s = sc.nextInt();\n            int d = sc.nextInt();\n            int c = sc.nextInt();\n            dijkstra.addDistande(s, d, c);\n        }\n        int[] dist = dijkstra.dikstra();\n        for (int i = 0; i < dist.length; i++){\n            if (dist[i] == 1 << 30)\n                System.out.println(\"INF\");\n            else\n                System.out.println(dist[i]);\n        }\n        return;\n    }\n\n\n    private static class DijkstraClass {\n        class edge{\n            int dest, cost;\n            edge(int dest, int cost){\n                this.dest = dest;\n                this.cost = cost;\n            }\n        }\n\n        private final int INF = 1 << 30;\n        private int S;\n        private int V;\n        private ArrayList<ArrayList<edge>> edgesOfNodes = new ArrayList<ArrayList<edge>>();\n\n        DijkstraClass(int V, int E, int Start){\n            this.S = Start;\n            this.V = V;\n            for (int i = 0; i < V; i++)\n                edgesOfNodes.add(new ArrayList<edge>());\n        }\n\n        void addDistande(int source, int dest, int cost){\n            edgesOfNodes.get(source).add(new edge(dest, cost));\n        }\n\n\n        int[] dikstra(){\n            class costAndNode implements Comparable {\n                int cost, node;\n                costAndNode(int cost, int node){\n                    this.cost = cost;\n                    this.node = node;\n                }\n                @Override\n                public int compareTo(Object o) {\n                    return this.cost - ((costAndNode) o).cost;\n                }\n            }\n\n            PriorityQueue<costAndNode> pque = new PriorityQueue<costAndNode>();\n            int[] distances = new int[V];\n            for (int i = 0; i < V; i++)\n                distances[i] = INF;\n            distances[S] = 0;\n\n            pque.add(new costAndNode(0, S));\n            while (!pque.isEmpty()){\n                costAndNode item = pque.poll();\n                if (distances[item.node] < item.cost)\n                    continue;\n\n                //System.out.printf(\"Focusing on Node %d\\n\", item.node);\n                //for (int i = 0; i < V; i++)\n                //    System.out.printf(\"%d \", distances[i]);\n                //System.out.println();\n\n                for (edge e : edgesOfNodes.get(item.node)) {\n                    //System.out.printf(\"Node %d -> %d, Cost %d -> %d\\n\",\n                    //        item.node, e.dest, distances[e.dest],\n                    //        distances[item.node] + e.cost);\n                    if (distances[e.dest] > distances[item.node] + e.cost) {\n                        distances[e.dest] = distances[item.node] + e.cost;\n                        pque.add(new costAndNode(distances[e.dest], e.dest));\n                    }\n                }\n            }\n\n            return distances;\n        }\n\n    }\n}", "code2": "def dijkstra(g, s)\n  def enq(pq, val)\n    pq << val\n    cd = pq.size\n    pr = cd / 2\n    until pr.zero? || (pq[pr - 1] <=> pq[cd - 1]) < 0\n      pq[pr - 1], pq[cd - 1] = pq[cd - 1], pq[pr - 1]\n      cd = pr\n      pr = cd / 2\n    end\n  end\n\n  def deq(pq)\n    pq[0], pq[-1] = pq[-1], pq[0]\n    rs = pq.delete_at(-1)\n    unless pq.empty?\n      pr = 1\n      cd = [pr * 2, pr * 2 + 1].select { |i| pq[i - 1] }.min_by { |i| pq[i - 1] }\n      until cd.nil? || (pq[pr - 1] <=> pq[cd - 1]) < 0\n        pq[pr - 1], pq[cd - 1] = pq[cd - 1], pq[pr - 1]\n        pr = cd\n        cd = [pr * 2, pr * 2 + 1].select { |i| pq[i - 1] }.min_by { |i| pq[i - 1] }\n      end\n    end\n    rs\n  end\n\n  pq = []\n  d = Array.new(g.size) { Float::INFINITY }\n  d[s] = 0\n  enq(pq, [0, s])\n\n  until pq.empty?\n    v_cost, v = deq(pq)\n    next if d[v] < v_cost\n    g[v].each do |e|\n      if d[e.to] > d[v] + e.cost\n        d[e.to] = d[v] + e.cost\n        enq(pq, [d[e.to], e.to])\n      end\n    end\n  end\n\n  d\nend\n\nEdge = Struct.new('Edge', :to, :cost)\n\nv, e, r = gets.split.map(&:to_i)\ng = Array.new(v) { [] }\ne.times do\n  s, t, d = gets.split.map(&:to_i)\n  g[s] << Edge.new(t, d)\nend\n\ndijkstra(g, r).each do |sum|\n  puts (sum == Float::INFINITY ? 'INF' : sum)\nend", "label": 1, "name1": "s575620429.java", "name2": "s716711304.rb"}, {"id": 673, "code1": "import java.util.*;\n \nclass Main{\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n \n        String S = sc.next();\n        String T = sc.next();\n        int ls = S.length();\n        int lt = T.length();\n        String a = \"?\";\n\n        if(ls<lt){\n            System.out.println(\"UNRESTORABLE\");\n            return;\n        }\n        int x = -1;\n        for(int i=0; i<=ls-lt; i++){\n            if(S.charAt(i)==T.charAt(0) || S.charAt(i)==a.charAt(0)){\n                for(int j=0; j<lt; j++){\n                    if(S.charAt(i+j)!=T.charAt(j) && S.charAt(i+j)!=a.charAt(0)){\n                        break;\n                    }\n                    if(j==lt-1){\n                        x = i;\n                    }\n                }\n            }\n        }\n        if(x==-1){\n            System.out.println(\"UNRESTORABLE\");\n            return;\n        }\n        else if(ls==lt){\n            S = T;\n            System.out.println(S);\n            return;\n        }\n        else if(x==0){\n            S = T + S.substring(lt);\n        }\n        else if(x!=0){\n            if(x+lt-1==ls){\n                S = S.substring(0, x) + T;\n            }\n            else{\n                S = S.substring(0, x) + T + S.substring(x + lt);\n            }\n        }\n        String st = \"\";\n        for(int i=0; i<ls; i++){\n            if(S.charAt(i)==a.charAt(0)){\n                st += \"a\";\n            }\n            else{\n                st += String.valueOf((char)S.charAt(i));\n            }\n        }\n        System.out.println(st);\n    }\n}", "code2": "require 'scanf'\nwhile true\ninput = scanf(\"%d %d\")\nn = input[0];\nx = input[1];\nif n == 0 && x == 0\nbreak\nend\ncnt = 0\nfor r in 1...n+1\nfor c in r + 1...n+1\nfor f in c + 1...n+1\nif r + c + f == x\ncnt += 1\nend\nend\nend\nend\nputs cnt\nend", "label": 0, "name1": "s748827885.java", "name2": "s364906499.rb"}, {"id": 163, "code1": "import java.util.Scanner;\nimport java.util.Stack;\n\nclass Main{\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tString str=sc.next();\n\t\t\tStack<Integer> st=new Stack<Integer>();\n\t\t\tfor(int i=0;i<str.length();i++){\n\t\t\t\tif(st.isEmpty() || st.peek()==1 || str.charAt(i)=='S') st.add(str.charAt(i)=='S' ? 0 : 1);\n\t\t\t\telse st.pop();\n\t\t\t}\n\t\t\tSystem.out.println(st.size());\n\t\t}\n\t}\n}", "code2": "X = gets.chomp\n\nchars = Array.new(X.size) {0}\nsp = 0\n\ndecrease = 0\nX.chars.each_with_index do |s, i|\n  if s == 'S'\n    sp += 1\n  else\n    next if sp == 0\n    sp -= 1\n    decrease += 1\n  end\nend\n\nputs X.size - decrease * 2\n", "label": 1, "name1": "s831441158.java", "name2": "s860052839.rb"}, {"id": 458, "code1": "/*\n *           AUTHOR: Maria Theresa M. Padayhag\n *             DATE: 20160326\n *  PRE-REQUIREMENT: JDK 1.8\n */\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.time.*;\nimport java.time.format.TextStyle;\nimport java.util.Locale;\n\nclass DayIndentifier\n{\n\tLocalDate date = null;\n\t\n\tpublic \tDayIndentifier( String inMonth, String inDay )\n\t{\n\t\t// NumberFormatException might be thrown here\n\t\t// but it will be handled by the caller.\n\t\tint month = Integer.parseInt( inMonth );\n\t\tint day   = Integer.parseInt( inDay );\n\t\t\n\t\t// DateTimeException might be thrown here\n\t\t// but it will be handled by the caller.\n\t\tdate = LocalDate.of( 2004, month, day );\n\t}\n\t\n\tpublic String getDayOfWeek()\n\t{\n\t\t// NullPointerException might be thrown here\n\t\t// but it will handled by the caller.\n\t\treturn date.getDayOfWeek().getDisplayName(TextStyle.FULL, Locale.ENGLISH);\n\t}\n}\n\npublic class Main\n{\n\tpublic static boolean toExit( String[] dataset )\n\t{\n\t\tfor(String data: dataset)\n\t\t{\n\t\t\tif(data.equals(\"0\"))\n\t\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic static void main( String args[] ) throws IOException\n\t{\n\t\tBufferedReader br = new BufferedReader( new InputStreamReader( System.in ) );\n\t\tString input;\n\t\tString dataset[];\n\t\tDayIndentifier di;\n\t\t\n\t\tREAD: \n\t\twhile( ( input = br.readLine() ) != null ) {\n\t\t\ttry {\n\t\t\t\tdataset = input.split(\" \");\n\t\t\t\n\t\t\t\tif( toExit( dataset ) ) {\n\t\t\t\t\tbreak READ;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif( dataset.length != 2 ) {\n\t\t\t\t\tSystem.out.println(\"Invalid input.\");\n\t\t\t\t\tcontinue READ;\n\t\t\t\t} \t\t\n\t\t\t\t\n\t\t\t\tdi = new DayIndentifier(dataset[0], dataset[1]);\n\t\t\t\tSystem.out.println( di.getDayOfWeek() );\n\t\t\t} catch( Exception e ) {\n\t\t\t\tSystem.out.println(\"Invalid input.\");\n\t\t\t\tcontinue READ;\n\t\t\t}\t\t\n\t\t}\n\t}\n}", "code2": "require 'date'\nwhile line = gets\n  m,d=line.split.map(&:to_i)\n  break if m == 0 || d == 0\n  puts Time.mktime(2004,m,d).strftime(\"%A\")\nend\n", "label": 1, "name1": "s944901694.java", "name2": "s356930170.rb"}, {"id": 652, "code1": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-9;\n\n\tint n;\n\tint start, goal, ttl;\n\tLinkedList<Integer>[] graph;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tn = sc.nextInt();\n\t\tgraph = new LinkedList[n];\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint u = sc.nextInt() - 1;// \u0083\u008b\u0081[\u0083^\u0094\u00d4\u008d\u0086\n\t\t\tint m = sc.nextInt();\n\t\t\tgraph[u] = new LinkedList<Integer>();\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint v = sc.nextInt() - 1;\n\t\t\t\tgraph[u].add(v);\n\t\t\t}\n\t\t}\n\t\tint p = sc.nextInt();\n\t\tfor (int i = 0; i < p; i++) {\n\t\t\tstart = sc.nextInt() - 1;\n\t\t\tgoal = sc.nextInt() - 1;\n\t\t\tttl = sc.nextInt();\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve() {\n\t\tLinkedList<Integer> que = new LinkedList<Integer>();\n\t\tboolean[] visited = new boolean[n];\n\t\tint[] d = new int[n];\n\t\tArrays.fill(d, INF);\n\t\tque.offer(start);\n\t\td[start] = 1;\n\t\tvisited[start] = true;\n\t\tfor (; !que.isEmpty();) {\n\t\t\tint u = que.poll();\n\t\t\tfor (int v : graph[u]) {\n\t\t\t\tif (!visited[v]) {\n\t\t\t\t\tque.offer(v);\n\t\t\t\t\td[v] = d[u] + 1;\n\t\t\t\t\tvisited[v] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[goal] <= ttl) {\n\t\t\tprintln(\"\" + d[goal]);\n\t\t} else {\n\t\t\tprintln(\"NA\");\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s) {\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s) {\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}", "code2": "n,k = gets.split.map(&:to_i)\nw = []\n(n).times do |i|\n  w[i] = gets.to_i\nend\nm = w.max\nans = (m..n*m).bsearch{|i|\n  count = 1\n  rest = i\n  for wi in w do\n    if rest >= wi\n      rest -= wi\n    else\n      count += 1\n      rest = i-wi\n    end\n  end\n  k >= count\n}\nprintf(\"%d\\n\",ans)\n", "label": 0, "name1": "s019260377.java", "name2": "s051438008.rb"}, {"id": 615, "code1": "\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int W = sc.nextInt();\n\t\t\tfinal int H = sc.nextInt();\n\t\t\t\n\t\t\tif(W == 0  && H == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] map = new int[H][W];\n\t\t\t\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tchar[] input = sc.next().toCharArray();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tif('0' <= input[j] && input[j] <= '9'){\n\t\t\t\t\t\tmap[i][j] = input[j] - '0';\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][] len = new int[H][W];\n\t\t\tshort[][][] dp = new short[H][W][H+W+1];\n\t\t\t\n\t\t\tint max = 0;\n\t\t\tint m_x = -1;\n\t\t\tint m_y = -1;\n\t\t\t\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tif(map[i][j] < 0){\n\t\t\t\t\t\tdp[i][j][0] = -1;\n\t\t\t\t\t\tlen[i][j] = -1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(i == 0 && j == 0){\n\t\t\t\t\t\tdp[i][j][0] = (short)(map[i][j]);\n\t\t\t\t\t\tlen[i][j] = map[i][j] == 0 ? 0 : 1;\n\t\t\t\t\t}else if(j == 0){\n\t\t\t\t\t\tfinal int p_len = len[i-1][j];\n\t\t\t\t\t\tif(p_len == -1){\n\t\t\t\t\t\t\tdp[i][j][0] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = map[i][j] == 0 ? 0 : 1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tSystem.arraycopy(dp[i-1][j], 0, dp[i][j], 0, p_len);\n\t\t\t\t\t\t\tdp[i][j][p_len] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = p_len +  (p_len == 0 && map[i][j] == 0 ? 0 : 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(i == 0){\n\t\t\t\t\t\tfinal int p_len = len[i][j-1];\n\t\t\t\t\t\tif(p_len == -1){\n\t\t\t\t\t\t\tdp[i][j][0] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = map[i][j] == 0 ? 0 : 1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tSystem.arraycopy(dp[i][j-1], 0, dp[i][j], 0, p_len);\n\t\t\t\t\t\t\tdp[i][j][p_len] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = p_len + (p_len == 0 && map[i][j] == 0 ? 0 : 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfinal int left_len = len[i][j-1];\n\t\t\t\t\t\tfinal int up_len = len[i-1][j];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(left_len == -1 && up_len == -1){\n\t\t\t\t\t\t\tdp[i][j][0] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = map[i][j] == 0 ? 0 : 1;\n\t\t\t\t\t\t}else if(left_len > up_len){\n\t\t\t\t\t\t\tfinal int p_len = len[i][j-1];\n\t\t\t\t\t\t\tSystem.arraycopy(dp[i][j-1], 0, dp[i][j], 0, p_len);\n\t\t\t\t\t\t\tdp[i][j][p_len] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = p_len + (p_len == 0 && map[i][j] == 0 ? 0 : 1);\n\t\t\t\t\t\t}else if(left_len < up_len){\n\t\t\t\t\t\t\tfinal int p_len = len[i-1][j];\n\t\t\t\t\t\t\tSystem.arraycopy(dp[i-1][j], 0, dp[i][j], 0, p_len);\n\t\t\t\t\t\t\tdp[i][j][p_len] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = p_len + (p_len == 0 && map[i][j] == 0 ? 0 : 1);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tfinal int size = len[i][j-1];\n\t\t\t\t\t\t\tboolean left_f = true;\n\t\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\t\tif(dp[i-1][j][k] < dp[i][j-1][k]){\n\t\t\t\t\t\t\t\t\tleft_f = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}else if(dp[i-1][j][k] > dp[i][j-1][k]){\n\t\t\t\t\t\t\t\t\tleft_f = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(left_f){\n\t\t\t\t\t\t\t\tfinal int p_len = len[i][j-1];\n\t\t\t\t\t\t\t\tSystem.arraycopy(dp[i][j-1], 0, dp[i][j], 0, p_len);\n\t\t\t\t\t\t\t\tdp[i][j][p_len] = (short)(map[i][j]);\n\t\t\t\t\t\t\t\tlen[i][j] = p_len + (p_len == 0 && map[i][j] == 0 ? 0 : 1);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tfinal int p_len = len[i-1][j];\n\t\t\t\t\t\t\t\tSystem.arraycopy(dp[i-1][j], 0, dp[i][j], 0, p_len);\n\t\t\t\t\t\t\t\tdp[i][j][p_len] = (short)(map[i][j]);\n\t\t\t\t\t\t\t\tlen[i][j] = p_len + (p_len == 0 && map[i][j] == 0 ? 0 : 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(max < len[i][j]){\n\t\t\t\t\t\tmax = len[i][j];\n\t\t\t\t\t\tm_x = j;\n\t\t\t\t\t\tm_y = i;\n\t\t\t\t\t}else if(max == len[i][j]){\n\t\t\t\t\t\tfinal int size = len[i][j];\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(dp[m_y][m_x][k] < dp[i][j][k]){\n\t\t\t\t\t\t\t\tmax = len[i][j];\n\t\t\t\t\t\t\t\tm_x = j;\n\t\t\t\t\t\t\t\tm_y = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(dp[m_y][m_x][k] > dp[i][j][k]){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tSystem.out.printf(\"%2d \", len[i][j]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t*/\n\t\t\tfor(int i = 0; i < max; i++){\n\t\t\t\tSystem.out.print(dp[m_y][m_x][i]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t\n\t}\n\n}", "code2": "a,b=gets.split.map(&:to_i)\np a>b ?a-1:a", "label": 0, "name1": "s531751281.java", "name2": "s660994056.rb"}, {"id": 53, "code1": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt(), result = 0, combo = 0, color = 0;\n        for (int i = 0; i < n; i++) {\n            int j = scanner.nextInt();\n            combo++;\n\n            if (j != color) {\n                result += combo / 2;\n                combo = 0;\n                color = j;\n            }\n        }\n        System.out.println(result + ++combo / 2);\n    }\n}", "code2": "N = gets.to_i\nas = gets.split.map(&:to_i)\nans = 0\n(N-1).times do |i|\n    if as[i] == as[i+1]\n        as[i+1] = -1\n        ans += 1\n    end\nend\nputs ans", "label": 1, "name1": "s379654146.java", "name2": "s512090046.rb"}, {"id": 356, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n\t\treturn (int) nl;\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n}\npublic class Main {\n\tstatic FastScanner scan=new FastScanner();\n\tstatic Scanner scanner=new Scanner(System.in);\n\tstatic long mod=1000000007;\n\tstatic double eps=0.0000000001;\n\tstatic int big=Integer.MAX_VALUE;\n\tstatic long gcd (long a, long b) {return b>0?gcd(b,a%b):a;}\n\tstatic long lcm (long a, long b) {return a*b/gcd(a,b);}\n\tstatic int max(int a,int b) {return a>b?a:b;}\n\tstatic int min(int a,int b) {return a<b?a:b;}\n\tstatic long factorial(int i) {return i==1?1:i*factorial(i-1);}\n\tstatic int lower_bound(int a[],int key) {\n\t\tint low=0,high=a.length;\n\t\twhile(low<high) {\n\t\t\tint mid=((high-low)/2)+low;\n\t\t\tif(a[mid]<=key)low=mid+1;\n\t\t\telse high=mid;\n\t\t}\n\t\treturn high;\n\t}\n\tstatic int upper_bound(int a[],int key) {\n\t\tint low=0,high=a.length;\n\t\twhile(low<high) {\n\t\t\tint mid=((high-low)/2)+low;\n\t\t\tif(a[mid]<key)low=mid+1;\n\t\t\telse high=mid;\n\t\t}\n\t\treturn high;\n\t}\n\tstatic boolean isPrime (long n) {\n\t\tif (n==2) return true;\n\t\tif (n<2 || n%2==0) return false;\n\t\tdouble d = Math.sqrt(n);\n\t\tfor (int i=3; i<=d; i+=2)if(n%i==0){return false;}\n\t\treturn true;\n\t}\n\tstatic int upper_division(int a,int b) {\n\t\tif(a%b==0) {\n\t\t\treturn a/b;\n\t\t}\n\t\telse {\n\t\t\treturn a/b+1;\n\t\t}\n\t}\n\tstatic long lupper_division(long a,long b) {\n\t\tif(a%b==0) {\n\t\t\treturn a/b;\n\t\t}\n\t\telse {\n\t\t\treturn a/b+1;\n\t\t}\n\t}\n\tstatic long lmax(long a,long b) {return Math.max(a, b);}\n\tstatic long lmin(long a,long b) {return Math.min(a, b);}\n\tstatic int[] setArray(int a) {\n\t\tint b[]=new int[a];\n\t\tfor(int i=0;i<a;i++) {\n\t\t\tb[i]=scan.nextInt();\n\t\t}\n\t\treturn b;\n\t}\n\tstatic long[] lsetArray(int a) {\n\t\tlong b[]=new long[a];\n\t\tfor(int i=0;i<a;i++) {\n\t\t\tb[i]=scan.nextLong();\n\t\t}\n\t\treturn b;\n\t}\n\tstatic String reverce(String str) {\n\t\tString strr=\"\";\n\t\tfor(int i=str.length()-1;i>=0;i--) {\n\t\t\tstrr+=str.charAt(i);\n\t\t}\n\t\treturn strr;\n\t}\n\tpublic static void printArray(char[] ch) {\n\t\tfor(int i=0;i<ch.length-1;i++) {\n\t\t\tSystem.out.print(ch[i]+\" \");\n\t\t}\n\t\tSystem.out.println(ch[ch.length-1]);\n\t}\n\tpublic static int[][] doublesort(int[][]a) {\n\t\tArrays.sort(a,(x,y)->Integer.compare(x[0],y[0]));\n\t\treturn a;\n\t}\n\tstatic long modpow(long x,long n,long mo) {\n\t\tlong sum=1;\n\t\twhile(n>0) {\n\t\t\tif((n&1)==1) {\n\t\t\t\tsum=sum*x%mo;\n\t\t\t}\n\t\t\tx=x*x%mo;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn sum;\n\t}\n\tpublic static char[] revch(char ch[]) {\n\t\tchar ret[]=new char[ch.length];\n\t\tfor(int i=ch.length-1,j=0;i>=0;i--,j++) {\n\t\t\tret[j]=ch[i];\n\t\t}\n\t\treturn ret;\n\t}\n\tpublic static int[] revint(int ch[]) {\n\t\tint ret[]=new int[ch.length];\n\t\tfor(int i=ch.length-1,j=0;i>=0;i--,j++) {\n\t\t\tret[j]=ch[i];\n\t\t}\n\t\treturn ret;\n\t}\n\tpublic static void warshall_floyd(int v[][],int n) {\n\t\tfor(int k=0;k<n;k++)\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t\tv[i][j]=min(v[i][j],v[i][k]+v[k][j]);\n\t}\n\tpublic static void main(String[] args) {\n\t\tlong a=scan.nextLong();\n\t\tlong b=scan.nextLong();\n\t\tint cnt=0;\n\t\tlong now=a;\n\t\twhile(now<=b) {\n\t\t\tcnt++;\n\t\t\tnow*=2;\n\t\t}\n\t\tSystem.out.println(cnt);\n\t}\n}", "code2": "X,Y=$<.read.split.map(&:to_i)\n\ni = 0\nn = X\nwhile n <= Y\n    i += 1\n    n *= 2\nend\n\nputs i\n", "label": 1, "name1": "s941851054.java", "name2": "s888422546.rb"}, {"id": 843, "code1": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n  public static void main(String[] args) {\n    FastScanner sc = new FastScanner();\n    int N = sc.nextInt();\n    int L = sc.nextInt();\n    long T = sc.nextLong();\n    \n    long[][] ari = sc.nextLongTable(N, 2);\n    \n    long[] cl = new long[N];\n    long[] ccl = new long[N];\n\n    int p = 0, q = 0;\n    for (int i = 0; i < N; i ++) {\n      if (ari[i][1] == 1) {\n        cl[p ++] = L - ari[i][0];\n      } else {\n        ccl[q ++] = ari[i][0];\n      }\n    }\n    cl = Arrays.copyOf(cl, p);\n    ccl = Arrays.copyOf(ccl, q);\n    Arrays.sort(cl);\n\n    long[] rets = new long[N];\n    for (int i = 0; i < N ;i ++) {\n      if (ari[i][1] == 1) {\n        int count = (int)(count(ccl, ari[i][0], ari[i][0] + 2L * T, L) % N);\n        rets[(i + count) % N] = (ari[i][0] + T) % L;\n      } else {\n        int count = (int)(count(cl, L - ari[i][0], L - ari[i][0] + 2L * T, L) % N);\n        rets[(i + N - count) % N] = (ari[i][0] + L - T % L) % L;\n      }\n    }\n    \n    for (int i = 0; i < N; i ++) {\n      System.out.println(rets[i]);\n    }\n  }\n  \n  private static long count(long[] xs, long f, long t, int L) {\n    long ret = 0;\n    int n = xs.length;\n    {\n      ret += t / L * n;\n      int ind = Arrays.binarySearch(xs, (int)(t % L));\n      if (ind < 0)  ind = -ind - 2;\n      ind ++;\n      ret += ind;\n    }\n    {\n      ret -= f / L * n;\n      int ind = Arrays.binarySearch(xs, (int)(f % L));\n      if (ind < 0)  ind = -ind - 2;\n      ind ++;\n      ret -= ind;\n    }\n    return ret;\n  }\n}\n\n\n\n\nclass FastScanner {\n\tpublic static String debug = null;\n\n\tprivate final InputStream in = System.in;\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate byte[] buffer = new byte[1024];\n\tprivate boolean eos = false;\n\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tif (debug != null) {\n\t\t\t\t\tbuflen = debug.length();\n\t\t\t\t\tbuffer = debug.getBytes();\n\t\t\t\t\tdebug = \"\";\n\t\t\t\t\teos = true;\n\t\t\t\t} else {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen < 0) {\n\t\t\t\teos = true;\n\t\t\t\treturn false;\n\t\t\t} else if (buflen == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\n\tprivate void skipUnprintable() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t}\n\n\tpublic boolean isEOS() {\n\t\treturn this.eos;\n\t}\n\n\tpublic boolean hasNext() {\n\t\tskipUnprintable();\n\t\treturn hasNextByte();\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tpublic int nextInt() {\n\t\treturn (int) nextLong();\n\t}\n\n\tpublic long[] nextLongList(int n) {\n\t\treturn nextLongTable(1, n)[0];\n\t}\n\n\tpublic int[] nextIntList(int n) {\n\t\treturn nextIntTable(1, n)[0];\n\t}\n\n\tpublic long[][] nextLongTable(int n, int m) {\n\t\tlong[][] ret = new long[n][m];\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tfor (int j = 0; j < m; j ++) {\n\t\t\t\tret[i][j] = nextLong();\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic int[][] nextIntTable(int n, int m) {\n\t\tint[][] ret = new int[n][m];\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tfor (int j = 0; j < m; j ++) {\n\t\t\t\tret[i][j] = nextInt();\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n}", "code2": "r=[*$<];a,b,c=r[0,8].sort_by{|t|t.split[1].to_f},r[8,8].sort_by{|t|t.split[1].to_f},r[16,8].sort_by{|t|t.split[1].to_f};puts a[0,2],b[0,2],c[0,2];*u=*a[2,6],*b[2,6],*c[2,6];\nputs u.sort_by{|t|t.split[1].to_f}[0,2]\n", "label": 0, "name1": "s345434798.java", "name2": "s099521906.rb"}, {"id": 370, "code1": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\tboolean eof;\n\t\n\tlong go(long a, long b, long c) {\n\t\tif (a < 0 || b < 0 || c < 0) {\n\t\t\treturn Long.MIN_VALUE;\n\t\t}\n\t\t\n\t\treturn a + b + c - (a & 1) - (b & 1) - (c & 1);\n\t}\n\n\tvoid solve() throws IOException {\n\t\tlong i = nextLong();\n\t\tlong o = nextLong();\n\t\tlong t = nextLong();\n\t\tlong j = nextLong();\n\t\tlong l = nextLong();\n\t\tlong s = nextLong();\n\t\tlong z = nextLong();\n\t\t\n\t\tlong ans = o + Math.max(go(i, j, l), go(i - 1, j - 1, l - 1) + 3);\n\t\t\n\t\tout.println(ans);\n\t}\n\n\tMain() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e) {\n\t\t\t\teof = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\teof = true;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}", "code2": "a = gets.split.map(&:to_i)\ntmp1 = 0\ntmp1 += a[0] / 2 * 2\ntmp1 += a[3] / 2 * 2\ntmp1 += a[4] / 2 * 2\ntmp2 = 0\nif a[0] > 0 && a[3] > 0 && a[4] > 0\n    tmp2 += 3\n    a[0] -= 1\n    a[3] -= 1\n    a[4] -= 1\nend\ntmp2 += a[0] / 2 * 2\ntmp2 += a[3] / 2 * 2\ntmp2 += a[4] / 2 * 2\nans = [tmp1, tmp2].max + a[1]\np ans", "label": 1, "name1": "s508741257.java", "name2": "s374653780.rb"}, {"id": 544, "code1": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\t//\u305d\u308c\u305e\u308c\u306e\u60a3\u8005\u306e\u756a\u53f7 p\n\t\t//1\u56de\u76ee\u306b\u6b69\u3044\u305f\u8ddd\u96e2 d1\n\t\t//2\u56de\u76ee\u306b\u6b69\u3044\u305f\u8ddd\u96e2 d2\n\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();//\u60a3\u8005\u306e\u6570 n\n\t\t\tint maxWalk = 0;//\u4e00\u756a\u6b69\u3044\u305f\u4eba\u306e\u8ddd\u96e2\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tMap<Integer, Integer> walkSum = new HashMap<Integer, Integer>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tint d1 = sc.nextInt();\n\t\t\t\tint d2 = sc.nextInt();\n\t\t\t\tint sumWalk = d1 + d2;\n\t\t\t\tif(sumWalk > maxWalk)maxWalk = sumWalk;\n\t\t\t\twalkSum.put(sumWalk,p);\n\t\t\t}\n\t\t\tSystem.out.println(walkSum.get((Object)maxWalk)+\" \"+maxWalk);\n\t\t}\n\t}\n}", "code2": "def  nnp1(n)\n    a=((n*2)**(0.5)).to_i\n    return a*(a+1)==n*2\nend\n\ndef  nnp(n)\n    a=((n*2)**(0.5)).to_i\n    return a\nend\n\nn=gets.strip.to_i\n\nif nnp1(n) == false \n    puts 'No'\n    exit\nend\nputs 'Yes'\na=nnp(n)\nx=Array.new(a+1).map{Array.new(a)}\nc=1\nputs a+1\n(0..a-1).each{|i|\n    \n    cc=c\n    (i..a-1).each{|j|\n        x[i][j]=cc\n        cc+=1\n    }\n\n    cc=c\n    (i+1..a).each{|j|\n        x[j][i]=cc\n        cc+=1\n    }\n    c=cc\n}\n\nx.each do |i|\n    print a.to_s + \" \"\n    puts i.join(\" \")\n\nend", "label": 0, "name1": "s421023762.java", "name2": "s713749025.rb"}, {"id": 236, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n    static class FS {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            return hasNextByte() ? buffer[ptr++] : -1;\n        }\n\n        private boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        private void skipUnprintable() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        }\n\n        public boolean hasNext() {\n            skipUnprintable();\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n    }\n\n    static int[] np;\n    static int n;\n\n    public static void main(String[] args) throws Exception {\n        FS fs = new FS();\n//        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n//        String s = bf.readLine();\n//        int n = Integer.parseInt(s.substring(0, s.indexOf(' ')));//n packages\n//        int k = Integer.parseInt(s.substring(s.indexOf(' '), s.length()));//k trucks\n        n = fs.nextInt();\n        int k = fs.nextInt();\n\n\n        np = new int[n];\n        int max = 0;\n        for (int i = 0; i < n; i++) {\n\n            np[i] = fs.nextInt();\n            max = max < np[i] ? np[i] : max;\n        }\n        int p = 0;\n        int resids = 0;\n\n        int maxInt = 10000 *100000;\n        int minInt = max-1;\n        int mid = (maxInt + minInt) / 2;\n        while (maxInt - minInt > 1) {\n            int v = checkN(mid);\n            if (v > k) minInt = mid;\n            else maxInt = mid;\n\n            mid = (maxInt + minInt) / 2;\n        }\n        System.out.println(maxInt);\n    }\n\n    private static int checkN(int p) {\n        int resids = p;\n        int ink = 1;//\u5f53\u524d\u5df2\u7528\u5361\u8f66\n        for (int i = 0; i < n; i++) {\n            int j = np[i];\n            if (resids >= j) {\n                resids -= j;\n            } else {\n                ink++;\n                resids = p;\n                i--;\n            }\n        }\n        return ink;\n    }\n}\n", "code2": "n, k = gets.chomp.split(' ').map(&:to_i)\nw = n.times.map{gets.chomp.to_i}\n\nN_MAX = K_MAX = 100000\nW_MAX = 10000\n\nleft = 0\nright = N_MAX * W_MAX\nmid = nil\n\nload_buggage = -> (p) do\n  i = 0\n  0.step(k-1) do |j|\n    s = 0\n    #STDERR.puts \"  kj=#{j}\"\n    while s + w[i] <= p\n      s += w[i]\n      #STDERR.puts \"    #{i}: w[#{i}]=#{w[i]}, s=#{s}\"\n      i += 1\n      break if i == n\n    end\n    break if i == n\n  end\n  #STDERR.puts \"load: #{i}\"\n  i\nend\n\nuntil (right - left) == 1 do\n  mid = (left + right) / 2\n  #STDERR.puts \"L=#{left}, M=#{mid}, R=#{right}\"\n  v = load_buggage.(mid)\n  if (v >= n)\n    right = mid\n  else\n    left = mid\n  end\nend\n\nputs right\n", "label": 1, "name1": "s272482227.java", "name2": "s107592187.rb"}, {"id": 189, "code1": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\n\nimport static java.util.Comparator.reverseOrder;\n\npublic class Main {\n\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n\n        List<Long> inputList = new ArrayList<Long>();\n        for(int i = 0; i < n ;i++) {\n            inputList.add(sc.nextLong());\n        }\n\n        /*\n        List<Integer> sortedList = inputList.stream().sorted(reverseOrder()).collect(Collectors.toList());\n        for(int a: sortedList) {\n            System.out.println(a);\n        }\n        */\n        List<Long> sortedList = inputList.stream().sorted(reverseOrder()).collect(Collectors.toList());\n        long result = sortedList.get(0);\n        int index = 1;\n        int count = 0;\n        for (int i = 0; i < n - 2 ; i++) {\n            result += sortedList.get(index);\n            count = count + 1;\n            if (count == 2) {\n                count = 0;\n                index = index + 1;\n            }\n        }\n        System.out.println(result);\n    }\n}", "code2": "gets\na = gets.chomp.split.map(&:to_i)\na = a.sort.reverse\n\ncount = 0\n\n(a.count - 1).times do |i|\n  count += a[((i + 1) / 2.0).to_i]\nend\n\np count\n", "label": 1, "name1": "s542407178.java", "name2": "s913271199.rb"}, {"id": 180, "code1": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tString str = scanner.nextLine();\n\t\tString[] ab = str.split(\" \");\n\t\tint a = Integer.parseInt(ab[0]);\n\t\tint b = Integer.parseInt(ab[1]);\n\t\tif (a > b) {\n\t\t\tSystem.out.println(a - 1);\n\t\t}else {\n\t\t\tSystem.out.println(a);\n\t\t}\n\t\t\n\t\tscanner.close();\n\n\t}\n\n}\n", "code2": "a,b=gets.split.map(&:to_i)\np a>b ?a-1:a", "label": 1, "name1": "s957138694.java", "name2": "s660994056.rb"}, {"id": 762, "code1": "import java.util.*;\nimport java.lang.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        long a = sc.nextLong();\n        long b = sc.nextLong();\n        long x = sc.nextLong();\n        long countA = a ==0 ? 0 : (a-1)/x+1;\n        long countB = b/x+1;\n        System.out.println(countB-countA);\n\n    }\n}\n", "code2": "n=gets.to_i\na=gets.split.map(&:to_i)\na.unshift 0\na.push 0\nsum=a.each_cons(2).map{|x,y|(x-y).abs}.inject(:+)\na.each_cons(3){|x,y,z|puts sum+(x-z).abs-(x-y).abs-(y-z).abs}", "label": 0, "name1": "s118772140.java", "name2": "s365262629.rb"}, {"id": 416, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.util.NoSuchElementException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author HBonsai\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CMultipleClocks solver = new CMultipleClocks();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CMultipleClocks {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int N = in.nextInt();\n            long[] T = in.nextLongArray(N);\n            long ans = T[0];\n            for (int i = 1; i < N; i++) {\n                long gcd = gcd(ans, T[i]);\n                ans = T[i] * (ans / gcd);\n            }\n            out.println(ans);\n        }\n\n        private static long gcd(long m, long n) {\n            if (m < n) return gcd(n, m);\n            if (n == 0) return m;\n            return gcd(n, m % n);\n        }\n\n    }\n\n    static class FastScanner implements Closeable {\n        private final InputStream in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        public FastScanner(InputStream in) {\n            this.in = in;\n        }\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        public boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n            return hasNextByte();\n        }\n\n        public long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        public int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] res = new long[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextLong();\n            }\n            return res;\n        }\n\n        public void close() {\n            try {\n                in.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n}\n\n", "code2": "a = []\ngets.to_i.times{ a << gets.to_i }\nputs a.inject{|x, y| x.lcm(y) }", "label": 1, "name1": "s654794279.java", "name2": "s688834112.rb"}, {"id": 816, "code1": "import java.util.*;\n\npublic class Main{\n    public static void main(String args[]){\n        Scanner sc = new Scanner(System.in);\n        \n        int N = sc.nextInt();\n        int[] a = new int[N];\n        int[] b = new int[N];\n        for(int i = 0; i < N; i++)\n            a[i] = sc.nextInt();\n        for(int i = 0; i < N; i++)\n            b[i] = sc.nextInt();\n        sc.close();\n        long sum1 = 0;\n        long sum2 = 0;\n        for(int i = 0; i < N; i++){\n            if(a[i] > b[i]){\n                sum1 += (a[i]-b[i]);\n            } else {\n                sum2 += (b[i]-a[i])/2;\n            }\n        }\n        if(sum1 <= sum2)\n            System.out.println(\"Yes\");\n        else\n            System.out.println(\"No\");\n\n    }\n}", "code2": "a = gets.split.map(&:to_i)\nputs a.uniq.size == 2 ? \"Yes\" : \"No\"\n", "label": 0, "name1": "s462003664.java", "name2": "s479750293.rb"}, {"id": 241, "code1": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\n\tstatic class TaskX {\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tint n = in.nextInt();\n\t\t\tint k = in.nextInt();\n\t\t\tint[] wn = in.nextIntArray(n);\n\n\t\t\tint left = 0;\n\t\t\tint right = INF;\n\t\t\tint mid = 0;\n\t\t\twhile (right > left + 1) {\n\t\t\t\tmid = (left + right) / 2;\n\t\t\t\tint count = 1;\n\t\t\t\tint ca = mid;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (ca - wn[i] >= 0) {\n\t\t\t\t\t\tca -= wn[i];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tca = mid;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tif (ca - wn[i] >= 0) {\n\t\t\t\t\t\t\tca -= wn[i];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcount = INF;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// k\u53f0\u4ee5\u4e0b\u3067\u7a4d\u3081\u308b\u5834\u5408\n\t\t\t\tif (count <= k){\n\t\t\t\t\tright = mid;\n\n\t\t\t\t// \uff4b\u53f0\u4ee5\u4e0a\u5fc5\u8981\u306a\u5834\u5408\n\t\t\t\t} else if (count > k) {\n\t\t\t\t\tleft = mid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout.println(right);\n\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\n\t}\n\n}\n\n", "code2": "n, k = gets.split( \" \" ).map { |val| val.to_i }\nw = []\nmaxW = sumW = 0\nn.times {\n\tnum = gets.to_i\n\tsumW += num\n\tw.push( num )\n\tmaxW = num if maxW < num\n}\n\nminP = 0\nif 1 == k\n\tminP = sumW\nelsif n == k\n\tminP = maxW\nelse\n\tleft = maxW\n\tright = 100000*10000\n\twhile left <= right\n\t\tmiddle = ( left+right ).div( 2 )\n\t\ttruckCnt = i = loadings = 0\n\n\t\twhile i < n\n\t\t\tloadings += w[i]\n\t\t\tif middle < loadings\n\t\t\t\ttruckCnt += 1\n\t\t\t\tbreak if k < truckCnt+1\n\t\t\t\tloadings = w[i]\n\t\t\tend\n\t\t\ti += 1\n\t\tend\n\t\t( minP = middle ) if truckCnt+1 <= k\n\t\t\n\t\tif k < truckCnt+1\n\t\t\tleft = middle + 1\t\t\n\t\telse\n\t\t\tright = middle - 1\n\t\tend\n\tend\nend\n\nputs( minP )", "label": 1, "name1": "s166648431.java", "name2": "s210429617.rb"}, {"id": 140, "code1": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        List<Integer> abc = new ArrayList<>();\n        abc.add(sc.nextInt());\n        abc.add(sc.nextInt());\n        abc.add(sc.nextInt());\n        Collections.sort(abc);\n\n        int count = 0;\n        int diff21 = abc.get(2) - abc.get(1);\n        abc.set(0, abc.get(0) + diff21);\n        abc.set(1, abc.get(1) + diff21);\n        count += diff21;\n\n        int diff10 = abc.get(1) - abc.get(0);\n        if (diff10 % 2 == 0) {\n            count += diff10 / 2;\n        } else {\n            count += (diff10 + 1) / 2 + 1;\n        }\n        System.out.println(count);\n    }\n\n}\n", "code2": "a,b,c = gets.chomp.split(' ').map(&:to_i)\nnum_of_odd = 0\narr = [[a,0],[b,0],[c,0]]\narr.each do |x|\n  if x[0] % 2 != 0\n    x[1] = 1\n    num_of_odd += 1\n  end\nend\ncount = 0\nif num_of_odd == 1#\u5076\u6570\u306b1\u3092\u8db3\u3059\u3002\n  count += 1\n  arr.each do |x|\n    if x[1] != 1\n      x[0] += 1\n    end\n  end\nelsif num_of_odd == 2#\u5947\u6570\u306b1\u3092\u8db3\u3059\u3002\n  count += 1\n  arr.each do |x|\n    if x[1] == 1\n      x[0] += 1\n    end\n  end\nend\nnums = [arr[0][0],arr[1][0],arr[2][0]] \nmax = nums.max\nnums.each do |num|\n  while max - num > 0\n    count += 1\n    num += 2\n  end\nend \nputs count", "label": 1, "name1": "s664157474.java", "name2": "s020203730.rb"}, {"id": 359, "code1": "import java.util.*;\nimport java.io.*;\n\npublic class Main implements Runnable {\n    public static void main(String[] args) {\n        Thread.setDefaultUncaughtExceptionHandler((t,e)->System.exit(1));\n        // keep stack\n        new Thread(null, new Main(), \"\", 16 * 1024 * 1024).start();\n    }\n    public void run() {\n        FastScanner sc = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        long X = sc.nextLong();\n        long Y = sc.nextLong();\n\n        long count = 1;\n        while(true) {\n            long A = X * 2;\n            if (Y < A) {\n                break;\n            }\n            X = A;\n            count++;\n        }\n        out.printf(\"%d\\n\", count);\n        out.flush();\n    }\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        } else {\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int readByte() {\n        if (hasNextByte()) {\n            return buffer[ptr++];\n        }\n        else {\n            return -1;\n        }\n    }\n\n    private static boolean isPrintableChar(int c) {\n        return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n        while (hasNextByte() && !isPrintableChar(buffer[ptr])) {\n            ptr++;\n        }\n    }\n\n    public boolean hasNext() {\n        skipUnprintable();\n        return hasNextByte();\n    }\n\n    public String next() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public int nextInt() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        int n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b)) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n\n    public long nextLong() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b)) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}", "code2": "x, y = gets.split.map(&:to_i)\n\nan = (y / x) * x\nl = 0\n\nloop do\n  l += 1\n  a = x * 2 ** l\n  break if a > an\nend\n\nputs l\n", "label": 1, "name1": "s869503854.java", "name2": "s287192340.rb"}, {"id": 543, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\n\n\npublic class Main {\n\n\tprivate BufferedReader reader = new BufferedReader(new InputStreamReader(System.in), 1);\n\n\tprivate String inputData = null;\n\n\tpublic String[] data = null;\n\n\tpublic int num = 0;\n\n\tpublic int count = 0;\n\n\tpublic HashMap<Integer, Integer> humanData = new HashMap<Integer, Integer>();\n\n\tpublic ArrayList<Integer> topId = new ArrayList<Integer>();\n\n\tpublic ArrayList<Integer> topLength = new ArrayList<Integer>();\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().start();\n\t\tSystem.exit(0);\n\t}\n\n\tpublic void start() {\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\tthis.inputData = reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t\t\tthis.data = this.inputData.split(\" \");\n\n\t\t\tif (this.data.length == 1) {\n\t\t\t\tif (this.data[0].equals(\"0\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tthis.num = Integer.parseInt(this.data[0]);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.humanData.clear();\n\n\t\t\tfor (int i = 0; i < this.num; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.inputData = reader.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tthis.data = this.inputData.split(\" \");\n\n\t\t\t\tthis.humanData.put(Integer.parseInt(data[0]),\n\t\t\t\t\t\tInteger.parseInt(data[1]) + Integer.parseInt(data[2]));\n\n\t\t\t}\n\n\t\t\tIterator<Integer> itId = this.humanData.keySet().iterator();\n\t\t\tint numCount = 0;\n\t\t\twhile (itId.hasNext()) {\n\t\t\t\tint id = itId.next();\n\t\t\t\tif (numCount == 0) {\n\t\t\t\t\tthis.topId.add(id);\n\t\t\t\t\tthis.topLength.add(this.humanData.get(id));\n\t\t\t\t} else {\n\t\t\t\t\tif (this.topLength.get(count) <= this.humanData.get(id)) {\n\t\t\t\t\t\tthis.topId.set(this.count, id);\n\t\t\t\t\t\tthis.topLength.set(this.count, this.humanData.get(id));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnumCount++;\n\t\t\t}\n\n\t\t\tthis.count++;\n\n\t\t}\n\n\t\tfor (int i = 0; i < this.topId.size(); i++) {\n\t\t\tSystem.out.println(this.topId.get(i) + \" \" + this.topLength.get(i));\n\t\t}\n\n\t}\n\n}", "code2": "n = gets.chomp.to_i\n\nif n == 1\n  puts 'Yes'\n  puts '2'\n  puts '1 1'\n  puts '1 1'\n  exit\nend\n\nif n == 3\n  puts 'Yes'\n  puts '3'\n  puts '2 1 2'\n  puts '2 3 1'\n  puts '2 2 3'\n  exit\nend\n\noks = [1]\n2.upto(10**5) do |i|\n  if i == (oks.last + oks.size + 1)\n    oks.push(i)\n  end\nend\n\nif !oks.include?(n)\n  puts 'No'\n  exit\nend\n\nnum = oks.index(n) + 1\n\nans = Array.new(num + 1) { Array.new }\ncounts = Array.new(n, 0)\n\ni = 1\n(1..num + 1).to_a.combination(2) do |a, b|\n  ans[a-1].push(i)\n  ans[b-1].push(i)\n   i += 1\nend\n\nputs 'Yes'\np num + 1\nans.each do |an|\n  puts \"#{an.size} #{an.join(' ')}\"\nend\n", "label": 0, "name1": "s083635030.java", "name2": "s963991485.rb"}, {"id": 863, "code1": "import java.io.*;\nimport java.util.*;\n\nclass Main{\n    public static void main(String args[])throws IOException{\n      try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))){\n        //input\n        String[] input = br.readLine().split(\" \");\n        int N = Integer.parseInt(input[0]);\n        int M = Integer.parseInt(input[1]);\n\n        //for algorithm & input\n        boolean[] answer = new boolean[N+1];\n        int[] wrong = new int[N+1];\n      \n        Arrays.fill(answer, false);\n        Arrays.fill(wrong, 0);\n        int pena = 0;\n        int result = 0;\n\n        for(int i = 0; i < M; i++){\n          String[] in = br.readLine().split(\" \");\n          int num = Integer.parseInt(in[0]);\n         \n          if(answer[num] == false){\n            if(in[1].equals(\"AC\")){\n              answer[num] = true;\n              result++;\n              pena += wrong[num];\n            }else{\n              wrong[num] += 1;\n            }\n          }else{\n            continue;\n          }\n        }\n\n        System.out.println(result + \" \" + pena);\n\n      }\n    }\n}\n", "code2": "A, B, C, X, Y = gets.split.map(&:to_i)\nans = 0\nx = X\ny = Y\nwhile x > 0 || y > 0\n  if x > 0 && y > 0\n    if C * 2 < A + B\n      ans += C * 2\n    else\n      ans += A + B\n    end\n    x -= 1\n    y -= 1\n  elsif x > 0\n    if C * 2 < A\n      ans += C * 2\n    else\n      ans += A\n    end\n    x -= 1\n  else # y > 0\n    if C * 2 < B\n      ans += C * 2\n    else\n      ans += B\n    end\n    y -= 1\n  end\nend\nputs ans\n", "label": 0, "name1": "s713620418.java", "name2": "s579966329.rb"}, {"id": 633, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        CTwoAlpinists solver = new CTwoAlpinists();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CTwoAlpinists {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            long[] t = in.readLongArray(n);\n            long[] a = in.readLongArray(n);\n\n            long[] max = new long[n];\n            long[] actual = new long[n];\n\n            {\n                for (int i = 0; i < n; i++) {\n                    max[i] = Math.min(t[i], a[i]);\n                }\n            }\n\n            {\n                long prev = 0;\n                for (int i = 0; i < n; i++) {\n                    if (t[i] > prev) {\n                        if (t[i] > max[i]) {\n                            out.printLine(0);\n                            return;\n                        }\n                        actual[i] = t[i];\n                        prev = t[i];\n                    }\n                }\n            }\n\n            {\n                long prev = 0;\n                for (int i = n - 1; i >= 0; i--) {\n                    if (a[i] > prev) {\n                        if (a[i] > max[i]) {\n                            out.printLine(0);\n                            return;\n                        }\n                        actual[i] = a[i];\n                        prev = a[i];\n                    }\n                }\n            }\n\n            long ans = 1;\n            for (int i = 0; i < n; i++) {\n                if (actual[i] != 0) continue;\n                ans = (ans * max[i]) % MiscUtils.MOD7;\n            }\n\n            out.printLine(ans);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public long[] readLongArray(int size) {\n            long[] array = new long[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readLong();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long readLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class MiscUtils {\n        public static final int MOD7 = (int) (1e9 + 7);\n\n    }\n}\n\n", "code2": "def get_min_point(points, ratio)\n\n  ap, bp = points\n  ar, br = ratio\n\n  an = get_min_count(ap, ar)\n  bn = get_min_count(bp, br)\n\n  mn = [an, bn].max\n  result = [ar*mn, br*mn]\n  result\nend\n\ndef get_min_count(ap, ar)\n  if ap % ar == 0\n    (ap / ar)\n  else\n    (ap / ar) + 1\n  end\nend\n\ninputs = readlines.map(&:chomp)\npoints = inputs[1].split(\" \").map(&:to_i)\nratios = inputs[2..-1].map {|x| x.split(\" \").map(&:to_i) }\n\nratios.each do |ratio|\n  points = get_min_point(points, ratio)\nend\n\nputs points.reduce(:+)\n", "label": 0, "name1": "s071160485.java", "name2": "s308934020.rb"}, {"id": 509, "code1": "import java.util.*;\n\npublic class Main{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n\n    String[] s = sc.next().split(\"\");\n    int l =  s.length;\n    int count =0;\n    for(int i=0; i<l; i++){\n      if(s[i].equals(\"U\")||s[i].equals(\"D\")){\n        count +=1;\n        continue;\n      }\n\n\n      if(i%2==0){\n        if(s[i].equals(\"R\")){\n          count += 1;\n        }\n      }else{\n        if(s[i].equals(\"L\")){\n          count += 1;\n        }\n      }\n    }\n    if(count == l){\n      System.out.println(\"Yes\");\n    }else{\n      System.out.println(\"No\");\n    }\n\n\n\n\n  }\n}", "code2": "n, a, b = gets.split.map(&:to_i)\nxs = gets.split.map(&:to_i)\n\nans = 0\n(n-1).times do |i|\n    ans += [(xs[i+1] - xs[i])*a, b].min\nend\n\nputs ans\n\n", "label": 0, "name1": "s855266906.java", "name2": "s703254975.rb"}, {"id": 825, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    private static class FastScanner {\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        public String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        int array[] = new int[3], num = 0;\n        int count = 0;\n\n        while (count < 3) {\n            num = sc.nextInt();\n            if (0 < num && num < 10) {\n                array[count] = num;\n                count++;\n            }\n        }\n\n\n        for (int i = 0; i < 3; i++) {\n            for (int j = i + 1; j < 3; j++) {\n                if (array[i] == array[j]) {\n                    count = count - 1;\n                }\n            }\n        }\n        if (count == 2) {\n            System.out.print(\"Yes\");\n        } else {\n            System.out.print(\"No\");\n        }\n    }\n}\n", "code2": "# frozen_string_literal: true\n\ndef read\n  [gets.to_i, gets.chomp]\nend\n\ndef solve(_, s)\n  min = Float::INFINITY\n  cnt = { e: 0, w: 0 }\n  table = [cnt.dup]\n  s.chars.each_with_index do |c, i|\n    k = if c == 'W' then :w\n        else :e\n        end\n    cnt[k] += 1\n    table[i + 1] = cnt.dup\n  end\n  table.each do |el|\n    c = el[:w] + table.last[:e] - el[:e]\n    min = c if c < min\n  end\n  min\nend\n\nputs solve(*read)\n# puts [\n#   solve(5, 'WEEWW') == 1,\n#   solve(12, 'WEWEWEEEWWWE') == 4,\n#   solve(8, 'WWWWWEEE') == 3\n# ].all?\n", "label": 0, "name1": "s136290389.java", "name2": "s025378271.rb"}, {"id": 105, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        double[] a = new double[]{sc.nextDouble(), sc.nextDouble(), sc.nextDouble()};\n        System.out.println(a[0] * a[1] * Math.sin((Math.PI / 180) * a[2]) / 2.0);\n        System.out.println(\n            a[0] + a[1] + Math.sqrt(a[0] * a[0] + a[1] * a[1] - 2 * a[0] * a[1] * Math.cos(Math.PI / 180 * a[2])));\n        System.out.println(a[1] * Math.sin(Math.PI / 180 * a[2]));\n    }\n}", "code2": "inputs = gets.strip.split(\" \").map{|i| i.to_f}\na, b, c = inputs[0], inputs[1], inputs[2]\nrad_c = (Math::PI / 180.0) * c \nd = Math.sqrt(a**2 + b**2 - 2*a*b*Math.cos(rad_c))\ns = 0.5 * a * b * Math.sin(rad_c)\nl = a + b + d\nh = 2*s / a\nputs s.floor(4)\nputs l.floor(4)\nputs h.floor(4)\n", "label": 1, "name1": "s203375488.java", "name2": "s843747761.rb"}, {"id": 581, "code1": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\t\n\tpublic static void main(String[] args) {\n\t\tFastScanner scanner=new FastScanner();\n\t\tint n=scanner.nextInt(),k=scanner.nextInt();\n\t\tint a[]=scanner.readArray(n);\n\t\t\n\t\tboolean dp[]=new boolean[k+1];\n//\t\tArrays.fill(dp, true);\n//\t\tdp[0]=false;\n\t\t\n\t\tfor(int stones=0;stones<=k;stones++) {\n\t\t\tfor(int j:a)\n\t\t\t\tif(j<=stones&&!dp[stones-j]) dp[stones]=true;\n\t\t}\n\t\tif(dp[k]) System.out.println(\"First\");\n\t\telse System.out.println(\"Second\");\n\t\n\t\t\n\t\t\n\n\t}\n\tstatic class FastScanner{\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\t\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tdouble nextDoubel() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tint [] readArray(int n) {\n\t\t\tint a[]=new int[n];\n\t\t\tfor(int i=0;i<n;i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\t\n\t}\n\n}\n\n", "code2": "a, b, c = gets().chomp.split(\"\\s\").map{|x| x.to_i}\n\nl = [a, b, c].sort()\n\ndiff1 = l[2] - l[0]\ndiff2 = l[2] - l[1]\n\nr = diff2\nrem = diff1 - diff2\n\nif rem.even?\n  r += rem / 2\n  puts r\n  exit()\nend\n\nr += rem / 2 + 1\nr += 1\n\nputs r\n", "label": 0, "name1": "s041813111.java", "name2": "s904033547.rb"}, {"id": 758, "code1": "import java.util.Scanner;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    long a = sc.nextLong();\n    long b = sc.nextLong();\n    long c;\n    long x = sc.nextLong();\n    if(a%x == 0) {\n      c = a / x -1;\n    }else {\n      c = a / x;\n    }\n    System.out.println(b/x-c);\n  }\n}\n", "code2": "#!/usr/local/bin/ruby\nn=gets.to_i\nputs rec=gets.split(\" \").map(&:to_i).sort.join(\" \")", "label": 0, "name1": "s320140275.java", "name2": "s940788758.rb"}, {"id": 745, "code1": "\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.AbstractCollection;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Comparator;\nimport java.util.ArrayList;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author silviase\n */\npublic class Main {\n    \n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DijkstraVerify solver = new DijkstraVerify();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DijkstraVerify {\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            int source = in.nextInt();\n            Graph g = new Graph(n);\n            for (int i = 0; i < m; i++) {\n                g.addEdge(new Edge(in.nextInt(), in.nextInt(), in.nextInt()));\n            }\n            long[] d = g.dijkstra(source);\n            for (int i = 0; i < n; i++) {\n                if (d[i] > 1e15) out.println(\"INF\");\n                else out.println(d[i]);\n            }\n        }\n\n    }\n\n    static class Graph {\n        public int size;\n        public ArrayList<Edge>[] adj;\n        public int[] inDeg;\n        public int[] vertexCost;\n\n        @SuppressWarnings(\"unchecked\")\n        public Graph(int size) {\n            this.size = size;\n            adj = new ArrayList[size];\n            inDeg = new int[size];\n            vertexCost = new int[size];\n            for (int i = 0; i < size; i++) {\n                adj[i] = new ArrayList<>();\n            }\n        }\n\n        public void addEdge(Edge e) {\n            adj[e.from].add(e);\n            inDeg[e.to]++;\n        }\n\n        public long[] dijkstra(int from) {\n            long[] d = new long[size];\n            PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.comparing(e -> d[e]));\n            for (int i = 0; i < size; i++) {\n                d[i] = (i == from) ? 0 : (long) 1e18;\n                pq.add(i);\n            }\n            // System.out.println(Arrays.toString(pq.toArray()));\n            while (!pq.isEmpty()) {\n                int search = pq.poll();\n                // System.out.println(\"now: \" + search);\n                ArrayList<Edge> edges = adj[search];\n                for (Edge e : edges) {\n                    // System.out.println(e.toString());\n                    long cmp = d[search] + e.cost;\n                    if (d[e.to] > d[search] + e.cost) {\n                        // \u66f4\u65b0\u304c\u5165\u308b\n                        // \u51e6\u7406\u3092\u5165\u308c\u305f\u3044\u5834\u5408\u306f\u3053\u3053\u306b\u5165\u308c\u308b\n                        d[e.to] = d[search] + e.cost;\n                        pq.add(e.to);\n                    }\n                }\n                //  System.out.println(Arrays.toString(pq.toArray()));\n            }\n            return d;\n        }\n\n    }\n\n    static class Edge {\n        public int from;\n        public int to;\n        public long cost;\n\n        public Edge(int to) {\n            this.to = to;\n        }\n\n        public Edge(int to, long cost) {\n            this.to = to;\n            this.cost = cost;\n        }\n\n        public Edge(int from, int to, long cost) {\n            this.from = from;\n            this.to = to;\n            this.cost = cost;\n        }\n\n        public String toString() {\n            return \"Edge{\" +\n                    \"from=\" + from +\n                    \", to=\" + to +\n                    \", cost=\" + cost +\n                    '}';\n        }\n\n    }\n}\n\n\n", "code2": "#!/usr/bin/ruby\nh,w=gets.split.map(&:to_i)\nm=$<.map{|e|e.chomp[1..-2]}\n2.times{|i|h.times{|y|\n\tif i==0\n\t\tif y%2==0\n\t\t\tputs '#'*(w-1)+'.'\n\t\telse\n\t\t\tputs '#'+m[y]+'.'\n\t\tend\n\telse\n\t\tif y%2==0\n\t\t\tputs '.'+m[y]+'#'\n\t\telse\n\t\t\tputs '.'+'#'*(w-1)\n\t\tend\n\tend\n};puts}", "label": 0, "name1": "s326905326.java", "name2": "s030629079.rb"}, {"id": 530, "code1": "import java.util.Scanner;\nimport java.util.Arrays;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\nclass Main{\n          public static void main(String[] args) {\n                  Scanner scan = new Scanner(System.in);\n                  int count = 0;\n                  int N = scan.nextInt();\n                  int a[] = new int[N];\n                  for (int i = 0; i < N; i++) {\n                          a[i] = scan.nextInt();\n                  }\n                  for(int j = 1; j < N; j++){\n                          if (a[j-1] == a[j]) {\n                                  a[j] = 10001;\n                                  count++;\n                          }\n                  }\n                  System.out.println(count);\n                  }\n}\n", "code2": "ss = 0\n4.times do\n  ss += gets.strip.to_i\nend\n \nputs ss / 60\nputs ss % 60", "label": 0, "name1": "s420774674.java", "name2": "s733866069.rb"}, {"id": 406, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int N = sc.nextInt();\n        int[] a = new int[N];\n        for (int i=0; i<N; i++) {\n            a[i] = sc.nextInt();\n        }\n\n        int[] ans = solve(N, a);\n\n        for (int i=0; i<N; i++) {\n            System.out.println(ans[i]);\n        }\n    }\n\n    private static int[] solve(int N, int[] a) {\n        int[] ans = new int[N];\n        int total = Math.abs(a[0]) + Math.abs(a[N-1]);\n\n        for (int i=0; i<N-1; i++) {\n            total += Math.abs(a[i+1] - a[i]);\n        }\n\n        for (int i=0; i<N; i++) {\n            ans[i] = total;\n\n            if (i == 0) {\n                if (0 <= a[i] && a[i] <= a[i+1]\n                        || a[i+1] <= a[i] && a[i] <= 0) {\n//                    System.err.println(\"ans[\" + i + \"] : skip\");\n                    continue;\n                }\n                ans[i] = total - Math.abs(a[i] - 0) - Math.abs(a[i] - a[i+1]) + Math.abs(a[i+1] - 0);\n//                System.err.println(\"ans[\" + i + \"] = \" + ans[i]);\n            } else if (i == N-1) {\n                if (0 <= a[i] && a[i] <= a[i-1]\n                        || a[i-1] <= a[i] && a[i] <= 0) {\n//                    System.err.println(\"ans[\" + i + \"] : skip\");\n                    continue;\n                }\n\n                ans[i] = total - Math.abs(a[i] - 0) - Math.abs(a[i] - a[i-1]) + Math.abs(a[i-1] - 0);\n//                System.err.println(\"ans[\" + i + \"] = \" + ans[i]);\n            }\n            else if (a[i-1] <= a[i] && a[i] <= a[i+1]\n                    || a[i+1] <= a[i] && a[i] < a[i-1]) {\n//                System.err.println(\"ans[\" + i + \"] : skip\");\n                continue;\n            } else {\n                ans[i] = total - Math.abs(a[i] - a[i-1]) - Math.abs(a[i] - a[i+1]) + Math.abs(a[i+1] - a[i-1]);\n//                System.err.println(\"ans[\" + i + \"] = \" + ans[i]);\n            }\n        }\n\n        return ans;\n    }\n}", "code2": "n = gets.chomp.to_i\nt = gets.chomp.split(' ').map {|v| v.to_i}\nt.unshift(0)\nt.push(0)\n\not = Array.new(t.length, 0)\n\nall = 0\nfor i in 1...t.length do\n  v = t[i] - t[i - 1]\n  ot[i] = v\n  all += v.abs\nend\n\nfor i in 1...t.length - 1 do\n  f = all - ot[i].abs - ot[i + 1].abs\n  v = t[i + 1] - t[i - 1]\n  f += v.abs\n\n  puts f\nend\n\n\n", "label": 1, "name1": "s919464469.java", "name2": "s176193708.rb"}, {"id": 739, "code1": "import java.util.*;\nimport java.io.*;\n\npublic class Main implements Runnable {\n    public static void main(String[] args) {\n        Thread.setDefaultUncaughtExceptionHandler((t,e)->System.exit(1));\n        // keep stack\n        new Thread(null, new Main(), \"\", 16 * 1024 * 1024).start();\n    }\n    public void run() {\n        FastScanner sc = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        long X = sc.nextLong();\n        long Y = sc.nextLong();\n\n        long count = 1;\n        while(true) {\n            long A = X * 2;\n            if (Y < A) {\n                break;\n            }\n            X = A;\n            count++;\n        }\n        out.printf(\"%d\\n\", count);\n        out.flush();\n    }\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        } else {\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int readByte() {\n        if (hasNextByte()) {\n            return buffer[ptr++];\n        }\n        else {\n            return -1;\n        }\n    }\n\n    private static boolean isPrintableChar(int c) {\n        return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n        while (hasNextByte() && !isPrintableChar(buffer[ptr])) {\n            ptr++;\n        }\n    }\n\n    public boolean hasNext() {\n        skipUnprintable();\n        return hasNextByte();\n    }\n\n    public String next() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public int nextInt() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        int n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b)) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n\n    public long nextLong() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b)) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}", "code2": "a = gets.split.map(&:to_i)\ntmp1 = 0\ntmp1 += a[0] / 2 * 2\ntmp1 += a[3] / 2 * 2\ntmp1 += a[4] / 2 * 2\ntmp2 = 0\nif a[0] > 0 && a[3] > 0 && a[4] > 0\n    tmp2 += 3\n    a[0] -= 1\n    a[3] -= 1\n    a[4] -= 1\nend\ntmp2 += a[0] / 2 * 2\ntmp2 += a[3] / 2 * 2\ntmp2 += a[4] / 2 * 2\nans = [tmp1, tmp2].max + a[1]\np ans", "label": 0, "name1": "s869503854.java", "name2": "s374653780.rb"}, {"id": 577, "code1": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        int c = sc.nextInt();\n\n        int min = Math.min(a, b);\n        int max = Math.max(a, b);\n        \n        boolean ans = false;\n        if (min < c && c < max)\n            ans = true;\n        System.out.println(ans ? \"Yes\" : \"No\");\n    }\n}", "code2": "d=*1..gets.to_i;\ngets.chop.bytes{|c|\n\tx=0;n=d.pop;\n\td.map!{|a|x=(x+n*c[1]+(1-c%3)*a).%10**9+7}\n}\np *d", "label": 0, "name1": "s912321420.java", "name2": "s587396214.rb"}, {"id": 58, "code1": "import java.util.*;\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int x = 0, y = 0; \n\tstatic String second;\n\tstatic int second_ = 0;\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO \u30c4\u7be0\u30a5\u30c4\u7763\u30e7\u30c4\u9752\u30ab\u30c4\u9752\u30e3\u30c4\u3064\u30a6\u30c4\u3065\u30a7\u30c4\u3064\u30b9\u30c4\u03b4\u30bd\u30c4\u30c3\u30c4\u30c9\u30c4\u30fb\u30c4\u30b9\u30c4\u30bf\u30c4\u30d6\n\t\tread();\t\n\t\tslove();\n\t\t\n\t}\n\tstatic boolean read(){\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tsecond = sc.next();\n\t\t\tsecond_ = second_ + Integer.parseInt(second);\n\t\t}\n\t\t//System.out.println(second_);\n\t\treturn true;\n\t}\n\tstatic void slove(){\n\t\tx = second_/60;\n\t\ty = second_ % 60;\n\t\tSystem.out.println(x);\n\t\tSystem.out.println(y);\n\t}\n}", "code2": "n=0\n4.times do\n  n+=gets.chomp.to_i\nend\n\np n/60\np n%60", "label": 1, "name1": "s543682667.java", "name2": "s834558089.rb"}, {"id": 858, "code1": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int N = in.nextInt();\n        int[] A = new int[N];\n        for (int i = 0; i < N; i++) {\n            A[i] = in.nextInt();\n        }\n        int ans = A[0];\n        for (int i = 1; i < N; i++) {\n            ans = gcd(ans, A[i]);\n        }\n        System.out.println(ans);\n    }\n\n    public static int gcd(int x, int y) {\n        return y == 0 ? x : gcd(y, x % y);\n    }\n}", "code2": "def fact(n)\n\t(1..n).inject(:*)\nend\n#fact(1500).to_s.length\nstart = fact(1500)+2\nn = gets.to_i\np start\nn.times {|k|\n\tp 2+k\n}", "label": 0, "name1": "s343621637.java", "name2": "s426934559.rb"}, {"id": 834, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    int n;\n    char[] cs;\n\n    public static void main(String args[]) {\n        new Main().run();\n    }\n\n    void run() {\n        FastReader sc = new FastReader();\n        n = sc.nextInt();\n        cs = sc.next().toCharArray();\n        solve();\n    }\n\n    void solve() {\n        int[] sumEastL = new int[n];\n        if (cs[0] == 'E') {\n            sumEastL[0] = 1;\n        }\n        for (int i = 1; i < n; i++) {\n            sumEastL[i] = sumEastL[i - 1] + (cs[i] == 'E' ? 1 : 0);\n        }\n        int min = 10000000;\n        for (int i = 0; i < n; i++) {\n            int num = sumEastL[n - 1] - sumEastL[i] + (i > 0 ? i - sumEastL[i - 1] : 0);\n            if (min > num) {\n                min = num;\n            }\n        }\n        System.out.println(min);\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n", "code2": "N, L, T = gets.split.map(&:to_i)\nXW = N.times.map { gets.split.map(&:to_i) }\n\nX0, W0 = XW.first\nnum = 0\nrotate_count = T / L\nrotate_len = T % L\n1.upto(N - 1) do |i|\n  x, w = XW[i]\n  next if w == W0\n  num += rotate_count * 2\n  if W0 == 1\n    d = x - X0\n    num += 1 if rotate_len * 2 > d\n    num += 1 if rotate_len * 2 > d + L\n  else\n    d = L + X0 - x\n    num += 1 if rotate_len * 2 >= d\n    num += 1 if rotate_len * 2 >= d + L\n  end\nend\n\nnew_x = XW.map do |x, w|\n  x = x + rotate_len * (w == 1 ? 1 : -1)\n  x %= L\nend\n\nnew_x0 = new_x.first\nnew_x.sort!\npos = new_x.find_index(new_x0)\nnew_x = new_x.rotate(W0 == 1 ? pos - num : pos + num)\nputs new_x\n", "label": 0, "name1": "s171588206.java", "name2": "s217387487.rb"}, {"id": 866, "code1": "import java.math.*;\nimport java.io.*;\n\n\nclass Main\n{\n    \n    public static void main(String args[])throws IOException\n    {\n\tBigInteger a = new BigInteger(\"1\");\n\tfor(int i=2;i<=1501;i++)\n\t    a = a.multiply(new BigInteger(Integer.toString(i)));\n\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));   \n\ta = a.add(new BigInteger(\"2\"));\n\tint n = Integer.parseInt(in.readLine());\n\tSystem.out.println(a);\n\tfor(int i=2;i<n+2;i++)\n\t    System.out.println(i);\n\n    }\n\n}", "code2": "A, B, C, X, Y = gets.split.map(&:to_i)\nans = 0\nx = X\ny = Y\nwhile x > 0 || y > 0\n  if x > 0 && y > 0\n    if C * 2 < A + B\n      ans += C * 2\n    else\n      ans += A + B\n    end\n    x -= 1\n    y -= 1\n  elsif x > 0\n    if C * 2 < A\n      ans += C * 2\n    else\n      ans += A\n    end\n    x -= 1\n  else # y > 0\n    if C * 2 < B\n      ans += C * 2\n    else\n      ans += B\n    end\n    y -= 1\n  end\nend\nputs ans\n", "label": 0, "name1": "s566455859.java", "name2": "s579966329.rb"}, {"id": 871, "code1": "import java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String args[]){\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tint num = sc.nextInt();\n\n\t\tBigInteger big_num = BigInteger.valueOf(1);\n\n\t\tfor(int i = 2; i <= num+1; i++){\n\t\t\tbig_num = big_num.multiply(BigInteger.valueOf(i));\n\t\t}\n\n\t\tSystem.out.println(big_num.add(BigInteger.valueOf(2)));\n\n\t\tfor(int i = 2; i <= num+1; i++){\n\t\t\tSystem.out.println(i);\n\t\t}\n\n\t}\n}", "code2": "a,b = gets.split.map(&:to_s)\nputs \"H\" if a == b\nputs \"D\" if a != b", "label": 0, "name1": "s634203769.java", "name2": "s017635501.rb"}, {"id": 747, "code1": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)924844033;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint ai = io.nextInt();\n\t\t\tint ao = io.nextInt();\n\t\t\tint at = io.nextInt();\n\t\t\tint aj = io.nextInt();\n\t\t\tint al = io.nextInt();\n\t\t\tint as = io.nextInt();\n\t\t\tint az = io.nextInt();\n\t\t\t\n\t\t\tlong ans = 0;\n\t\t\t\n\t\t\tint cnt = aj % 2 + al % 2 + ai % 2;\n\t\t\tif (cnt >= 2) {\n\t\t\t\tif (aj > 0 && al > 0 && ai > 0) {\n\t\t\t\t\tai--;\n\t\t\t\t\taj--;\n\t\t\t\t\tal--;\n\t\t\t\t\tans += 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += ao;\n\t\t\tans += ai / 2 * 2;\n\t\t\tans += aj / 2 * 2;\n\t\t\tans += al / 2 * 2;\n\t\t\t\n\t\t\tio.out.println(ans);\n\t\t}\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n", "code2": "H, W = gets.split.map(&:to_i)\nas = []\nH.times do |i|\n    as[i] = gets.chomp\nend\n\nrs = Array.new(H){Array.new(W, '.')}\nbs = Array.new(H){Array.new(W, '.')}\nrs[0] = Array.new(W, '#')\nbs[H-1] = Array.new(W, '#')\n\n(1...(H-1)).each do |i|\n    W.times do |j|\n        if as[i][j] == '#' || j % 2 == 0\n            rs[i][j] = '#'\n        end\n        if as[i][j] == '#' || j % 2 == 1\n            bs[i][j] = '#'\n        end\n    end\nend\n\nH.times do |i|\n    puts rs[i].join\nend\n\nputs\n\nH.times do |i|\n    puts bs[i].join\nend", "label": 0, "name1": "s961512992.java", "name2": "s600860222.rb"}, {"id": 139, "code1": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        List<Integer> abc = new ArrayList<>();\n        abc.add(sc.nextInt());\n        abc.add(sc.nextInt());\n        abc.add(sc.nextInt());\n        Collections.sort(abc);\n\n        int count = 0;\n        int diff21 = abc.get(2) - abc.get(1);\n        abc.set(0, abc.get(0) + diff21);\n        abc.set(1, abc.get(1) + diff21);\n        count += diff21;\n\n        int diff10 = abc.get(1) - abc.get(0);\n        if (diff10 % 2 == 0) {\n            count += diff10 / 2;\n        } else {\n            count += (diff10 + 1) / 2 + 1;\n        }\n        System.out.println(count);\n    }\n\n}\n", "code2": "array = gets.split(\" \").map { |e| e.to_i }\n\nguki = [0,0,0] #\u4e09\u3064\u306e\u5076\u5947\u3092\u8abf\u3079\u308b\nki = 0\nfor i in 0..2 do\n  if array[i]%2 == 1\n    guki[i] = 1\n    ki += 1\n  end\nend\n\ncount = 0\n\nif ki == 1 #\u5076\u5947\u3092\u63c3\u3048\u308b\n  for i in 0..2 do\n    if guki[i] == 0\n      array[i] += 1\n    end\n  end\n  count += 1\nelsif ki == 2\n  for i in 0..2 do\n    if guki[i] == 1\n      array[i] += 1\n    end\n  end\n  count += 1\nend\n\nmax = array.max #\u3044\u3061\u3070\u3093\u5927\u304d\u3044\u306e\u306b\u5408\u308f\u305b\u308b\nfor i in 0..2 do\n  if array[i] < max\n    count += (max - array[i]) / 2\n  end\nend\n\nputs count\n", "label": 1, "name1": "s664157474.java", "name2": "s981224172.rb"}, {"id": 622, "code1": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\n\tprivate static Scanner sc;\n\tprivate static Printer pr;\n\n\tprivate static void solve() {\n\t\tint a = sc.nextInt();\n\t\tint b = sc.nextInt();\n\n\t\tif (b < a) {\n\t\t\ta--;\n\t\t}\n\n\t\tpr.println(a);\n\t}\n\n\t// ---------------------------------------------------\n\tpublic static void main(String[] args) {\n\t\tsc = new Scanner(INPUT == null ? System.in : new ByteArrayInputStream(INPUT.getBytes()));\n\t\tpr = new Printer(System.out);\n\n\t\tsolve();\n\n//\t\tpr.close();\n\t\tpr.flush();\n//\t\tsc.close();\n\t}\n\n\tstatic String INPUT = null;\n\n\tprivate static class Printer extends PrintWriter {\n\t\tPrinter(OutputStream out) {\n\t\t\tsuper(out);\n\t\t}\n\t}\n}\n", "code2": "N = gets.to_i\nA = gets.split.map(&:to_i).sort\n\nans = A.pop\n(N-2).times do |i|\n  ans += i.odd? ? A.pop : A[-1]\nend\nputs ans", "label": 0, "name1": "s998480605.java", "name2": "s029357848.rb"}, {"id": 123, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.IntStream;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMain main = new Main();\n\t\tmain.solve();\n\t}\n\n\tprivate void solve() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tint[] a = new int[N];\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\ta[j] = sc.nextInt();\n\t\t}\n\t\tboolean[] dp = new boolean[K + 1];\n\t\tfor (int i = 0; i <= K; i++) {\n\t\t\tboolean isWin = false;\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (a[j] <= i && !dp[i - a[j]]) {\n\t\t\t\t\tisWin = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i] = isWin;\n\t\t}\n\t\tSystem.out.println(dp[K] ? \"First\" : \"Second\");\n\t}\n\n\tclass Scanner {\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int index;\n\t\tprivate int length;\n\n\t\tpublic Scanner(InputStream in) {\n\t\t\tthis.in = in;\n\t\t}\n\n\t\tprivate boolean isPrintableChar(int c) {\n\t\t\treturn '!' <= c && c <= '~';\n\t\t}\n\n\t\tprivate boolean isDigit(int c) {\n\t\t\treturn '0' <= c && c <= '9';\n\t\t}\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (index < length) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tlength = in.read(buffer);\n\t\t\t\t\tindex = 0;\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\treturn length > 0;\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[index])) {\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\treturn hasNextByte() ? buffer[index++] : -1;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) {\n\t\t\t\tthrow new RuntimeException(\"no input\");\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) {\n\t\t\t\tthrow new RuntimeException(\"no input\");\n\t\t\t}\n\t\t\tlong value = 0L;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tif (isDigit(b)) {\n\t\t\t\t\tvalue = value * 10 + (b - '0');\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn minus ? -value : value;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n\n\tinterface CombCalculator {\n\t\tlong comb(int n, int m);\n\t}\n\n\tinterface MobiusFunction {\n\t\tint get(int n);\n\t}\n\n\t/**\n\t * \u30e1\u30d3\u30a6\u30b9\u95a2\u6570\u3092\u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9\u3063\u307d\u304f\u524d\u8a08\u7b97\u3059\u308b\u30af\u30e9\u30b9\u3067\u3059\u3002\n\t * \u8a08\u7b97\u91cf\u306fO(1)\u3067\u3001\u524d\u8a08\u7b97\u3067O(N logN)\u3067\u3059\u3002\n\t */\n\tclass SieveMobiusFunction implements MobiusFunction {\n\t\tint size;\n\t\tint[] mobiusFunctionValues;\n\n\t\tpublic SieveMobiusFunction(int size) {\n\t\t\tthis.size = size;\n\t\t\tmobiusFunctionValues = new int[size];\n\n\t\t\tmobiusFunctionValues[0] = 0;\n\t\t\tmobiusFunctionValues[1] = 1;\n\t\t\tfor (int i = 2; i < size; i++) {\n\t\t\t\tmobiusFunctionValues[i] = 1;\n\t\t\t}\n\t\t\tfor (int i = 2; i * i < size; i++) {\n\t\t\t\tfor (int k = 1; i * i * k < size; k++) {\n\t\t\t\t\tmobiusFunctionValues[i * i * k] *= 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 2; i < size; i++) {\n\t\t\t\tif (mobiusFunctionValues[i] == 1) {\n\t\t\t\t\tfor (int k = 1; i * k < size; k++) {\n\t\t\t\t\t\tmobiusFunctionValues[i * k] *= -2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mobiusFunctionValues[i] > 1) {\n\t\t\t\t\tmobiusFunctionValues[i] = 1;\n\t\t\t\t}\n\t\t\t\tif (mobiusFunctionValues[i] < -1) {\n\t\t\t\t\tmobiusFunctionValues[i] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int get(int n) {\n\t\t\tif (n > size) {\n\t\t\t\tthrow new RuntimeException(\"n is greater than size.\");\n\t\t\t}\n\t\t\tif (n < 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn mobiusFunctionValues[n];\n\t\t}\n\t}\n\n\t/**\n\t * \u30e1\u30d3\u30a6\u30b9\u95a2\u6570\u3092\u5b9a\u7fa9\u901a\u308a\u8a08\u7b97\u3059\u308b\u30af\u30e9\u30b9\u3067\u3059\u3002\n\t * \u8a08\u7b97\u91cf\u306fO(logN)\u3067\u3059\u3002\n\t */\n\tclass PrimeFactorizationMobiusFunction implements MobiusFunction {\n\t\t@Override\n\t\tpublic int get(int n) {\n\t\t\tif (n <= 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (n == 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tint num = 0;\n\t\t\tfor (int i = 2; i < n; i++) {\n\t\t\t\tif (n % i == 0) {\n\t\t\t\t\tn /= i;\n\t\t\t\t\tnum++;\n\t\t\t\t\tif (n % i == 0) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn num % 2 == 0 ? -1 : 1;\n\t\t}\n\t}\n\n\t/**\n\t * \u7d44\u307f\u5408\u308f\u305b\u8a08\u7b97\u3092\u968e\u4e57\u306e\u5024\u3067\u884c\u3046\u30af\u30e9\u30b9\u3067\u3059(MOD\u5bfe\u5fdc)\n\t * \u968e\u4e57\u3068\u305d\u306e\u9006\u5143\u306f\u524d\u8a08\u7b97\u3057\u3066\u30c6\u30fc\u30d6\u30eb\u306b\u683c\u7d0d\u3057\u307e\u3059\u3002\n\t * C(N, N) % M \u306e\u8a08\u7b97\u91cf\u306f O(1)\u3001 \u524d\u8a08\u7b97\u3067O(max(N, logM))\u3067\u3059\u3002\n\t * size\u30921e8\u3088\u308a\u5927\u304d\u3044\u5024\u3067\u5b9f\u884c\u3059\u308b\u3068MLE\u306e\u5371\u967a\u6027\u304c\u3042\u308a\u307e\u3059\u3002\n\t * \u307e\u305f\u7d20\u6570\u4ee5\u5916\u306eMOD\u306b\u306f\u5bfe\u5fdc\u3057\u3066\u3044\u307e\u305b\u3093(\u9006\u5143\u306e\u8a08\u7b97\u306b\u7d20\u6570\u306e\u5270\u4f59\u74b0\u306e\u6027\u8cea\u3092\u5229\u7528\u3057\u3066\u3044\u308b\u305f\u3081)\u3002\n\t */\n\tclass FactorialTableCombCalculator implements CombCalculator {\n\t\tint size;\n\t\tlong[] factorialTable;\n\t\tlong[] inverseFactorialTable;\n\t\tlong mod;\n\n\t\tpublic FactorialTableCombCalculator(int size, long mod) {\n\t\t\tthis.size = size;\n\t\t\tfactorialTable = new long[size + 1];\n\t\t\tinverseFactorialTable = new long[size + 1];\n\t\t\tthis.mod = mod;\n\n\t\t\tfactorialTable[0] = 1L;\n\t\t\tfor (int i = 1; i <= size; i++) {\n\t\t\t\tfactorialTable[i] = (factorialTable[i - 1] * i) % mod;\n\t\t\t}\n\t\t\tinverseFactorialTable[size] = inverse(factorialTable[size], mod);\n\t\t\tfor (int i = size - 1; i >= 0; i--) {\n\t\t\t\tinverseFactorialTable[i] = (inverseFactorialTable[i + 1] * (i + 1)) % mod;\n\t\t\t}\n\t\t}\n\n\t\tprivate long inverse(long n, long mod) {\n\t\t\treturn pow(n, mod - 2, mod);\n\t\t}\n\n\t\tprivate long pow(long n, long p, long mod) {\n\t\t\tif (p == 0) {\n\t\t\t\treturn 1L;\n\t\t\t}\n\t\t\tlong half = pow(n, p / 2, mod);\n\t\t\tlong ret = (half * half) % mod;\n\t\t\tif (p % 2 == 1) {\n\t\t\t\tret = (ret * n) % mod;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic long comb(int n, int m) {\n\t\t\tif (n > size) {\n\t\t\t\tthrow new RuntimeException(\"n is greater than size.\");\n\t\t\t}\n\t\t\tif (n < 0 || m < 0 || n < m) {\n\t\t\t\treturn 0L;\n\t\t\t}\n\t\t\treturn (((factorialTable[n] * inverseFactorialTable[m]) % mod) * inverseFactorialTable[n - m]) % mod;\n\t\t}\n\t}\n\n\t/**\n\t * \u7d44\u307f\u5408\u308f\u305b\u8a08\u7b97\u3092\u30c6\u30fc\u30d6\u30eb\u3067\u5b9f\u88c5\u3057\u305f\u30af\u30e9\u30b9\u3067\u3059(MOD\u5bfe\u5fdc)\n\t * \u524d\u8a08\u7b97\u3067O(N^2), comb\u306fO(1)\u3067\u5b9f\u884c\u3067\u304d\u307e\u3059\n\t * size\u30922 * 1e4\u3088\u308a\u5927\u304d\u3044\u5024\u3067\u5b9f\u884c\u3059\u308b\u3068MLE\u306e\u5371\u967a\u6027\u304c\u3042\u308a\u307e\u3059\n\t */\n\tclass TableCombCalculator implements CombCalculator {\n\t\tlong[][] table;\n\t\tint size;\n\n\t\tpublic TableCombCalculator(int size, long mod) {\n\t\t\tthis.size = size;\n\t\t\ttable = new long[size + 1][];\n\n\t\t\ttable[0] = new long[1];\n\t\t\ttable[0][0] = 1L;\n\t\t\tfor (int n = 1; n <= size; n++) {\n\t\t\t\ttable[n] = new long[n + 1];\n\t\t\t\ttable[n][0] = 1L;\n\t\t\t\tfor (int m = 1; m < n; m++) {\n\t\t\t\t\ttable[n][m] = (table[n - 1][m - 1] + table[n - 1][m]) % mod;\n\t\t\t\t}\n\t\t\t\ttable[n][n] = 1L;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic long comb(int n, int m) {\n\t\t\tif (n > size) {\n\t\t\t\tthrow new RuntimeException(\"n is greater than size.\");\n\t\t\t}\n\t\t\tif (n < 0 || m < 0 || n < m) {\n\t\t\t\treturn 0L;\n\t\t\t}\n\t\t\treturn table[n][m];\n\t\t}\n\t}\n\n\tinterface Graph {\n\t\tvoid link(int from, int to, long cost);\n\t\tOptional<Long> getCost(int from, int to);\n\t\tint getVertexNum();\n\t}\n\n\tinterface FlowResolver {\n\t\tlong maxFlow(int from, int to);\n\t}\n\n\t/**\n\t * \u30b0\u30e9\u30d5\u306e\u884c\u5217\u306b\u3088\u308b\u5b9f\u88c5\n\t * \u63a5\u70b9\u6570\u306e\u5927\u304d\u3044\u30b0\u30e9\u30d5\u3067\u4f7f\u3046\u3068MLE\u3067\u6b7b\u306b\u305d\u3046\n\t */\n\tclass ArrayGraph implements Graph {\n\t\tprivate Long[][] costArray;\n\t\tprivate int vertexNum;\n\n\t\tpublic ArrayGraph(int n) {\n\t\t\tcostArray = new Long[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tcostArray[i] = new Long[n];\n\t\t\t}\n\t\t\tvertexNum = n;\n\t\t}\n\n\t\t@Override\n\t\tpublic void link(int from, int to, long cost) {\n\t\t\tcostArray[from][to] = new Long(cost);\n\t\t}\n\n\t\t@Override\n\t\tpublic Optional<Long> getCost(int from, int to) {\n\t\t\treturn Optional.ofNullable(costArray[from][to]);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getVertexNum() {\n\t\t\treturn vertexNum;\n\t\t}\n\t}\n\n\t/**\n\t * DFS(\u6df1\u3055\u512a\u5148\u63a2\u7d22)\u306b\u3088\u308b\u5b9f\u88c5\n\t * \u8a08\u7b97\u91cf\u306fO(E*MaxFlow)\u306e\u306f\u305a (E:\u8fba\u306e\u6570, MaxFlow:\u6700\u5927\u30d5\u30ed\u30fc)\n\t */\n\tclass DfsFlowResolver implements FlowResolver {\n\t\tprivate Graph graph;\n\t\tpublic DfsFlowResolver(Graph graph) {\n\t\t\tthis.graph = graph;\n\t\t}\n\n\t\t/**\n\t\t * \u6700\u5927\u30d5\u30ed\u30fc(\u6700\u5c0f\u30ab\u30c3\u30c8)\u3092\u6c42\u3081\u308b\n\t\t * @param from \u59cb\u70b9(source)\u306eID\n\t\t * @param to \u7d42\u70b9(target)\u306eID\n\t\t * @return \u6700\u5927\u30d5\u30ed\u30fc(\u6700\u5c0f\u30ab\u30c3\u30c8)\n\t\t */\n\t\tpublic long maxFlow(int from, int to) {\n\t\t\tlong sum = 0L;\n\t\t\tlong currentFlow;\n\t\t\tdo {\n\t\t\t\tcurrentFlow = flow(from, to, Long.MAX_VALUE / 3, new boolean[graph.getVertexNum()]);\n\t\t\t\tsum += currentFlow;\n\t\t\t} while (currentFlow > 0);\n\t\t\treturn sum;\n\t\t}\n\n\t\t/**\n\t\t * \u30d5\u30ed\u30fc\u306e\u5b9f\u884c \u30b0\u30e9\u30d5\u306e\u66f4\u65b0\u3082\u884c\u3046\n\t\t * @param from \u73fe\u5728\u3044\u308b\u7bc0\u70b9\u306eID\n\t\t * @param to \u7d42\u70b9(target)\u306eID\n\t\t * @param current_flow \u3053\u3053\u307e\u3067\u306e\u6d41\u91cf\n\t\t * @param passed \u65e2\u306b\u901a\u3063\u305f\u7bc0\u70b9\u304b\u5426\u304b\u3092\u683c\u7d0d\u3057\u305f\u914d\u5217\n\t\t * @return \u7d42\u70b9(target)\u306b\u6d41\u3057\u305f\u6d41\u91cf/\u623b\u308a\u306e\u30b0\u30e9\u30d5\u306e\u6d41\u91cf\n\t\t */\n\t\tprivate long flow(int from, int to, long current_flow, boolean[] passed) {\n\t\t\tpassed[from] = true;\n\t\t\tif (from == to) {\n\t\t\t\treturn current_flow;\n\t\t\t}\n\t\t\tfor (int id = 0; id < graph.getVertexNum(); id++) {\n\t\t\t\tif (passed[id]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tOptional<Long> cost = graph.getCost(from, id);\n\t\t\t\tif (cost.orElse(0L) > 0) {\n\t\t\t\t\tlong nextFlow = current_flow < cost.get() ? current_flow : cost.get();\n\t\t\t\t\tlong returnFlow = flow(id, to, nextFlow, passed);\n\t\t\t\t\tif (returnFlow > 0) {\n\t\t\t\t\t\tgraph.link(from, id, cost.get() - returnFlow);\n\t\t\t\t\t\tgraph.link(id, from, graph.getCost(id, from).orElse(0L) + returnFlow);\n\t\t\t\t\t\treturn returnFlow;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0L;\n\t\t}\n\t}\n\n\t/**\n\t * 1-indexed\u306eBIT\u914d\u5217\n\t */\n\tclass BinaryIndexedTree {\n\t\tprivate long[] array;\n\n\t\tpublic BinaryIndexedTree(int size) {\n\t\t\tthis.array = new long[size + 1];\n\t\t}\n\n\t\t/**\n\t\t * \u6307\u5b9a\u3057\u305f\u8981\u7d20\u306b\u5024\u3092\u52a0\u7b97\u3059\u308b\n\t\t * \u8a08\u7b97\u91cf\u306fO(logN)\n\t\t * @param index \u52a0\u7b97\u3059\u308b\u8981\u7d20\u306e\u6dfb\u5b57\n\t\t * @param value \u52a0\u7b97\u3059\u308b\u91cf\n\t\t */\n\t\tpublic void add(int index, long value) {\n\t\t\tfor (int i = index; i < array.length; i += (i & -i)) {\n\t\t\t\tarray[i] += value;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * 1\u301c\u6307\u5b9a\u3057\u305f\u8981\u7d20\u307e\u3067\u306e\u548c\u3092\u53d6\u5f97\u3059\u308b\n\t\t * \u8a08\u7b97\u91cf\u306fO(logN)\n\t\t * @param index \u548c\u306e\u7d42\u7aef\u3068\u306a\u308b\u8981\u7d20\u306e\u6dfb\u5b57\n\t\t * @return 1\u301cindex\u307e\u3067\u306e\u548c\n\t\t */\n\t\tpublic long getSum(int index) {\n\t\t\tlong sum = 0L;\n\t\t\tfor (int i = index; i > 0; i -= (i & -i)) {\n\t\t\t\tsum += array[i];\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\n\t/**\n\t * 1-indexed\u306e2\u6b21\u5143BIT\u914d\u5217\n\t */\n\tclass BinaryIndexedTree2D {\n\t\tprivate long[][] array;\n\n\t\tpublic BinaryIndexedTree2D(int size1, int size2) {\n\t\t\tthis.array = new long[size1 + 1][];\n\t\t\tfor (int i = 1; i <= size1; i++) {\n\t\t\t\tthis.array[i] = new long[size2 + 1];\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * \u6307\u5b9a\u3057\u305f\u8981\u7d20\u306b\u5024\u3092\u52a0\u7b97\u3059\u308b\n\t\t * \u8a08\u7b97\u91cf\u306fO(logN * logN)\n\t\t * @param index1 \u52a0\u7b97\u3059\u308b\u8981\u7d20\u306e1\u6b21\u5143\u76ee\u306e\u6dfb\u5b57\n\t\t * @param index2 \u52a0\u7b97\u3059\u308b\u8981\u7d20\u306e2\u6b21\u5143\u76ee\u306e\u6dfb\u5b57\n\t\t * @param value \u52a0\u7b97\u3059\u308b\u91cf\n\t\t */\n\t\tpublic void add(int index1, int index2, long value) {\n\t\t\tfor (int i1 = index1; i1 < array.length; i1 += (i1 & -i1)) {\n\t\t\t\tfor (int i2 = index2; i2 < array.length; i2 += (i2 & -i2)) {\n\t\t\t\t\tarray[i1][i2] += value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * (1,1)\u301c\u6307\u5b9a\u3057\u305f\u8981\u7d20\u307e\u3067\u306e\u77e9\u5f62\u548c\u3092\u53d6\u5f97\u3059\u308b\n\t\t * \u8a08\u7b97\u91cf\u306fO(logN * logN)\n\t\t * @param index1 \u548c\u306e\u7d42\u7aef\u3068\u306a\u308b\u8981\u7d20\u306e1\u6b21\u5143\u76ee\u306e\u6dfb\u5b57\n\t\t * @param index2 \u548c\u306e\u7d42\u7aef\u3068\u306a\u308b\u8981\u7d20\u306e2\u6b21\u5143\u76ee\u306e\u6dfb\u5b57\n\t\t * @return (1,1)\u301c(index1,index2)\u307e\u3067\u306e\u77e9\u5f62\u548c\n\t\t */\n\t\tpublic long getSum(int index1, int index2) {\n\t\t\tlong sum = 0L;\n\t\t\tfor (int i1 = index1; i1 > 0; i1 -= (i1 & -i1)) {\n\t\t\t\tfor (int i2 = index2; i2 > 0; i2 -= (i2 & -i2)) {\n\t\t\t\t\tsum += array[i1][i2];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\n\tinterface UnionFind {\n\t\tvoid union(int A, int B);\n\t\tboolean judge(int A, int B);\n\t\tSet<Integer> getSet(int id);\n\t}\n\n\t/**\n\t * ArrayUnionFind\u306e\u62e1\u5f35\n\t * MapSet\u3067\u6839\u306e\u6dfb\u5b57\u304b\u3089\u6839\u306b\u3076\u3089\u4e0b\u304c\u308b\u9802\u70b9\u306e\u96c6\u5408\u304c\u53d6\u5f97\u3067\u304d\u308b\u3088\u3046\u306b\u3057\u305f\n\t * getSet\u30e1\u30bd\u30c3\u30c9\u3092O(logN * logN)\u306b\u843d\u3068\u305b\u3066\u3044\u308b\u306f\u305a\n\t * \u305f\u3060\u3057union\u30e1\u30bd\u30c3\u30c9\u306f2\u500d\u306e\u8a08\u7b97\u91cf\u306b\u306a\u3063\u3066\u3044\u308b\u306e\u3067\u6ce8\u610f(\u30aa\u30fc\u30c0\u30fc\u306f\u5909\u308f\u3089\u306a\u3044\u306f\u305a)\n\t */\n\tclass SetUnionFind extends ArrayUnionFind {\n\t\tMap<Integer, Set<Integer>> map;\n\t\tpublic SetUnionFind(int size) {\n\t\t\tsuper(size);\n\t\t\tmap = new HashMap<>();\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tmap.put(i, new HashSet<>());\n\t\t\t\tmap.get(i).add(i);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tprotected void unionTo(int source, int dest) {\n\t\t\tsuper.unionTo(source, dest);\n\t\t\tmap.get(dest).addAll(map.get(source));\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<Integer> getSet(int id) {\n\t\t\treturn map.get(root(id));\n\t\t}\n\t}\n\n\t/**\n\t * \u914d\u5217\u306b\u3088\u308bUnionFind\u306e\u5b9f\u88c5\n\t * getSet\u30e1\u30bd\u30c3\u30c9\u306fO(NlogN)\u306a\u306e\u3067TLE\u306b\u6ce8\u610f\n\t */\n\tclass ArrayUnionFind implements UnionFind {\n\t\tint[] parent;\n\t\tint[] rank;\n\t\tint size;\n\t\tpublic ArrayUnionFind(int size) {\n\t\t\tparent = new int[size];\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tparent[i] = i;\n\t\t\t}\n\t\t\trank = new int[size];\n\t\t\tthis.size = size;\n\t\t}\n\n\t\t@Override\n\t\tpublic void union(int A, int B) {\n\t\t\tint rootA = root(A);\n\t\t\tint rootB = root(B);\n\t\t\tif (rootA != rootB) {\n\t\t\t\tif (rank[rootA] < rank[rootB]) {\n\t\t\t\t\tunionTo(rootA, rootB);\n\t\t\t\t} else {\n\t\t\t\t\tunionTo(rootB, rootA);\n\t\t\t\t\tif (rank[rootA] == rank[rootB]) {\n\t\t\t\t\t\trank[rootA]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprotected void unionTo(int source, int dest) {\n\t\t\tparent[source] = dest;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean judge(int A, int B) {\n\t\t\treturn root(A) == root(B);\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<Integer> getSet(int id) {\n\t\t\tSet<Integer> set = new HashSet<>();\n\t\t\tIntStream.range(0, size).filter(i -> judge(i, id)).forEach(set::add);\n\t\t\treturn set;\n\t\t}\n\n\t\tprotected int root(int id) {\n\t\t\tif (parent[id] == id) {\n\t\t\t\treturn id;\n\t\t\t}\n\t\t\tparent[id] = root(parent[id]);\n\t\t\treturn parent[id];\n\t\t}\n\t}\n\n\t/**\n\t * \u7d20\u6570\u306e\u30e6\u30fc\u30c6\u30a3\u30ea\u30c6\u30a3\n\t */\n\tclass PrimeNumberUtils {\n\t\tboolean[] isPrimeArray;\n\t\tList<Integer> primes;\n\n\t\t/**\n\t\t * \u7d20\u6570\u5224\u5b9a\u306e\u4e0a\u9650\u3068\u306a\u308b\u5024\u3092\u6307\u5b9a\u3057\u3066\u30e6\u30fc\u30c6\u30a3\u30ea\u30c6\u30a3\u3092\u521d\u671f\u5316\n\t\t * @param limit \u7d20\u6570\u5224\u5b9a\u306e\u4e0a\u9650(\u3053\u306e\u5024\u4ee5\u4e0a\u304c\u7d20\u6570\u3067\u3042\u308b\u304b\u5224\u5b9a\u3057\u306a\u3044)\n\t\t */\n\t\tpublic PrimeNumberUtils(int limit) {\n\t\t\tif (limit > 10000000) {\n\t\t\t\tSystem.err.println(\"\u4e0a\u9650\u306e\u5024\u304c\u9ad8\u3059\u304e\u308b\u305f\u3081\u7d20\u6570\u30e6\u30fc\u30c6\u30a3\u30ea\u30c6\u30a3\u306e\u521d\u671f\u5316\u3067TLE\u3059\u308b\u53ef\u80fd\u6027\u304c\u5927\u5909\u9ad8\u3044\u3067\u3059\");\n\t\t\t}\n\t\t\tprimes = new ArrayList<>();\n\t\t\tisPrimeArray = new boolean[limit];\n\t\t\tif (limit > 2) {\n\t\t\t\tprimes.add(2);\n\t\t\t\tisPrimeArray[2] = true;\n\t\t\t}\n\n\t\t\tfor (int i = 3; i < limit; i += 2) {\n\t\t\t\tif (isPrime(i, primes)) {\n\t\t\t\t\tprimes.add(i);\n\t\t\t\t\tisPrimeArray[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic List<Integer> getPrimeNumberList() {\n\t\t\treturn primes;\n\t\t}\n\n\t\tpublic boolean isPrime(int n) {\n\t\t\treturn isPrimeArray[n];\n\t\t}\n\n\t\tprivate boolean isPrime(int n, List<Integer> primes) {\n\t\t\tfor (int prime : primes) {\n\t\t\t\tif (n % prime == 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (prime > Math.sqrt(n)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tinterface BitSet {\n\t\tvoid set(int index, boolean bit);\n\t\tboolean get(int index);\n\t\tvoid shiftRight(int num);\n\t\tvoid shiftLeft(int num);\n\t\tvoid or(BitSet bitset);\n\t\tvoid and(BitSet bitset);\n\t}\n\n\t/**\n\t * Long\u306e\u914d\u5217\u306b\u3088\u308bBitSet\u306e\u5b9f\u88c5\n\t * get/set\u306fO(1)\n\t * shift/or/and\u306fO(size / 64)\n\t */\n\tclass LongBit implements BitSet {\n\t\tlong[] bitArray;\n\n\t\tpublic LongBit(int size) {\n\t\t\tbitArray = new long[((size + 63) / 64)];\n\t\t}\n\n\t\t@Override\n\t\tpublic void set(int index, boolean bit) {\n\t\t\tint segment = index / 64;\n\t\t\tint inIndex = index % 64;\n\t\t\tif (bit) {\n\t\t\t\tbitArray[segment] |= 1L << inIndex;\n\t\t\t} else {\n\t\t\t\tbitArray[segment] &= ~(1L << inIndex);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean get(int index) {\n\t\t\tint segment = index / 64;\n\t\t\tint inIndex = index % 64;\n\t\t\treturn (bitArray[segment] & (1L << inIndex)) != 0L;\n\t\t}\n\n\t\t@Override\n\t\tpublic void shiftRight(int num) {\n\t\t\tint shiftSeg = num / 64;\n\t\t\tint shiftInI = num % 64;\n\t\t\tfor (int segment = 0; segment < bitArray.length; segment++) {\n\t\t\t\tint sourceSeg = segment + shiftSeg;\n\t\t\t\tif (sourceSeg < bitArray.length) {\n\t\t\t\t\tbitArray[segment] = bitArray[sourceSeg] >>> shiftInI;\n\t\t\t\t\tif (shiftInI > 0 && sourceSeg + 1 < bitArray.length) {\n\t\t\t\t\t\tbitArray[segment] |= bitArray[sourceSeg + 1] << (64 - shiftInI);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbitArray[segment] = 0L;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void shiftLeft(int num) {\n\t\t\tint shiftSeg = num / 64;\n\t\t\tint shiftInI = num % 64;\n\t\t\tfor (int segment = bitArray.length - 1; segment >= 0; segment--) {\n\t\t\t\tint sourceSeg = segment - shiftSeg;\n\t\t\t\tif (sourceSeg >= 0) {\n\t\t\t\t\tbitArray[segment] = bitArray[sourceSeg] << shiftInI;\n\t\t\t\t\tif (shiftInI > 0 && sourceSeg > 0) {\n\t\t\t\t\t\tbitArray[segment] |= bitArray[sourceSeg - 1] >>> (64 - shiftInI);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbitArray[segment] = 0L;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic long getLong(int segment) {\n\t\t\treturn bitArray[segment];\n\t\t}\n\n\t\t@Override\n\t\tpublic void or(BitSet bitset) {\n\t\t\tif (!(bitset instanceof LongBit)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int segment = 0; segment < bitArray.length; segment++) {\n\t\t\t\tbitArray[segment] |= ((LongBit)bitset).getLong(segment);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void and(BitSet bitset) {\n\t\t\tif (!(bitset instanceof LongBit)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int segment = 0; segment < bitArray.length; segment++) {\n\t\t\t\tbitArray[segment] &= ((LongBit)bitset).getLong(segment);\n\t\t\t}\n\t\t}\n\t}\n\n}", "code2": "eval\"(*D),K,*A=\"+`dd`.split*?,;puts D[K.times{D<<A.none?{D[-_1]}}]?:Second: :First", "label": 1, "name1": "s208804589.java", "name2": "s954498434.rb"}, {"id": 144, "code1": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint[] pri = new int[25000];\n\t\tpri[0] = 2;\n\t\tpri[1] = 3;\n\t\tpri[2] = 5;\n\t\tpri[3] = 7;\n\t\tpri[4] = 11;\n\t\tpri[5] = 13;\n\t\tpri[6] = 17;\n\t\tpri[7] = 19;\n\t\tpri[8] = 23;\n\t\tpri[9] = 29;\n\t\tint fl = 0;\n\t\tint a=0;\n\t\tint b=0;\n\t\tint c=0;\n\t\twhile(pri[a]<=250000){\n\t\t\tfl++;\n\t\t\tfor(int i=0;i<8;i++){\n\t\t\t\ta=0;\n\t\t\t\tb=0;\n\t\t\t\tc=0;\t\t\t\t\n\t\t\t\tif(i==0){\n\t\t\t\t\tc=1;\n\t\t\t\t}else if(i>0){\n\t\t\t\t\tc=pri[2+i];\n\t\t\t\t}\n\t\t\t\twhile(pri[a]!=0){\n\t\t\t\t\tif((30*fl + c)%pri[a]==0){\n\t\t\t\t\t\tb=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ta++;\n\t\t\t\t}\n\t\t\t\tif(b==0){\n\t\t\t\t\tpri[a]=(30*fl + c);\n\t\t\t\t}\n\t\t\t}\t\t\t\t\t\n\t\t}\n\t\t\n\t\tboolean exit = true;\n\t\twhile(exit==true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)exit=false;\n\t\t\tif(exit==true){\n\t\t\t\tint sum=-1;\n\t\t\t\tint i=0;\n\t\t\t\twhile(true){\n\t\t\t\t\tif(pri[i]>n)sum++;\n\t\t\t\t\tif(pri[i]>2*n)break;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(sum);\n\t\t\t}\n\t\t}\n\t}\n\t\n}", "code2": "require 'prime'\nwhile n = gets.to_i\n  break if n == 0\n  p Prime.each.lazy.take_while{ |p| p <= 2 * n }.drop_while{ |p| p <= n }.to_a.size\nend", "label": 1, "name1": "s593802453.java", "name2": "s057981665.rb"}, {"id": 196, "code1": "import java.util.*;\nimport java.io.*;\n\n\nclass Main {\n\n    public static void main(String[] args) throws IOException\n    {\n        PrintWriter out = new PrintWriter(System.out);\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        int n = Integer.parseInt(br.readLine());\n        Long arr[] = new Long[n];\n        StringTokenizer st1 = new StringTokenizer(br.readLine());\n        for(int i = 0 ; i < n ; i++)\n        {\n            arr[i] = Long.parseLong(st1.nextToken());\n        }\n        Arrays.sort(arr);\n        long sum = arr[n-1];\n        int ind = n-2;\n        for(int i = 0 ; i < n-2 ; i++)\n        {\n            sum += arr[ind];\n\n            if(i%2 != 0)\n                ind--;\n        }\n        out.println(sum);\n\n        out.flush();\n        out.close();\n\n    }\n\n    static class pair{\n        long x1;\n        long x2;\n\n        public pair(long x1 , long x2)\n        {\n            this.x1 = x1;\n            this.x2 = x2;\n        }\n\n    }\n\n}\n", "code2": "n = gets.to_i\na = gets.chomp.split.map &:to_i\na.sort!.reverse!\n\nans = a[0]\ncount = 1\n\na[1..-1].each_with_index do |v|\n  break if count >= n - 1 \n  ans += v\n  count += 1\n  break if count >= n - 1\n  ans += v\n  count += 1\nend\n\np ans\n", "label": 1, "name1": "s590431029.java", "name2": "s887528547.rb"}, {"id": 658, "code1": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\n\tstatic class TaskX {\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tint n = in.nextInt();\n\t\t\tint k = in.nextInt();\n\t\t\tint[] wn = in.nextIntArray(n);\n\n\t\t\tint left = 0;\n\t\t\tint right = INF;\n\t\t\tint mid = 0;\n\t\t\twhile (right > left + 1) {\n\t\t\t\tmid = (left + right) / 2;\n\t\t\t\tint count = 1;\n\t\t\t\tint ca = mid;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (ca - wn[i] >= 0) {\n\t\t\t\t\t\tca -= wn[i];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tca = mid;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tif (ca - wn[i] >= 0) {\n\t\t\t\t\t\t\tca -= wn[i];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcount = INF;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// k\u53f0\u4ee5\u4e0b\u3067\u7a4d\u3081\u308b\u5834\u5408\n\t\t\t\tif (count <= k){\n\t\t\t\t\tright = mid;\n\n\t\t\t\t// \uff4b\u53f0\u4ee5\u4e0a\u5fc5\u8981\u306a\u5834\u5408\n\t\t\t\t} else if (count > k) {\n\t\t\t\t\tleft = mid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout.println(right);\n\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\n\t}\n\n}\n\n", "code2": "n = gets.to_i\na = gets.chomp.split(\" \").map(&:to_i)\n\n#b = Array.new(n+1).map{Array.new}\nh = Hash.new{|k,v| k[v]=0}\n\na.each_with_index do |n, i|\n  t = [n, i+1].sort!\n  h[t] += 1\n  #b[n] << i+1\n  #b[i+1] << n\nend\np h.to_a.select{|t| t[1]==2}.size\n\n\n#b.select{|t| }\n", "label": 0, "name1": "s166648431.java", "name2": "s972469766.rb"}, {"id": 836, "code1": "import java.util.Scanner;\n\tpublic class Main {\n\tprivate static Scanner scanner;\n\tpublic static void main(String args[]) {\n\n\t\tscanner = new Scanner(System.in);\n\t\tint a = scanner.nextInt();\n\t\tint[] b = new int[a];\n\t\tint minj,count = 0;\n\t\tfor(int i=0;i < a;i++) b[i] = scanner.nextInt();\n\n\t\tfor(int i = 0;i < a;i++) {\n\t\t\tminj = i;\n\t\t\tfor(int j = i;j < a;j++) {\n\t\t\t\tif(b[j] < b[minj]) {\n\t\t\t\t\tminj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tif(minj != i) {\n\t\t\t\t\tint tmp = b[i];\n\t\t\t\t\tb[i] = b[minj];\n\t\t\t\t\tb[minj] = tmp;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t}\n\t\tfor(int i=0;i < a;i++) {\n\t\t\tSystem.out.print(b[i]);\n\t\t\tif(i == a-1) System.out.println(\"\");\n\t\t\telse System.out.print(\" \");\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n\t}\n\n", "code2": "# 3 8 3   n l t\n# 0 1     x w\n# 3 2\n# 6 1\n\nn, l, t = gets.split.map(&:to_i)\n\narray_x = []\narray_w = []\nn.times do \n  x_temp, w_temp = gets.split.map(&:to_i)\n  array_x << x_temp\n  array_w << w_temp\nend\n\ndef round_once_plus(array)\n  array << array[0]\n  array.shift\nend\n\ndef round_once_minus(array)\n  array.unshift(array.last)\n  array.pop\nend\n\narray_position = []\ncount_over = 0\n\narray_x.each_with_index do |x, i|\n  if array_w[i] == 1\n    array_position << (x + t) % l\n    count_over += (x + t) / l\n  else # array_w[i] == 2\n    array_position << (x - t) % l\n    count_over += (x - t) / l\n  end\nend\n\narray_position.sort!\n\nif count_over > 0\n  # count_over = count_over % l\n  count_over.times do\n    round_once_plus(array_position)\n  end\nelsif count_over < 0\n  count_over = count_over.abs\n  # count_over = count_over % l\n  count_over.times do\n    round_once_minus(array_position)\n  end\nend\n\nputs array_position\n", "label": 0, "name1": "s404045978.java", "name2": "s129377988.rb"}, {"id": 821, "code1": "import java.util.*;\n\npublic class Main {\n\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    int cnt = 0;\n\n    List<Integer>[] lists = new ArrayList[n];\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    void run() {\n\n        for (int i=0; i<n; i++) lists[i] = new ArrayList<>();\n\n        int m = sc.nextInt();\n        for (int i=0; i<m; i++) {\n            int s = sc.nextInt() - 1;\n            int t = sc.nextInt() - 1;\n            lists[s].add(t);\n            lists[t].add(s);\n        }\n\n        dfs(\"\", n);\n\n        System.out.println(cnt);\n\n    }\n\n    void dfs(String s, int n) {\n\n        if (s.length() == n) {\n//            System.out.println(s);\n            if (s.charAt(0) == '0') {\n                boolean check = true;\n                for (int i=0; i<s.length()-1; i++) {\n                    if (!lists[s.charAt(i) - 48].contains(s.charAt(i+1) - 48)) {\n                        check = false;\n                        break;\n                    }\n                }\n                if (check) cnt++;\n            }\n\n        } else {\n            for (int i=0; i<n; i++) {\n                if (s.contains(String.valueOf(i))) continue;\n                dfs(s + i, n);\n            }\n        }\n    }\n\n\n}\n\n", "code2": "n = gets.chomp\nstr = gets.chomp\n\nlen = str.length\nans = len\n\nwcounts = []\necounts = []\n\nlen.times do |i|\n  wcounts[i] = i == 0 ? 0 : wcounts[i-1]\n  wcounts[i] += 1 if str[i] == 'W'\nend\n\nlen.times do |i|\n  j = len - i - 1\n  ecounts[j] = j == len - 1 ? 0 : ecounts[j+1]\n  ecounts[j] += 1 if str[j] == 'E'\nend\n\n# p wcounts\n# p ecounts\n\nans = len\n\nlen.times do |i|\n  if i == 0\n    count = ecounts[i+1]\n  elsif i == len - 1\n    count = wcounts[i]\n  else\n    count = wcounts[i] + ecounts[i+1]\n  end\n  ans = [ans, count].min\nend\n\nputs ans\n", "label": 0, "name1": "s337668331.java", "name2": "s582528009.rb"}, {"id": 435, "code1": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n\t\t\tint K = io.nextInt();\n\t\t\tint L = io.nextInt();\n\n\t\t\tUnionFind uf1 = new UnionFind(n);\n\t\t\tUnionFind uf2 = new UnionFind(n);\n\t\t\tUnionFind uf3 = new UnionFind(n);\n\t\t\t\n\t\t\tfor (int i = 0; i < K; i++) {\n\t\t\t\tint a = io.nextInt() - 1;\n\t\t\t\tint b = io.nextInt() - 1;\n\t\t\t\tuf1.union(a, b);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < L; i++) {\n\t\t\t\tint a = io.nextInt() - 1;\n\t\t\t\tint b = io.nextInt() - 1;\n\t\t\t\tuf2.union(a, b);\n\t\t\t}\n\n\t\t\tTreeSet<Integer>[] s1 = new TreeSet[n];\n\t\t\tTreeSet<Integer>[] s2 = new TreeSet[n];\n\t\t\tfor (int i = 0; i < n; i++) if (uf1.root(i) == i) {\n\t\t\t\tTreeSet<Integer> s = new TreeSet<>();\n\t\t\t\tfor (int j = i; j != -1; j = uf1.next[j]) { s.add(j); }\n\t\t\t\ts1[i] = s;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) if (uf2.root(i) == i) {\n\t\t\t\tTreeSet<Integer> s = new TreeSet<>();\n\t\t\t\tfor (int j = i; j != -1; j = uf2.next[j]) { s.add(j); }\n\t\t\t\ts2[i] = s;\n\t\t\t}\n\t\t\t\n\t\t\tint[] ans = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint r1 = uf1.root(i);\n\t\t\t\tint r2 = uf2.root(i);\n\n\t\t\t\tif (!s1[r1].contains(i)) continue;\n\n\t\t\t\tTreeSet<Integer> a = s1[r1].size() < s2[r2].size() ? s1[r1] : s2[r2];\n\t\t\t\tTreeSet<Integer> b = s1[r1].size() < s2[r2].size() ? s2[r2] : s1[r1];\n\t\t\t\tList<Integer> same = new ArrayList<>();\n\t\t\t\tfor (int t : a) {\n\t\t\t\t\tif (b.contains(t)) same.add(t);\n\t\t\t\t}\n\t\t\t\tfor (int t : same) {\n\t\t\t\t\ts1[r1].remove(t);\n\t\t\t\t\ts2[r2].remove(t);\n\t\t\t\t\tans[t] = same.size();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tprintArrayLn(ans);\n\t\t}\n\t}\n\t\n\tstatic\n\tclass UnionFind {\n\t\tprivate int[] data;\n\t\tprivate int[] next;\n\t\tprivate int[] last;\n\t\t\n\t\tpublic UnionFind(int size) {\n\t\t\tdata = new int[size];\n\t\t\tnext = new int[size];\n\t\t\tlast = new int[size];\n\t\t\tclear();\n\t\t}\n\t\t\n\t\tpublic void clear() {\n\t\t\tArrays.fill(data, -1);\n\t\t\tArrays.fill(next, -1);\n\t\t\tfor(int i = 0; i < last.length; i++) {\n\t\t\t\tlast[i] = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int root(int x) { return data[x] < 0 ? x : (data[x] = root(data[x])); }\n\t\t\n\t\tpublic void union(int x, int y) {\n\t\t\tif((x = root(x)) != (y = root(y))) {\n\t\t\t\tif(data[y] < data[x]) { final int t = x; x = y; y = t; }\n\t\t\t\tdata[x] += data[y];\n\t\t\t\tdata[y] = x;\n\t\t\t\tnext[last[x]] = y;\n\t\t\t\tlast[x] = last[y];\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic boolean same(int x, int y) { return root(x) == root(y); }\n\t\tpublic int size(int x) { return -data[root(x)]; }\n\t}\n\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n", "code2": "N, K, L = gets.split.map(&:to_i)\n\nroad = [*0..N]\nroad_r = Array.new(N + 1) { 1 }\n\nrail = [*0..N]\nrail_r = Array.new(N + 1) { 1 }\n\ndef root uf, i\n  uf[i] == i ? i : uf[i] = root(uf, uf[i])\nend\n\ndef set_union_find n, uf, rank\n  n.times do\n    x, y = gets.split.map(&:to_i)\n    x = root(uf, x)\n    y = root(uf, y)\n\n    next if x == y\n\n    if rank[x] > rank[y]\n      uf[y] = x\n    else\n      uf[x] = y\n      rank[y] += 1 if rank[x] == rank[y]\n    end\n  end\nend\n\nset_union_find K, road, road_r\nset_union_find L, rail, rail_r\n\nh = Hash.new {|h, k| h[k] = [] }\n(1..N).each do |i|\n  h[[root(road, i), root(rail, i)]] << i\nend\n\nresult = Array.new(N + 1) { 0 }\nh.values.each do |arr|\n  arr.each do |j|\n    result[j] = arr.size\n  end\nend\n\nputs (1..N).map {|i| result[i] }.join(' ')", "label": 1, "name1": "s632399466.java", "name2": "s244848536.rb"}, {"id": 974, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tlong a = sc.nextLong();\n\t\tlong b = sc.nextLong();\n\t\tlong[] h = new long[n];\n\t\tfor(int i = 0; i < n; i++) h[i] = sc.nextLong();\n\t\tlong l = 0, r = Integer.MAX_VALUE;\n\t\twhile(r - l != 1) {\n\t\t\tlong mid = (r + l) / 2;\n\t\t\tlong[] x = Arrays.copyOf(h, h.length);\n\t\t\tlong cnt = 0;\n\t\t\tfor(int i = 0; i < x.length; i++) {\n\t\t\t\tif(x[i] - b * mid <= 0) continue;\n\t\t\t\tcnt += ((x[i] - b * mid) + (a - b - 1)) / (a - b);\n\t\t\t}\n\t\t\tif(mid >= cnt) r = mid;\n\t\t\telse l = mid;\n\t\t}\n\t\tSystem.out.println(r);\n\t}\n}\n", "code2": "### constant\n\nMAX_P = 1000000\n\n### subroutines\n\ndef gen_primes(max_p)\n  primes = Array.new(max_p + 1){true}\n  primes[0] = primes[1] = false\n\n  for p in (2..max_p)\n    if primes[p]\n      for q in (p * p).step(max_p, p)\n        primes[q] = false\n      end\n    end\n  end\n\n  return primes\nend\n\n### main\n\nprimes = gen_primes(MAX_P)\n\nwhile true\n  n = gets.strip.to_i\n  break if n == 0\n\n  hn = n / 2\n  count = 0\n\n  for i in (3..hn)\n    if primes[i] && primes[n - i]\n      count += 1\n    end\n  end\n\n  puts count\nend", "label": 0, "name1": "s073004253.java", "name2": "s145027976.rb"}, {"id": 715, "code1": "\npublic class Main {\n\n  static int mod = 1000003;\n  static int[][] fif = enumFIF(mod * 3, mod);\n\n  private static void solve() {\n    int q = ni();\n\n    for (int i = 0; i < q; i++) {\n      int x = ni();\n      int d = ni();\n      int n = ni();\n      out.println(f(x, d, n));\n    }\n  }\n\n  private static long f(int x, int d, int n) {\n    if (x == 0) {\n      return 0;\n    } else if (d == 0) {\n      return pow(x, n, mod);\n    }\n\n    int y = (int) (x * invl(d, mod) % mod);\n    if (n >= mod || y % mod > (y + n - 1) % mod) {\n      return 0;\n    }\n\n    long z = fif[0][y + n - 1] * invl(fif[0][y - 1], mod) % mod;\n    z *= pow(d, n, mod);\n    z %= mod;\n\n    return z;\n  }\n\n  public static long pow(long a, long n, long mod) {\n    // a %= mod;\n    long ret = 1;\n    int x = 63 - Long.numberOfLeadingZeros(n);\n    for (; x >= 0; x--) {\n      ret = ret * ret % mod;\n      if (n << 63 - x < 0)\n        ret = ret * a % mod;\n    }\n    return ret;\n  }\n\n\n  public static int[][] enumFIF(int n, int mod) {\n    int[] f = new int[n + 1];\n    int[] invf = new int[n + 1];\n    f[0] = 1;\n    for (int i = 1; i <= n; i++) {\n      f[i] = (int) ((long) f[i - 1] * i % mod);\n    }\n    long a = f[n];\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    invf[n] = (int) (p < 0 ? p + mod : p);\n    for (int i = n - 1; i >= 0; i--) {\n      invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n    }\n    return new int[][] {f, invf};\n  }\n\n  public static long invl(long a, long mod) {\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    return p < 0 ? p + mod : p;\n  }\n\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n\n", "code2": "$s = gets.chomp\n$result = 0\n\ndef calc(idxs)\n  sum = 0\n  start = 0\n  idxs.each do |idx|\n    sum += $s[start..(idx-1)].to_i\n    start = idx\n  end\n  return sum + $s[start..($s.size-1)].to_i\nend\n\ndef explore(idx=0, idxs=[])\n  if idx == $s.size-1 then\n    $result += calc(idxs)\n  else\n    explore(idx+1, idxs)\n    explore(idx+1, idxs + [idx+1])\n  end\nend\n\nexplore()\nputs $result", "label": 0, "name1": "s606179301.java", "name2": "s268035195.rb"}, {"id": 104, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tdouble a = sc.nextDouble();\n\t\tdouble b = sc.nextDouble();\n\t\tdouble C = sc.nextDouble();\n\t\t\n\t\tdouble S = 0.5*a*b*Math.sin(Math.toRadians(C));\n\t\tdouble c = Math.sqrt(Math.pow(a, 2)+Math.pow(b, 2)-(2*a*b*Math.cos(Math.toRadians(C))));\n\t\tdouble L = a + b + c;\n\t\tdouble h = 2*S / a;\n\t\t\n\t\tSystem.out.println(S);\n\t\tSystem.out.println(L);\n\t\tSystem.out.println(h);\n\n\t}\n}", "code2": "a, b, C = gets.split.map(&:to_i)\nrad = C * Math::PI / 180\n\nh = b * Math.sin(rad)\ns = a * h / 2\n\nc =  Math.sqrt(a ** 2 + b ** 2 - 2 * a * b * Math.cos(rad))\nl = a + b + c\n\nputs s\nputs l\nputs h", "label": 1, "name1": "s501686962.java", "name2": "s610004516.rb"}, {"id": 882, "code1": "import java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException{\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tString AtCoDeer = sc.next();\n\t\tString TopCoDeer = sc.next();\n\n\t\tif(AtCoDeer.equals(TopCoDeer)){\n\t\t\tSystem.out.println(\"H\");\n\t\t}else {\n\t\t\tSystem.out.println(\"D\");\n\t\t}\n\t}\n}\n", "code2": "1000.times do\n  puts \"Hello World\"\nend", "label": 0, "name1": "s574933896.java", "name2": "s077912847.rb"}, {"id": 80, "code1": "import java.io.*;\nimport java.util.*;\nimport static java.lang.System.out;\n\npublic class Main {\n    static MyReader in = new MyReader();\n\n    public static void main(String[] args) {\n        int N = in.i();\n        int k = ((int)Math.sqrt(1 + 8 * N) + 1) / 2;\n        out.println(k * (k - 1) / 2 == N ? solve(k) : \"No\");\n    }\n\n    static String solve(int k) {\n        StringBuilder sb = new StringBuilder(\"Yes\\n\");\n        sb.append(k).append('\\n');\n\n        for (int i = 1; i < k; i++) {\n            sb.append(k - 1).append(' ');\n\n            int t = 1 + i * (i - 1) / 2;\n            for (int j = 1; j < i; j++) {\n                sb.append(t++).append(' ');\n            }\n\n            for (int j = i; j < k; j++) {\n                sb.append(t).append(' ');\n                t += j;\n            }\n            sb.append('\\n');\n        }\n\n        sb.append(k - 1).append(' ');\n        int t = 1;\n        for (int i = 2; i <= k; i++) {\n            sb.append(t).append(' ');\n            t += i;\n        }\n\n        return sb.toString();\n    }\n}\n\nclass MyReader extends BufferedReader {\n    char[] cbuf = new char[1024];\n    int head = 0;\n    int tail = 0;\n\n    MyReader() {\n        super(new InputStreamReader(System.in));\n    }\n\n    char next() {\n        if (head == tail) {\n            try {\n                tail = super.read(cbuf, 0, cbuf.length);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            head = 0;\n        }\n        return cbuf[head++];\n    }\n\n    void back() {\n        head--;\n    }\n\n    boolean minus() {\n        boolean minus;\n        while (true) {\n            char c = next();\n            if (!isDelimiter(c)) {\n                if (!(minus = c == '-')) back();\n                return minus;\n            }\n        }\n    }\n\n    void skip() {\n        while (isDelimiter(next()));\n        back();\n    }\n\n    char[] s(int N) {\n        char[] cbuf = new char[N];\n        read(cbuf, 0, N);\n        return cbuf;\n    }\n\n    public int read(char[] cbuf, int off, int len) {\n        skip();\n        int i;\n        for (i = 0; i < cbuf.length; i++) {\n            char c = next();\n            if (isDelimiter(c)) {\n                break;\n            }\n            cbuf[i] = c;\n        }\n        return i;\n    }\n\n    boolean isDelimiter(char c) {\n        return c == ' ' || c == '\\n' || c == '\\r';\n    }\n\n    int i() {\n        boolean minus = minus();\n        int n = 0;\n        while (true) {\n            int k = next() - '0';\n            if (k < 0 || 9 < k) break;\n            n = 10 * n + k;\n        }\n        return minus ? -n : n;\n    }\n\n    int[] ii(final int N) {\n        int[] a = new int[N];\n        for (int j = 0; j < a.length; j++) a[j] = i();\n        return a;\n    }\n\n    long l() {\n        boolean minus = minus();\n        long n = 0;\n        while (true) {\n            int k = next() - '0';\n            if (k < 0 || 9 < k) break;\n            n = 10 * n + k;\n        }\n        return minus ? -n : n;\n    }\n}\n", "code2": "N = gets.to_i\nk = (1..N).find{|k|\n  k + (k * (k-1))/2 == N\n}\nif k.nil?\n  puts \"No\"; exit\nend\nputs \"Yes\"\nputs k+1\nputs \"#{k} \" + (1..k).to_a.join(' ')\nsets = Array.new(k){|i| [i+1] }\nn = k+1\nfor u in 0...k\n  for v in (u+1)...k\n    sets[u] << n\n    sets[v] << n\n    n += 1\n  end\nend\nsets.each do |set|\n  puts \"#{k} \" + set.join(' ')\nend", "label": 1, "name1": "s799940458.java", "name2": "s903511283.rb"}, {"id": 107, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        double[] a = new double[]{sc.nextDouble(), sc.nextDouble(), sc.nextDouble()};\n        System.out.println(a[0] * a[1] * Math.sin((Math.PI / 180) * a[2]) / 2.0);\n        System.out.println(\n            a[0] + a[1] + Math.sqrt(a[0] * a[0] + a[1] * a[1] - 2 * a[0] * a[1] * Math.cos(Math.PI / 180 * a[2])));\n        System.out.println(a[1] * Math.sin(Math.PI / 180 * a[2]));\n    }\n}", "code2": "include Math\na,b,C = gets.split.map(&:to_f)\nc = sqrt(a*a+b*b-2*a*b*cos(C*PI/180))\nputs (a/2)*b*sin(C*PI/180)\nputs a+b+c\nputs b*sin(C*PI/180)\n", "label": 1, "name1": "s203375488.java", "name2": "s653214785.rb"}, {"id": 702, "code1": "import java.util.*;\n\npublic class Main {\n    \n    public static boolean[] alr;\n    \n    public static List<List<Integer>> list = new ArrayList<>();\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        alr = new boolean[N];\n        for (int i = 0; i < N; i++) {\n            list.add(new ArrayList<>());\n        }\n        for (int i = 0; i < M; i++) {\n            int A = sc.nextInt()-1;\n            int B = sc.nextInt()-1;\n            list.get(A).add(B);\n            list.get(B).add(A);\n        }\n        long count = 0;\n        for (int i = 0; i < list.size(); i++) {\n            if (alr[i]) {\n                continue;\n            } else {\n                alr[i] = true;\n                count++;\n            }\n            List<Integer> lst = list.get(i);\n            count(lst);\n        }\n        System.out.println(count-1);\n    }\n    \n    private static void count(List<Integer> lst) {\n        int friends = 0;\n        for (Integer i : lst) {\n            if (alr[i]) {\n                continue;\n            } else {\n                alr[i] = true;\n            }           \n            count(list.get(i));\n        }\n    }\n}\n", "code2": "M=1000003\no=->a,n{n<1?1:(n%2>0?a:1)*o[a,n/2]**2%M}\nf=f=1,*(1..M).map{|i|f=f*i%M}\ngets\n$<.map{|s|x,d,n=s.split.map &:to_i\nt=x*o[d,M-2]%M\np d<1?o[x,n]:M<t+n ?0:f[t+n-1]*o[f[t-1],M-2]*o[d,n]%M}", "label": 0, "name1": "s602301737.java", "name2": "s167510522.rb"}, {"id": 306, "code1": "import java.io.*;\nimport java.util.StringTokenizer;\n\npublic final class Main{\n    public static void main(String[] args){\n        FastScanner stdIn = new FastScanner(System.in);\n        long a = stdIn.nextLong();\n        long b = stdIn.nextLong();\n        long c = stdIn.nextLong();\n\n        if(c-(a-b)<0){\n            System.out.println(0);\n        }else{\n            System.out.println(c-(a-b));\n        }\n    }\n}\n\nclass FastScanner {\n    private BufferedReader reader = null;\n    private StringTokenizer tokenizer = null;\n\n    public FastScanner(InputStream in) {\n        reader = new BufferedReader(new InputStreamReader(in));\n        tokenizer = null;\n    }\n\n    public String next() {\n        if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public String nextLine() {\n        if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        return tokenizer.nextToken(\"\\n\");\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n    \n    public long nextInt() {\n        return Integer.parseInt(next());\n    }\n\n}\n", "code2": "a, b, c = gets.strip.split(' ').map(&:to_i)\n\nans = 0\nif a - b < c then\n    ans = c - a + b\nend\n\nputs(ans)", "label": 1, "name1": "s641134227.java", "name2": "s914404322.rb"}, {"id": 89, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tblood_groups();\n\t}\n\n\tprivate static void blood_groups() {\n\t\tint[] bg = new int[4];\n\n\t\twhile (sc.hasNext()) {\n\t\t\tString[] datas = sc.nextLine().split(\",\");\n\n\t\t\tswitch( datas[1] ) {\n\t\t\tcase \"A\":\n\t\t\t\tbg[0]++;\n\t\t\t\tbreak;\n\t\t\tcase \"B\":\n\t\t\t\tbg[1]++;\n\t\t\t\tbreak;\n\t\t\tcase \"AB\":\n\t\t\t\tbg[2]++;\n\t\t\t\tbreak;\n\t\t\tcase \"O\":\n\t\t\t\tbg[3]++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(bg[0]);\n\t\tSystem.out.println(bg[1]);\n\t\tSystem.out.println(bg[2]);\n\t\tSystem.out.println(bg[3]);\n\n\t}\n\n}\n\n", "code2": "b = [0,0,0,0]\n\nwhile line = gets\nn1,n2 = line.chomp.split(\",\")\nif n2 == \"A\"\n  b[0] += 1\n  elsif n2 == \"B\"\n  b[1] += 1\n  elsif n2 == \"AB\"\n  b[2] += 1\n  elsif n2 == \"O\"\n  b[3] += 1\nend\nend\nputs b\n", "label": 1, "name1": "s776356865.java", "name2": "s150350303.rb"}, {"id": 330, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint a = scanner.nextInt(),b = scanner.nextInt(),c = scanner.nextInt();\n\t\tint[] x = {a,b,c};\n\t\tArrays.sort(x);\n\t\tSystem.out.println(x[0]+x[1]);\n\t}\n\n}\n", "code2": "price = gets.split.map(&:to_i)\nsorted_p = price.sort\nans = sorted_p[0] + sorted_p[1]\nputs ans", "label": 1, "name1": "s134824979.java", "name2": "s680191741.rb"}, {"id": 986, "code1": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.awt.Point;\n\npublic class Main {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"\";\n    int n;\n    void solve()\n    {\n        n = ni();\n        int[] d  = new int[n+1];\n        d[0] = 0;\n        for(int i = 0; i < n; i++){\n            d[i+1] = ni();\n        }\n        n++;\n        boolean[] seen = new boolean[25];\n        int min = 0;\n        int ans = 0;\n        for(int i = 0; i <= 24; i++){\n            int[][] e = new int[n][2];\n            e[0][0] = i;\n            e[0][1] = i;\n            for(int j = 0; j < n-1; j++){\n                e[j+1][0] = (d[j+1]+i)%24;\n                e[j+1][1] = (-d[j+1]+i+24)%24;\n            }\n            int left = 1;\n            int right = 24;\n            while(left+1<right){\n                int res = (left+right)/2;\n                if(f(e,res,0,seen)) left = res;\n                else{\n                    right = res;\n                }\n            }\n            if(left>min){\n                // if(left==5){\n                //     out.println(i);\n                // }\n                if(left == 1){\n                    if(f(e,left,0,seen)){\n                        min = left;\n                    }\n                }\n                else min = left;\n            }\n        }\n\n        ans = min;\n        out.println(ans);\n    }\n\n    boolean f(int[][] d, int sub, int k, boolean[] seen){\n        if(k==n){\n            return true;\n        }\n        boolean res = false;\n        for(int i = 0; i < 2; i++){\n            boolean[] seenc  = new boolean[25];\n            for(int j = 0; j <= 24; j++) seenc[j] = seen[j];\n            seenc[d[k][i]] = true;\n            if(d[k][i]==0) seenc[24] = true;\n            if(d[k][i]==24) seenc[0] = true;\n            for(int j = 0; j <= 24; j++){\n                if(d[k][i]-sub < j && j < d[k][i]+sub) seenc[j] = true;\n                if(d[k][i]-sub < 0 && j > d[k][i]-sub+24) seenc[j] = true;\n                if(d[k][i]+sub > 24 && j < d[k][i]+sub-24) seenc[j] = true;\n            }\n            // for(int g = 0; g <= 24; g++){\n            //     if(seenc[g]) out.print(g);\n            // }\n            // out.println();\n            // out.println(d[k][i]);\n            // if(!seen[d[k][i]])out.println(\"ok\");\n            // else out.println(\"ng\");\n            if(!seen[d[k][i]]){\n                if(d[k][i]==0){\n                    if(!seen[24])res |= f(d, sub, k+1, seenc);\n                } \n                else if(d[k][i]==24){\n                    if(!seen[0])res |= f(d, sub, k+1, seenc);\n                } \n                else res |= f(d, sub, k+1, seenc);\n            }\n        }  \n        return res;\n    }   \n    \n    void run() throws Exception\n    {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        \n        long s = System.currentTimeMillis();\n        solve();\n        out.flush();\n        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n    }\n    \n    public static void main(String[] args) throws Exception { new Main().run(); }\n    \n    private byte[] inbuf = new byte[1024];\n    private int lenbuf = 0, ptrbuf = 0;\n    \n    private int readByte()\n    {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n    \n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n    \n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n    \n    private String ns()\n    {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b) && b != ' ')){\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    \n    private char[] ns(int n)\n    {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    \n    private char[][] nm(int n, int m)\n    {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n    \n    private int[] na(int n)\n    {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n    \n    private int ni()\n    {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private long nl()\n    {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }\n\n    static class ArrayUtils {\n        public static void fill(double[][] array, double value) {\n            for (double[] a : array) Arrays.fill(a, value);\n        }\n \n        public static void fill(double[][][] array, double value) {\n            for (double[][] l : array) fill(l, value);\n        } \n    }\n}", "code2": "s = gets.chomp\nn = s.length\n\n1.upto(n) do |i|\n  guu = s[0...(n-i)]\n  c = guu.length/2\n  if guu[0...c] == guu[c..-1]\n    puts guu.length\n    exit\n  end\nend", "label": 0, "name1": "s840399954.java", "name2": "s983887093.rb"}, {"id": 93, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        final Scanner sc = new Scanner(System.in);\n\n        final long n = sc.nextLong();\n        final long k = sc.nextLong();\n\n        final long t = n % k;\n        System.out.println(Math.min(t, k-t));\n    }\n}\n", "code2": "N, K = gets.chomp.split(\" \").map(&:to_i)\n\ns, m = N.divmod(K)\nputs [N, m, (m-K).abs].min\n", "label": 1, "name1": "s071954198.java", "name2": "s201038310.rb"}, {"id": 55, "code1": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tvoid run(){\n\t\tint s=0;\n\t\tfor(int i=0; i<4; i++){\n\t\t\ts+=sc.nextInt();\n\t\t}\n\t\tprintln(s/60+\"\");\n\t\tprintln(s%60+\"\");\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}", "code2": "### main\n\nsec = 0\n4.times do\n  sec += gets.strip.to_i\nend\n\nputs sec / 60\nputs sec % 60", "label": 1, "name1": "s582549641.java", "name2": "s928347272.rb"}, {"id": 792, "code1": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n\t\t\tint K = io.nextInt();\n\t\t\tint L = io.nextInt();\n\n\t\t\tUnionFind uf1 = new UnionFind(n);\n\t\t\tUnionFind uf2 = new UnionFind(n);\n\t\t\tUnionFind uf3 = new UnionFind(n);\n\t\t\t\n\t\t\tfor (int i = 0; i < K; i++) {\n\t\t\t\tint a = io.nextInt() - 1;\n\t\t\t\tint b = io.nextInt() - 1;\n\t\t\t\tuf1.union(a, b);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < L; i++) {\n\t\t\t\tint a = io.nextInt() - 1;\n\t\t\t\tint b = io.nextInt() - 1;\n\t\t\t\tuf2.union(a, b);\n\t\t\t}\n\n\t\t\tTreeSet<Integer>[] s1 = new TreeSet[n];\n\t\t\tTreeSet<Integer>[] s2 = new TreeSet[n];\n\t\t\tfor (int i = 0; i < n; i++) if (uf1.root(i) == i) {\n\t\t\t\tTreeSet<Integer> s = new TreeSet<>();\n\t\t\t\tfor (int j = i; j != -1; j = uf1.next[j]) { s.add(j); }\n\t\t\t\ts1[i] = s;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) if (uf2.root(i) == i) {\n\t\t\t\tTreeSet<Integer> s = new TreeSet<>();\n\t\t\t\tfor (int j = i; j != -1; j = uf2.next[j]) { s.add(j); }\n\t\t\t\ts2[i] = s;\n\t\t\t}\n\t\t\t\n\t\t\tint[] ans = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint r1 = uf1.root(i);\n\t\t\t\tint r2 = uf2.root(i);\n\n\t\t\t\tif (!s1[r1].contains(i)) continue;\n\n\t\t\t\tTreeSet<Integer> a = s1[r1].size() < s2[r2].size() ? s1[r1] : s2[r2];\n\t\t\t\tTreeSet<Integer> b = s1[r1].size() < s2[r2].size() ? s2[r2] : s1[r1];\n\t\t\t\tList<Integer> same = new ArrayList<>();\n\t\t\t\tfor (int t : a) {\n\t\t\t\t\tif (b.contains(t)) same.add(t);\n\t\t\t\t}\n\t\t\t\tfor (int t : same) {\n\t\t\t\t\ts1[r1].remove(t);\n\t\t\t\t\ts2[r2].remove(t);\n\t\t\t\t\tans[t] = same.size();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tprintArrayLn(ans);\n\t\t}\n\t}\n\t\n\tstatic\n\tclass UnionFind {\n\t\tprivate int[] data;\n\t\tprivate int[] next;\n\t\tprivate int[] last;\n\t\t\n\t\tpublic UnionFind(int size) {\n\t\t\tdata = new int[size];\n\t\t\tnext = new int[size];\n\t\t\tlast = new int[size];\n\t\t\tclear();\n\t\t}\n\t\t\n\t\tpublic void clear() {\n\t\t\tArrays.fill(data, -1);\n\t\t\tArrays.fill(next, -1);\n\t\t\tfor(int i = 0; i < last.length; i++) {\n\t\t\t\tlast[i] = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int root(int x) { return data[x] < 0 ? x : (data[x] = root(data[x])); }\n\t\t\n\t\tpublic void union(int x, int y) {\n\t\t\tif((x = root(x)) != (y = root(y))) {\n\t\t\t\tif(data[y] < data[x]) { final int t = x; x = y; y = t; }\n\t\t\t\tdata[x] += data[y];\n\t\t\t\tdata[y] = x;\n\t\t\t\tnext[last[x]] = y;\n\t\t\t\tlast[x] = last[y];\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic boolean same(int x, int y) { return root(x) == root(y); }\n\t\tpublic int size(int x) { return -data[root(x)]; }\n\t}\n\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n", "code2": "#!ruby -apl\n$F[0]<?1&&exit\n$_=Time.gm(4,*$F).strftime\"%A\"", "label": 0, "name1": "s632399466.java", "name2": "s452040833.rb"}, {"id": 600, "code1": "import java.util.*;\npublic class Main {\n\tint n;\n\tint[] num;\n\tScanner stdin =new Scanner(System.in);\n\t\n\tvoid Solve(){\n\t\tnum=new int[21000000];\n\t\twhile(true){\n\t\t\tn=stdin.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tSystem.out.println(findPrime(n+1,2*n));\n\t\t}\n\t\t\n\t}\n\tint findPrime(int a,int b){\n\t\tint count=0;\n\t\tfor(int i=a;i<=b;i++){\n\t\t\tif(judgePrime(i)) count++;\n\t\t}\n\t\t\n\t\treturn count;\n\t}\n\t\n\tboolean judgePrime(int p){\n\t\tif(num[p]==1) return true;\n\t\tif(num[p]==-1) return false;\n\t\t\n\t\tif(p<4){\n\t\t\tnum[p]=1;\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\tif(p%2==0){\n\t\t\t\tnum[p]=-1;\n\t\t\t\treturn false; \n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=3;i<p;i++){\n\t\t\t\tif(p%i==0){\n\t\t\t\t\tnum[p]=-1;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tnum[p]=1;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\t\n\t\n\tpublic static void main(String args[]){\n\t\tMain m=new Main();\n\t\tm.Solve();\n\t}\n\t\n}", "code2": "X = gets.chomp\n\np 2*X.each_char.inject(0){|acc, c|\n\t[acc + (c.ord&2) - 1, 0].max\n}\n", "label": 0, "name1": "s726742249.java", "name2": "s636939727.rb"}, {"id": 121, "code1": "import java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\n\n \nclass Main implements Runnable {\n  // static Scanner in;\n  static FastReader in;\n  static PrintWriter out;\n  static int[][] dirs8 = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1, 1}, {-1, -1}, {-1, 1}, {1, -1}};\n  static int[][] dirs = {{0, -1}, {1, 0}, {0, +1}, {-1, 0}};\n \n  static int[][] E;\n  // static List<int[]>[] adj;\n  static List<Integer>[] adj;\n  static int[] vis;\n \n  static long INFL = (long) 1e15 + 7;\n  static int INF = (int) 1e9 + 7;\n  static int mod = 998244353;\n  \n  static int T, n, m, k, count, cur, w;\n  static boolean flag;\n  static int[] a, b;\n  static int[][] map;\n\n  static int[] par;\n  static boolean[] dp;\n\n  static void solve() throws Exception {\n    n = in.nextInt();\n    k = in.nextInt();\n    a = new int[n]; \n    for (int i = 0; i < n; i++) {a[i] = in.nextInt();}\n    dp = new boolean[k + 1];\n    // dp[i]: win(true) or loss(false) if \"I\" have i stones left and I am to play this round\n    dp[0] = false;\n    for (int i = 1; i <= k; i++) {\n      for (int x : a) {\n        if (x > i) {break;}\n        if (!dp[i - x]) {dp[i] = true; break;}\n      }\n    }\n    out.println(dp[k] ? \"First\" : \"Second\");\n  }\n\n\n  public static void main(String[] args) throws Exception {\n \n    // in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n    in = new FastReader();\n    out = new PrintWriter(System.out);\n \n    // int numOfTests = in.nextInt();\n    // for (int caseNum = 1; caseNum <= numOfTests; caseNum++) {\n    //   // Thread t = new Thread(null, new Main(), \"Main\", 1 << 28);\n    //   // t.start();\n    //   // t.join();\n    //   solve();\n    // }\n \n    // // Thread t = new Thread(null, new Main(), \"Main\", 1 << 28);\n    // // t.start();\n    // // t.join();\n    solve();\n \n    out.flush();\n    out.close();\n  }\n \n  @Override\n  public void run() {\n    try {\n      solve();\n    } catch (Exception e) {\n      e.printStackTrace(); \n    }\n  }\n \n  static class FastReader {\n    public BufferedReader br; \n    StringTokenizer st; \n    public FastReader() {br = new BufferedReader(new InputStreamReader(System.in));} \n    String next() { \n      while (st == null || !st.hasMoreElements()) { \n          try {st = new StringTokenizer(br.readLine());} \n          catch (IOException e) {e.printStackTrace();} \n      } \n      return st.nextToken(); \n    } \n    int nextInt() {return Integer.parseInt(next());} \n    long nextLong() {return Long.parseLong(next());} \n    double nextDouble() {return Double.parseDouble(next());} \n    String nextLine() {\n      String str = \"\"; \n        try {str = br.readLine();} \n        catch (IOException e) {e.printStackTrace();} \n        return str; \n    }\n  }\n\n  static void as(boolean result) throws Exception {\n    if (!result) {\n      throw new Exception();\n    }\n  }\n\n  static int modInverse(int a, int m) { \n    int m0 = m; \n    int y = 0, x = 1; \n    if (m == 1) {return 0;} \n    while (a > 1) { \n      // q is quotient \n      int q = a / m; \n      int t = m; \n      // m is remainder now, process \n      // same as Euclid's algo \n      m = a % m; \n      a = t; \n      t = y; \n      // Update x and y \n      y = x - q * y; \n      x = t; \n    } \n    // Make x positive \n    if (x < 0) \n      x += m0; \n    return x; \n  } \n} \n", "code2": "eval\"(*D),K,*A=\"+`dd`.split*?,;puts D[K.times{D<<A.none?{D[-_1]}}]?:Second: :First", "label": 1, "name1": "s772358717.java", "name2": "s954498434.rb"}, {"id": 457, "code1": "/*\n *           AUTHOR: Maria Theresa M. Padayhag\n *             DATE: 20160326\n *  PRE-REQUIREMENT: JDK 1.8\n */\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.time.*;\nimport java.time.format.TextStyle;\nimport java.util.Locale;\n\nclass DayIndentifier\n{\n\tLocalDate date = null;\n\t\n\tpublic \tDayIndentifier( String inMonth, String inDay )\n\t{\n\t\t// NumberFormatException might be thrown here\n\t\t// but it will be handled by the caller.\n\t\tint month = Integer.parseInt( inMonth );\n\t\tint day   = Integer.parseInt( inDay );\n\t\t\n\t\t// DateTimeException might be thrown here\n\t\t// but it will be handled by the caller.\n\t\tdate = LocalDate.of( 2004, month, day );\n\t}\n\t\n\tpublic String getDayOfWeek()\n\t{\n\t\t// NullPointerException might be thrown here\n\t\t// but it will handled by the caller.\n\t\treturn date.getDayOfWeek().getDisplayName(TextStyle.FULL, Locale.ENGLISH);\n\t}\n}\n\npublic class Main\n{\n\tpublic static boolean toExit( String[] dataset )\n\t{\n\t\tfor(String data: dataset)\n\t\t{\n\t\t\tif(data.equals(\"0\"))\n\t\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic static void main( String args[] ) throws IOException\n\t{\n\t\tBufferedReader br = new BufferedReader( new InputStreamReader( System.in ) );\n\t\tString input;\n\t\tString dataset[];\n\t\tDayIndentifier di;\n\t\t\n\t\tREAD: \n\t\twhile( ( input = br.readLine() ) != null ) {\n\t\t\ttry {\n\t\t\t\tdataset = input.split(\" \");\n\t\t\t\n\t\t\t\tif( toExit( dataset ) ) {\n\t\t\t\t\tbreak READ;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif( dataset.length != 2 ) {\n\t\t\t\t\tSystem.out.println(\"Invalid input.\");\n\t\t\t\t\tcontinue READ;\n\t\t\t\t} \t\t\n\t\t\t\t\n\t\t\t\tdi = new DayIndentifier(dataset[0], dataset[1]);\n\t\t\t\tSystem.out.println( di.getDayOfWeek() );\n\t\t\t} catch( Exception e ) {\n\t\t\t\tSystem.out.println(\"Invalid input.\");\n\t\t\t\tcontinue READ;\n\t\t\t}\t\t\n\t\t}\n\t}\n}", "code2": "#!ruby -pal\nexit if$F[0]==?0\n$_=Time.gm(4,*$F).strftime \"%A\"", "label": 1, "name1": "s944901694.java", "name2": "s335808393.rb"}, {"id": 158, "code1": "/**\n * Created at 16:38 on 2019-08-27\n */\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n  static FastScanner sc = new FastScanner();\n  static Output out = new Output(System.out);\n\n  static final int[] dx = {0, 1, 0, -1};\n  static final int[] dy = {-1, 0, 1, 0};\n\n  static final long MOD = (long) (1e9 + 7);\n  static final long INF = Long.MAX_VALUE / 2;\n\n  public static class Solver {\n    public Solver() {\n\n      int Q = sc.nextInt();\n\n      for (int q=0; q<Q; q++) {\n        long A = sc.nextLong();\n        long B = sc.nextLong();\n        long P = A * B;\n\n        long sqrt = sqrt(P-1);\n\n        long ans = 2*sqrt;\n\n        if (Math.min(A, B) <= sqrt) ans--; //\u9ad8\u6a4b\u541b\u3068\u540c\u3058\u9806\u4f4d\u306b\u306a\u3063\u3066\u3044\u308b\u3082\u306e\u3092\u9664\u304f\n        if (sqrt * (sqrt+1) > P-1) ans--; //\u30c0\u30d6\u30eb\u30ab\u30a6\u30f3\u30c8\u3057\u3066\u3044\u308b\u3082\u306e\u3092\u9664\u304f(x == y \u306e\u3068\u304d)\n\n        out.println(ans);\n      }\n\n\n    }\n\n    long sqrt(long n) {\n      long res = (long)Math.floor(Math.sqrt(n));\n      while (res * res > n) res--;\n      while ((res+1) * (res+1) <= n) res++;\n      return res;\n    }\n\n  }\n\n  public static void main(String[] args) {\n    new Solver();\n    out.flush();\n  }\n\n  static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int N, boolean oneBased) {\n      if (oneBased) {\n        int[] array = new int[N + 1];\n        for (int i = 1; i <= N; i++) {\n          array[i] = sc.nextInt();\n        }\n        return array;\n      } else {\n        int[] array = new int[N];\n        for (int i = 0; i < N; i++) {\n          array[i] = sc.nextInt();\n        }\n        return array;\n      }\n    }\n\n    public long[] nextLongArray(int N, boolean oneBased) {\n      if (oneBased) {\n        long[] array = new long[N + 1];\n        for (int i = 1; i <= N; i++) {\n          array[i] = sc.nextLong();\n        }\n        return array;\n      } else {\n        long[] array = new long[N];\n        for (int i = 0; i < N; i++) {\n          array[i] = sc.nextLong();\n        }\n        return array;\n      }\n    }\n  }\n\n  static class Output extends PrintWriter {\n\n    public Output(PrintStream ps) {\n      super(ps);\n    }\n\n    public void print(int[] a, String separator) {\n      for (int i = 0; i < a.length; i++) {\n        if (i == 0) print(a[i]);\n        else print(separator + a[i]);\n      }\n      println();\n    }\n\n    public void print(long[] a, String separator) {\n      for (int i = 0; i < a.length; i++) {\n        if (i == 0) print(a[i]);\n        else print(separator + a[i]);\n      }\n      println();\n    }\n\n    public void print(String[] a, String separator) {\n      for (int i = 0; i < a.length; i++) {\n        if (i == 0) print(a[i]);\n        else print(separator + a[i]);\n      }\n      println();\n    }\n\n    public void print(ArrayList a, String separator) {\n      for (int i = 0; i < a.size(); i++) {\n        if (i == 0) print(a.get(i));\n        else print(separator + a.get(i));\n      }\n      println();\n    }\n  }\n\n}\n", "code2": "Q = gets.to_i\nABs = readlines.map{|l| l.split.map(&:to_i)}\n\ndef solve(a, b)\n  s = a*b\n  a, b = [a, b].minmax\n  c = (Math.sqrt(s) - 1).ceil\n  case \n  when b == a, b == a + 1\n    2*a - 2\n  when c*(c + 1) >= s\n    2*c - 2\n  else\n    2*c - 1\n  end\nend\n\nABs.each{|a, b| puts solve(a, b)}", "label": 1, "name1": "s001351994.java", "name2": "s379184672.rb"}, {"id": 627, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n  public static void main(String[] args) {\n\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    long[] a = new long[n];\n\n    for (int i = 0; i < n; i++) {\n      a[i] = sc.nextInt();\n    }\n\n    Arrays.sort(a); // \u6607\u9806\n    long sum = a[n - 1];\n\n    if (n == 2) {\n      System.out.println(sum);\n    } else {\n      if (n % 2 == 1) {\n        int num = n / 2;\n        sum += a[n - num - 1];\n        for (int i = n - num; i < n - 1; i++) {\n          sum += 2 * a[i];\n        }\n        System.out.println(sum);\n      } else {\n        int num = n / 2;\n        for (int i = n - num; i < n - 1; i++) {\n          sum += 2 * a[i];\n        }\n        System.out.println(sum);\n      }\n    }\n\n  }\n}", "code2": "n=gets.to_i\nT=gets.split.map &:to_i\nA=gets.split.map &:to_i\nX=[0]*n\nc=0\na=1\nn.times{|i|\n  if T[i]!=c\n    X[i] = 1\n    a=0 if T[i]>A[i]\n  end\n  c=T[i]\n}\nY=[0]*n\nc=0\n(n-1).downto(0){|i|\n  if A[i]!=c\n    Y[i] = 1\n    a=0 if T[i]<A[i]\n  end\n  c=A[i]\n}\nn.times{|i|\n  if X[i]+Y[i]<1\n    a *= [T[i],A[i]].min\n    a %= 10**9+7\n  end\n}\np a", "label": 0, "name1": "s266436818.java", "name2": "s894245225.rb"}, {"id": 237, "code1": "import java.util.*;\nimport java.io.*;\n\nclass Main {\n    static int searchP(long p,int[] ws){\n        int count = 1;\n        int sum = 0; \n        for(int i = 0; i < ws.length; i++){\n            if(sum + ws[i] <= p) {\n            sum += ws[i];\n            } else {\n                count++;\n                if(ws[i] <= p){\n                sum = ws[i];\n                } else{\n                    count += 99999;\n                }\n            }\n        }\n        return count;\n    }\n    static long solve(long p, int[] ws, long k){\n        long right = p;\n        long left = 0;\n        long mid;\n        while(right - left > 1) {\n            mid = (left + right) / 2;\n            int v = searchP(mid,ws);\n            if(k >= v) {\n                right = mid;\n            } else {\n               left = mid;\n                \n            }\n        }\n    return right;\n    }\n    public static void main(String...args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        \n        String[] info = br.readLine().split(\" \");\n        int n = Integer.parseInt(info[0]);\n        int k = Integer.parseInt(info[1]);\n        int[] ws = new int[n];\n        for(int i = 0; i < n; i++) {\n            ws[i] = Integer.parseInt(br.readLine());\n        }\n        long p = 100000 * 10000;\n        System.out.println(solve(p,ws,k));\n        \n    }\n}\n\n\n\n", "code2": "n,k = gets.split.map(&:to_i)\nw = []\n(n).times do |i|\n  w[i] = gets.to_i\nend\nm = w.max\nans = (m..n*m).bsearch{|i|\n  count = 1\n  rest = i\n  for wi in w do\n    if rest >= wi\n      rest -= wi\n    else\n      count += 1\n      rest = i-wi\n    end\n  end\n  k >= count\n}\nprintf(\"%d\\n\",ans)\n", "label": 1, "name1": "s705576178.java", "name2": "s051438008.rb"}, {"id": 267, "code1": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Random;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        try (BufferedInputStream in = new BufferedInputStream(System.in);\n             PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out))) {\n\n            _Scanner sc = new _Scanner(in);\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            int c = sc.nextInt();\n            int k = sc.nextInt();\n\n            if (a + b >= k) {\n                out.println(Math.min(k, a));\n            } else {\n                out.println(a - (k - a - b));\n            }\n        }\n    }\n\n    private static void reverse(int[] vs) {\n        for (int i = 0; i < vs.length / 2; i++) {\n            swap(vs, i, vs.length - 1 - i);\n        }\n    }\n\n    static class _Scanner {\n        InputStream is;\n        _Scanner(InputStream is) {\n            this.is = is;\n        }\n        byte[] bb = new byte[1 << 15];\n        int k, l;\n        byte getc() {\n            try {\n                if (k >= l) {\n                    k = 0;\n                    l = is.read(bb);\n                    if (l < 0) return -1;\n                }\n                return bb[k++];\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        byte skip() {\n            byte b;\n            while ((b = getc()) <= 32)\n                ;\n            return b;\n        }\n\n        int nextInt() {\n            int n = 0;\n            int sig = 1;\n            for (byte b = skip(); b > 32; b = getc()) {\n                if (b == '-') {\n                    sig = -1;\n                } else {\n                    n = n * 10 + b - '0';\n                }\n            }\n            return sig * n;\n        }\n\n        long nextLong() {\n            long n = 0;\n            long sig = 1;\n            for (byte b = skip(); b > 32; b = getc()) {\n                if (b == '-') {\n                    sig = -1;\n                } else {\n                    n = n * 10 + b - '0';\n                }\n            }\n            return sig * n;\n        }\n\n        public String next() {\n            StringBuilder sb = new StringBuilder();\n            for (int b = skip(); b > 32; b = getc()) {\n                sb.append(((char) b));\n            }\n            return sb.toString();\n        }\n    }\n\n    private static void shuffle(int[] ar) {\n        Random rnd = new Random();\n        for (int i = 0; i < ar.length; i++) {\n            int j = i + rnd.nextInt(ar.length - i);\n            swap(ar, i, j);\n        }\n    }\n\n    private static void shuffle(Object[] ar) {\n        Random rnd = new Random();\n        for (int i = 0; i < ar.length; i++) {\n            int j = i + rnd.nextInt(ar.length - i);\n            swap(ar, i, j);\n        }\n    }\n\n    private static void swap(int[] ar, int i, int j) {\n        int t = ar[i];\n        ar[i] = ar[j];\n        ar[j] = t;\n    }\n\n    private static void swap(Object[] ar, int i, int j) {\n        Object t = ar[i];\n        ar[i] = ar[j];\n        ar[j] = t;\n    }\n\n\n}\n", "code2": "a, b, c, k = gets.split(\" \").map(&:to_i)\nsum = 0\nif k < a\n  sum = k\n  puts sum\n  exit\nelse\n  sum = a\n  k = k - a\nend\n\nif k < b\n  puts sum\n  exit\nelse\n  k = k - b\nend\n\nif k < c\n  sum = sum + (k * -1)\n  puts sum\nelse\n  sum = sum + (c * -1)\n  puts sum\nend", "label": 1, "name1": "s673107340.java", "name2": "s605447000.rb"}, {"id": 809, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.stream.IntStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.PriorityQueue;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.AbstractCollection;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            Dijkstra d = new Dijkstra(n);\n            for (int i = 0; i < n - 1; i++) {\n                int from = in.readInt() - 1;\n                int to = in.readInt() - 1;\n                d.addUndirectedEdge(from, to, 1);\n            }\n            long[] dist1 = d.getDist(0);\n            long[] distN = d.getDist(n - 1);\n            long count1 = IntStream.range(0, n)\n                    .filter(i -> dist1[i] <= distN[i])\n                    .count();\n            out.printLine(count1 > n - count1 ? \"Fennec\" : \"Snuke\");\n        }\n\n    }\n\n    static class Dijkstra {\n        int n;\n        ArrayList<Pair>[] G;\n        private long INF = Long.MAX_VALUE / 3;\n\n        public Dijkstra(int n) {\n            this.n = n;\n            G = new ArrayList[n];\n            for (int i = 0; i < n; i++) {\n                G[i] = new ArrayList<>();\n            }\n        }\n\n        public void addUndirectedEdge(int from, int to, long cost) {\n            G[from].add(new Pair(to, cost));\n            G[to].add(new Pair(from, cost));\n        }\n\n        public long[] getDist(int s) {\n            PriorityQueue<Pair> Q = new PriorityQueue<>();\n            Q.add(new Pair(s, 0));\n            long[] dist = new long[n];\n            Arrays.fill(dist, INF);\n            boolean[] used = new boolean[n];\n            while (!Q.isEmpty()) {\n                Pair p = Q.poll();\n                if (used[p.x]) continue;\n                used[p.x] = true;\n                dist[p.x] = p.y;\n\n                for (Pair edge : G[p.x]) {\n                    Q.add(new Pair(edge.x, p.y + edge.y));\n                }\n            }\n            return dist;\n        }\n\n        class Pair implements Comparable<Pair> {\n            int x;\n            long y;\n\n            Pair(int x, long y) {\n                this.x = x;\n                this.y = y;\n            }\n\n            public int compareTo(Pair p) {\n                return Long.compare(y, p.y);\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n}\n\n", "code2": "N, M = gets.split.map{|i|i.to_i}\nm = Array.new(N){Array.new(N){false}}\nM.times{\n    a, b = gets.split.map{|i|i.to_i - 1}\n    m[a][b] = true\n    m[b][a] = true\n}\n\nq = []\nq << [0]\ncount = 0\nuntil q.empty?\n    o = q.shift\n    if o.size == N\n        count += 1\n        next\n    end\n    n = o[-1]\n    N.times{|i|\n        next unless m[n][i]\n        next if o.include?(i)\n        q << (o + [i])\n    }\nend\nputs count\n", "label": 0, "name1": "s823656696.java", "name2": "s811488043.rb"}, {"id": 663, "code1": "import java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.util.Scanner;\n\npublic class Main{\n\tstatic Scanner sc;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t//InputStream in = new FileInputStream(\"src/input.txt\");\n\t\tInputStream in = System.in;\n\t\t//PrintStream out = new PrintStream(\"src/output.txt\");\n\n\t\t//System.setOut(out);\n\n\t\tsc = new Scanner(in);\n\n\t\tint N = sc.nextInt();\n\t\tint[] a = new int[N];\n\t\tint answer = 0;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(a[a[i]-1] == i+1){\n\t\t\t\tanswer++;\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(answer/2);\n\n\t\t//out.close();\n\t}\n}", "code2": "S = gets.chomp\nT = gets.chomp\n\noffset = (0 .. S.size - T.size).reverse_each.find do |offset|\n  found = T.size.times.all? do |i| \n    S[offset + i] == '?' || S[offset + i] == T[i]\n  end\nend\nif offset\n  z = S.tr('?','a')\n  z[offset,T.size] = T\n  puts z\nelse\n  puts \"UNRESTORABLE\"\nend", "label": 0, "name1": "s219137444.java", "name2": "s917754252.rb"}, {"id": 814, "code1": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\n\t\tint n = sc.nextInt();\n\n\t\tint a[] = new int[n];\n\t\tint b[] = new int[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tb[i] = sc.nextInt();\n\t\t}\n\n\t\tlong ba = 0;\n\t\tlong ab = 0;\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (b[i] > a[i]) {\n\t\t\t\tba += (b[i] - a[i]) / 2;\n\t\t\t} else {\n\t\t\t\tab += (a[i] - b[i]);\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tSystem.out.println(ab <= ba ? \"Yes\" : \"No\");\n\t}\n}\n", "code2": "N, M = gets.split.map(&:to_i)\ngraph = Array.new(N + 1) { [] }\nM.times do\n  a, b = gets.split.map(&:to_i)\n  graph[a] << b\n  graph[b] << a\nend\n\nans = 0\n(2..N).to_a.permutation(N - 1).each do |p|\n  p.unshift(1)\n  ans += 1 if (1...N).all? { |i| graph[p[i - 1]].include?(p[i]) }\nend\nputs ans\n", "label": 0, "name1": "s582242118.java", "name2": "s112297491.rb"}, {"id": 315, "code1": "import java.util.*;\n\npublic class Main {\n  public static long MOD = (long)Math.pow(10, 6) + 3;\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    long[] kai = new long[(int)MOD];\n//    long[] inkai = new long[(int)MOD];\n//    long[] in = new long[(int)MOD];\n    kai[0] = 1;\n    kai[1] = 1;\n//    inkai[0] = 1;\n//    inkai[1] = 1;\n//    in[1] = 1;\n    for(long i = 2; i < MOD; i++) {\n      kai[(int)i] = (i * kai[(int)i - 1]) % MOD;\n//      inkai[(int)i] = func(kai[(int)i], MOD - 2);\n//      in[(int)i] = func(i, MOD - 2);\n    }\n    int q = sc.nextInt();\n    for(int i = 0; i < q; i++) {\n      long x = sc.nextLong();\n      long d = sc.nextLong();\n      long n = sc.nextLong();\n      long ans = 0;\n      if(d == 0) {\n        if(x == 0) {\n          ans = 0;\n        } else {\n          ans = func(x, n % (MOD - 1));\n        }\n      } else {\n        long inv = func(d, MOD - 2);\n        x = (x * inv) % MOD;\n        if(x == 0) {\n          ans = 0;\n        } else {\n          if((int)(x + n - 1) >= MOD) {\n            ans = 0;\n          } else {\n            long t = func(d, n % (MOD - 1));\n            long invkai = func(kai[(int)x - 1], MOD - 2);\n            ans = (((kai[(int)(x + n - 1)] * invkai) % MOD) * t) % MOD;\n          }\n        }\n      }\n      System.out.println(ans);\n    }\n  }\n  public static long func(long a, long x) {\n    if(x == 0) return 1;\n    if(x >= 1) {\n      if(x % 2 == 0) {\n        long t = func(a, x / 2);\n        return (t * t) % MOD;\n      } else {\n        long t = func(a, x - 1);\n        return (a * t) % MOD;\n      }\n    }\n    return 0;\n  } \n}", "code2": "M=1000003\no=->a,n{n<1?1:(n%2>0?a:1)*o[a,n/2]**2%M}\nf=f=1,*(1..M).map{|i|f=f*i%M}\ngets\n$<.map{|s|x,d,n=s.split.map &:to_i\nt=x*o[d,M-2]%M\np d<1?o[x,n]:M<t+n ?0:f[t+n-1]*o[f[t-1],M-2]*o[d,n]%M}", "label": 1, "name1": "s406339057.java", "name2": "s167510522.rb"}, {"id": 186, "code1": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\n\tprivate static Scanner sc;\n\tprivate static Printer pr;\n\n\tprivate static void solve() {\n\t\tint a = sc.nextInt();\n\t\tint b = sc.nextInt();\n\n\t\tif (b < a) {\n\t\t\ta--;\n\t\t}\n\n\t\tpr.println(a);\n\t}\n\n\t// ---------------------------------------------------\n\tpublic static void main(String[] args) {\n\t\tsc = new Scanner(INPUT == null ? System.in : new ByteArrayInputStream(INPUT.getBytes()));\n\t\tpr = new Printer(System.out);\n\n\t\tsolve();\n\n//\t\tpr.close();\n\t\tpr.flush();\n//\t\tsc.close();\n\t}\n\n\tstatic String INPUT = null;\n\n\tprivate static class Printer extends PrintWriter {\n\t\tPrinter(OutputStream out) {\n\t\t\tsuper(out);\n\t\t}\n\t}\n}\n", "code2": "a,b=gets.split.map &:to_i;p a-(a>b ? 1 : 0)", "label": 1, "name1": "s998480605.java", "name2": "s514721505.rb"}, {"id": 932, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.UncheckedIOException;\nimport java.util.StringTokenizer;\n\n\nclass Main{\n\tstatic int[][] ban;\n\tstatic boolean[][] visited;\n\tstatic long sum=0;\n\tstatic int H,W;\n\tstatic long kuro=0;\n\tstatic long siro=0;\n\tpublic static void main(String[] args) {\n\t\tSC sc=new SC(System.in);\n\t\tH=sc.nextInt();\n\t\tW=sc.nextInt();\n\t\tvisited=new boolean[H][W];\n\t\tban=new int[H][W];\n\t\tString s;\n\t\tfor(int i=0; i<H; i++){\n\t\t\ts=sc.next();\n\t\t\tfor(int j=0; j<W; j++){\n\t\t\t\tif(s.charAt(j)=='#'){\n\t\t\t\t\tban[i][j]=1;\t//\u9ed2\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tban[i][j]=0;\t//\u767d\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<H; i++){\t\t//\u3057\u3089\u3079\u308b\n\t\t\tfor(int j=0; j<W; j++){\n\t\t\t\tif(ban[i][j]==1 && !visited[i][j]){\n\t\t\t\t\tkuro=0; siro=0;\n\t\t\t\t\tdfs(i,j);\n\t\t\t\t\tsum+=kuro*siro;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpl(sum);\n\t}\n\n\tpublic static void dfs(int y,int x){\n\t\tint[] vx={0,1,0,-1};\n\t\tint[] vy={-1,0,1,0};\n\t\tif(ban[y][x]==1){\n\t\t\tkuro++;\n\t\t}\n\t\telse{\n\t\t\tsiro++;\n\t\t}\n\t\tvisited[y][x]=true;\n\t\tfor(int i=0; i<4; i++){\n\t\t\tif(x+vx[i]>=0 && x+vx[i]<W && y+vy[i]>=0 && y+vy[i]<H){\n\t\t\t\tif(ban[y][x]!=ban[y+vy[i]][x+vx[i]] && !visited[y+vy[i]][x+vx[i]]){\n\t\t\t\t\tdfs(y+vy[i],x+vx[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void pl(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\tpublic static void pl() {\n\t\tSystem.out.println();\n\t}\n\tpublic static void p(Object o) {\n\t\tSystem.out.print(o);\n\t}\n\tstatic class SC {\n\t\tprivate BufferedReader reader = null;\n\t\tprivate StringTokenizer tokenizer = null;\n\t\tpublic SC(InputStream in) {\n\t\t\treader = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\t\tpublic String next() {\n\t\t\tif (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new UncheckedIOException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new UncheckedIOException(e);\n\t\t\t}\n\t\t}\n\t}\n}", "code2": "n,*a=`dd`.split.map &:to_i;p (1..2*n).bsearch(&->x{b=a.map{|e|e<x};1.upto(n){|i|[-1,1].map{|f|return x if b[n+i*f-1]==x=b[n+i*f-f-1]}};b[0]})-1", "label": 0, "name1": "s037642808.java", "name2": "s095757920.rb"}, {"id": 875, "code1": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint a = sc.nextInt();\n\t\tint b = sc.nextInt();\n\t\tint c = sc.nextInt();\n\t\tint x = sc.nextInt();\n\t\tint y = sc.nextInt();\n\t\tlong ans = 0;\n\t\tint tmp = Math.min(x, y);\n\t\tx -= tmp;\n\t\ty -= tmp;\n\t\tif(a + b < 2 * c) {\n\t\t\tans += tmp * (a + b);\n\t\t} else {\n\t\t\tans += tmp * 2 * c;\n\t\t}\n\t\tif(x % 2 == 1) {\n\t\t\tif(a < 2 * c) {\n\t\t\t\tans += a;\n\t\t\t} else {\n\t\t\t\tans += 2 * c;\n\t\t\t}\n\t\t\tx--;\n\t\t}\n\t\tif(a < 2 * c) {\n\t\t\tans += a * x;\n\t\t} else {\n\t\t\tans += 2 * c * x;\n\t\t}\n\t\tif(y % 2 == 1) {\n\t\t\tif(b < 2 * c) {\n\t\t\t\tans += b;\n\t\t\t} else {\n\t\t\t\tans += 2 * c;\n\t\t\t}\n\t\t\ty--;\n\t\t}\n\t\tif(b < 2 * c) {\n\t\t\tans += b * y;\n\t\t} else {\n\t\t\tans += 2 * c * y;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n}\n", "code2": "k = gets.chomp.to_i\na,b = gets.chomp.split(' ').map(&:to_i)\n \n(a..b).each do |n|\n  if n%k == 0\n    puts \"OK\"\n    exit\n  end\nend\n  puts \"NG\"", "label": 0, "name1": "s186641609.java", "name2": "s738091462.rb"}, {"id": 568, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        double[] a = new double[]{sc.nextDouble(), sc.nextDouble(), sc.nextDouble()};\n        System.out.println(a[0] * a[1] * Math.sin((Math.PI / 180) * a[2]) / 2.0);\n        System.out.println(\n            a[0] + a[1] + Math.sqrt(a[0] * a[0] + a[1] * a[1] - 2 * a[0] * a[1] * Math.cos(Math.PI / 180 * a[2])));\n        System.out.println(a[1] * Math.sin(Math.PI / 180 * a[2]));\n    }\n}", "code2": "i = gets.split(\" \")\nif i[0].to_i < i[1].to_i then\n  if i[0].to_i < i[2].to_i and i[2].to_i < i[1].to_i then\n    print \"Yes\"\n  else\n    print \"No\"\n  end\n  else\n    if i[0].to_i > i[2].to_i and i[2].to_i > i[1].to_i then\n      print \"Yes\"\n    else\n      print \"No\"\n    end\n    end", "label": 0, "name1": "s203375488.java", "name2": "s608185400.rb"}, {"id": 970, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = Integer.parseInt(sc.next());\n\t\tlong[] a = new long[n];\n\t\tlong[] b = new long[n];\n\t\tlong[] c = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = Long.parseLong(sc.next());\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tb[i] = Long.parseLong(sc.next());\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tc[i] = Long.parseLong(sc.next());\n\t\tArrays.sort(a);\n\t\tArrays.sort(b);\n\t\tArrays.sort(c);\n\t\tlong[] u = new long[n];\n\t\tint index = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\twhile (index < n && a[index] < b[i])\n\t\t\t\tindex++;\n\t\t\tif (i == 0)\n\t\t\t\tu[i] = index;\n\t\t\telse\n\t\t\t\tu[i] = u[i - 1] + index;\n\t\t}\n\t\tint[] l = new int[n];\n\t\tindex = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\twhile (index < n && b[index] < c[i])\n\t\t\t\tindex++;\n\t\t\tl[i] = index;\n\t\t}\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (l[i] != 0)\n\t\t\t\tans += u[l[i] - 1];\n\t\tSystem.out.println(ans);\n\n\t}\n}", "code2": "n, a, b=gets.strip.split.map(&:to_i)\nh = readlines.map {|line| line.strip.to_i }\nc=a-b\n\nok=h.inject(:+)\nng=0\n\nuntil ok-ng==1\n  mid = (ok+ng)/2\n  remains = h.map {|e| e-mid*b }.select {|e| e>0 }\n  r_c = remains.map {|e| e/c + ((e.ceil%c).zero? ? 0 : 1) }.inject(0, :+)\n  if r_c > mid\n    ng=mid.to_i\n  else\n    ok=mid.to_i\n  end\nend\n\np ok", "label": 0, "name1": "s329855365.java", "name2": "s037770959.rb"}, {"id": 705, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint a=scan.nextInt();\n\t\tint b=scan.nextInt();\n\t\tint c=scan.nextInt();\n\t\tint d=a-b;\n\t\tif(c-d>0) System.out.println(c-d);\n\t\telse System.out.println(\"0\");\n\n\t}\n\n}\n", "code2": "M=1000003\no=->a,n{n<1?1:(n%2>0?a:1)*o[a,n/2]**2%M}\nf=f=1,*(1..M).map{|i|f=f*i%M}\ngets\n$<.map{|s|x,d,n=s.split.map &:to_i\nt=x*o[d,M-2]%M\np d<1?o[x,n]:M<t+n ?0:f[t+n-1]*o[f[t-1],M-2]*o[d,n]%M}", "label": 0, "name1": "s407931652.java", "name2": "s167510522.rb"}, {"id": 450, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\t\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tString[] days={\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\"};\n\t\twhile(sc.hasNextInt()){\n\t\t\tint month=sc.nextInt();\n\t\t\tint day=sc.nextInt();\n\t\t\tint a=modd(month);\n\t\t\tint b=a+day;\n\t\t\tif(month==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif((b-1)%7==0){\n\t\t\t\tSystem.out.println(days[0]);\n\t\t}else if((b-1)%7==1){\n\t\t\tSystem.out.println(days[1]);\n\t\t}else if((b-1)%7==2){\n\t\t\tSystem.out.println(days[2]);\n\t\t}else if((b-1)%7==3){\n\t\t\tSystem.out.println(days[3]);\n\t\t}else if((b-1)%7==4){\n\t\t\tSystem.out.println(days[4]);\n\t\t}else if((b-1)%7==5){\n\t\t\tSystem.out.println(days[5]);\n\t\t}else if((b-1)%7==6){\n\t\t\tSystem.out.println(days[6]);\n\t\t}\n\t}\n\n\t}\n\tpublic static int modd(int month){\n\t\tint[] months={31,29,31,30,31,30,31,31,30,31,30,31};\n\t\tint a=0;\n\t\tfor(int i=0; i<=month-2; i++){\n\t\t\ta+=months[i];\n\t\t}\n\n\t\treturn a;\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n}", "code2": "#!ruby -apl\n$F[0]<?1&&exit\n$_=Time.gm(4,*$F).strftime\"%A\"", "label": 1, "name1": "s331323698.java", "name2": "s452040833.rb"}, {"id": 717, "code1": "import java.util.Scanner;\n\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    // \u6574\u6570\u306e\u5165\u529b\n    int a = sc.nextInt();\n    // \u30b9\u30da\u30fc\u30b9\u533a\u5207\u308a\u306e\u6574\u6570\u306e\u5165\u529b\n    int b = sc.nextInt();\n    int c = sc.nextInt();\n\n//    int ab = a + b;\n//    int bc = b + c;\n//    int ac = a+c;\n//\n//    int result = Math.min(ab, Math.min(bc , ac));\n\n    int max = Math.max(a, Math.max(b, c));\n\n    System.out.println(a + b + c - max);\n  }\n}\n", "code2": "def main\n  s = ARGF.gets.chomp\n\n  # + \u3092\u5165\u308c\u3089\u308c\u308b\u5834\u6240\u306e\u6570\n  n = s.length - 1\n\n  sum = 0\n  # 2^n     = 1 << n\n  0.upto((1 << n) - 1) do |mask|\n    # puts \"mask = #{mask}\"\n    last_idx = 0\n    0.upto(n-1) do |i|\n      if mask[i] == 1\n        # '+'\u3092 i\u756a\u76ee \u3068 i+1\u756a\u76ee\u306e\u9593\u306b\u5165\u308c\u308b\n        part = s.slice(last_idx, i - last_idx + 1)\n        # puts part\n        sum += part.to_i\n        last_idx = i+1\n      end\n    end\n    last_part = s.slice(last_idx..-1)\n    # puts last_part\n    sum += last_part.to_i\n  end\n\n  puts sum\nend\n\nif __FILE__ == $0\n  main\nend\n", "label": 0, "name1": "s393158982.java", "name2": "s267462480.rb"}, {"id": 247, "code1": "import java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.util.Scanner;\n\npublic class Main{\n\tstatic Scanner sc;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t//InputStream in = new FileInputStream(\"src/input.txt\");\n\t\tInputStream in = System.in;\n\t\t//PrintStream out = new PrintStream(\"src/output.txt\");\n\n\t\t//System.setOut(out);\n\n\t\tsc = new Scanner(in);\n\n\t\tint N = sc.nextInt();\n\t\tint[] a = new int[N];\n\t\tint answer = 0;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(a[a[i]-1] == i+1){\n\t\t\t\tanswer++;\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(answer/2);\n\n\t\t//out.close();\n\t}\n}", "code2": "n=gets.to_i\nas=gets.chomp.split.map(&:to_i)\na=0\nn.times{|i|\n    if as[as[i] - 1] - 1 == i\n        a += 1\n    end\n}\np a / 2\n", "label": 1, "name1": "s219137444.java", "name2": "s050852619.rb"}, {"id": 176, "code1": "\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int W = sc.nextInt();\n\t\t\tfinal int H = sc.nextInt();\n\t\t\t\n\t\t\tif(W == 0  && H == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] map = new int[H][W];\n\t\t\t\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tchar[] input = sc.next().toCharArray();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tif('0' <= input[j] && input[j] <= '9'){\n\t\t\t\t\t\tmap[i][j] = input[j] - '0';\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][] len = new int[H][W];\n\t\t\tshort[][][] dp = new short[H][W][H+W+1];\n\t\t\t\n\t\t\tint max = 0;\n\t\t\tint m_x = -1;\n\t\t\tint m_y = -1;\n\t\t\t\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tif(map[i][j] < 0){\n\t\t\t\t\t\tdp[i][j][0] = -1;\n\t\t\t\t\t\tlen[i][j] = -1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(i == 0 && j == 0){\n\t\t\t\t\t\tdp[i][j][0] = (short)(map[i][j]);\n\t\t\t\t\t\tlen[i][j] = map[i][j] == 0 ? 0 : 1;\n\t\t\t\t\t}else if(j == 0){\n\t\t\t\t\t\tfinal int p_len = len[i-1][j];\n\t\t\t\t\t\tif(p_len == -1){\n\t\t\t\t\t\t\tdp[i][j][0] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = map[i][j] == 0 ? 0 : 1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tSystem.arraycopy(dp[i-1][j], 0, dp[i][j], 0, p_len);\n\t\t\t\t\t\t\tdp[i][j][p_len] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = p_len +  (p_len == 0 && map[i][j] == 0 ? 0 : 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(i == 0){\n\t\t\t\t\t\tfinal int p_len = len[i][j-1];\n\t\t\t\t\t\tif(p_len == -1){\n\t\t\t\t\t\t\tdp[i][j][0] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = map[i][j] == 0 ? 0 : 1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tSystem.arraycopy(dp[i][j-1], 0, dp[i][j], 0, p_len);\n\t\t\t\t\t\t\tdp[i][j][p_len] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = p_len + (p_len == 0 && map[i][j] == 0 ? 0 : 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfinal int left_len = len[i][j-1];\n\t\t\t\t\t\tfinal int up_len = len[i-1][j];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(left_len == -1 && up_len == -1){\n\t\t\t\t\t\t\tdp[i][j][0] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = map[i][j] == 0 ? 0 : 1;\n\t\t\t\t\t\t}else if(left_len > up_len){\n\t\t\t\t\t\t\tfinal int p_len = len[i][j-1];\n\t\t\t\t\t\t\tSystem.arraycopy(dp[i][j-1], 0, dp[i][j], 0, p_len);\n\t\t\t\t\t\t\tdp[i][j][p_len] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = p_len + (p_len == 0 && map[i][j] == 0 ? 0 : 1);\n\t\t\t\t\t\t}else if(left_len < up_len){\n\t\t\t\t\t\t\tfinal int p_len = len[i-1][j];\n\t\t\t\t\t\t\tSystem.arraycopy(dp[i-1][j], 0, dp[i][j], 0, p_len);\n\t\t\t\t\t\t\tdp[i][j][p_len] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = p_len + (p_len == 0 && map[i][j] == 0 ? 0 : 1);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tfinal int size = len[i][j-1];\n\t\t\t\t\t\t\tboolean left_f = true;\n\t\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\t\tif(dp[i-1][j][k] < dp[i][j-1][k]){\n\t\t\t\t\t\t\t\t\tleft_f = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}else if(dp[i-1][j][k] > dp[i][j-1][k]){\n\t\t\t\t\t\t\t\t\tleft_f = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(left_f){\n\t\t\t\t\t\t\t\tfinal int p_len = len[i][j-1];\n\t\t\t\t\t\t\t\tSystem.arraycopy(dp[i][j-1], 0, dp[i][j], 0, p_len);\n\t\t\t\t\t\t\t\tdp[i][j][p_len] = (short)(map[i][j]);\n\t\t\t\t\t\t\t\tlen[i][j] = p_len + (p_len == 0 && map[i][j] == 0 ? 0 : 1);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tfinal int p_len = len[i-1][j];\n\t\t\t\t\t\t\t\tSystem.arraycopy(dp[i-1][j], 0, dp[i][j], 0, p_len);\n\t\t\t\t\t\t\t\tdp[i][j][p_len] = (short)(map[i][j]);\n\t\t\t\t\t\t\t\tlen[i][j] = p_len + (p_len == 0 && map[i][j] == 0 ? 0 : 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(max < len[i][j]){\n\t\t\t\t\t\tmax = len[i][j];\n\t\t\t\t\t\tm_x = j;\n\t\t\t\t\t\tm_y = i;\n\t\t\t\t\t}else if(max == len[i][j]){\n\t\t\t\t\t\tfinal int size = len[i][j];\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(dp[m_y][m_x][k] < dp[i][j][k]){\n\t\t\t\t\t\t\t\tmax = len[i][j];\n\t\t\t\t\t\t\t\tm_x = j;\n\t\t\t\t\t\t\t\tm_y = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(dp[m_y][m_x][k] > dp[i][j][k]){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tSystem.out.printf(\"%2d \", len[i][j]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t*/\n\t\t\tfor(int i = 0; i < max; i++){\n\t\t\t\tSystem.out.print(dp[m_y][m_x][i]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t\n\t}\n\n}", "code2": "loop {\n    w, h = gets.split.map &:to_i\n    break if w == 0\n    max = (1..h).map{ gets.split(\"\").map{|s| s =~ /\\d/ ? s.to_i : -1} }\n    \n    opt = 0 \n    (0..h-1).each{|i|\n        (0..w-1).each{|j|\n            next if max[i][j] < 0 \n            m = 0 \n            m = max[i-1][j] if i > 0 && max[i-1][j] > m \n            m = max[i][j-1] if j > 0 && max[i][j-1] > m \n            max[i][j] += 10 * m \n            opt = max[i][j] if max[i][j] > opt \n        }\n    }   \n    p opt \n}", "label": 1, "name1": "s531751281.java", "name2": "s661213064.rb"}, {"id": 257, "code1": "import java.io.File;\nimport java.io.IOException;\nimport java.util.*;\n \npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\t//File file = new File(\"input.txt\");\n\t\t//Scanner in = new Scanner(file);\n\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\t\n\t\tString SS = in.next();\n\t\tString T = in.next();\n\t\t\n\t\tint index = SS.length() - T.length();\n\t\t\n\t\twhile(index >= 0){\n\t\t\tString s = SS.substring(index, index + T.length());\n\t\t\t\n\t\t\tboolean tf = true;\n\t\t\tfor(int i = 0; i < T.length(); i++){\n\t\t\t\tif(s.charAt(i) != '?' && s.charAt(i) != T.charAt(i)){\n\t\t\t\t\ttf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(tf){\n\t\t\t\tSS = new StringBuilder(SS).replace(index, index + s.length(), T).toString();\n\t\t\t\tSS = SS.replace('?', 'a');\n\t\t\t\tSystem.out.println(SS);\n\t\t\t\treturn;\n\t\t\t}else{\n\t\t\t\tindex--;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"UNRESTORABLE\");\n\t}\n}", "code2": "S = gets.chomp.chars\nT = gets.chomp.chars\n\ns = S.length\nt = T.length\n\n(s-t).downto(0).each do |i|\n  check = S[i..i+t-1].zip(T).all?{|a,b| a == b or a == \"?\"}\n  if check\n    retval = S.join.gsub(\"?\", \"a\").chars\n    retval[i..i+t-1] = T\n    puts(retval.join)\n    exit\n  end\nend\n\nputs \"UNRESTORABLE\"", "label": 1, "name1": "s419255365.java", "name2": "s623715533.rb"}, {"id": 122, "code1": "import java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\n\n \nclass Main implements Runnable {\n  // static Scanner in;\n  static FastReader in;\n  static PrintWriter out;\n  static int[][] dirs8 = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1, 1}, {-1, -1}, {-1, 1}, {1, -1}};\n  static int[][] dirs = {{0, -1}, {1, 0}, {0, +1}, {-1, 0}};\n \n  static int[][] E;\n  // static List<int[]>[] adj;\n  static List<Integer>[] adj;\n  static int[] vis;\n \n  static long INFL = (long) 1e15 + 7;\n  static int INF = (int) 1e9 + 7;\n  static int mod = 998244353;\n  \n  static int T, n, m, k, count, cur, w;\n  static boolean flag;\n  static int[] a, b;\n  static int[][] map;\n\n  static int[] par;\n  static boolean[] dp;\n\n  static void solve() throws Exception {\n    n = in.nextInt();\n    k = in.nextInt();\n    a = new int[n]; \n    for (int i = 0; i < n; i++) {a[i] = in.nextInt();}\n    dp = new boolean[k + 1];\n    // dp[i]: win(true) or loss(false) if \"I\" have i stones left and I am to play this round\n    dp[0] = false;\n    for (int i = 1; i <= k; i++) {\n      for (int x : a) {\n        if (x > i) {break;}\n        if (!dp[i - x]) {dp[i] = true; break;}\n      }\n    }\n    out.println(dp[k] ? \"First\" : \"Second\");\n  }\n\n\n  public static void main(String[] args) throws Exception {\n \n    // in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n    in = new FastReader();\n    out = new PrintWriter(System.out);\n \n    // int numOfTests = in.nextInt();\n    // for (int caseNum = 1; caseNum <= numOfTests; caseNum++) {\n    //   // Thread t = new Thread(null, new Main(), \"Main\", 1 << 28);\n    //   // t.start();\n    //   // t.join();\n    //   solve();\n    // }\n \n    // // Thread t = new Thread(null, new Main(), \"Main\", 1 << 28);\n    // // t.start();\n    // // t.join();\n    solve();\n \n    out.flush();\n    out.close();\n  }\n \n  @Override\n  public void run() {\n    try {\n      solve();\n    } catch (Exception e) {\n      e.printStackTrace(); \n    }\n  }\n \n  static class FastReader {\n    public BufferedReader br; \n    StringTokenizer st; \n    public FastReader() {br = new BufferedReader(new InputStreamReader(System.in));} \n    String next() { \n      while (st == null || !st.hasMoreElements()) { \n          try {st = new StringTokenizer(br.readLine());} \n          catch (IOException e) {e.printStackTrace();} \n      } \n      return st.nextToken(); \n    } \n    int nextInt() {return Integer.parseInt(next());} \n    long nextLong() {return Long.parseLong(next());} \n    double nextDouble() {return Double.parseDouble(next());} \n    String nextLine() {\n      String str = \"\"; \n        try {str = br.readLine();} \n        catch (IOException e) {e.printStackTrace();} \n        return str; \n    }\n  }\n\n  static void as(boolean result) throws Exception {\n    if (!result) {\n      throw new Exception();\n    }\n  }\n\n  static int modInverse(int a, int m) { \n    int m0 = m; \n    int y = 0, x = 1; \n    if (m == 1) {return 0;} \n    while (a > 1) { \n      // q is quotient \n      int q = a / m; \n      int t = m; \n      // m is remainder now, process \n      // same as Euclid's algo \n      m = a % m; \n      a = t; \n      t = y; \n      // Update x and y \n      y = x - q * y; \n      x = t; \n    } \n    // Make x positive \n    if (x < 0) \n      x += m0; \n    return x; \n  } \n} \n", "code2": "n, k = gets.split.map(&:to_i)\na = gets.split.map(&:to_i)\n\ndp = Array.new(k+1) {[nil, nil]}\n\n(k+1).times do |i|\n    2.times do |player|\n        a.each do |e|\n            break 1 if i < e\n\n            if dp[i-e][player ^ 1] == player\n                dp[i][player] = player\n                break\n            end\n        end or next\n        dp[i][player] = player ^ 1\n    end\nend\n\nputs dp[k][0] == 0 ? \"First\" : \"Second\"", "label": 1, "name1": "s772358717.java", "name2": "s959450124.rb"}, {"id": 81, "code1": "import java.util.Scanner;\n\nclass Main\n{\n\tpublic static void main(String args[])\n\t{\n\t\tScanner sc = new Scanner(System.in).useDelimiter(\"[,\\n]\");\n\t\t\n\t\tint a = 0;\n\t\tint b = 0;\n\t\tint o = 0;\n\t\tint ab = 0;\n\t\t\n\t\twhile (sc.hasNext())\n\t\t{\n\t\t\tsc.nextInt();\n\t\t\tString str = sc.next();\n\t\t\tif (str.equals(\"A\"))\n\t\t\t{\n\t\t\t\ta++;\n\t\t\t}\n\t\t\telse if (str.equals(\"B\"))\n\t\t\t{\n\t\t\t\tb++;\n\t\t\t}\n\t\t\telse if (str.equals(\"O\"))\n\t\t\t{\n\t\t\t\to++;\n\t\t\t}\n\t\t\telse if (str.equals(\"AB\"))\n\t\t\t{\n\t\t\t\tab++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(a);\n\t\tSystem.out.println(b);\n\t\tSystem.out.println(ab);\n\t\tSystem.out.println(o);\n\t}\n}", "code2": "T = ['A', 'B', 'AB', 'O']\nr = Array.new(4, 0)\n\nwhile s = gets\n  r[T.index(s.chomp.split(',')[1])] += 1\nend\n\nr.each { |n| puts n } ", "label": 1, "name1": "s541319729.java", "name2": "s391304310.rb"}, {"id": 590, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint[] abc = new int[3];\n\t\tArrays.setAll(abc, i -> sc.nextInt());\n\t\tArrays.sort(abc);\n\t\t\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tint dif = abc[2] - abc[i];\n\t\t\tint quo = dif / 2;\n\t\t\tcnt += quo;\n\t\t\tabc[i] += 2 * quo;\n\t\t}\n\t\t\n\t\tArrays.sort(abc);\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tabc[2 - i] -= abc[0];\n\t\t}\n\t\t\n\t\tfor (int i : abc) {\n\t\t\tcnt += i;\n\t\t}\n\t\t\n\t\tSystem.out.println(cnt);\n\t}\t\n}\n", "code2": "primes = []\n2.upto(123456*2){|x|\n    prime = true\n    2.upto(Math.sqrt(x)){|y|\n        if x % y == 0\n            prime = false\n            break\n        end\n    }\n    primes << x if prime\n}\n\narr = Array.new(123456 * 2 + 1 , 0)\nprimes.each{|prime| arr[prime] = 1}\n1.upto(arr.length - 1){|i| arr[i] += arr[i - 1]}\n\nwhile true\n    n = gets.to_i\n    break if n == 0\n    puts arr[n * 2] - arr[n]\nend\n", "label": 0, "name1": "s839188761.java", "name2": "s199415764.rb"}, {"id": 372, "code1": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)924844033;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint ai = io.nextInt();\n\t\t\tint ao = io.nextInt();\n\t\t\tint at = io.nextInt();\n\t\t\tint aj = io.nextInt();\n\t\t\tint al = io.nextInt();\n\t\t\tint as = io.nextInt();\n\t\t\tint az = io.nextInt();\n\t\t\t\n\t\t\tlong ans = 0;\n\t\t\t\n\t\t\tint cnt = aj % 2 + al % 2 + ai % 2;\n\t\t\tif (cnt >= 2) {\n\t\t\t\tif (aj > 0 && al > 0 && ai > 0) {\n\t\t\t\t\tai--;\n\t\t\t\t\taj--;\n\t\t\t\t\tal--;\n\t\t\t\t\tans += 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += ao;\n\t\t\tans += ai / 2 * 2;\n\t\t\tans += aj / 2 * 2;\n\t\t\tans += al / 2 * 2;\n\t\t\t\n\t\t\tio.out.println(ans);\n\t\t}\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n", "code2": "a = gets.split.map(&:to_i)\ntmp1 = 0\ntmp1 += a[0] / 2 * 2\ntmp1 += a[3] / 2 * 2\ntmp1 += a[4] / 2 * 2\ntmp2 = 0\nif a[0] > 0 && a[3] > 0 && a[4] > 0\n    tmp2 += 3\n    a[0] -= 1\n    a[3] -= 1\n    a[4] -= 1\nend\ntmp2 += a[0] / 2 * 2\ntmp2 += a[3] / 2 * 2\ntmp2 += a[4] / 2 * 2\nans = [tmp1, tmp2].max + a[1]\np ans", "label": 1, "name1": "s961512992.java", "name2": "s374653780.rb"}, {"id": 768, "code1": "//\u0083\\\u0081[\u0083g\u0082\u00b7\u0082\u00e9\u0083v\u0083\u008d\u0083O\u0083\u0089\u0083\u0080\u0081i\u0082\u008e\u0082\u00cc\u0092l\u0082\u00cd1,000,000\u0088\u00c8\u0089\u00ba\u0081j\nimport java.util.*;\npublic class Main {\n\n\tpublic void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tTreeSet<Integer> set = new TreeSet<Integer>();\n\t\tTreeMap<Integer,Integer> map = new TreeMap<Integer, Integer>();\n\n\t\tfor(int i=0; i < n; i++){\n\t\t\tint temp = sc.nextInt();\n\t\t\tif( set.contains(temp)){\n\t\t\t\tif(map.containsKey(temp)){\n\t\t\t\t\tmap.put(temp, map.get(temp) + 1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmap.put(temp, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tset.add(temp);\n\t\t\t}\n\t\t}\n\t\tfor(int num: set){\n\t\t\tif(map.containsKey(num)){\n\t\t\t\tfor(int i=0; i < map.get(num);i++){\n\t\t\t\t\tSystem.out.print(num + \" \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(num == set.last()){\n\t\t\t\tSystem.out.println(num);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.print(num + \" \");\n\t\t\t}\n\n\t\t}\n\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doIt();\n\n\t}\n\n}", "code2": "n = gets.to_i\nx = gets.to_i\n(n - 1).times do\n  x = x.lcm(gets.to_i)\nend\nputs x", "label": 0, "name1": "s012590995.java", "name2": "s903706562.rb"}, {"id": 848, "code1": "import java.util.*;\npublic class Main {\n\tpublic static void doIt(){\n\t\tScanner in = new Scanner(System.in);\n\t\tdata pp[][] = new data[3][8];\n\t\tfor(int i=0;i<3;i++){\n\t\t\tfor(int s=0;s<8;s++){\n\t\t\t\tint ban=in.nextInt();\n\t\t\t\tdouble time=in.nextDouble();\n\t\t\t\tpp[i][s]=new data(ban,time);\n\t\t\t}\n\t\t\tArrays.sort(pp[i]);\n\t\t}\n\t\tfor(int i=0;i<3;i++){\n\t\t\tSystem.out.printf(\"%d %.2f\\n\",pp[i][0].code,pp[i][0].time);\n\t\t\tSystem.out.printf(\"%d %.2f\\n\",pp[i][1].code,pp[i][1].time);\n\t\t}\n\t\tdata ans[]=new data[18];\n\t\tint cnt=0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tfor(int s=2;s<8;s++){\n\t\t\t\tans[cnt]=pp[i][s];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tArrays.sort(ans);\n\t\tSystem.out.printf(\"%d %.2f\\n\",ans[0].code,ans[0].time);\n\t\tSystem.out.printf(\"%d %.2f\\n\",ans[1].code,ans[1].time);\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain.doIt();\n\t}\n\tstatic class data implements Comparable<data>{\n\t\tint code;\n\t\tdouble time;\n\t\tdata(int code,double time){\n\t\t\tthis.code=code;\n\t\t\tthis.time=time;\n\t\t}\n\t\tpublic int compareTo(data o) {\n\t\t\treturn Double.compare(this.time,o.time);//\u3053\u308c\u3067\u6bd4\u3079\u3089\u308c\u308b\u3002\n\t\t}\n\t}\n}", "code2": "n=gets.to_i\na=gets.split.map(&:to_i)\ng=a.pop\na.each{|v|g=v.gcd g}\nputs g", "label": 0, "name1": "s614656631.java", "name2": "s558839561.rb"}, {"id": 252, "code1": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n\n        char[] s = sc.next().toCharArray();\n        char[] t = sc.next().toCharArray();\n\n        boolean isAns = false;\n        for (int i = s.length-1; i >= t.length-1; i--) {\n            char[] tmp = s.clone();\n            isAns = true;\n            for (int j = 0; j < t.length; j++) {\n                if (s[i-j] == t[t.length-1-j] || s[i-j] == '?') {\n                    tmp[i-j] = t[t.length-1-j];\n                } else {\n                    isAns = false;\n                    break;\n                }\n            }\n\n            if (isAns) {\n                s = tmp;\n                break;\n            }\n        }\n\n        if (isAns) {\n            for (char c : s)\n                System.out.print(c == '?' ? 'a' : c);\n        } else {\n            System.out.println(\"UNRESTORABLE\");\n        }\n    }\n\n    static class MyScanner {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in), 1 << 15);\n        StringTokenizer tokenizer;\n\n        String next() {\n            try {\n                while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                }\n            } catch (IOException ignored) {\n            }\n            return tokenizer.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}", "code2": "S = gets.chomp\nT = gets.chomp\n\noffset = (0 .. S.size - T.size).reverse_each.find do |offset|\n  found = T.size.times.all? do |i| \n    S[offset + i] == '?' || S[offset + i] == T[i]\n  end\nend\nif offset\n  z = S.tr('?','a')\n  z[offset,T.size] = T\n  puts z\nelse\n  puts \"UNRESTORABLE\"\nend", "label": 1, "name1": "s842757542.java", "name2": "s917754252.rb"}, {"id": 79, "code1": "import java.io.*;\nimport java.util.*;\nimport static java.lang.System.out;\n\npublic class Main {\n    static MyReader in = new MyReader();\n\n    public static void main(String[] args) {\n        int N = in.i();\n        int k = ((int)Math.sqrt(1 + 8 * N) + 1) / 2;\n        out.println(k * (k - 1) / 2 == N ? solve(k) : \"No\");\n    }\n\n    static String solve(int k) {\n        StringBuilder sb = new StringBuilder(\"Yes\\n\");\n        sb.append(k).append('\\n');\n\n        for (int i = 1; i < k; i++) {\n            sb.append(k - 1).append(' ');\n\n            int t = 1 + i * (i - 1) / 2;\n            for (int j = 1; j < i; j++) {\n                sb.append(t++).append(' ');\n            }\n\n            for (int j = i; j < k; j++) {\n                sb.append(t).append(' ');\n                t += j;\n            }\n            sb.append('\\n');\n        }\n\n        sb.append(k - 1).append(' ');\n        int t = 1;\n        for (int i = 2; i <= k; i++) {\n            sb.append(t).append(' ');\n            t += i;\n        }\n\n        return sb.toString();\n    }\n}\n\nclass MyReader extends BufferedReader {\n    char[] cbuf = new char[1024];\n    int head = 0;\n    int tail = 0;\n\n    MyReader() {\n        super(new InputStreamReader(System.in));\n    }\n\n    char next() {\n        if (head == tail) {\n            try {\n                tail = super.read(cbuf, 0, cbuf.length);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            head = 0;\n        }\n        return cbuf[head++];\n    }\n\n    void back() {\n        head--;\n    }\n\n    boolean minus() {\n        boolean minus;\n        while (true) {\n            char c = next();\n            if (!isDelimiter(c)) {\n                if (!(minus = c == '-')) back();\n                return minus;\n            }\n        }\n    }\n\n    void skip() {\n        while (isDelimiter(next()));\n        back();\n    }\n\n    char[] s(int N) {\n        char[] cbuf = new char[N];\n        read(cbuf, 0, N);\n        return cbuf;\n    }\n\n    public int read(char[] cbuf, int off, int len) {\n        skip();\n        int i;\n        for (i = 0; i < cbuf.length; i++) {\n            char c = next();\n            if (isDelimiter(c)) {\n                break;\n            }\n            cbuf[i] = c;\n        }\n        return i;\n    }\n\n    boolean isDelimiter(char c) {\n        return c == ' ' || c == '\\n' || c == '\\r';\n    }\n\n    int i() {\n        boolean minus = minus();\n        int n = 0;\n        while (true) {\n            int k = next() - '0';\n            if (k < 0 || 9 < k) break;\n            n = 10 * n + k;\n        }\n        return minus ? -n : n;\n    }\n\n    int[] ii(final int N) {\n        int[] a = new int[N];\n        for (int j = 0; j < a.length; j++) a[j] = i();\n        return a;\n    }\n\n    long l() {\n        boolean minus = minus();\n        long n = 0;\n        while (true) {\n            int k = next() - '0';\n            if (k < 0 || 9 < k) break;\n            n = 10 * n + k;\n        }\n        return minus ? -n : n;\n    }\n}\n", "code2": "n = gets.chop.to_i\n\nk = 1\nflag = false\nloop do\n  k += 1\n  num = k * (k-1) / 2\n  if num == n\n    flag = true\n    break\n  end\n  break if num > n\nend\n\nif flag\n  ans = Array.new(k, nil).map{Array.new(0)}\n  (1..k).to_a.combination(2).to_a.each_with_index do |v, i|\n    v.each do |j|\n      ans[j-1] << i + 1\n    end\n  end\n  puts 'Yes'\n  puts k\n  k.times do |i|\n    puts \"#{ans[i].size} #{ans[i].join(' ')}\"\n  end\nelse\n  puts 'No'\nend", "label": 1, "name1": "s799940458.java", "name2": "s909820344.rb"}, {"id": 718, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint a = scanner.nextInt(),b = scanner.nextInt(),c = scanner.nextInt();\n\t\tint[] x = {a,b,c};\n\t\tArrays.sort(x);\n\t\tSystem.out.println(x[0]+x[1]);\n\t}\n\n}\n", "code2": "$s = gets.chomp\n$result = 0\n\ndef calc(idxs)\n  sum = 0\n  start = 0\n  idxs.each do |idx|\n    sum += $s[start..(idx-1)].to_i\n    start = idx\n  end\n  return sum + $s[start..($s.size-1)].to_i\nend\n\ndef explore(idx=0, idxs=[])\n  if idx == $s.size-1 then\n    $result += calc(idxs)\n  else\n    explore(idx+1, idxs)\n    explore(idx+1, idxs + [idx+1])\n  end\nend\n\nexplore()\nputs $result", "label": 0, "name1": "s134824979.java", "name2": "s268035195.rb"}, {"id": 684, "code1": "import java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc= new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint count=0;\n\t\t\tint n=sc.nextInt();\n\t\t\tint x=sc.nextInt();\n\t\t\tif(n==0 && x==0) break;\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=i+1;j<=n;j++){\n\t\t\t\t\tfor(int k=j+1;k<=n;k++){\n\t\t\t\t\t\tif(i+j+k == x) count++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}", "code2": "n,m = gets.chomp.split(' ').map(&:to_i)\nx = gets.chomp.split(' ').map(&:to_i).sort!\nif x.size == 1 || n >= m\n    puts '0'\nelse\n    diff = Array.new((m-1),0)\n    (m-1).times do |i|\n        diff[i] = x[i+1]-x[i]\n    end\n    puts diff.sort.slice(0,m-n).inject(:+)\nend", "label": 0, "name1": "s030330226.java", "name2": "s394989460.rb"}, {"id": 722, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n    private static int[] arr;\n\n    public static void main(String[] args) {\n\n        Scanner scanner = new Scanner(System.in);\n        String input = scanner.nextLine();\n        arr = Arrays.stream(input.split(\"\")).mapToInt(Integer::parseInt).toArray();\n\n        long sum = calc(0, arr.length - 1);\n        System.out.println(sum);\n    }\n\n    private static long calc(int position, int end) {\n        if (position > end) return 0;\n\n        long tmp = 0;\n        for (int i = position; i < end; i++) {\n            tmp += toInt(position, i) * Math.pow(2, (end - i - 1)) + calc(i + 1, end);\n        }\n        tmp += toInt(position, end);\n        return tmp;\n    }\n\n    private static long toInt(int start, int end) {\n        if (start == end) {\n//            System.out.println(\"start: \" + start + \" end: \" + end + \" -> \" + arr[start]);\n            return arr[start];\n        }\n\n        long tmp = 0;\n        for (int i = start; i <= end; i++) {\n            tmp += arr[i] * Math.pow(10, (end - i));\n        }\n//        System.out.println(\"start: \" + start + \" end: \" + end + \" -> \" + tmp);\n        return tmp;\n    }\n}", "code2": "n,m=gets.split.map &:to_i\nmin=[]\nmax=[]\nm.times do\n  x,y=gets.split.map &:to_i\n  if x==1 || y==1\n    min<< [x,y].max\n  end\n  if x==n || y==n\n    max<< [x,y].min\n  end\n  \n  \nend\nputs min & max == [] ? :IMPOSSIBLE : :POSSIBLE\n  ", "label": 0, "name1": "s752481979.java", "name2": "s240457577.rb"}, {"id": 595, "code1": "import java.io.IOException;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\nimport java.io.PrintWriter;\n\n@SuppressWarnings(\"unchecked\")\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        final String s;\n\n        try (\n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(System.in))) {\n            s = reader.readLine();\n        }\n\n        PrintWriter out = new PrintWriter(System.out);\n\n        final String[] sl = s.split(\" \");\n        int A = Integer.parseInt(sl[0]);\n        int B = Integer.parseInt(sl[1]);\n        int C = Integer.parseInt(sl[2]);\n\n        int max = Math.max(A, Math.max(B, C));\n\n        int sum = 3 * max - A - B - C;\n\n        int ans;\n\n        if (sum % 2 == 0) ans = sum / 2;\n        else ans = (int)Math.ceil((double)sum / 2) + 1;\n\n        out.println(ans);\n\n        out.flush();\n    }\n}\n", "code2": "#!/usr/bin/env ruby\n\nrequire 'set'\n\nclass Hash\n  def push(key, value)\n    self[key] = [] if self[key] == nil\n    self[key].push(value)\n  end\nend\n\nclass Array\n  def lower_bound(value)\n    left = -1;\n    right = self.length;\n    while left + 1 < right\n      mid = left + (right - left) / 2;\n      if self[mid] >= value\n        right = mid\n      else\n        left = mid\n      end\n    end\n    right\n  end\n\n  def unique\n    res = [self.first]\n    each_cons(2) do |a, b|\n      if a != b\n        res.push(b)\n      end\n    end\n    res\n  end\nend\n\ndef get_ints\n  gets.chomp.split.map(&:to_i)\nend\n\ndef get_ints_minus_one\n  get_ints.map { |x| x - 1 }\nend\n\ndef get_int\n  gets.chomp.to_i\nend\n\nQ = get_int\nQ.times do |i|\n  a, b = get_ints\n\n  if a == b\n    puts 2 * (a-1)\n    next\n  end\n  min = [a, b].min\n  max = [a, b].max\n\n  ab = a * b\n\n  high = max - 1\n  low = min\n  while high - low > 1\n    mid = low + (high - low) / 2\n\n    if mid ** 2 >= ab\n      high = mid\n    else\n      low = mid\n    end\n  end\n\n  high, low = [high, low].max, [high, low].min\n  rest = if high * high < ab\n    high + high - min - 1\n  elsif high * low < ab\n    high + low - min - 1\n  else\n    low + low - min - 1\n  end\n\n  puts min - 1 + rest\n\n  # ab = a * b\n  # b_down = (ab/(a+1)).then { |x| x * (a+1) == ab ? x - 1 : x }\n  # b_down_amari = b - b_down - 1\n  #\n  # a_down = (ab/(b+1)).then { |x| x * (b+1) == ab ? x - 1 : x }\n  # a_down_amari = a - a_down - 1\n  #\n  # binding.pry if a == 22\n  # puts b_down + a_down + [a_down_amari, b_down_amari].min\nend\n", "label": 0, "name1": "s588342457.java", "name2": "s516108110.rb"}, {"id": 63, "code1": "import java.util.*;\nclass Main {\n\tstatic int n;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\tint maxDistance = 0;\n\t\t\tMap<Integer, Integer> map = new HashMap<Integer, Integer>(n);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tint d = sc.nextInt() + sc.nextInt();\n\t\t\t\tmap.put(d, p);\n\t\t\t\tmaxDistance = Math.max(d, maxDistance);\n\t\t\t}\n\t\t\tSystem.out.printf(\"%d %d\\n\", map.get(maxDistance), maxDistance);\n\t\t}\n\t}\n}", "code2": "puts (1..$_.to_i).map{a,b,c=gets.split.map &:to_i;[a,b+c]}.max_by{|i,j|j}*\" \"while gets>=?1", "label": 1, "name1": "s188031790.java", "name2": "s404961830.rb"}, {"id": 639, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    void solve() throws IOException {\n    \tint N = ni();\n\n    \tint[] T = new int[N];\n    \tint[] A = new int[N];\n\n    \tfor (int i=0; i<N; i++) {\n\t\t\tT[i] = ni();\n\t\t\tA[i] = ni();\n\t\t}\n\n    \tlong t = T[0];\n    \tlong a = A[0];\n\n    \tfor (int i=1; i<N; i++) {\n    \t\tlong x = (t%T[i]==0)? t/T[i] : (t/T[i] + 1);\n    \t\tlong y = (a%A[i]==0)? a/A[i] : (a/A[i] + 1);\n    \t\tt = T[i] * Math.max(x, y);\n    \t\ta = A[i] * Math.max(x, y);\n    \t}\n\n    \tout.println(t + a);\n    }\n\n    String ns() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine(), \" \");\n        }\n        return tok.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.parseInt(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.parseLong(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.parseDouble(ns());\n    }\n\n    String[] nsa(int n) throws IOException {\n        String[] res = new String[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ns();\n        }\n        return res;\n    }\n\n    int[] nia(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ni();\n        }\n        return res;\n    }\n\n    long[] nla(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nl();\n        }\n        return res;\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        tok = new StringTokenizer(\"\");\n        Main main = new Main();\n        main.solve();\n        out.close();\n    }\n}\n", "code2": "# matrix\u306e\u57fa\u672c\u64cd\u4f5c\n\ndef same_el(array_)\n  if array_.kind_of?(Array)\n    output = []\n    for i in  0..(array_.count-1)\n      output.push(array_[i])\n    end\n  end\n  return output\nend\n\n# ---------------------------------------------\n\ndef replace(n)\n\n  sgn=[]\n  remain=[]\n  output=[] #n!\u500b\u306e\u8981\u7d20\u3092\u6301\u3064\u914d\u5217\u3092\u8fd4\u3059\n  for i in 0..n\n    sgn << i\n    remain << i\n  end\n  output << []\n  for i in 0..n\n    output[0] << i\n  end\n\n  while true\n    remain_act = same_el(remain)\n    remain_act.delete(0)\n    for i in 1..n-1\n      judge_order = true\n      for j in i+1..n-1\n        sgn[j]<sgn[j+1] && judge_order = false\n      end\n      judge_order && break\n      remain_act.delete(sgn[i])\n    end\n    singular = i\n    remain_act.sort!\n    for i in 0..n-(singular-2)\n      if sgn[singular] == remain_act[i]\n        sgn[singular] = remain_act[i+1]\n        break\n      end\n    end\n    remain_act.delete(sgn[singular])\n    for i in singular+1..n\n      sgn[i] = remain_act[i-(singular+1)]\n    end\n    inp =same_el(sgn)\n    output << inp\n    lastmat=true\n    for i in 1..n\n      sgn[i] != n+1-i && lastmat=false\n    end\n    lastmat && break\n  end\n\n  for i in 0..output.count-1\n    output[i].delete(0)\n  end\n  output\nend\n\n# ---------------------------------------------\n\ndef signal(replaces)\n  output = Array.new\n  index = Array.new\n\n  replace.size.times do |i|\n    for j in 0..replaces.size-1\n      index[j] = j+1\n    end\n    i_op = i.clone\n    while true\n      j = 0\n      nimotu = index[0]\n      sgn_part = -1\n      while true\n        if i_op[j] == nimotu\n\n        else\n        end\n      end\n\n    end\n    output << sgn\n  end\nend\n\nN=gets.to_i\nar=replace(N)\nps=gets.split.map(&:to_i)\nqs=gets.split.map(&:to_i)\np (ar.index(ps)-ar.index(qs)).abs", "label": 0, "name1": "s760488688.java", "name2": "s189807644.rb"}, {"id": 432, "code1": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Map;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class TaskX {\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tint n = in.nextInt();\n\t\t\tint k = in.nextInt();\n\t\t\tint l = in.nextInt();\n\t\t\tUnionFind u1 = new UnionFind(n);\n\t\t\tUnionFind u2 = new UnionFind(n);\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tint p = in.nextInt()-1;\n\t\t\t\tint q = in.nextInt()-1;\n\t\t\t\tu1.link(p, q);\n\t\t\t}\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tint r = in.nextInt()-1;\n\t\t\t\tint s = in.nextInt()-1;\n\t\t\t\tu2.link(r, s);\n\t\t\t}\n\t\t\tMap<Long, Integer> roots = new HashMap<Long, Integer>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tlong code = (long)u1.root(i)<< 32 | u2.root(i);\n\t\t\t\troots.merge(code, 1, Integer::sum);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i > 0)out.print(\" \");\n\t\t\t\tlong code = (long)u1.root(i) << 32 | u2.root(i);\n\t\t\t\tout.print(roots.get(code));\n\t\t\t}\n\n\t\t}\n\n\t\tpublic class UnionFind {\n\t\t\tint[] data;\n\n\t\t\tpublic UnionFind(int n) {\n\t\t\t\tdata = new int[n];\n\t\t\t\tArrays.fill(data, -1);\n\t\t\t}\n\n\t\t\tboolean link(int x, int y) {\n\t\t\t\tx = root(x);\n\t\t\t\ty = root(y);\n\t\t\t\tif (x != y) {\n\t\t\t\t\tif (data[y] < data[x]) {\n\t\t\t\t\t\tdata[y] += data[x];\n\t\t\t\t\t\tdata[x] = y;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdata[x] += data[y];\n\t\t\t\t\t\tdata[y] = x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn x != y;\n\t\t\t}\n\n\t\t\tint root(int x) {\n\t\t\t\treturn data[x] < 0 ? x : (data[x] = root(data[x]));\n\t\t\t}\n\t\t}\n\t}\n\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\n\t}\n\n}\n", "code2": "class Node\n    attr_accessor :parent, :rank\n\n    def initialize(n)\n      @parent = n\n      @rank = 0\n    end\nend\n\nclass UnionFindTree\n  def initialize(n)\n    @n = n\n    @nodes = (0..n).to_a.map { |i| Node.new(i) }\n  end\n\n  def find(x)\n    return x if @nodes[x].parent == x\n\n    return @nodes[x].parent = find(@nodes[x].parent)\n  end\n\n  def unite(a, b)\n    a = find(a)\n    b = find(b)\n    return if a == b\n\n    if @nodes[a].rank < @nodes[b].rank\n      @nodes[a].parent = b\n    else\n      @nodes[b].parent = a\n      @nodes[a].rank += 1 if @nodes[a].rank == @nodes[b].rank\n    end\n  end\n\n  def same?(a, b)\n    find(a) == find(b)\n  end\n\n  def parents\n    @nodes.map(&:parent)\n  end\n\n  def roots\n    (1..@n).map {|i| find(i)}\n  end\nend\n\nn,k,l = gets.chomp.split.map(&:to_i)\ntree1 = UnionFindTree.new(n)\nk.times do\n    p,q = gets.chomp.split.map(&:to_i)\n    tree1.unite(p,q)\nend\n\ntree2 = UnionFindTree.new(n)\nl.times do\n    r,s = gets.chomp.split.map(&:to_i)\n    tree2.unite(r,s)\nend\n\np =  (1..n).to_a.zip(tree1.roots, tree2.roots)\ng = p.group_by {|i| [i[1], i[2]]}\n\nans = []\np.each do |v|\n    ans << g[[v[1],v[2]]].size\nend\nputs ans.join(\" \")\n\n\n\n", "label": 1, "name1": "s544715299.java", "name2": "s325987922.rb"}, {"id": 459, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.stream.IntStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.PriorityQueue;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.AbstractCollection;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            Dijkstra d = new Dijkstra(n);\n            for (int i = 0; i < n - 1; i++) {\n                int from = in.readInt() - 1;\n                int to = in.readInt() - 1;\n                d.addUndirectedEdge(from, to, 1);\n            }\n            long[] dist1 = d.getDist(0);\n            long[] distN = d.getDist(n - 1);\n            long count1 = IntStream.range(0, n)\n                    .filter(i -> dist1[i] <= distN[i])\n                    .count();\n            out.printLine(count1 > n - count1 ? \"Fennec\" : \"Snuke\");\n        }\n\n    }\n\n    static class Dijkstra {\n        int n;\n        ArrayList<Pair>[] G;\n        private long INF = Long.MAX_VALUE / 3;\n\n        public Dijkstra(int n) {\n            this.n = n;\n            G = new ArrayList[n];\n            for (int i = 0; i < n; i++) {\n                G[i] = new ArrayList<>();\n            }\n        }\n\n        public void addUndirectedEdge(int from, int to, long cost) {\n            G[from].add(new Pair(to, cost));\n            G[to].add(new Pair(from, cost));\n        }\n\n        public long[] getDist(int s) {\n            PriorityQueue<Pair> Q = new PriorityQueue<>();\n            Q.add(new Pair(s, 0));\n            long[] dist = new long[n];\n            Arrays.fill(dist, INF);\n            boolean[] used = new boolean[n];\n            while (!Q.isEmpty()) {\n                Pair p = Q.poll();\n                if (used[p.x]) continue;\n                used[p.x] = true;\n                dist[p.x] = p.y;\n\n                for (Pair edge : G[p.x]) {\n                    Q.add(new Pair(edge.x, p.y + edge.y));\n                }\n            }\n            return dist;\n        }\n\n        class Pair implements Comparable<Pair> {\n            int x;\n            long y;\n\n            Pair(int x, long y) {\n                this.x = x;\n                this.y = y;\n            }\n\n            public int compareTo(Pair p) {\n                return Long.compare(y, p.y);\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n}\n\n", "code2": "N=gets.to_i\nedges=Array.new(N){Array.new}\n(N-1).times do\n    a,b=gets.split.map(&:to_i)\n    a-=1\n    b-=1\n    edges[a] << b\n    edges[b] << a\nend\ndist_from_1=Array.new(N)\ndist_from_last=Array.new(N)\n\ndef dfs(edges,start,dists)\n    used=Array.new(edges.size,false)\n    used[start]=true\n    dists[start]=0\n    stack=[start]\n    while !stack.empty?\n        v=stack.pop\n        edges[v].each do |vv|\n            next if used[vv]\n            used[vv]=true\n            dists[vv]=dists[v]+1\n            stack << vv\n        end\n    end\nend\n\ndfs(edges,0,dist_from_1)\ndfs(edges,N-1,dist_from_last)\n\n\nb_count=0\nw_count=0\nN.times do |i|\n    b_count+=1 if dist_from_1[i]<=dist_from_last[i]\n    w_count+=1 if dist_from_1[i]>dist_from_last[i]\nend\n\nputs b_count>w_count ? \"Fennec\" : \"Snuke\"", "label": 1, "name1": "s823656696.java", "name2": "s497047069.rb"}, {"id": 455, "code1": "import java.util.*;\nimport java.text.*;\nimport java.math.*;\n\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tScanner in = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint m = in.nextInt();\n\t\t\tint d = in.nextInt();\n\t\t\tif((m|d) == 0) break;\n\t\t\tint day = d;\n\t\t\tswitch(m){\n\t\t\tcase 12:\n\t\t\t\tday += 335;\n\t\t\t\tbreak;\n\t\t\tcase 11:\n\t\t\t\tday += 305;\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tday += 274;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tday += 244;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tday += 213;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tday += 182;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tday += 152;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tday += 121;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tday += 91;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tday += 60;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tday += 31;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t}\n\t\t\tswitch(day%7){\n\t\t\tcase 1:\n\t\t\t\tSystem.out.println(\"Thursday\");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tSystem.out.println(\"Friday\");\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tSystem.out.println(\"Saturday\");\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tSystem.out.println(\"Sunday\");\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tSystem.out.println(\"Monday\");\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tSystem.out.println(\"Tuesday\");\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tSystem.out.println(\"Wednesday\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "code2": "#!ruby -pal\nexit if$F[0]==?0\n$_=Time.gm(4,*$F).strftime \"%A\"", "label": 1, "name1": "s648991274.java", "name2": "s335808393.rb"}, {"id": 938, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int N = in.nextInt();\n            int A[] = new int[2 * N - 1];\n            for (int i = 0; i < 2 * N - 1; i++) {\n                A[i] = in.nextInt();\n            }\n\n            int lo = 0, hi = 2 * N;\n\n            while (lo + 1 < hi) {\n                int mid = lo + (hi - lo) / 2;\n\n                if (onTopAtLeast(mid, A)) {\n                    lo = mid;\n                } else {\n                    hi = mid;\n                }\n            }\n\n            out.println(lo);\n        }\n\n        private boolean onTopAtLeast(int x, int[] a) {\n            int LEN = a.length; // LEN = 2*N-1\n            int[] b = new int[LEN];\n            for (int i = 0; i < LEN; i++) {\n                b[i] = a[i] < x ? 0 : 1;\n            }\n            int[] c = new int[LEN - 2];\n            for (int i = 1; i < LEN - 1; i++) {\n                c[i - 1] = b[i - 1] + b[i] + b[i + 1] < 2 ? 0 : 1;\n            }\n\n            int MID = c.length / 2;\n            int left = MID;\n            int right = MID;\n\n            while (left > 0 && c[left - 1] != c[left]) left--;\n            while (right < c.length - 1 && c[right] != c[right + 1]) right++;//C[1, 2*N-3]\n\n            int ANS = (MID - left < right - MID) ? c[left] : c[right];\n\n            return ANS == 1;\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n", "code2": "D = gets.to_i\nC = gets.chomp.split.map(&:to_i)\ns = D.times.map{gets.split.map(&:to_i)}\nc = Array.new(26, 0)\nt = []\n\n(0..D-1).each do |i|\n\n  (0..25).each do |l|\n    c[l] += C[l]\n  end\nans = 0\nboder = s[i][0]+9*c[0]\n\n  (1..25).each do |e|\n    if s[i][e]+9*c[e] >= boder\n      ans = e\n      boder = s[i][e]+9*c[e]\n    end\n  end\nc[ans] = 0\nputs ans+1\nend\n\n\n  \n\n", "label": 0, "name1": "s219661576.java", "name2": "s375164204.rb"}, {"id": 169, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() { return Double.parseDouble(next());}\n}\npublic class Main {\n\tstatic FastScanner stdIn=new FastScanner();\n\tpublic static void main(String[] args) {\n\t\tString X=stdIn.next();\n\t\tint N=X.length();\n\t\tint s=0,t=0,ans=N;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tchar a=X.charAt(i);\n\t\t\tif(a=='S')\n\t\t\t\ts++;\n\t\t\telse{\n\t\t\t\tif(s!=0){\n\t\t\t\t\tans-=2;\n\t\t\t\t\ts--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n", "code2": "x = gets.chomp\nt = 0\ns = 0\n\nx.each_char do |c|\n  if c == 'S'\n    s += 1\n  else c == 'T'\n    if s == 0\n      t += 1\n    else\n      s -= 1\n    end\n  end\nend\n\nputs t + s\n", "label": 1, "name1": "s724983945.java", "name2": "s945964760.rb"}, {"id": 389, "code1": "import java.util.Scanner;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    long a = sc.nextLong();\n    long b = sc.nextLong();\n    long c;\n    long x = sc.nextLong();\n    if(a%x == 0) {\n      c = a / x -1;\n    }else {\n      c = a / x;\n    }\n    System.out.println(b/x-c);\n  }\n}\n", "code2": "a,b,x=gets.split.map &:to_i\np b/x-(a-1)/x", "label": 1, "name1": "s320140275.java", "name2": "s276778558.rb"}, {"id": 799, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        BRemovingBlocks solver = new BRemovingBlocks();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BRemovingBlocks {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            long[] a = in.readLongArray(n);\n\n            Modulo.mod = MiscUtils.MOD7;\n\n            long[] s = new long[n];\n            s[0] = 1;\n            for (int i = 1; i < n; i++) {\n                s[i] = Modulo.add(s[i - 1], Modulo.rev(i + 1));\n            }\n\n            long ans = 0;\n            for (int i = 0; i < n; i++) {\n                long sum = Modulo.mlt(a[i], s[i] + s[n - 1 - i] - 1);\n                ans = Modulo.add(ans, sum);\n            }\n            for (int i = 1; i <= n; i++) ans = Modulo.mlt(ans, i);\n            out.printLine(ans);\n        }\n\n    }\n\n    static class Modulo {\n        public static long mod;\n        private long value;\n\n        public Modulo(long value) {\n            this.value = (value % mod + mod) % mod;\n        }\n\n        public static long add(long a, long b) {\n            return ((a + b) % mod + mod) % mod;\n        }\n\n        public static long mlt(long a, long b) {\n            return ((a % mod + mod) * (b % mod + mod)) % mod;\n        }\n\n        public static long rev(long a) {\n            //return pow(a, mod - 2);\n            return (Euclid.extgcd(a, mod, new long[3])[0] % mod + mod) % mod;\n        }\n\n        public String toString() {\n            return \"\" + value;\n        }\n\n    }\n\n    static class Euclid {\n        public static long[] extgcd(long a, long b, long[] is) {\n            if (a == 0) {\n                is[0] = 0;\n                is[1] = 1;\n                is[2] = b;\n            } else {\n                extgcd(b % a, a, is);\n                long x = is[1] - b / a * is[0];\n                is[1] = is[0];\n                is[0] = x;\n            }\n            return is;\n        }\n\n    }\n\n    static class MiscUtils {\n        public static final int MOD7 = (int) (1e9 + 7);\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public long[] readLongArray(int size) {\n            long[] array = new long[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readLong();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long readLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "code2": "n = gets.to_i\nadj = Array.new(n).map{Array.new}\n(n-1).times do\n  a,b = gets.chomp.split(\" \").map{|i|i.to_i-1}\n  adj[a] << b\n  adj[b] << a\nend\nvst = Array.new(n,false)\nvst[0] = true\nvst[n-1] = true\nsum = [1,1]\nq = [[],[]]\nf = [[0],[n-1]]\nwhile vst.include?(false)\n  q = Marshal.load(Marshal.dump(f))\n  f = [[],[]]\n  2.times do |i|\n    q[i].each do |j|\n      adj[j].each do |k|\n        if vst[k] == false\n          vst[k] = true\n          f[i] << k\n        end\n      end\n    end\n    sum[i] += f[i].size\n  end\nend\nif sum[0] > sum[1]\n  puts \"Fennec\"\nelse\n  puts \"Snuke\"\nend", "label": 0, "name1": "s003754625.java", "name2": "s543014556.rb"}, {"id": 484, "code1": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int a[][] = new int[n][n];\n\n        for (int i = 0; i < m; i++) {\n            int t1 = in.nextInt() - 1;\n            int t2 = in.nextInt() - 1;\n            a[t1][t2] = 1;\n            a[t2][t1] = 1;\n        }\n        List<Integer> order = new ArrayList<>();\n        order.add(0);\n        List<Integer> remain = new ArrayList<>();\n        for (int i = 1; i < n; i++) {\n            remain.add(i);\n        }\n        System.out.println(f(order, remain, a));\n    }\n\n    static int f(List<Integer> order, List<Integer> remain, int edges[][]) {\n        if (remain.size() == 0) {\n            int cur = order.get(0);\n            int next;\n            for (int p = 1; p < order.size(); p++) {\n                next = order.get(p);\n                if (edges[cur][next] == 1 || edges[next][cur] == 1) {\n                    cur = next; \n                } else {\n                    return 0;\n                }\n            }\n            return 1;\n        }\n\n        int total = 0;\n        for (int p = 0; p < remain.size(); p++) {\n            order.add(remain.get(p));\n            remain.remove(p);\n            total += f(order, remain, edges);\n            remain.add(p, order.get(order.size() - 1));\n            order.remove(order.size() - 1);\n        }\n        return total;\n    }\n}", "code2": "n, m = gets.split.map(&:to_i)\nary = (n + 1).times.map { Array.new(n + 1) }\nm.times {\n  a, b = gets.split.map(&:to_i)\n  ary[a][b] = ary[b][a] = true\n}\n\nputs [*2..n].permutation.count { |a| ([1] + a).each_cons(2).all? { |b| ary.dig(*b) } }", "label": 1, "name1": "s216336518.java", "name2": "s048457622.rb"}, {"id": 175, "code1": "\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int W = sc.nextInt();\n\t\t\tfinal int H = sc.nextInt();\n\t\t\t\n\t\t\tif(W == 0  && H == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] map = new int[H][W];\n\t\t\t\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tchar[] input = sc.next().toCharArray();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tif('0' <= input[j] && input[j] <= '9'){\n\t\t\t\t\t\tmap[i][j] = input[j] - '0';\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][] len = new int[H][W];\n\t\t\tshort[][][] dp = new short[H][W][H+W+1];\n\t\t\t\n\t\t\tint max = 0;\n\t\t\tint m_x = -1;\n\t\t\tint m_y = -1;\n\t\t\t\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tif(map[i][j] < 0){\n\t\t\t\t\t\tdp[i][j][0] = -1;\n\t\t\t\t\t\tlen[i][j] = -1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(i == 0 && j == 0){\n\t\t\t\t\t\tdp[i][j][0] = (short)(map[i][j]);\n\t\t\t\t\t\tlen[i][j] = map[i][j] == 0 ? 0 : 1;\n\t\t\t\t\t}else if(j == 0){\n\t\t\t\t\t\tfinal int p_len = len[i-1][j];\n\t\t\t\t\t\tif(p_len == -1){\n\t\t\t\t\t\t\tdp[i][j][0] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = map[i][j] == 0 ? 0 : 1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tSystem.arraycopy(dp[i-1][j], 0, dp[i][j], 0, p_len);\n\t\t\t\t\t\t\tdp[i][j][p_len] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = p_len +  (p_len == 0 && map[i][j] == 0 ? 0 : 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(i == 0){\n\t\t\t\t\t\tfinal int p_len = len[i][j-1];\n\t\t\t\t\t\tif(p_len == -1){\n\t\t\t\t\t\t\tdp[i][j][0] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = map[i][j] == 0 ? 0 : 1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tSystem.arraycopy(dp[i][j-1], 0, dp[i][j], 0, p_len);\n\t\t\t\t\t\t\tdp[i][j][p_len] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = p_len + (p_len == 0 && map[i][j] == 0 ? 0 : 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfinal int left_len = len[i][j-1];\n\t\t\t\t\t\tfinal int up_len = len[i-1][j];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(left_len == -1 && up_len == -1){\n\t\t\t\t\t\t\tdp[i][j][0] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = map[i][j] == 0 ? 0 : 1;\n\t\t\t\t\t\t}else if(left_len > up_len){\n\t\t\t\t\t\t\tfinal int p_len = len[i][j-1];\n\t\t\t\t\t\t\tSystem.arraycopy(dp[i][j-1], 0, dp[i][j], 0, p_len);\n\t\t\t\t\t\t\tdp[i][j][p_len] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = p_len + (p_len == 0 && map[i][j] == 0 ? 0 : 1);\n\t\t\t\t\t\t}else if(left_len < up_len){\n\t\t\t\t\t\t\tfinal int p_len = len[i-1][j];\n\t\t\t\t\t\t\tSystem.arraycopy(dp[i-1][j], 0, dp[i][j], 0, p_len);\n\t\t\t\t\t\t\tdp[i][j][p_len] = (short)(map[i][j]);\n\t\t\t\t\t\t\tlen[i][j] = p_len + (p_len == 0 && map[i][j] == 0 ? 0 : 1);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tfinal int size = len[i][j-1];\n\t\t\t\t\t\t\tboolean left_f = true;\n\t\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\t\tif(dp[i-1][j][k] < dp[i][j-1][k]){\n\t\t\t\t\t\t\t\t\tleft_f = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}else if(dp[i-1][j][k] > dp[i][j-1][k]){\n\t\t\t\t\t\t\t\t\tleft_f = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(left_f){\n\t\t\t\t\t\t\t\tfinal int p_len = len[i][j-1];\n\t\t\t\t\t\t\t\tSystem.arraycopy(dp[i][j-1], 0, dp[i][j], 0, p_len);\n\t\t\t\t\t\t\t\tdp[i][j][p_len] = (short)(map[i][j]);\n\t\t\t\t\t\t\t\tlen[i][j] = p_len + (p_len == 0 && map[i][j] == 0 ? 0 : 1);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tfinal int p_len = len[i-1][j];\n\t\t\t\t\t\t\t\tSystem.arraycopy(dp[i-1][j], 0, dp[i][j], 0, p_len);\n\t\t\t\t\t\t\t\tdp[i][j][p_len] = (short)(map[i][j]);\n\t\t\t\t\t\t\t\tlen[i][j] = p_len + (p_len == 0 && map[i][j] == 0 ? 0 : 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(max < len[i][j]){\n\t\t\t\t\t\tmax = len[i][j];\n\t\t\t\t\t\tm_x = j;\n\t\t\t\t\t\tm_y = i;\n\t\t\t\t\t}else if(max == len[i][j]){\n\t\t\t\t\t\tfinal int size = len[i][j];\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int k = 0; k < size; k++){\n\t\t\t\t\t\t\tif(dp[m_y][m_x][k] < dp[i][j][k]){\n\t\t\t\t\t\t\t\tmax = len[i][j];\n\t\t\t\t\t\t\t\tm_x = j;\n\t\t\t\t\t\t\t\tm_y = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(dp[m_y][m_x][k] > dp[i][j][k]){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tSystem.out.printf(\"%2d \", len[i][j]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t*/\n\t\t\tfor(int i = 0; i < max; i++){\n\t\t\t\tSystem.out.print(dp[m_y][m_x][i]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t\n\t}\n\n}", "code2": "loop do\n    w, h = gets.split.map(&:to_i)\n    break if w == 0 && h == 0\n    c = h.times.map{gets.strip}\n    dp = Array.new(h).map{Array.new(w,0)}\n    max = 0\n    c.each_with_index do |r,i|\n        r.each_char.with_index do |ch, j|\n            next if ch.to_s.match(/[A-Z]/)\n            if i == 0\n                if j == 0\n                    dp[i][j] = ch.to_i\n                else\n                    dp[i][j] = (dp[i][j-1].to_s + ch).to_i\n                end\n            else\n                if j == 0\n                    dp[i][j] = (dp[i-1][j].to_s + ch).to_i\n                else\n                    dp[i][j] = ([dp[i-1][j], dp[i][j-1]].max.to_s + ch).to_i\n                end\n            end\n        end\n        max = [max, dp[i].max].max\n    end\n    puts max\nend", "label": 1, "name1": "s531751281.java", "name2": "s260108293.rb"}, {"id": 339, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        PrintWriter out = new PrintWriter(System.out);\n        InputStreamScanner in = new InputStreamScanner(System.in);\n        new Main().solve(in, out);\n        out.flush();\n    }\n\n    private void solve(InputStreamScanner in, PrintWriter out) {\n        String s = in.next();\n\n        long t = 0;\n        for (int i = 0; i < 1 << (s.length() - 1); i++) {\n            int p = 0;\n            for (int j = 0; j < s.length() - 1; j++) {\n                if ((1 & i >> j) == 1) {\n                    t += Long.parseLong(s.substring(p, j + 1));\n                    p = j + 1;\n                }\n            }\n            t += Long.parseLong(s.substring(p));\n        }\n\n        out.println(t);\n    }\n\n    static class InputStreamScanner {\n\n        private InputStream in;\n\n        private byte[] buf = new byte[1024];\n        private int len = 0;\n        private int off = 0;\n\n        InputStreamScanner(InputStream in)\t{\n            this.in = in;\n        }\n\n        String next() {\n            StringBuilder sb = new StringBuilder();\n            for (int b = skip(); !isSpace(b);){\n                sb.appendCodePoint(b);\n                b = read();\n            }\n            return sb.toString();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        char nextChar() {\n            return (char)skip();\n        }\n\n        int skip() {\n            for (int b; (b = read()) != -1;) {\n                if (!isSpace(b)) {\n                    return b;\n                }\n            }\n            return -1;\n        }\n\n        private boolean isSpace(int c) {\n            return c < 33 || c > 126;\n        }\n\n        private int read() {\n            if (len == -1) {\n                throw new InputMismatchException(\"End of Input\");\n            }\n            if (off >= len){\n                off = 0;\n                try {\n                    len = in.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException(e.getMessage());\n                }\n                if (len <= 0) {\n                    return -1;\n                }\n            }\n            return buf[off++];\n        }\n    }\n}", "code2": "s = gets.chomp.chars\nsum = 0\n['', '+'].repeated_permutation(s.size-1).each do |array|\n  sum += eval(s.zip(array).join)\nend\n\nputs sum", "label": 1, "name1": "s838868939.java", "name2": "s545852610.rb"}, {"id": 13, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString s= sc.next();\n\t\tfor (int i=0;i<s.length();i++) {\n\t\t\tif (s.charAt(i)=='R'||s.charAt(i)=='L') {\n\t\t\t\tif (i%2==0&&s.charAt(i)!='R')\t{\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t\treturn ;\n\t\t\t\t} else if (i%2==1&&s.charAt(i)!='L'){\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t\treturn ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\treturn ;\n\t\t}\n\t}\n}\n", "code2": "ary = gets.chomp.chars \nx = ary.each_slice(2).map { |a, b| [a, b] }.transpose\nputs x[0].include?(\"L\") || x[1].include?(\"R\") ? \"No\" : \"Yes\"", "label": 1, "name1": "s922990944.java", "name2": "s268735595.rb"}, {"id": 507, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString s= sc.next();\n\t\tfor (int i=0;i<s.length();i++) {\n\t\t\tif (s.charAt(i)=='R'||s.charAt(i)=='L') {\n\t\t\t\tif (i%2==0&&s.charAt(i)!='R')\t{\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t\treturn ;\n\t\t\t\t} else if (i%2==1&&s.charAt(i)!='L'){\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t\treturn ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\treturn ;\n\t\t}\n\t}\n}\n", "code2": "h,w = gets.split.map(&:to_i)\nif h == 1 || w == 1\n  p 1\nelsif h.odd?\n  p w * (h-1) / 2 + (w+1)/2\nelse\n  p w * h / 2\nend", "label": 0, "name1": "s922990944.java", "name2": "s213238625.rb"}, {"id": 862, "code1": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n     \npublic class Main{\n\tpublic static void main(String[] args) throws Exception {\n\tIO io = new IO();\n\tPrintWriter out = new PrintWriter(System.out);\n\tSolver sr = new Solver();\n\tsr.solve(io,out);\n\tout.flush();\n\tout.close();\n    \t}\n\n\tstatic class Solver\n\t{\n      class Pair{\n        int x, y;\n        Pair(int a, int b)\n        {\n          x=a;\n          y=b;\n        }\n      }\n\t    void solve(IO io, PrintWriter out)\n\t    {\n           int i, j;\n          int n = io.nextInt();\n          int m = io.nextInt();\n          \n          ArrayList<Pair> ar = new ArrayList<>();\n          for(i=0 ; i<=n ; i++)\n            \tar.add(new Pair(0,0));\n          for(i=0 ; i<m ; i++)\n          {\n            int tmp=io.nextInt();\n            String str = io.next();\n            if(ar.get(tmp).x==0)\n            {\n              if(str.equals(\"WA\"))\n                ar.get(tmp).y++;\n              else\n                ar.get(tmp).x++;\n            }\n          }\n          int pen=0, correct=0;\n          for(Pair p : ar)\n          {\n            if(p.x!=0)\n            {\n              correct++;\n              pen+=p.y;\n            }\n          }\n            out.print(correct+\" \"+pen);\n\t    }\n    \t\n\t}\n\t//Special thanks to Petr (on codeforces) who inspired me to implement IO class!\n\tstatic class IO\n\t{\n    \tBufferedReader reader;\n        StringTokenizer tokenizer;\n    \tpublic IO() {\n                reader = new BufferedReader(new InputStreamReader(System.in));\n                tokenizer = null;\n            }\n     \n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        public String nextLine() {\n            String s=\"\";\n            try {\n                    s=reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            return s;\n        }\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n    \n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    \tdouble nextDouble()\n    \t{\n    \t\treturn Double.parseDouble(next());\n    \t}\n\t}\n}", "code2": "n = gets.to_i\nputs (1..n + 1).reduce(:*) + 2\n(2..n + 1).each(&method(:puts))", "label": 0, "name1": "s215380733.java", "name2": "s370225239.rb"}, {"id": 837, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\t\n\t\tint n = stdIn.nextInt();\n\t\tint[] a = new int[n];\n\t\tint i;\n\t\t\n\t\tfor (i = 0; i < n; i++)\n\t\t\ta[i] = stdIn.nextInt();\n\t\t\n\t\tint count = SelectionSort(a, n);\n\t\t\n\t\tSystem.out.print(a[0]);\n\t\tfor (i = 1; i < n; i++)\n\t\t\tSystem.out.print(\" \" + a[i]);\n\t\tSystem.out.println();\n\t\tSystem.out.println(count);\n\t}\n\t\n\tpublic static int SelectionSort(int[] a, int n) {\n\t\tint i, j, minat, t, count = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tminat = i;\n\t\t\tfor (j = i + 1; j < n; j++)\n\t\t\t\tif (a[j] < a[minat])\n\t\t\t\t\tminat = j;\n\t\t\tif (i != minat) {\n\t\t\t\tt = a[i];\n\t\t\t\ta[i] = a[minat];\n\t\t\t\ta[minat] = t;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}", "code2": "N, L, T = gets.split.map(&:to_i)\nXW = N.times.map { gets.split.map(&:to_i) }\n\nX0, W0 = XW.first\nnum = 0\nrotate_count = T / L\nrotate_len = T % L\n1.upto(N - 1) do |i|\n  x, w = XW[i]\n  next if w == W0\n  num += rotate_count * 2\n  if W0 == 1\n    d = x - X0\n    num += 1 if rotate_len * 2 > d\n    num += 1 if rotate_len * 2 > d + L\n  else\n    d = L + X0 - x\n    num += 1 if rotate_len * 2 >= d\n    num += 1 if rotate_len * 2 >= d + L\n  end\nend\n\nnew_x = XW.map do |x, w|\n  x = x + rotate_len * (w == 1 ? 1 : -1)\n  x %= L\nend\n\nnew_x0 = new_x.first\nnew_x.sort!\npos = new_x.find_index(new_x0)\nnew_x = new_x.rotate(W0 == 1 ? pos - num : pos + num)\nputs new_x\n", "label": 0, "name1": "s307544938.java", "name2": "s217387487.rb"}, {"id": 605, "code1": "import java.io.*;\nimport java.util.*;\n \npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n \n    static class TaskD {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n \n            int N = in.nextInt();\n            for (int i = 0; i < N; i++) {\n                long A = in.nextLong();\n                long B = in.nextLong();\n \n                long a = Math.min(A, B);\n                long b = Math.max(A, B);\n \n                long ans = 2L * (a - 1) + przedzial(a, b);\n \n                out.println(ans);\n            }\n        }\n \n        private long przedzial(long a, long b) {\n            if (a == b || a + 1 == b) {\n                return 0;\n            }\n \n            return 1L + szukaj(a + 1, b - 2, a * b);\n        }\n \n        private long szukaj(long a, long b, long LIMIT) {\n            if (a > b) return 0;\n            if (a == b) {\n                return a * b < LIMIT ? 1 : 0;\n            }\n            long lo = a, hi = b;\n            while (lo + 1 < hi) {\n                long m = lo + (hi - lo) / 2;\n                if (m * m >= LIMIT) {\n                    hi = m;\n                } else {\n                    lo = m;\n                }\n            }\n            long ans1 = 1 + 2L * (lo - 1 - a + 1);\n            long ans2 = 0;\n            if (lo * (lo + 1) < LIMIT) {\n                ans2 = 2L * (lo - a + 1);\n            }\n            return Math.max(ans1, ans2);\n        }\n    }\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n    }\n}", "code2": "$x=0\n$y=0\n$bord = []\n\nloop{\n\tline = gets\n\tif line==nil then\n\t\tbreak\n\tend\n\tsp = line.split(nil)\n\t\n\tif sp.count() != 2 then\n\t\tbreak\n\telse\n\t\t$x = sp[0].to_i()\n\t\t$y = sp[1].to_i()\n\t\tif $x == 0 and $y == 0 then\n\t\t\tbreak\n\t\tend\n\t\t$bord = Array.new($y).map{Array.new($x,0)}\n\t\tmax = 0\n\t\tfor i in 0..$y-1\n\t\t\tline = gets\n\t\t\tleft = 0\n\t\t\tfor j in 0..$x-1\n\t\t\t\ttmp = 0\n\t\t\t\tif line[j] =~ /\\d/ then\n\t\t\t\t\ttmp = line[j].to_i() \n\t\t\t\t\tif i > 0 then\n\t\t\t\t\t\tup = $bord[i-1][j]\n\t\t\t\t\telse\n\t\t\t\t\t\tup = 0\n\t\t\t\t\tend\n\n\t\t\t\t\tif up > left then\n\t\t\t\t\t\ttmp += up * 10\t\t\t\t\t\n\t\t\t\t\telse\n\t\t\t\t\t\ttmp += left * 10\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\t\tif tmp > max then\n\t\t\t\t\t\tmax = tmp\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t$bord[i][j] = tmp\n\t\t\t\tleft = tmp\n\t\t\tend\n\t\tend\n\t\tprint max\n\t\tprint(\"\\n\")\n\tend\n}", "label": 0, "name1": "s546530291.java", "name2": "s391567402.rb"}, {"id": 304, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyScanner in = new MyScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        C solver = new C();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class C {\n        int N;\n        int M;\n\n        public void solve(int testNumber, MyScanner in, PrintWriter out) {\n            N = in.Int();\n            M = in.Int();\n            DSU dsu = new DSU(N);\n            for (int i = 0; i < M; i++) {\n                int A = in.Int() - 1;\n                int B = in.Int() - 1;\n                dsu.merge(A, B);\n            }\n            out.println(dsu.groups().size() - 1);\n        }\n\n    }\n\n    static class DSU {\n        private int n;\n        private int[] parentOrSize;\n\n        public DSU(int n) {\n            this.n = n;\n            this.parentOrSize = new int[n];\n            Arrays.fill(parentOrSize, -1);\n        }\n\n        int merge(int a, int b) {\n            if (!(0 <= a && a < n))\n                throw new IndexOutOfBoundsException(\"a=\" + a);\n            if (!(0 <= b && b < n))\n                throw new IndexOutOfBoundsException(\"b=\" + b);\n\n            int x = leader(a);\n            int y = leader(b);\n            if (x == y) return x;\n            if (-parentOrSize[x] < -parentOrSize[y]) {\n                int tmp = x;\n                x = y;\n                y = tmp;\n            }\n            parentOrSize[x] += parentOrSize[y];\n            parentOrSize[y] = x;\n            return x;\n        }\n\n        int leader(int a) {\n            if (parentOrSize[a] < 0) {\n                return a;\n            } else {\n                parentOrSize[a] = leader(parentOrSize[a]);\n                return parentOrSize[a];\n            }\n        }\n\n        ArrayList<ArrayList<Integer>> groups() {\n            int[] leaderBuf = new int[n];\n            int[] groupSize = new int[n];\n            for (int i = 0; i < n; i++) {\n                leaderBuf[i] = leader(i);\n                groupSize[leaderBuf[i]]++;\n            }\n            ArrayList<ArrayList<Integer>> result = new ArrayList<>(n);\n            for (int i = 0; i < n; i++) {\n                result.add(new ArrayList<>(groupSize[i]));\n            }\n            for (int i = 0; i < n; i++) {\n                result.get(leaderBuf[i]).add(i);\n            }\n            result.removeIf(ArrayList::isEmpty);\n            return result;\n        }\n\n    }\n\n    static class MyScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public MyScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    return null;\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int Int() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "code2": "class UnionFind\n    def initialize(size)\n        @rank = Array.new(size, 0)\n        @parent = Array.new(size, &:itself)\n    end\n  \n    def unite(id_x, id_y)\n        x_parent = get_parent(id_x)\n        y_parent = get_parent(id_y)\n        return if x_parent == y_parent\n    \n        if @rank[x_parent] > @rank[y_parent]\n            @parent[y_parent] = x_parent\n        else\n            @parent[x_parent] = y_parent\n            @rank[y_parent] += 1 if @rank[x_parent] == @rank[y_parent]\n        end\n    end\n  \n    def get_parent(id_x)\n        @parent[id_x] == id_x ? id_x : (@parent[id_x] = get_parent(@parent[id_x]))\n    end\n  \n    def same_parent?(id_x, id_y)\n        get_parent(id_x) == get_parent(id_y)\n    end\nend\n\nn, m = gets.chomp.split.map(&:to_i)\nuf = UnionFind.new(n)\nm.times do\n    a, b = gets.chomp.split.map(&:to_i)\n    uf.unite(a-1, b-1)\nend\n\nh = Hash.new(0)\nhoge = []\n\nn.times do |i|\n    tmp = uf.get_parent(i)\n    hoge << tmp\n    h[tmp] += 1\nend\n\nputs h.size-1", "label": 1, "name1": "s578903603.java", "name2": "s039827889.rb"}, {"id": 25, "code1": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map.Entry;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nclass Main {\n    static final int MOD = 1000000007;\n    static final int INF = 1 << 30;\n\n    Main() {\n        Scanner sc = new Scanner(System.in);\n        long ans = 0;\n        long H = sc.nextLong();\n        long W = sc.nextLong();\n        if(H==1 || W==1){\n        System.out.println(1);\n        return;\n        }\n        long ht = H/2+H%2;\n        long hd = H/2;\n        long wt = W/2+W%2;\n        long wd = W/2;\n        ans += ht*wt;\n        ans += hd*wd;\n        System.out.println(ans);\n    }\n\n    public static void main(String[] args) {\n        new Main();\n    }\n}\n ", "code2": "H, W = gets.split.map(&:to_i)\n\nif H == 1 || W == 1\n  puts 1\nelse\n  puts (H * W / 2.0).ceil\nend", "label": 1, "name1": "s490391243.java", "name2": "s406316016.rb"}, {"id": 77, "code1": "import java.util.*;\n\nclass Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int k = findK(n);\n        if(k==-1){\n            System.out.println(\"No\");\n            System.exit(0);\n        }\n        int[][] res = new int[k][k-1];\n        for(int i=0;i<k-1;i++) res[0][i] = i+1;\n        int[] index = new int[k];\n        for(int i=0;i<k;i++) index[i]=i;\n        for(int row=1;row<k;row++){\n            int idx = 0;\n            for(int j=0;j<row;j++) res[row][idx++] = res[j][index[j]++];\n            if(row==k-1) continue;\n            res[row][idx++]=res[row-1][k-2]+1;\n            while(idx<k-1){\n                res[row][idx] = res[row][idx-1]+1;\n                idx++;\n            }\n        }\n        System.out.println(\"Yes\");\n        System.out.println(k);\n        for(int i=0;i<k;i++){\n            System.out.print(Integer.toString(k-1)+\" \");\n            for(int j=0;j<k-1;j++){\n                System.out.print(Integer.toString(res[i][j])+\" \");\n            }\n            System.out.println(\"\");\n        }\n    }\n    static int findK(int n){\n        int k=1;\n        while(k*(k-1)<=2*n){\n            if(k*(k-1)==2*n) return k;\n            k++;\n        }\n        return -1;\n    }\n}\n", "code2": "n = gets.chop.to_i\n\nk = 1\nflag = false\nloop do\n  k += 1\n  num = k * (k-1) / 2\n  if num == n\n    flag = true\n    break\n  end\n  break if num > n\nend\n\nif flag\n  ans = Array.new(k, nil).map{Array.new(0)}\n  (1..k).to_a.combination(2).to_a.each_with_index do |v, i|\n    v.each do |j|\n      ans[j-1] << i + 1\n    end\n  end\n  puts 'Yes'\n  puts k\n  k.times do |i|\n    puts \"#{ans[i].size} #{ans[i].join(' ')}\"\n  end\nelse\n  puts 'No'\nend", "label": 1, "name1": "s741808618.java", "name2": "s909820344.rb"}, {"id": 945, "code1": "import java.util.*;\n\npublic class Main {\n    public static void main(String args[]){\n        Scanner stdIn = new Scanner(System.in);\n        int n = stdIn.nextInt();\n        int c[] = new int[26];\n        int s[][] = new int[n][26];\n        \n        for(int i = 0; i < 26; i++){\n            c[i] = stdIn.nextInt();\n        }\n        \n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < 26; j++){\n                s[i][j] = stdIn.nextInt();\n            }\n        }\n        \n        /* \n        for(int i = 0; i < n; i++){\n            int max = 0;\n            int index = 0;\n            for(int j = 0; j < 26; j++){\n                if(s[i][j] > max){\n                    max = s[i][j];\n                    index = j;\n                }\n            }\n            System.out.println(index + 1);\n        }\n        */\n        \n        for(int i = 1; i < n + 1; i++){\n            System.out.println(i % 26 + 1);\n        }\n        \n        //System.out.println(\"XXXXXXXX\");\n    }\n}\n", "code2": "puts gets.count('2')", "label": 0, "name1": "s555776282.java", "name2": "s996141713.rb"}, {"id": 181, "code1": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tString str = scanner.nextLine();\n\t\tString[] ab = str.split(\" \");\n\t\tint a = Integer.parseInt(ab[0]);\n\t\tint b = Integer.parseInt(ab[1]);\n\t\tif (a > b) {\n\t\t\tSystem.out.println(a - 1);\n\t\t}else {\n\t\t\tSystem.out.println(a);\n\t\t}\n\t\t\n\t\tscanner.close();\n\n\t}\n\n}\n", "code2": "a,b = gets.split.map(&:to_i)\n\nif a <= b\n  puts a\nelse\n  puts a-1\nend", "label": 1, "name1": "s957138694.java", "name2": "s914009735.rb"}, {"id": 147, "code1": "import java.util.*;\npublic class Main {\n\tint n;\n\tint[] num;\n\tScanner stdin =new Scanner(System.in);\n\t\n\tvoid Solve(){\n\t\tnum=new int[21000000];\n\t\twhile(true){\n\t\t\tn=stdin.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tSystem.out.println(findPrime(n+1,2*n));\n\t\t}\n\t\t\n\t}\n\tint findPrime(int a,int b){\n\t\tint count=0;\n\t\tfor(int i=a;i<=b;i++){\n\t\t\tif(judgePrime(i)) count++;\n\t\t}\n\t\t\n\t\treturn count;\n\t}\n\t\n\tboolean judgePrime(int p){\n\t\tif(num[p]==1) return true;\n\t\tif(num[p]==-1) return false;\n\t\t\n\t\tif(p<4){\n\t\t\tnum[p]=1;\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\tif(p%2==0){\n\t\t\t\tnum[p]=-1;\n\t\t\t\treturn false; \n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=3;i<p;i++){\n\t\t\t\tif(p%i==0){\n\t\t\t\t\tnum[p]=-1;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tnum[p]=1;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\t\n\t\n\tpublic static void main(String args[]){\n\t\tMain m=new Main();\n\t\tm.Solve();\n\t}\n\t\n}", "code2": "objects = []\n\nmax_n = 123456*2\n\nsosu_arr = []\nsosu_set = {}\n\nmax_n.times.each do |ii|\n  i = ii + 1\n  next if i == 1\n  next if sosu_set.key?(i)\n  sosu_arr.push i\n  sosu_set[i] = true\n  (max_n/i).to_i.times.each do |j|\n    next if j == 0\n    sosu_set[i * (j+1)] = false\n  end\nend\n\nlines = []\nwhile num = gets\n  num = num.to_i\n  break if num == 0\n  if num == 1\n    puts 1\n    next\n  end\n  sum = 0\n  ((num+1)..(num*2)).each do |i|\n    sum = sum + 1 if sosu_set[i]\n  end\n  puts sum\nend", "label": 1, "name1": "s726742249.java", "name2": "s102129990.rb"}, {"id": 899, "code1": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n\t\n\tvoid solve() {\n\t\tint n = in.nextInt(), m = in.nextInt();\n\t\tout.println((1L << m) * (1900 * m + 100 * (n - m))); \n\t}\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tvoid run() {\n\t\tin = new FastScanner();\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(s));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic String nextToken() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n", "code2": "#input of int(split by space)\ndef get_i()\n  return gets.chomp.split(\" \").map(&:to_i)\nend\n#input of float(split by space)\ndef get_f()\n  return gets.chomp.split(\" \").map(&:to_f)\nend\n#input of string(split by space)\ndef get()\n  return gets.chomp.split(\" \")\nend\n#input of string(split per one character)\ndef get_nsp()\n  return gets.chomp.split(\"\")\nend\n#yes or no decision\ndef yn_judge(bool,y=\"Yes\",n=\"No\")\n  return bool ? y : n \nend\n#create of array\ndef array(size1,init=nil,size2=-1)\n  if size2==-1\n      return Array.new(size1){init}\n  else\n      return Array.new(size2){Array.new(size1){init}}\n  end\nend\n\ndef max(a,b)\n    return a>b ? a : b\nend\n\ndef min(a,b)\n    return a>b ? b : a\nend\n\nINF=Float::INFINITY\n\nH,W=get_i\nkind=Hash.new(0)\nH.times do|i|\n    get_nsp.each do|a|\n        kind[a]+=1\n    end\nend\n\nif W.even? or H.even?\n  kind.each do|k,v|\n      if kind[k].odd?\n          puts \"No\"\n          exit\n      end\n      kind[k]/=2\n  end\n  cnt=kind.count{|x| x[1].odd?}\n  if W.even? and H.even?\n    if cnt.zero?\n        puts \"Yes\"\n    else\n        puts \"No\"\n    end\n  else\n      even=(W.even? ? W : H)\n      if cnt<=even/2\n          puts \"Yes\"\n      else\n          puts \"No\"\n      end\n  end\nelse\n    g={}\n    g[1]=0\n    g[2]=0\n    g[4]=0\n    kind.each do|k,v|\n      if v>=4\n          g[4]+=v/4\n          v%=4\n      end\n      if v>=2\n          g[2]+=1\n          v%=2\n      end\n      if v==1\n          g[1]+=1\n      end\n    end\n    if g[1]==1 and g[4]>=(H/2)*(W/2) and (g[4]-(H/2)*(W/2))*2+g[2]>=H/2+W/2\n        puts \"Yes\"\n    else\n        puts \"No\"\n    end\nend", "label": 0, "name1": "s585016642.java", "name2": "s908373380.rb"}, {"id": 696, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.AbstractCollection;\nimport java.util.PriorityQueue;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CStreamline solver = new CStreamline();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CStreamline {\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            int[] x = in.nextIntArray(m);\n            Arrays.sort(x);\n            int ans = x[m - 1] - x[0];\n            PriorityQueue<Integer> q = new PriorityQueue<>();\n            for (int i = 0; i < m - 1; i++) {\n                q.add(-(x[i + 1] - x[i]));\n            }\n            for (int i = 0; i < n - 1 && !q.isEmpty(); i++) {\n                ans += q.poll();\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        public int[] nextIntArray(final int n) {\n            final int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt();\n            }\n            return res;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n", "code2": "a, b, c = gets.strip.split(' ').map(&:to_i)\n\nans = 0\nif a - b < c then\n    ans = c - a + b\nend\n\nputs(ans)", "label": 0, "name1": "s975956716.java", "name2": "s914404322.rb"}, {"id": 928, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tint n;\n\tlong mo = 1_000_000_000 + 7;\n\tlong[] fac = new long[3000000];\n\tlong[] ifac = new long[3000000];\n\tlong[] inv = new long[3000000];\n\t{\n\t\tfac[0] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i) {\n\t\t\tfac[i] = i * fac[i - 1] % mo;\n\t\t}\n\t\tinv[1] = 1;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = mo - inv[(int) (mo % i)] * (mo / i) % mo;\n\t\t}\n\t\tifac[0] = 1;\n\t\tfor (int i = 1; i < ifac.length; ++i) {\n\t\t\tifac[i] = ifac[i - 1] * inv[i] % mo;\n\t\t}\n\t}\n\n\tlong comb(int n, int k) {\n\t\treturn fac[n] * ifac[n - k] % mo * ifac[k] % mo;\n\t}\n\n\tlong g(int k) {\n\t\tif (2 * k < n)\n\t\t\treturn 0;\n\t\tint a = 2 * k - n;\n\t\tint b = n - k;\n\t\treturn comb(a - 1 + b, b - 1) * fac[k] % mo * fac[n - 1 - k] % mo;\n\t}\n\n\tlong f(int k) {\n\t\treturn (g(k) - g(k - 1) + mo) % mo;\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner();\n\t\tn = (int) sc.nextLong();\n\t\tlong ans = 0;\n\t\tfor (int i = (n + 1) / 2; i <= n - 1; ++i) {\n\t\t\tans = (ans + f(i) * i % mo) % mo;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tlong pow(long a, long n) {\n\t\tlong ret = 1;\n\t\tfor (; n > 0; n >>= 1, a = a * a % mo) {\n\t\t\tif (n % 2 == 1) {\n\t\t\t\tret = ret * a % mo;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tlong inv(long a) {\n\t\treturn pow(a, mo - 2);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tclass Scanner {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[ptr++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isPrintableChar(int c) {\n\t\t\treturn 33 <= c && c <= 126;\n\t\t}\n\n\t\tprivate void skipUnprintable() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\t\tptr++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskipUnprintable();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n}\n", "code2": "h,w = gets.split.map(&:to_i)\na = Array.new(h){ gets.chomp }\n\nseen = Array.new(h){ Array.new(w){ false } }\nDX = [ 0, 1, 0,-1, 1,-1, 1,-1]\nDY = [ 1, 0,-1, 0, 1,-1,-1, 1]\ninside = -> y, x { 0 <= y && y < h && 0 <= x && x < w }\n\nbfs = -> sy,sx do\n  return 0 if seen[sy][sx]\n  que = [[sy,sx]]\n  seen[sy][sx] = true\n  black = 0\n  white = 0\n  while que.size > 0\n    y,x = que.pop\n    a[y][x] == \"#\" ? black += 1 : white += 1\n    4.times do |i|\n      ny = y + DY[i]\n      nx = x + DX[i]\n      next unless inside[ny,nx]\n      next if seen[ny][nx]\n      next if a[y][x] == a[ny][nx] # \u540c\u3058\u8272\u306a\u3089\u5bfe\u8c61\u5916\n      que << [ny,nx]\n      seen[ny][nx] = true\n    end\n  end\n  return black * white\nend\n\nans = 0\nh.times do |y|\n  w.times do |x|\n    ans += bfs[y,x]\n  end\nend\nputs ans", "label": 0, "name1": "s980347613.java", "name2": "s257634144.rb"}, {"id": 959, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            int k = in.nextInt();\n            String ans = \"No\";\n            for (int i = 0; i <= n; i++) {\n                for (int j = 0; j <= m; j++) {\n                    int v = (n - i) * j + i * (m - j);\n                    if (v == k) {\n                        ans = \"Yes\";\n                    }\n                }\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n", "code2": "n = gets.to_i\nas = gets.chomp.split.map(&:to_i).sort\nbs = gets.chomp.split.map(&:to_i).sort\ncs = gets.chomp.split.map(&:to_i).sort\n\ncnt = 0\n\nbs.each do |b|\n  a_idx = as.bsearch_index{|x| x >= b} || n\n  c_idx = cs.bsearch_index{|x| x > b} || n\n  cnt += a_idx * (n - c_idx) \nend\n\nputs cnt\n", "label": 0, "name1": "s599604936.java", "name2": "s704220285.rb"}, {"id": 261, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint A = sc.nextInt();\n\t\tint B = sc.nextInt();\n\t\tint C = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tint res = 0;\n\t\tres+=Math.min(A, K);\n\t\tK -= res;\n\t\tif(K==0) {\n\t\t\tSystem.out.println(res);\n\t\t\tSystem.exit(0);\n\t\t}\n\t\tK-=B;\n\t\tif(K>0) {\n\t\t\tres-=Math.min(K, C);\n\t\t}\n\t\tSystem.out.println(res);\n\n\t}\n}", "code2": "a, b, c, k = gets.split.map &:to_i\nans = 0\n[a, b, c].zip([1, 0, -1]).each do |n, cost|\n\tm = [n, k].min\n\tk -= m\n\tans += cost * m\nend\nputs ans\n", "label": 1, "name1": "s649759516.java", "name2": "s146217788.rb"}, {"id": 616, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[][] field;\n\tstatic String[][] dp;\n\tstatic int h,w;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = cin.nextInt();\n\t\t\th = cin.nextInt();\n\t\t\tif(w+h==0)break;\n\t\t\tfield=new int[h][w];\n\t\t\tdp=new String[h][w];\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tString s = cin.next();\n\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\tdp[i][j]=\"\";\n\t\t\t\t\tif(Character.isDigit(s.charAt(j))){\n\t\t\t\t\t\tfield[i][j]=s.charAt(j)-'0';\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tfield[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i<w;i++){\n\t\t\t\tif(i==0){\n\t\t\t\t\tif(field[0][i]<=0){\n\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdp[0][i]=\"\"+field[0][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(field[0][i]==-1){\n\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(!dp[0][i-1].equals(\"0\")&&!dp[0][i-1].equals(\"\")){\n\t\t\t\t\t\t\tdp[0][i]=dp[0][i-1]+field[0][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[0][i]=\"\"+field[0][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tif(i==0){\n\t\t\t\t\tif(field[i][0]<=0){\n\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdp[i][0]=\"\"+field[i][0];\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(field[i][0]==-1){\n\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(!dp[i-1][0].equals(\"0\")&&!dp[i-1][0].equals(\"\")){\n\t\t\t\t\t\t\tdp[i][0]=dp[i-1][0]+field[i][0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i][0]=\"\"+field[i][0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tString ans=\"0\";\n\t\t\tfor(int i = 1;i<h;i++){\n\t\t\t\tfor(int j = 1;j<w;j++){\n\t\t\t\t\tif(field[i][j]==-1)continue;\n\t\t\t\t\tString s1=dp[i-1][j]+field[i][j];\n\t\t\t\t\tString s2=dp[i][j-1]+field[i][j];\n\t\t\t\t\tString s3=field[i][j]+\"\";\n\t\t\t\t\tif(big(s1,s2)>=0){\n\t\t\t\t\t\tif(big(s1,s3)>=0){\n\t\t\t\t\t\t\tdp[i][j]=s1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i][j]=s3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(big(s2,s3)>=0){\n\t\t\t\t\t\t\tdp[i][j]=s2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i][j]=s3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\twhile(dp[i][j].charAt(0)=='0'&&dp[i][j].length()>1){\n\t\t\t\t\t\tdp[i][j]=dp[i][j].substring(1,dp[i][j].length());\n\t\t\t\t\t}\n\t\t\t\t\tif(big(dp[i][j],ans)>0){\n\t\t\t\t\t\tans=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\tif(big(dp[i][j],ans)>0){\n\t\t\t\t\t\tans=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//output();\n\t\t\tSystem.out.println(ans);\n\t\t}\n\n\t}\n\tstatic int big(String s1,String s2){\n\t\tif(s1.length()==s2.length()){\n\t\t\treturn s1.compareTo(s2);\n\t\t}\n\t\treturn s1.length()-s2.length();\n\t}\n\tstatic void output(){\n\t\tfor(int i = 0;i<h;i++){\n\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\tSystem.out.print(dp[i][j]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n}", "code2": "a,b = gets.split.map(&:to_i)\n\nif a <= b\n  puts a\nelse\n  puts a-1\nend", "label": 0, "name1": "s061375468.java", "name2": "s914009735.rb"}, {"id": 438, "code1": "import java.io.*;\nimport java.util.*;\n\n/**\n *\n * @author baito\n */\nclass UnionFindTree\n{\n    int[] par;\n    int[] rank;\n    int[] sizes;\n\n    UnionFindTree(int n)\n    {\n        par = new int[n];\n        rank = new int[n];\n        sizes = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            par[i] = i;\n            rank[i] = 0;\n            sizes[i] = 1;\n        }\n    }\n\n    int find(int x)\n    {\n        if (par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n\n    void unite(int x, int y)\n    {\n        x = find(x);\n        y = find(y);\n\n        if (x == y) return;\n        if (rank[x] < rank[y])\n        {\n            par[x] = y;\n            sizes[y] += sizes[x];\n        }\n        else\n        {\n            par[y] = x;\n            sizes[x] += sizes[y];\n            if (rank[x] == rank[y]) rank[x]++;\n        }\n    }\n\n    boolean same(int x, int y)\n    {\n        return find(x) == find(y);\n    }\n\n    int size(int x)\n    {\n        return sizes[par[x]];\n    }\n}\npublic class Main\n{\n    static StringBuilder sb = new StringBuilder();\n    static FastScanner sc = new FastScanner(System.in);\n    static int INF = 10000;\n    static long MOD =1000000007;\n    static long[] f;//factorial\n    static int[] y4 = {0,1,0,-1};\n    static int[] x4 = {1,0,-1,0};\n    static int[] y8 = {0,1,0,-1,-1,1,1,-1};\n    static int[] x8 = {1,0,-1,0,1,-1,1,-1};\n\n    static int N,K,L;\n\n    public static void main(String[] args)\n    {\n\n        N = sc.nextInt();\n        K = sc.nextInt();\n        L = sc.nextInt();\n        UnionFindTree u1 = new UnionFindTree(N);\n        UnionFindTree u2 = new UnionFindTree(N);\n        //long\u3092\u5fd8\u308c\u308b\u306a\u30aa\u30fc\u30d0\u30fc\u30d5\u30ed\u30fc\u3059\u308b\u305e\n        for (int i = 0; i < K; i++)\n        {\n            int p = sc.nextInt()-1;\n            int q = sc.nextInt()-1;\n            u1.unite(p,q);\n        }\n        for (int i = 0; i < L; i++)\n        {\n            int p = sc.nextInt()-1;\n            int q = sc.nextInt()-1;\n            u2.unite(p,q);\n        }\n        Map<Long,Integer> sizes = new HashMap<>();\n        for (int i = 0; i < N; i++)\n        {\n            long root1 = u1.find(i);\n            long root2 = u2.find(i);\n            long hash = root1 * 1000000L + root2;\n            int value = sizes.containsKey(hash) ? sizes.get(hash):0;\n            sizes.put(hash,value+1);\n\n\n        }\n        for (int i = 0; i < N; i++)\n        {\n            long root1 = u1.find(i);\n            long root2 = u2.find(i);\n            long hash = root1 * 1000000L + root2;\n            System.out.println(sizes.get(hash));\n        }\n\n\n\n    }\n    //\u2193nCr\u3092mod\u8a08\u7b97\u3059\u308b\u305f\u3081\u306b\u5fc5\u8981\u3002\u3000***factorial(N)\u3092\u547c\u3076\u5fc5\u8981\u304c\u3042\u308b***\n    static long comb(int n, int r)\n    {\n        long result = f[n];\n        result = result * modInv(f[n - r]) % MOD;\n        result = result * modInv(f[r]) % MOD;\n        return result;\n    }\n\n    static long modInv(long n)\n    {\n        return modPow(n, MOD - 2);\n    }\n\n    static void factorial(int n)\n    {\n        f = new long[n + 1];\n        f[0] = f[1] = 1;\n        for (int i = 2; i <= n; i++)\n        {\n            f[i] = (f[i - 1] * i) % MOD;\n        }\n    }\n\n    static long modPow(long x, long n)\n    {\n        long res = 1L;\n        while (n > 0)\n        {\n            if ((n & 1) == 1)\n            {\n                res = res * x % MOD;\n            }\n            x = x * x % MOD;\n            n >>= 1;\n        }\n        return res;\n    }\n\n    //\u2191nCr\u3092mod\u8a08\u7b97\u3059\u308b\u305f\u3081\u306b\u5fc5\u8981\n\n    static int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n    static long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\n    static <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n    static void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n    public static void reverse(int[] x)\n    {\n        int l = 0;\n        int r = x.length - 1;\n        while (l < r)\n        {\n            int temp = x[l];\n            x[l] = x[r];\n            x[r] = temp;\n            l++;\n            r--;\n        }\n    }\n    public static void reverse(int[] x,int s, int e)\n    {\n        int l = s;\n        int r = e;\n        while (l < r)\n        {\n            int temp = x[l];\n            x[l] = x[r];\n            x[r] = temp;\n            l++;\n            r--;\n        }\n    }\n    static int length(int a) {int cou = 0; while(a != 0){ a /= 10; cou++; } return cou;}\n    static int length(long a) {int cou = 0; while(a != 0){ a /= 10; cou++; } return cou;}\n    static int countC2(char[][] a, char c){\n        int co = 0;\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[0].length; j++)\n                if(a[i][j] == c)\n                    co++;\n        return co;\n    }\n    static void fill(int[][] a, int v){\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[0].length; j++)\n                a[i][j] = v;\n    }\n    static class FastScanner {\n\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        public String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        /*public String nextChar(){\n            return (char)next()[0];\n        }*/\n        public String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n        public int [][] nextIntArray2(int h, int w){\n            int[][] a = new int[h][w];\n            for(int hi = 0 ; hi < h ; hi++){\n                for(int wi = 0 ; wi < w ; wi++){\n                    a[hi][wi] = nextInt();\n                }\n            }\n            return a;\n        }\n        public Integer[] nextIntegerArray(int n) {\n            Integer[] a = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n        public char[] nextCharArray(int n){\n            char[] a = next().toCharArray();\n\n            return a;\n        }\n        public char[][] nextCharArray2(int h , int w){\n            char[][] a = new char[h][w];\n            for (int i = 0; i < h; i++) {\n                a[i] = next().toCharArray();\n            }\n            return a;\n        }\n        //\u30b9\u30da\u30fc\u30b9\u304c\u5165\u3063\u3066\u3044\u308b\u5834\u5408\n        public char[][] nextCharArray2s(int h , int w){\n            char[][] a = new char[h][w];\n            for (int i = 0; i < h; i++) {\n                a[i] = nextLine().replace(\" \",\"\").toCharArray();\n            }\n            return a;\n        }\n        public char[][] nextWrapCharArray2(int h , int w, char c){\n            char[][] a = new char[h + 2][w + 2];\n            //char c = '*';\n            int i;\n            for (i = 0; i < w + 2; i++)\n                a[0][i] = c;\n            for (i = 1; i < h + 1; i++) {\n                a[i] = (c + next() + c).toCharArray();\n            }\n            for (i = 0; i < w + 2; i++)\n                a[h + 1][i] = c;\n            return a;\n        }\n        //\u30b9\u30da\u30fc\u30b9\u304c\u5165\u3063\u3066\u308b\u6642\u7528\n        public char[][] nextWrapCharArray2s(int h , int w ,char c){\n            char[][] a = new char[h + 2][w + 2];\n            //char c = '*';\n            int i;\n            for (i = 0; i < w + 2; i++)\n                a[0][i] = c;\n            for (i = 1; i < h + 1; i++) {\n                a[i] = (c + nextLine().replace(\" \",\"\") + c).toCharArray();\n            }\n            for (i = 0; i < w + 2; i++)\n                a[h + 1][i] = c;\n            return a;\n        }\n        public long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextLong();\n            }\n            return a;\n        }\n        public long [][] nextLongArray2(int h, int w){\n            long[][] a = new long[h][w];\n            for(int hi = 0 ; hi < h ; hi++){\n                for(int wi = 0 ; wi < h ; wi++){\n                    a[h][w] = nextLong();\n                }\n            }\n            return a;\n        }\n    }\n}\n", "code2": "class Node\n  attr_accessor :parent, :rank\n  def initialize(n)\n    @parent = n\n    @rank = 0\n  end\nend\n\nclass UnionFindTree\n  def initialize(n)\n    @nodes = (0..n).map { |i| Node.new(i) }\n  end\n\n  def unite(a, b)\n    pa = find(a)\n    pb = find(b)\n    return if pa == pb\n\n    if @nodes[pa].rank < @nodes[pb].rank\n      @nodes[pb].parent = pa\n    else\n      @nodes[pa].parent = pb\n      @nodes[pa].rank += 1 if @nodes[pa].rank == @nodes[pb].rank\n    end\n  end\n\n  def find(x)\n    return x if @nodes[x].parent == x\n    @nodes[x].parent = find(@nodes[x].parent)\n  end\nend\n\nn,k,l = gets.split(\" \").map(&:to_i)\n\nroad = UnionFindTree.new(n)\n1.upto(k) do\n  x,y = gets.split(\" \").map(&:to_i)\n  road.unite(x,y)\nend\n\nrail = UnionFindTree.new(n)\n1.upto(l) do\n  x,y = gets.split(\" \").map(&:to_i)\n  rail.unite(x,y)\nend\n\npair = Array.new\nhash = Hash.new(0)\n1.upto(n) do |p|\n x = road.find(p)\n y = rail.find(p)\n key = [x,y]\n pair.push(key)\n \n hash[key] = hash[key] + 1\n  \nend\n\npair.each do |key|\n print hash[key], \" \"\nend\nprint \"\\n\"", "label": 1, "name1": "s138073781.java", "name2": "s211925773.rb"}, {"id": 399, "code1": "//\u0083\\\u0081[\u0083g\u0082\u00b7\u0082\u00e9\u0083v\u0083\u008d\u0083O\u0083\u0089\u0083\u0080\u0081i\u0082\u008e\u0082\u00cc\u0092l\u0082\u00cd1,000,000\u0088\u00c8\u0089\u00ba\u0081j\nimport java.util.*;\npublic class Main {\n\n\tpublic void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tTreeSet<Integer> set = new TreeSet<Integer>();\n\t\tTreeMap<Integer,Integer> map = new TreeMap<Integer, Integer>();\n\n\t\tfor(int i=0; i < n; i++){\n\t\t\tint temp = sc.nextInt();\n\t\t\tif( set.contains(temp)){\n\t\t\t\tif(map.containsKey(temp)){\n\t\t\t\t\tmap.put(temp, map.get(temp) + 1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmap.put(temp, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tset.add(temp);\n\t\t\t}\n\t\t}\n\t\tfor(int num: set){\n\t\t\tif(map.containsKey(num)){\n\t\t\t\tfor(int i=0; i < map.get(num);i++){\n\t\t\t\t\tSystem.out.print(num + \" \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(num == set.last()){\n\t\t\t\tSystem.out.println(num);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.print(num + \" \");\n\t\t\t}\n\n\t\t}\n\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doIt();\n\n\t}\n\n}", "code2": "#!/usr/bin/ruby\n\ni=STDIN.gets\n\nnum = STDIN.gets.split()\nnum.map!{|i| i.to_i}\n\nnum.sort!\n\nputs num.join(\" \")", "label": 1, "name1": "s012590995.java", "name2": "s080700840.rb"}, {"id": 751, "code1": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tstatic void solve() {\n\t\tlong i = ni(), o = ni(), t = ni(), j = ni(), l = ni(), s = ni(), z = ni();\n\t\tlong ans = 0;\n\t\tans += o;\n\t\t\n\t\t\n\t\tlong rem = i%2+j%2+l%2;\n\t\tif(i==0||j==0||l==0) {\n\t\t\tans += 2*(i/2 + j/2 + l/2);\n\t\t\tout.println(ans);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(rem<=1) {\n\t\t\tans += 2*(i/2 + j/2 + l/2);\n\t\t}\n\t\telse {\n\t\t\tans += 3;\n\t\t\ti--; j--;l--;\n\t\t\tans += 2*(i/2 + j/2 + l/2);\n\t\t}\n\t\tout.println(ans);\n\t\t\n\t}\n\n\t//constant\n\tstatic final long mod = (long) 1e9 + 7;\n\tstatic final int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };\n\tstatic final int[] dx8 = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\tstatic final int inf = Integer.MAX_VALUE / 2;\n\tstatic final long linf = Long.MAX_VALUE / 3;\n\tstatic final double dinf = Double.MAX_VALUE / 3;\n\tstatic final double eps = 1e-10;\n\tstatic final double pi = Math.PI;\n\tstatic StringBuilder sb = new StringBuilder();\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\t//libraries\n\tstatic void reverse(int ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tint t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(long ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tlong t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(double ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tdouble t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(char ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tchar t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic String getReverse(String s) {\n\t\tchar c[] = s.toCharArray();\n\t\treverse(c);\n\t\ts = String.valueOf(c);\n\t\treturn s;\n\t}\n\n\tstatic <T> void reverse(List<T> ls) {\n\t\tint sz = ls.size();\n\t\tfor (int i = 0; i < sz / 2; i++) {\n\t\t\tT t = ls.get(i);\n\t\t\tls.set(i, ls.get(sz - 1 - i));\n\t\t\tls.set(sz - 1 - i, t);\n\t\t}\n\t}\n\n\tstatic <T> void reverse(T[] ar) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tT t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void sbnl() {//StringBuilder\u306b\u6539\u884c\u6587\u5b57\u3092append\u3059\u308b\n\t\tsb.append(\"\\n\");\n\t}\n\n\tstatic int lowerBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int lowerBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int lowerBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int lowerBound(char[] a, char x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(char[] a, char x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(char[] a, char x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(char[] a, char x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic <T> int lowerBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) >= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) >= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) >= 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int upperBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) > 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) > 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) > 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int rupperBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) < 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) < 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) < 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int rlowerBound(List<T> ls, T x) {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) <= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) <= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) <= 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic int[] concat(int x, int arr[]) {\n\t\tint ret[] = new int[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 1, ret.length - 1);\n\t\tret[0] = x;\n\t\treturn ret;\n\t}\n\n\tstatic int[] concat(int arr[], int x) {\n\t\tint ret[] = new int[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 0, ret.length - 1);\n\t\tret[ret.length - 1] = x;\n\t\treturn ret;\n\t}\n\n\tstatic long[] concat(long x, long arr[]) {\n\t\tlong ret[] = new long[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 1, ret.length - 1);\n\t\tret[0] = x;\n\t\treturn ret;\n\t}\n\n\tstatic long[] concat(long arr[], long x) {\n\t\tlong ret[] = new long[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 0, ret.length - 1);\n\t\tret[ret.length - 1] = x;\n\t\treturn ret;\n\t}\n\n\tstatic int max(int x, int y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic int min(int x, int y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic int max(int x, int y, int z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic int min(int x, int y, int z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic long max(long x, long y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic long min(long x, long y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic long max(long x, long y, long z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic long min(long x, long y, long z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic double max(double x, double y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic double min(double x, double y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic double max(double x, double y, double z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic double min(double x, double y, double z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic void sort(int[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void sort(long[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void sort(double[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void sort(char[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void rsort(int[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tint tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void rsort(long[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tlong tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void rsort(double[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tdouble tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void rsort(char[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tchar tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void fill(int arr[], int x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(long arr[], long x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(boolean arr[], boolean x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(double arr[], double x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(int arr[][], int x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(long arr[][], long x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(double arr[][], double x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(boolean arr[][], boolean x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\t//MOD culc\n\tstatic long plus(long x, long y) {\n\t\tlong res = (x + y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long sub(long x, long y) {\n\t\tlong res = (x - y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long mul(long x, long y) {\n\t\tlong res = (x * y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long div(long x, long y) {\n\t\tlong res = x * pow(y, mod - 2) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long pow(long x, long y) {\n\t\tif (y < 0)\n\t\t\treturn 0;\n\t\tif (y == 0)\n\t\t\treturn 1;\n\t\tif (y % 2 == 1)\n\t\t\treturn (x * pow(x, y - 1)) % mod;\n\t\tlong root = pow(x, y / 2);\n\t\treturn root * root % mod;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\t//input\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static long[] nla(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n}\n", "code2": "a,b,x=gets.split.map &:to_i\np b/x-(a-1)/x", "label": 0, "name1": "s751122857.java", "name2": "s453515568.rb"}, {"id": 501, "code1": "\nimport java.util.Scanner;\n\n/**\n * Created by enpingkuang on 2020/9/10 10:58 \u4e0b\u5348\n */\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String s = scanner.next();\n        long sum = 0;\n        int length = s.length();\n        for(int i = 0;i<length;i++){\n            sum += (s.charAt(i)-'0');\n        }\n        System.out.println(sum % 9==0?\"Yes\":\"No\");\n    }\n}\n", "code2": "s = gets.chomp.split(\"\")\nflag = 1\n\ns.size.times do |i|\n    if (i + 1) % 2 == 0 && s[i] == \"R\"\n        flag = 0\n        break\n    elsif (i + 1) % 2 == 1 && s[i] == \"L\"\n        flag = 0\n        break\n    end\nend\n\nif flag == 0\n    puts \"No\"\nelse\n    puts \"Yes\"\nend\n", "label": 0, "name1": "s939687060.java", "name2": "s337975959.rb"}, {"id": 835, "code1": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tchar[] s = ns(n);\n\t\tint[] pres = new int[n+1];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tpres[i+1] = pres[i] + (s[i] == 'W' ? 1 : 0);\n\t\t}\n\t\tint[] sufs = new int[n+1];\n\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\tsufs[i] = sufs[i+1] + (s[i] == 'E' ? 1 : 0);\n\t\t}\n\t\tint min = 999999999;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tmin = Math.min(min, pres[i] + sufs[i+1]);\n\t\t}\n\t\tout.println(min);\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n", "code2": "n,l,t = gets.split.map(&:to_i)\nx = Array.new(n)\nw = Array.new(n)\nn.times do |i|\n    x[i],w[i] = gets.split.map(&:to_i)\nend\nu = 0\na = 0\nn.times do |i|\n    next if w[i] == 2\n    n.times do |j|\n        next if w[j] == 1\n        u += (2*t-(x[j]-x[i])%l+l-1)/l\n    end\n    a = i\n    break\nend\nn.times do |i|\n    x[i] += (w[i] == 1 ? t : -t)\n    x[i] %= l\nend\nb = x[a]\nx.sort!\nm = x.bsearch_index{|num|num >= b}\nn.times do |i|\n    puts x[(m+i-u-a)%n]\nend", "label": 0, "name1": "s365509328.java", "name2": "s700324516.rb"}, {"id": 779, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.util.NoSuchElementException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author HBonsai\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CMultipleClocks solver = new CMultipleClocks();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CMultipleClocks {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int N = in.nextInt();\n            long[] T = in.nextLongArray(N);\n            long ans = T[0];\n            for (int i = 1; i < N; i++) {\n                long gcd = gcd(ans, T[i]);\n                ans = T[i] * (ans / gcd);\n            }\n            out.println(ans);\n        }\n\n        private static long gcd(long m, long n) {\n            if (m < n) return gcd(n, m);\n            if (n == 0) return m;\n            return gcd(n, m % n);\n        }\n\n    }\n\n    static class FastScanner implements Closeable {\n        private final InputStream in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        public FastScanner(InputStream in) {\n            this.in = in;\n        }\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        public boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n            return hasNextByte();\n        }\n\n        public long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        public int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] res = new long[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextLong();\n            }\n            return res;\n        }\n\n        public void close() {\n            try {\n                in.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n}\n\n", "code2": "class UnionFind\n  def initialize(size)\n    @parent = (0...size).to_a\n    @rank = Array.new(size, 0)\n  end\n\n  def find(x)\n    return x if @parent[x] == x\n    return (@parent[x] = find(@parent[x]))\n  end\n\n  def unite(x, y)\n    x, y = find(x), find(y)\n    return if x == y\n    if @rank[x] < @rank[y]\n      @parent[x] = y\n    else\n      @parent[y] = x\n      @rank[x] += 1 if @rank[x] == @rank[y]\n    end\n  end\n\n  def same(x, y)\n    find(x) == find(y)\n  end\nend\n\nn, k, l = gets.split.map(&:to_i)\nroad = UnionFind.new(n)\nrail = UnionFind.new(n)\nk.times do\n  x, y = gets.split.map { |c| c.to_i - 1 }\n  road.unite(x, y)\nend\nl.times do\n  x, y = gets.split.map { |c| c.to_i - 1 }\n  rail.unite(x, y)\nend\nroad = n.times.map { |i| road.find(i) }\nrail = n.times.map { |i| rail.find(i) }\ninter = n.times.map { |i| road[i] + n * rail[i] }\nh = {}\ninter.each { |x| h[x] ||= 0; h[x] += 1 }\ninter.each { |x| puts h[x] }\n", "label": 0, "name1": "s654794279.java", "name2": "s716688657.rb"}, {"id": 364, "code1": "import java.util.ArrayList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n/**\n * Created by shoya on 2017/04/12.\n */\npublic class Main {\n    public static void main(String... args) {\n        Scanner sc = new Scanner(System.in);\n        int V = sc.nextInt();\n        int E = sc.nextInt();\n        int r = sc.nextInt();\n        DijkstraClass dijkstra = new DijkstraClass(V, E, r);\n        for (int i = 0; i < E; i++) {\n            int s = sc.nextInt();\n            int d = sc.nextInt();\n            int c = sc.nextInt();\n            dijkstra.addDistande(s, d, c);\n        }\n        int[] dist = dijkstra.dikstra();\n        for (int i = 0; i < dist.length; i++){\n            if (dist[i] == 1 << 30)\n                System.out.println(\"INF\");\n            else\n                System.out.println(dist[i]);\n        }\n        return;\n    }\n\n\n    private static class DijkstraClass {\n        class edge{\n            int dest, cost;\n            edge(int dest, int cost){\n                this.dest = dest;\n                this.cost = cost;\n            }\n        }\n\n        private final int INF = 1 << 30;\n        private int S;\n        private int V;\n        private ArrayList<ArrayList<edge>> edgesOfNodes = new ArrayList<ArrayList<edge>>();\n\n        DijkstraClass(int V, int E, int Start){\n            this.S = Start;\n            this.V = V;\n            for (int i = 0; i < V; i++)\n                edgesOfNodes.add(new ArrayList<edge>());\n        }\n\n        void addDistande(int source, int dest, int cost){\n            edgesOfNodes.get(source).add(new edge(dest, cost));\n        }\n\n\n        int[] dikstra(){\n            class costAndNode implements Comparable {\n                int cost, node;\n                costAndNode(int cost, int node){\n                    this.cost = cost;\n                    this.node = node;\n                }\n                @Override\n                public int compareTo(Object o) {\n                    return this.cost - ((costAndNode) o).cost;\n                }\n            }\n\n            PriorityQueue<costAndNode> pque = new PriorityQueue<costAndNode>();\n            int[] distances = new int[V];\n            for (int i = 0; i < V; i++)\n                distances[i] = INF;\n            distances[S] = 0;\n\n            pque.add(new costAndNode(0, S));\n            while (!pque.isEmpty()){\n                costAndNode item = pque.poll();\n                if (distances[item.node] < item.cost)\n                    continue;\n\n                //System.out.printf(\"Focusing on Node %d\\n\", item.node);\n                //for (int i = 0; i < V; i++)\n                //    System.out.printf(\"%d \", distances[i]);\n                //System.out.println();\n\n                for (edge e : edgesOfNodes.get(item.node)) {\n                    //System.out.printf(\"Node %d -> %d, Cost %d -> %d\\n\",\n                    //        item.node, e.dest, distances[e.dest],\n                    //        distances[item.node] + e.cost);\n                    if (distances[e.dest] > distances[item.node] + e.cost) {\n                        distances[e.dest] = distances[item.node] + e.cost;\n                        pque.add(new costAndNode(distances[e.dest], e.dest));\n                    }\n                }\n            }\n\n            return distances;\n        }\n\n    }\n}", "code2": "class PriorityQueue\n  def initialize es = [], &block\n    block = proc { |a, b| a < b } unless block_given?\n    @fun = block\n    @tree = []\n    @n = 0\n\n    es.each do |e| enqueue e end\n  end\n\n  def enqueue e\n    @tree[@n] = e\n    i = @n\n    @n += 1\n    until i.zero?\n      j = (i-1)/2\n      if @fun.(@tree[i], @tree[j])\n        @tree[i], @tree[j] = @tree[j], @tree[i]\n        i = j\n      else\n        break\n      end\n    end\n    self\n  end\n\n  alias push enqueue\n  alias << enqueue\n  alias insert enqueue\n\n  def dequeue\n    return nil if @n.zero?\n    @n -= 1\n    @tree.first.tap do\n      @tree[0] = @tree.pop\n      i = 0\n      loop do\n        l = i*2+1\n        r = i*2+2\n        break if @tree[l].nil?\n        j =\n          if @tree[r].nil?\n            l\n          else\n            @fun.(@tree[r], @tree[l]) ? r : l\n          end\n        if @fun.(@tree[j], @tree[i])\n          @tree[i], @tree[j] = @tree[j], @tree[i]\n          i = j\n        else\n          break\n        end\n      end\n    end\n  end\n\n  alias pop dequeue\n  alias remove dequeue\n\n  def peek\n    @tree.first\n  end\n\n  alias first peek\n  alias top peek\n\n  def to_a\n    [].tap do |arr|\n      while e = dequeue\n        arr << e\n      end\n    end\n  end\n\n  def empty?\n    @n == 0\n  end\nend\n\nv, e, r = gets.split.map(&:to_i)\ng = Array.new(v) { [] }\ne.times do\n  s, t, d = gets.split.map(&:to_i)\n  g[s] << [t, d]\nend\n\narr = Array.new(v) { Float::INFINITY }\narr[r] = 0\n\npq = PriorityQueue.new([[r, 0]]) { |(_, a), (_, b)| a < b }\nwhile h = pq.pop\n  i, d1 = h\n  g[i].each do |j, d2|\n    next if arr[j] <= d1+d2\n    arr[j] =d1+d2\n    pq.push [j, d1+d2]\n  end\nend\n\nputs arr.map { |i| i == Float::INFINITY ? \"INF\" : i }\n", "label": 1, "name1": "s575620429.java", "name2": "s636190295.rb"}, {"id": 671, "code1": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n\n        char[] s = sc.next().toCharArray();\n        char[] t = sc.next().toCharArray();\n\n        boolean isAns = false;\n        for (int i = s.length-1; i >= t.length-1; i--) {\n            char[] tmp = s.clone();\n            isAns = true;\n            for (int j = 0; j < t.length; j++) {\n                if (s[i-j] == t[t.length-1-j] || s[i-j] == '?') {\n                    tmp[i-j] = t[t.length-1-j];\n                } else {\n                    isAns = false;\n                    break;\n                }\n            }\n\n            if (isAns) {\n                s = tmp;\n                break;\n            }\n        }\n\n        if (isAns) {\n            for (char c : s)\n                System.out.print(c == '?' ? 'a' : c);\n        } else {\n            System.out.println(\"UNRESTORABLE\");\n        }\n    }\n\n    static class MyScanner {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in), 1 << 15);\n        StringTokenizer tokenizer;\n\n        String next() {\n            try {\n                while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                }\n            } catch (IOException ignored) {\n            }\n            return tokenizer.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}", "code2": "while input = gets\n  n, x = input.split.map(&:to_i)\n  count = 0\n\n  if n == 0 && x == 0\n    exit\n  else\n\n    for roop1 in 1 .. n\n      for roop2 in roop1 + 1 .. n\n        for roop3 in roop2 + 1 .. n\n\n          if (roop1 + roop2 + roop3) == x\n            count += 1\n          end\n\n        end\n      end\n    end\n\n  end\n\n  puts count\nend", "label": 0, "name1": "s842757542.java", "name2": "s333259857.rb"}, {"id": 136, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint[] abc = new int[3];\n\t\tArrays.setAll(abc, i -> sc.nextInt());\n\t\tArrays.sort(abc);\n\t\t\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tint dif = abc[2] - abc[i];\n\t\t\tint quo = dif / 2;\n\t\t\tcnt += quo;\n\t\t\tabc[i] += 2 * quo;\n\t\t}\n\t\t\n\t\tArrays.sort(abc);\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tabc[2 - i] -= abc[0];\n\t\t}\n\t\t\n\t\tfor (int i : abc) {\n\t\t\tcnt += i;\n\t\t}\n\t\t\n\t\tSystem.out.println(cnt);\n\t}\t\n}\n", "code2": "#!/usr/bin/env ruby\n\nrequire 'set'\n\nclass Hash\n  def push(key, value)\n    self[key] = [] if self[key] == nil\n    self[key].push(value)\n  end\nend\n\nclass Array\n  def lower_bound(value)\n    left = -1;\n    right = self.length;\n    while left + 1 < right\n      mid = left + (right - left) / 2;\n      if self[mid] >= value\n        right = mid\n      else\n        left = mid\n      end\n    end\n    right\n  end\n\n  def unique\n    res = [self.first]\n    each_cons(2) do |a, b|\n      if a != b\n        res.push(b)\n      end\n    end\n    res\n  end\nend\n\ndef get_ints\n  gets.chomp.split.map(&:to_i)\nend\n\ndef get_ints_minus_one\n  get_ints.map { |x| x - 1 }\nend\n\ndef get_int\n  gets.chomp.to_i\nend\n\nA, B, C = get_ints\n\nsum = A + B + C\nstock = [A, B, C].max * 3\n\nwaru = (stock - sum)/2\namari = (stock - sum) % 2\n\nputs waru + (amari == 1 ? 2 : 0)\n", "label": 1, "name1": "s839188761.java", "name2": "s046246097.rb"}, {"id": 556, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tblood_groups();\n\t}\n\n\tprivate static void blood_groups() {\n\t\tint[] bg = new int[4];\n\n\t\twhile (sc.hasNext()) {\n\t\t\tString[] datas = sc.nextLine().split(\",\");\n\n\t\t\tswitch( datas[1] ) {\n\t\t\tcase \"A\":\n\t\t\t\tbg[0]++;\n\t\t\t\tbreak;\n\t\t\tcase \"B\":\n\t\t\t\tbg[1]++;\n\t\t\t\tbreak;\n\t\t\tcase \"AB\":\n\t\t\t\tbg[2]++;\n\t\t\t\tbreak;\n\t\t\tcase \"O\":\n\t\t\t\tbg[3]++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(bg[0]);\n\t\tSystem.out.println(bg[1]);\n\t\tSystem.out.println(bg[2]);\n\t\tSystem.out.println(bg[3]);\n\n\t}\n\n}\n\n", "code2": "N, K = gets.chomp.split(\" \").map(&:to_i)\n\ns, m = N.divmod(K)\nputs [N, m, (m-K).abs].min\n", "label": 0, "name1": "s776356865.java", "name2": "s201038310.rb"}, {"id": 911, "code1": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n\tvoid solve() {\n\t\tint r = in.nextInt(), c = in.nextInt();\n\t\tint[] cnt = new int[26];\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tfor (char ch : in.nextToken().toCharArray()){ \n\t\t\t\tcnt[ch - 'a']++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt4 = (r / 2) * (c / 2);\n\t\tint cnt2 = (r / 2) * (c % 2) + (c / 2) * (r % 2);\n\t\tint cnt1 = (r % 2) * (c % 2);\n\t\t\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\twhile (cnt[i] >= 4 && cnt4 > 0) {\n\t\t\t\tcnt[i] -= 4;\n\t\t\t\tcnt4--;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\twhile (cnt[i] >= 2 && cnt2 > 0) {\n\t\t\t\tcnt[i] -= 2;\n\t\t\t\tcnt2--;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\twhile (cnt[i] >= 1 && cnt1 > 0) {\n\t\t\t\tcnt[i] -= 1;\n\t\t\t\tcnt1--;\n\t\t\t}\n\t\t}\n\t\tout.println((cnt1 == 0 && cnt2 == 0 && cnt4 == 0) ? \"Yes\" : \"No\");\n\t}\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tvoid run() {\n\t\tin = new FastScanner();\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(s));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic String nextToken() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n", "code2": "$N = gets.chomp.to_i\n\ns = []\n$N.times do\n  s << gets.chomp.to_i\nend\n\ndef max(a, b)\n  a < b ? b : a\nend\n\n# s = s.sort\nsum = s.reduce(:+)\n\n$table = Array.new(sum + 1, 0)\n\ndef point(n)\n  n % 10 == 0 ? 0 : n\nend\n\ndef max_a(arr)\n  res = -10_000_000_000_000_000_000\n  arr.each do |i|\n    res = i < res ? res : i\n  end\n  res\nend\n\n$N.times do |i|\n  (0...sum).each do |j|\n    current = sum - j\n    $table[current] = if s[i] <= current\n                        max($table[current], $table[current - s[i]] + s[i])\n                      else\n                        $table[current]\n                      end\n  end\nend\nputs max_a($table.map { |t| point(t) })\n", "label": 0, "name1": "s917006414.java", "name2": "s204912293.rb"}, {"id": 219, "code1": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        Main main = new Main();\n        main.solve();\n    }\n\n    public void solve() {\n        Scanner scan = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n        int N = scan.nextInt();\n        List<Integer> candidate = new ArrayList<>();\n        for (int i = 1; i <= N; i++) {\n            candidate.add(i);\n        }\n        scan.nextLine();\n        String p = scan.nextLine();\n        String q = scan.nextLine();\n        List<List<Integer>> list = make(candidate);\n        List<String> strings = new ArrayList();\n        for (List<Integer> x : list) {\n            strings.add(x.stream().map(i -> i.toString()).collect(Collectors.joining(\" \")));\n        }\n        int len = strings.size();\n        int l = 0;\n        int r = 0;\n        for (int i = 0; i < len; i++) {\n            if (p.equals(strings.get(i))) {\n                l = i;\n            }\n            if (q.equals(strings.get(i))) {\n                r = i;\n            }\n        }\n        System.out.println(Math.abs(l - r));\n    }\n\n    public static List<List<Integer>> make(List<Integer> candidate) {\n        if (candidate.size() == 0) {\n            List<List<Integer>> empty = new ArrayList<>();\n            empty.add(new ArrayList<>());\n            return empty;\n        }\n\n        return candidate.stream().flatMap(i -> {\n            List<Integer> rest = new ArrayList<>(candidate);\n            rest.remove(i);\n            return make(rest).stream().map(list -> {\n                list.add(0, i);\n                return list;\n            });\n        }).collect(Collectors.toList());\n    }\n}\n", "code2": "def solve(n, p, q)\n  perms = [ *1..n ].permutation(n)\n  a = perms.find_index { |perm| perm == p }\n  b = perms.find_index { |perm| perm == q }\n  (a - b).abs\nend\n\nn = gets.chomp.to_i\np = gets.chomp.split.map(&:to_i)\nq = gets.chomp.split.map(&:to_i)\n\nputs solve(n, p, q)\n", "label": 1, "name1": "s162956680.java", "name2": "s527873790.rb"}, {"id": 127, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        int count = Integer.valueOf(reader.readLine());\n        String s = reader.readLine();\n\n        long[][] dp = new long[count][count];\n        dp[0][0] = 1;\n        long modulo = 1_000_000_007;\n\n        for (int i = 1; i < count; ++i) {\n            if (s.charAt(i - 1) == '<') {\n                dp[i][0] = 0;\n                for (int j = 1; j <= i; ++j) {\n                    dp[i][j] = dp[i][j - 1] + dp[i - 1][j - 1];\n                    dp[i][j] %= modulo;\n                }\n            } else {\n                dp[i][i] = 0;\n                for (int j = i - 1; j >= 0; --j) {\n                    dp[i][j] = dp[i][j + 1] + dp[i - 1][j];\n                    dp[i][j] %= modulo;\n                }\n            }\n        }\n\n        long res = 0;\n        for (int i = 0; i < count; ++i) {\n            res += dp[count - 1][i];\n            res %= modulo;\n        }\n        System.out.println(res);\n    }\n}\n", "code2": "d=*1..gets.to_i;\ngets.chop.bytes{|c|\n\tx=0;n=d.pop;\n\td.map!{|a|x=(x+n*c[1]+(1-c%3)*a).%10**9+7}\n}\np *d", "label": 1, "name1": "s833810272.java", "name2": "s587396214.rb"}, {"id": 767, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String args[]){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tInteger[] num = new Integer[n];\n\t\tStringBuilder s = new StringBuilder(\"\");\n\t\tfor(int i=0;i<n;i++){\n\t\t\tnum[i] = scan.nextInt();\n\t\t}\n\t\tArrays.sort(num);\n\t\t\n\t\ts.append(num[0]);\n\t\tfor(int i=1;i<num.length;i++){\n\t\t\ts.append(\" \"+num[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(s);\n\t}\n}", "code2": "N = gets.to_i\nT = readlines.map(&:to_i)\nputs T.inject {|r,t| r.lcm(t) }", "label": 0, "name1": "s177932526.java", "name2": "s946977011.rb"}, {"id": 968, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n        }\n        int[] b = new int[n];\n        for (int i = 0; i < n; i++) {\n            b[i] = sc.nextInt();\n        }\n        int[] c = new int[n];\n        for (int i = 0; i < n; i++) {\n            c[i] = sc.nextInt();\n        }\n        Arrays.sort(a);\n        Arrays.sort(b);\n        Arrays.sort(c);\n        System.out.println(solve(a, b, c));\n    }\n\n    private static long solve(int[] a, int[] b, int[] c) {\n        int n = a.length;\n        long[] bmemo = new long[n];\n        int cidx = 0;\n        for (int j = 0; j < n; j++) {\n            for (int k = cidx; k < n; k++) {\n                if (b[j] >= c[k]) {\n                    cidx++;\n                } else {\n                    bmemo[j] = n - k;\n                    break;\n                }\n            }\n        }\n        for (int i = n - 2; i >= 0; i--) {\n            bmemo[i] += bmemo[i + 1];\n        }\n        long sum = 0;\n        int bidx = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = bidx; j < n; j++) {\n                if (a[i] >= b[j]) {\n                    bidx++;\n                } else {\n                    sum += bmemo[j];\n                    break;\n                }\n            }\n        }\n        return sum;\n    }\n}\n", "code2": "n, a, b = gets.split.map(&:to_i)\nh = n.times.map {gets.to_i}.sort_by{|e| -e}\n\nl = 1\nr = (h[0] + b - 1) / b\n\nwhile l != r\n    m = (l + r) / 2\n\n    t = 0\n    h.each do |e|\n        break if e <= b * m\n        t += (e - m * b + a - b - 1) / (a - b)\n        break if t > m\n    end\n\n    if t > m\n        l = m + 1\n    else\n        r = m\n    end\nend\n\np l", "label": 0, "name1": "s244653324.java", "name2": "s034006177.rb"}, {"id": 327, "code1": "import java.util.Scanner;\n\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    // \u6574\u6570\u306e\u5165\u529b\n    int a = sc.nextInt();\n    // \u30b9\u30da\u30fc\u30b9\u533a\u5207\u308a\u306e\u6574\u6570\u306e\u5165\u529b\n    int b = sc.nextInt();\n    int c = sc.nextInt();\n\n//    int ab = a + b;\n//    int bc = b + c;\n//    int ac = a+c;\n//\n//    int result = Math.min(ab, Math.min(bc , ac));\n\n    int max = Math.max(a, Math.max(b, c));\n\n    System.out.println(a + b + c - max);\n  }\n}\n", "code2": "# coding: utf-8\nlines = $stdin.read\narray = lines.split(\"\\n\")\n\na = array[0].split(\" \")[0].to_i\nb = array[0].split(\" \")[1].to_i\nc = array[0].split(\" \")[2].to_i\n\nab = a+b\nbc = b+c\nca = c+a\n\narr = [ab, bc, ca].sort\n\nputs arr[0]\n", "label": 1, "name1": "s393158982.java", "name2": "s342762132.rb"}, {"id": 795, "code1": "import java.util.*;\nclass Main\n{\n    static long mod = 1000000007;\n    public static void main (String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long[] a = new long[n];\n        for(int i = 0; i < n; i++){\n            a[i] = sc.nextLong();\n        }\n        long[] b = new long[n+1];\n        b[0] = 0;\n        for(int i = 1; i <= n; i++){\n            b[i] = (b[i-1] + pow(i, mod - 2)) % mod;\n        }\n        long ans = 0;\n        for(int i = 0; i < n; i++){\n            ans += a[i] * (b[i+1] + b[n - i] - 1);\n            ans %= mod;\n        }\n        for(int i = 1; i <= n; i++){\n            ans *= i;\n            ans %= mod;\n        }\n        System.out.println(ans);\n    }\n    static long pow(long a, long p){\n        if(p == 0) return 1;\n        else if(p % 2 == 0){\n            long d = pow(a, p/2);\n            return d * d % mod;\n        }\n        else return pow(a, p-1) * a % mod;\n    }\n}", "code2": "#!ruby -apl\n$F[0]<?1&&exit\n$_=Time.gm(4,*$F).strftime\"%A\"", "label": 0, "name1": "s041637006.java", "name2": "s452040833.rb"}, {"id": 26, "code1": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map.Entry;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nclass Main {\n    static final int MOD = 1000000007;\n    static final int INF = 1 << 30;\n\n    Main() {\n        Scanner sc = new Scanner(System.in);\n        long ans = 0;\n        long H = sc.nextLong();\n        long W = sc.nextLong();\n        if(H==1 || W==1){\n        System.out.println(1);\n        return;\n        }\n        long ht = H/2+H%2;\n        long hd = H/2;\n        long wt = W/2+W%2;\n        long wd = W/2;\n        ans += ht*wt;\n        ans += hd*wd;\n        System.out.println(ans);\n    }\n\n    public static void main(String[] args) {\n        new Main();\n    }\n}\n ", "code2": "h, w = gets.split.map(&:to_i)\nif h == 1 || w == 1\n  puts 1\nelse\n  puts (h * w + 1) / 2\nend\n", "label": 1, "name1": "s490391243.java", "name2": "s043512520.rb"}, {"id": 819, "code1": "\n\nimport java.util.*;\nimport java.io.*;\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t\n\tScanner sc=new Scanner(System.in);\n\t     int n=sc.nextInt();\n\t     int m=sc.nextInt();\n\t     ArrayList<ArrayList<Integer>> a=new ArrayList<>();\nfor(int i=0;i<n;i++) {\n\ta.add(new ArrayList<Integer>());\n}\nfor(int j=0;j<m;j++) {\n\tint x=sc.nextInt()-1;\n\tint y=sc.nextInt()-1;\n\ta.get(x).add(y);\n\ta.get(y).add(x);\n}\nboolean vis[]=new boolean[n];\nans=0;\n\tSystem.out.println(dfs(a,0,vis,1,n));\n\t}\nstatic int ans=0;\t\n\tstatic int dfs(ArrayList<ArrayList<Integer>> a,int src,boolean vis[],int count,int n) {\n\t\tvis[src]=true;\n\t\tfor(int i:a.get(src)) {\n\t\t\tif(vis[i]==false) {\n\t\t\t\t\n\t\t\t\tdfs(a,i,vis,count+1,n);\n\t\t\t}\n\t\t}\n\t\tif(count==n) {\n\t\tans++;\n\t\tvis[src]=false;\n\t\t\t}else {\n\t\t\t\tvis[src]=false;\n\t\t\t}\n\t\t\n\t\treturn ans;\n\t}\n\tstatic int[] arr(int n,Scanner sc) {\n\t\tint a[]=new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i]=sc.nextInt();\n\t\t}\n\t\treturn a;\n}\n\n}\n", "code2": "a = gets.split.map(&:to_i)\nputs a.uniq.size == 2 ? \"Yes\" : \"No\"\n", "label": 0, "name1": "s658101216.java", "name2": "s479750293.rb"}, {"id": 778, "code1": "import java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n    static void solve() {\n        int n = nextInt();\n\n        long ans = nextLong();\n//        System.out.println(ans);\n        for (int i = 1; i < n; i++) {\n            long t = nextLong();\n            ans = lcm(ans, t);\n//            System.out.println(ans);\n        }\n        out.println(ans);\n    }\n\n    static final int MOD = 1_000_000_007;\n    static long[] fac, finv, inv;\n\n    // nCk\u306e\u521d\u671f\u5316\n    static void comInit(int max) {\n        fac = new long[max];\n        finv = new long[max];\n        inv = new long[max];\n        fac[0] = fac[1] = 1;\n        finv[0] = finv[1] = 1;\n        inv[1] = 1;\n\n        for (int i = 2; i < max; i++) {\n            fac[i] = fac[i - 1] * i % MOD;\n            inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n            finv[i] = finv[i - 1] * inv[i] % MOD;\n        }\n    }\n\n    // nCk\u306e\u8a08\u7b97\n    static long com(int n, int k) {\n        if (n < k)\n            return 0;\n        if (n < 0 || k < 0)\n            return 0;\n        return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n    }\n\n    static PrintWriter out;\n    static Scanner sc;\n\n    static int[][] newIntArray(int h, int w, int value) {\n        int[][] ret = new int[h][w];\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                ret[i][j] = value;\n            }\n        }\n        return ret;\n    }\n\n    static int nextInt() {\n        return Integer.parseInt(sc.next());\n    }\n\n    static long nextLong() {\n        return Long.parseLong(sc.next());\n    }\n\n    static String nextString() {\n        return sc.next();\n    }\n\n    static int[] nextIntArray(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = nextInt();\n        }\n        return a;\n    }\n\n    static List<Integer> nextIntList(int n) {\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add(nextInt());\n        }\n        return list;\n    }\n\n    static List<Double> nextDoubleList(int n) {\n        List<Double> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add((double) nextInt());\n        }\n        return list;\n    }\n\n    static List<Long> nextLongList(int n) {\n        List<Long> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add(nextLong());\n        }\n        return list;\n    }\n\n    static char[][] nextCharArray(int h, int w) {\n        char[][] c = new char[h][w];\n        for (int i = 0; i < h; i++) {\n            String str = nextString();\n            for (int j = 0; j < w; j++) {\n                c[i][j] = str.charAt(j);\n            }\n        }\n        return c;\n    }\n\n    static <T extends Comparable<? super T>> void sort(List<T> list) {\n        Collections.sort(list);\n    }\n\n    // greatest common divisor\n    // \u6700\u5927\u516c\u7d04\u6570\n    static long gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    // least common multiple\n    // \u6700\u5c0f\u516c\u500d\u6570\n    static long lcm(long a, long b) {\n        if (a >= b && a % b == 0)\n            return a;\n        if (b > a && b % a == 0)\n            return b;\n\n//        return a * b / gcd(a, b);\n        if (a > b) {\n            return (a / gcd(a, b)) * b;\n        } else {\n            return (b / gcd(a, b)) * a;\n        }\n    }\n\n    // base\u306en\u4e57\u3092\u8a08\u7b97\u3092\u8fd4\u3059\n    static int pow(int base, int n) {\n        int ret = 1;\n        for (int i = 0; i < n; i++) {\n            ret *= base;\n        }\n        return ret;\n    }\n\n    // return n^k mod m\n    static long powMod(long n, long k, long m) {\n        if (k == 0) {\n            return 1;\n        } else if (k % 2 == 1) {\n            return powMod(n, k - 1, m) * n % m;\n        } else {\n            long tmp = powMod(n, k / 2, m);\n            return tmp * tmp % m;\n        }\n    }\n\n    // int\u3092length\u6841\u306ebit\u6587\u5b57\u5217\u306b\u5909\u63db\n    static String toBitString(int length, int n) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = length - 1; i >= 0; i--) {\n            if ((n >> i) % 2 == 1) {\n                sb.append(\"1\");\n            } else {\n                sb.append(\"0\");\n            }\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        out = new PrintWriter(System.out);\n        sc = new Scanner(System.in);\n\n        solve();\n\n        out.flush();\n        sc.close();\n    }\n\n}\n", "code2": "def find(x, root)\n  return unless @group[x]\n  return true if @group[x].include?(root)\n  @group[x].each do |m|\n    return true if find(m, root)\n  end\n  false\nend\n\nwhile n = gets.to_i\n  break if n == 0\n  root = ''\n  @group = {}\n  n.times do |i|\n    g, m = gets.split(':')\n    root = g if i == 0\n    ms = m[0..-3].split(',')\n    ms.each{ |m| @group[m] ||= []; @group[m] << g }\n  end\n  cnt = 0\n  @group.keys.each do |name|\n    if find(name, root) && !@group.values.flatten.include?(name)\n      cnt += 1\n    end\n  end\n  p cnt\nend", "label": 0, "name1": "s078472493.java", "name2": "s172002341.rb"}, {"id": 608, "code1": "import java.util.Scanner;\nimport java.util.Stack;\n\nclass Main{\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tString str=sc.next();\n\t\t\tStack<Integer> st=new Stack<Integer>();\n\t\t\tfor(int i=0;i<str.length();i++){\n\t\t\t\tif(st.isEmpty() || st.peek()==1 || str.charAt(i)=='S') st.add(str.charAt(i)=='S' ? 0 : 1);\n\t\t\t\telse st.pop();\n\t\t\t}\n\t\t\tSystem.out.println(st.size());\n\t\t}\n\t}\n}", "code2": "$x=0\n$y=0\n$bord = []\n\nloop{\n\tline = gets\n\tif line==nil then\n\t\tbreak\n\tend\n\tsp = line.split(nil)\n\t\n\tif sp.count() != 2 then\n\t\tbreak\n\telse\n\t\t$x = sp[0].to_i()\n\t\t$y = sp[1].to_i()\n\t\tif $x == 0 and $y == 0 then\n\t\t\tbreak\n\t\tend\n\t\t$bord = Array.new($y).map{Array.new($x,0)}\n\t\tmax = 0\n\t\tfor i in 0..$y-1\n\t\t\tline = gets\n\t\t\tleft = 0\n\t\t\tfor j in 0..$x-1\n\t\t\t\ttmp = 0\n\t\t\t\tif line[j] =~ /\\d/ then\n\t\t\t\t\ttmp = line[j].to_i() \n\t\t\t\t\tif i > 0 then\n\t\t\t\t\t\tup = $bord[i-1][j]\n\t\t\t\t\telse\n\t\t\t\t\t\tup = 0\n\t\t\t\t\tend\n\n\t\t\t\t\tif up > left then\n\t\t\t\t\t\ttmp += up * 10\t\t\t\t\t\n\t\t\t\t\telse\n\t\t\t\t\t\ttmp += left * 10\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\t\tif tmp > max then\n\t\t\t\t\t\tmax = tmp\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t$bord[i][j] = tmp\n\t\t\t\tleft = tmp\n\t\t\tend\n\t\tend\n\t\tprint max\n\t\tprint(\"\\n\")\n\tend\n}", "label": 0, "name1": "s831441158.java", "name2": "s391567402.rb"}, {"id": 631, "code1": "import java.util.*;\nimport java.io.*;\n\n\nclass Main {\n\n    public static void main(String[] args) throws IOException\n    {\n        PrintWriter out = new PrintWriter(System.out);\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        int n = Integer.parseInt(br.readLine());\n        Long arr[] = new Long[n];\n        StringTokenizer st1 = new StringTokenizer(br.readLine());\n        for(int i = 0 ; i < n ; i++)\n        {\n            arr[i] = Long.parseLong(st1.nextToken());\n        }\n        Arrays.sort(arr);\n        long sum = arr[n-1];\n        int ind = n-2;\n        for(int i = 0 ; i < n-2 ; i++)\n        {\n            sum += arr[ind];\n\n            if(i%2 != 0)\n                ind--;\n        }\n        out.println(sum);\n\n        out.flush();\n        out.close();\n\n    }\n\n    static class pair{\n        long x1;\n        long x2;\n\n        public pair(long x1 , long x2)\n        {\n            this.x1 = x1;\n            this.x2 = x2;\n        }\n\n    }\n\n}\n", "code2": "N = gets.to_i\nTs = Array.new(N)\nAs = Array.new(N)\nN.times do |i|\n  Ts[i], As[i] = gets.split.map(&:to_i)\nend\n\ntz = az = 1\nN.times do |i|\n  tk = (tz + Ts[i] - 1) / Ts[i]\n  ak = (az + As[i] - 1) / As[i]\n  k = [tk, ak].max\n  tz = Ts[i] * k\n  az = As[i] * k\nend\n\nputs tz + az\n", "label": 0, "name1": "s590431029.java", "name2": "s973322062.rb"}, {"id": 220, "code1": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        Main main = new Main();\n        main.solve();\n    }\n\n    public void solve() {\n        Scanner scan = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n        int N = scan.nextInt();\n        List<Integer> candidate = new ArrayList<>();\n        for (int i = 1; i <= N; i++) {\n            candidate.add(i);\n        }\n        scan.nextLine();\n        String p = scan.nextLine();\n        String q = scan.nextLine();\n        List<List<Integer>> list = make(candidate);\n        List<String> strings = new ArrayList();\n        for (List<Integer> x : list) {\n            strings.add(x.stream().map(i -> i.toString()).collect(Collectors.joining(\" \")));\n        }\n        int len = strings.size();\n        int l = 0;\n        int r = 0;\n        for (int i = 0; i < len; i++) {\n            if (p.equals(strings.get(i))) {\n                l = i;\n            }\n            if (q.equals(strings.get(i))) {\n                r = i;\n            }\n        }\n        System.out.println(Math.abs(l - r));\n    }\n\n    public static List<List<Integer>> make(List<Integer> candidate) {\n        if (candidate.size() == 0) {\n            List<List<Integer>> empty = new ArrayList<>();\n            empty.add(new ArrayList<>());\n            return empty;\n        }\n\n        return candidate.stream().flatMap(i -> {\n            List<Integer> rest = new ArrayList<>(candidate);\n            rest.remove(i);\n            return make(rest).stream().map(list -> {\n                list.add(0, i);\n                return list;\n            });\n        }).collect(Collectors.toList());\n    }\n}\n", "code2": "n = gets.to_i\nps = gets.split(\" \").map(&:to_i)\nq = gets.split(\" \").map(&:to_i)\n\npermu = []\n(1..n).each do |i|\n    permu.push(i)\n    i += 1\nend\n\nflag_p = 0\nflag_q = 0\ncount = 0\n\npermu.permutation(n) do |a|\n    current_permu = a\n    if current_permu == ps\n        flag_p = count\n    end\n    if current_permu == q\n        flag_q = count\n    end\n    count = count + 1\nend\n\nputs (flag_p - flag_q).abs", "label": 1, "name1": "s162956680.java", "name2": "s303474561.rb"}, {"id": 588, "code1": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable {\n\tFastReader scn;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\n\tvoid solve() {\n\t\tint n = scn.nextInt(), mod = (int) 1e9 + 7;\n\t\tchar[] cmp = scn.next().toCharArray();\n\t\t\n\t\tint[][] dp = new int[n + 1][n + 1];\n\t\tdp[1][1] = 1;\n\t\t\n\t\tfor(int len = 2; len <= n; len++) {\n\t\t\tint[] pref = new int[n + 1];\n\t\t\tfor(int i = 1; i <= n; i++) {\n\t\t\t\tpref[i] = (pref[i - 1] + dp[len - 1][i]) % mod;\n\t\t\t}\n\t\t\tfor(int curr = 1; curr <= len; curr++) {\n\t\t\t\tint L, R;\n\t\t\t\tif(cmp[len - 2] == '<') {\n\t\t\t\t\tL = 1;\n\t\t\t\t\tR = curr - 1;\n\t\t\t\t} else {\n\t\t\t\t\tL = curr;\n\t\t\t\t\tR = n;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(L <= R) {\n\t\t\t\t\tdp[len][curr] += (pref[R] - pref[L - 1]);\n\t\t\t\t\tif(dp[len][curr] >= mod) {\n\t\t\t\t\t\tdp[len][curr] -= mod;\n\t\t\t\t\t} else if(dp[len][curr] < 0) {\n\t\t\t\t\t\tdp[len][curr] += mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor(int curr = 1; curr <= n; curr++) {\n\t\t\tans += dp[n][curr];\n\t\t\tif(ans >= mod) {\n\t\t\t\tans -= mod;\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t}\n\n\tpublic void run() {\n\t\tlong time = System.currentTimeMillis();\n\t\tboolean oj = true;\n\t\tout = new PrintWriter(System.out);\n\t\tscn = new FastReader(oj);\n\t\tsolve();\n\t\tout.flush();\n\t\tif (!oj) {\n\t\t\tSystem.out.println(Arrays.deepToString(new Object[] { System.currentTimeMillis() - time + \" ms\" }));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"Main\", 1 << 26).start();\n\t}\n\n\tclass FastReader {\n\t\tInputStream is;\n\n\t\tpublic FastReader(boolean onlineJudge) {\n\t\t\tis = onlineJudge ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\t}\n\n\t\tpublic FastReader() {\n\t\t\tis = System.in;\n\t\t}\n\n\t\tbyte[] inbuf = new byte[1024];\n\t\tpublic int lenbuf = 0, ptrbuf = 0;\n\n\t\tint readByte() {\n\t\t\tif (lenbuf == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (ptrbuf >= lenbuf) {\n\t\t\t\tptrbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn inbuf[ptrbuf++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tint skip() {\n\t\t\tint b;\n\t\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t\t;\n\t\t\treturn b;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tchar nextChar() {\n\t\t\treturn (char) skip();\n\t\t}\n\n\t\tString next() {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile ((!isSpaceChar(b) || b == ' ')) { // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tchar[] next(int n) {\n\t\t\tchar[] buf = new char[n];\n\t\t\tint b = skip(), p = 0;\n\t\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t\t}\n\n\t\tint nextInt() {\n\t\t\tint num = 0, b;\n\t\t\tboolean minus = false;\n\t\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\tlong num = 0;\n\t\t\tint b;\n\t\t\tboolean minus = false;\n\t\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tchar[][] nextMatrix(int n, int m) {\n\t\t\tchar[][] map = new char[n][];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next(m);\n\t\t\treturn map;\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tint[][] IndIntArray(int n) {\n\t\t\tint[][] a = new int[n][];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = new int[] { nextInt(), i };\n\t\t\treturn a;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tint[][] next2DInt(int n, int m) {\n\t\t\tint[][] arr = new int[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[][] next2DLong(int n, int m) {\n\t\t\tlong[][] arr = new long[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextLongArray(m);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] shuffle(int[] arr) {\n\t\t\tRandom r = new Random();\n\t\t\tfor (int i = 1, j; i < arr.length; i++) {\n\t\t\t\tj = r.nextInt(i);\n\t\t\t\tint c = arr[i];\n\t\t\t\tarr[i] = arr[j];\n\t\t\t\tarr[j] = c;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] shuffle(long[] arr) {\n\t\t\tRandom r = new Random();\n\t\t\tfor (int i = 1, j; i < arr.length; i++) {\n\t\t\t\tj = r.nextInt(i);\n\t\t\t\tlong c = arr[i];\n\t\t\t\tarr[i] = arr[j];\n\t\t\t\tarr[j] = c;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] uniq(int[] arr) {\n\t\t\tarr = scn.shuffle(arr);\n\t\t\tArrays.sort(arr);\n\t\t\tint[] rv = new int[arr.length];\n\t\t\tint pos = 0;\n\t\t\trv[pos++] = arr[0];\n\t\t\tfor (int i = 1; i < arr.length; i++) {\n\t\t\t\tif (arr[i] != arr[i - 1]) {\n\t\t\t\t\trv[pos++] = arr[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Arrays.copyOf(rv, pos);\n\t\t}\n\n\t\tlong[] uniq(long[] arr) {\n\t\t\tarr = scn.shuffle(arr);\n\t\t\tArrays.sort(arr);\n\t\t\tlong[] rv = new long[arr.length];\n\t\t\tint pos = 0;\n\t\t\trv[pos++] = arr[0];\n\t\t\tfor (int i = 1; i < arr.length; i++) {\n\t\t\t\tif (arr[i] != arr[i - 1]) {\n\t\t\t\t\trv[pos++] = arr[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Arrays.copyOf(rv, pos);\n\t\t}\n\n\t\tint[] reverse(int[] arr) {\n\t\t\tint l = 0, r = arr.length - 1;\n\t\t\twhile (l < r) {\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tarr[r] = arr[l] ^ arr[r];\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tl++;\n\t\t\t\tr--;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] reverse(long[] arr) {\n\t\t\tint l = 0, r = arr.length - 1;\n\t\t\twhile (l < r) {\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tarr[r] = arr[l] ^ arr[r];\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tl++;\n\t\t\t\tr--;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] compress(int[] arr) {\n\t\t\tint n = arr.length;\n\t\t\tint[] rv = Arrays.copyOf(arr, n);\n\t\t\trv = uniq(rv);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = Arrays.binarySearch(rv, arr[i]);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] compress(long[] arr) {\n\t\t\tint n = arr.length;\n\t\t\tlong[] rv = Arrays.copyOf(arr, n);\n\t\t\trv = uniq(rv);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = Arrays.binarySearch(rv, arr[i]);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\t}\n}", "code2": "require 'prime'\nwhile n = gets.to_i\n  break if n == 0\n  p Prime.each.lazy.take_while{ |p| p <= 2 * n }.drop_while{ |p| p <= n }.to_a.size\nend", "label": 0, "name1": "s976963924.java", "name2": "s057981665.rb"}, {"id": 451, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\t\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tString[] days={\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\"};\n\t\twhile(sc.hasNextInt()){\n\t\t\tint month=sc.nextInt();\n\t\t\tint day=sc.nextInt();\n\t\t\tint a=modd(month);\n\t\t\tint b=a+day;\n\t\t\tif(month==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif((b-1)%7==0){\n\t\t\t\tSystem.out.println(days[0]);\n\t\t}else if((b-1)%7==1){\n\t\t\tSystem.out.println(days[1]);\n\t\t}else if((b-1)%7==2){\n\t\t\tSystem.out.println(days[2]);\n\t\t}else if((b-1)%7==3){\n\t\t\tSystem.out.println(days[3]);\n\t\t}else if((b-1)%7==4){\n\t\t\tSystem.out.println(days[4]);\n\t\t}else if((b-1)%7==5){\n\t\t\tSystem.out.println(days[5]);\n\t\t}else if((b-1)%7==6){\n\t\t\tSystem.out.println(days[6]);\n\t\t}\n\t}\n\n\t}\n\tpublic static int modd(int month){\n\t\tint[] months={31,29,31,30,31,30,31,31,30,31,30,31};\n\t\tint a=0;\n\t\tfor(int i=0; i<=month-2; i++){\n\t\t\ta+=months[i];\n\t\t}\n\n\t\treturn a;\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n}", "code2": "require \"date\"\narr = Array.new\nuntil (line = gets) == \"0 0\\n\"\n  arr << line\nend\narr.each do |i|\n  a = i.split(\" \")\n  a.map!{|j| j.to_i}\n  m = a[0]\n  d = a[1]\n  wday = [\"Sunday\",\n          \"Monday\",\n          \"Tuesday\",\n          \"Wednesday\",\n          \"Thursday\",\n          \"Friday\",\n          \"Saturday\"]\n  day = Date::new(2004, m, d)\n  puts wday[day.wday]\nend", "label": 1, "name1": "s331323698.java", "name2": "s152498090.rb"}, {"id": 975, "code1": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int A = sc.nextInt();\n        int B = sc.nextInt();\n        int [] h = new int [N];\n        for(int i=0; i<N; i++){\n            h[i] = sc.nextInt();\n        }\n        Arrays.sort(h);\n        long min = 0;\n        long max = 1000000000;\n        long mid = 0;\n        while(max-min>1){\n            mid = max-(max-min)/2;\n            if(judge(mid,h,N,B,A-B)){\n                max = mid;\n            }else{\n                min = mid;\n            }\n        }\n        if(!judge(mid,h,N,B,A-B))mid++;\n        System.out.println(mid);\n    }\n    static boolean judge(long mid, int[]h, int N, int B, double C){\n        long Z=0;\n        for(int i=N-1; i>=0; i--){\n            long tmp = h[i]-mid*B;\n            if(tmp>0){\n                Z+=((long)(Math.ceil(tmp/C)));\n            }else{\n                break;\n            }\n        }\n        if(Z>mid)return false;\n        return true;\n    }\n}\n", "code2": "N = 1000000\n\nsieve = Array.new(N + 1, 0)\n2.upto(Math.sqrt(N).to_i) do |i|\n  next if sieve[i].nonzero?\n  2.upto(N / i) {|j| sieve[i * j] = 1}\nend\n\nnum = (2..N).select {|i| sieve[i].zero?}\n\nuntil (n = $<.gets.to_i).zero?\n  co = 0\n  num.each do |a|\n    b = n - a\n    break if a > b\n    co += 1 if sieve[b].zero?\n  end\n  puts co\nend\n", "label": 0, "name1": "s057072996.java", "name2": "s789375060.rb"}, {"id": 674, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint A = sc.nextInt();\n\t\tint B = sc.nextInt();\n\t\tint C = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tint res = 0;\n\t\tres+=Math.min(A, K);\n\t\tK -= res;\n\t\tif(K==0) {\n\t\t\tSystem.out.println(res);\n\t\t\tSystem.exit(0);\n\t\t}\n\t\tK-=B;\n\t\tif(K>0) {\n\t\t\tres-=Math.min(K, C);\n\t\t}\n\t\tSystem.out.println(res);\n\n\t}\n}", "code2": "while input = gets\n  n, x = input.split.map(&:to_i)\n  count = 0\n\n  if n == 0 && x == 0\n    exit\n  else\n\n    for roop1 in 1 .. n\n      for roop2 in roop1 + 1 .. n\n        for roop3 in roop2 + 1 .. n\n\n          if (roop1 + roop2 + roop3) == x\n            count += 1\n          end\n\n        end\n      end\n    end\n\n  end\n\n  puts count\nend", "label": 0, "name1": "s649759516.java", "name2": "s333259857.rb"}, {"id": 666, "code1": "import java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.util.Scanner;\n\npublic class Main{\n\tstatic Scanner sc;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t//InputStream in = new FileInputStream(\"src/input.txt\");\n\t\tInputStream in = System.in;\n\t\t//PrintStream out = new PrintStream(\"src/output.txt\");\n\n\t\t//System.setOut(out);\n\n\t\tsc = new Scanner(in);\n\n\t\tint N = sc.nextInt();\n\t\tint[] a = new int[N];\n\t\tint answer = 0;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(a[a[i]-1] == i+1){\n\t\t\t\tanswer++;\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(answer/2);\n\n\t\t//out.close();\n\t}\n}", "code2": "a, b, c, k = gets.split.map &:to_i\nans = 0\n[a, b, c].zip([1, 0, -1]).each do |n, cost|\n\tm = [n, k].min\n\tk -= m\n\tans += cost * m\nend\nputs ans\n", "label": 0, "name1": "s219137444.java", "name2": "s146217788.rb"}, {"id": 637, "code1": "\nimport static java.lang.Math.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic int modP = 1000000007;\n\n\tstatic class TaskX {\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tint n = in.nextInt();\n\t\t\tlong[] t = in.nextLongArray(n), a = in.nextLongArray(n);\n\n\t\t\tlong[] tCalc = new long[n];\n\t\t\tArrays.fill(tCalc, -1);\n\n\t\t\tlong[] aCalc = new long[n];\n\t\t\tArrays.fill(aCalc, -1);\n\n\t\t\tlong[] tDef = new long[n];\n\t\t\tlong[] aDef = new long[n];\n\n\t\t\tlong tMax = -1, aMax = -1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (tMax < t[i]) {\n\t\t\t\t\ttMax = t[i];\n\t\t\t\t\ttDef[i] = t[i];\n\t\t\t\t} else {\n\t\t\t\t\ttCalc[i] = tMax;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = n-1; i >= 0; i--) {\n\t\t\t\tif (aMax < a[i]) {\n\t\t\t\t\taMax = a[i];\n\t\t\t\t\taDef[i] = a[i];\n\t\t\t\t} else {\n\t\t\t\t\taCalc[i] = aMax;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (aCalc[i] == -1 && tCalc[i] == -1) {\n\t\t\t\t\tif (aDef[i] != tDef[i]) {\n\t\t\t\t\t\tout.println(0);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else if (aCalc[i] == -1) {\n\t\t\t\t\tif (aDef[i] > tCalc[i]) {\n\t\t\t\t\t\tout.println(0);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else if (tCalc[i] == -1) {\n\t\t\t\t\tif (tDef[i] > aCalc[i]) {\n\t\t\t\t\t\tout.println(0);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong ans = 1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (tCalc[i] == -1 || aCalc[i] == -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tans = ans * min(aCalc[i],tCalc[i]) % modP;\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\n\t}\n\n}\n", "code2": "def solve(n, p, q)\n  perms = [ *1..n ].permutation(n)\n  a = perms.find_index { |perm| perm == p }\n  b = perms.find_index { |perm| perm == q }\n  (a - b).abs\nend\n\nn = gets.chomp.to_i\np = gets.chomp.split.map(&:to_i)\nq = gets.chomp.split.map(&:to_i)\n\nputs solve(n, p, q)\n", "label": 0, "name1": "s083135979.java", "name2": "s527873790.rb"}, {"id": 603, "code1": "/**\n * Created at 16:38 on 2019-08-27\n */\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n  static FastScanner sc = new FastScanner();\n  static Output out = new Output(System.out);\n\n  static final int[] dx = {0, 1, 0, -1};\n  static final int[] dy = {-1, 0, 1, 0};\n\n  static final long MOD = (long) (1e9 + 7);\n  static final long INF = Long.MAX_VALUE / 2;\n\n  public static class Solver {\n    public Solver() {\n\n      int Q = sc.nextInt();\n\n      for (int q=0; q<Q; q++) {\n        long A = sc.nextLong();\n        long B = sc.nextLong();\n        long P = A * B;\n\n        long sqrt = sqrt(P-1);\n\n        long ans = 2*sqrt;\n\n        if (Math.min(A, B) <= sqrt) ans--; //\u9ad8\u6a4b\u541b\u3068\u540c\u3058\u9806\u4f4d\u306b\u306a\u3063\u3066\u3044\u308b\u3082\u306e\u3092\u9664\u304f\n        if (sqrt * (sqrt+1) > P-1) ans--; //\u30c0\u30d6\u30eb\u30ab\u30a6\u30f3\u30c8\u3057\u3066\u3044\u308b\u3082\u306e\u3092\u9664\u304f(x == y \u306e\u3068\u304d)\n\n        out.println(ans);\n      }\n\n\n    }\n\n    long sqrt(long n) {\n      long res = (long)Math.floor(Math.sqrt(n));\n      while (res * res > n) res--;\n      while ((res+1) * (res+1) <= n) res++;\n      return res;\n    }\n\n  }\n\n  public static void main(String[] args) {\n    new Solver();\n    out.flush();\n  }\n\n  static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int N, boolean oneBased) {\n      if (oneBased) {\n        int[] array = new int[N + 1];\n        for (int i = 1; i <= N; i++) {\n          array[i] = sc.nextInt();\n        }\n        return array;\n      } else {\n        int[] array = new int[N];\n        for (int i = 0; i < N; i++) {\n          array[i] = sc.nextInt();\n        }\n        return array;\n      }\n    }\n\n    public long[] nextLongArray(int N, boolean oneBased) {\n      if (oneBased) {\n        long[] array = new long[N + 1];\n        for (int i = 1; i <= N; i++) {\n          array[i] = sc.nextLong();\n        }\n        return array;\n      } else {\n        long[] array = new long[N];\n        for (int i = 0; i < N; i++) {\n          array[i] = sc.nextLong();\n        }\n        return array;\n      }\n    }\n  }\n\n  static class Output extends PrintWriter {\n\n    public Output(PrintStream ps) {\n      super(ps);\n    }\n\n    public void print(int[] a, String separator) {\n      for (int i = 0; i < a.length; i++) {\n        if (i == 0) print(a[i]);\n        else print(separator + a[i]);\n      }\n      println();\n    }\n\n    public void print(long[] a, String separator) {\n      for (int i = 0; i < a.length; i++) {\n        if (i == 0) print(a[i]);\n        else print(separator + a[i]);\n      }\n      println();\n    }\n\n    public void print(String[] a, String separator) {\n      for (int i = 0; i < a.length; i++) {\n        if (i == 0) print(a[i]);\n        else print(separator + a[i]);\n      }\n      println();\n    }\n\n    public void print(ArrayList a, String separator) {\n      for (int i = 0; i < a.size(); i++) {\n        if (i == 0) print(a.get(i));\n        else print(separator + a.get(i));\n      }\n      println();\n    }\n  }\n\n}\n", "code2": "X = gets.chomp\n\np 2*X.each_char.inject(0){|acc, c|\n\t[acc + (c.ord&2) - 1, 0].max\n}\n", "label": 0, "name1": "s001351994.java", "name2": "s636939727.rb"}, {"id": 371, "code1": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\tboolean eof;\n\t\n\tlong go(long a, long b, long c) {\n\t\tif (a < 0 || b < 0 || c < 0) {\n\t\t\treturn Long.MIN_VALUE;\n\t\t}\n\t\t\n\t\treturn a + b + c - (a & 1) - (b & 1) - (c & 1);\n\t}\n\n\tvoid solve() throws IOException {\n\t\tlong i = nextLong();\n\t\tlong o = nextLong();\n\t\tlong t = nextLong();\n\t\tlong j = nextLong();\n\t\tlong l = nextLong();\n\t\tlong s = nextLong();\n\t\tlong z = nextLong();\n\t\t\n\t\tlong ans = o + Math.max(go(i, j, l), go(i - 1, j - 1, l - 1) + 3);\n\t\t\n\t\tout.println(ans);\n\t}\n\n\tMain() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e) {\n\t\t\t\teof = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\teof = true;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}", "code2": "a = gets.split.map(&:to_i)\nans = a[1]\nif (a[0]%2)+(a[3]%2)+(a[4]%2) >= 2 && [a[0], a[3], a[4]].min > 0\n  ans += 3\n  a[0] -= 1\n  a[3] -= 1\n  a[4] -= 1\nend\n\nans += (a[0] / 2) * 2\nans += (a[3] / 2) * 2\nans += (a[4] / 2) * 2\n\nputs ans", "label": 1, "name1": "s508741257.java", "name2": "s995460361.rb"}, {"id": 431, "code1": "import java.util.*;\n\npublic class Main {\n\tpublic static HashMap<String,HashSet<String>> map;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tmap = new HashMap<String, HashSet<String>>();\n\t\t\tString first = null;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tString[] s = sc.next().split(\":\");\n\t\t\t\tif(i == 0) first = s[0];\n\t\t\t\ts[1] = s[1].replaceAll(\"\\\\.\", \"\");\n\t\t\t\tString[] ss = s[1].split(\",\");\n\t\t\t\tmap.put(s[0], new HashSet<String>());\n\t\t\t\tfor(String tmp : ss){\n\t\t\t\t\tmap.get(s[0]).add(tmp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(String si : map.keySet()){\n\t\t\t\tfor(String sj : map.keySet()){\n\t\t\t\t\tif(map.get(si).contains(sj)){\n\t\t\t\t\t\tmap.get(si).remove(sj);\n\t\t\t\t\t\tmap.get(si).addAll(map.get(sj));\n\t\t\t\t\t}\n\t\t\t\t\tif(map.get(sj).contains(si)){\n\t\t\t\t\t\tmap.get(sj).remove(si);\n\t\t\t\t\t\tmap.get(sj).addAll(map.get(si));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(map.get(first).size());\n\t\t}\n\t}\n/*\n\tpublic static HashSet<String> solve(String group){\n\t\tfor(String s : map.get(group)){\n\n\t\t}\n\n\t}\n\t*/\n}", "code2": "module Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\treturn dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nclass Digraph < Graph\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.out_edges << e\n\t\tv.in_edges << e\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.out_edges.delete(e)\n\t\tv.in_edges.delete(e)\n\t\te\n\tend\n\n\tclass Node < Graph::Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@out_edges = Set.new\n\t\t\t@in_edges = Set.new\n\t\tend\n\n\t\tdef add_out_edge(e)\n\t\t\t@out_edges << e\n\t\tend\n\n\t\tdef del_out_edge(e)\n\t\t\t@out_edges.delete(e)\n\t\tend\n\n\t\tdef add_in_edge(e)\n\t\t\t@in_edges << e\n\t\tend\n\n\t\tdef del_in_edge(e)\n\t\t\t@in_edges.delete(e)\n\t\tend\n\n\t\tattr_reader :in_edges, :out_edges\n\tend\n\n\tclass Edge < Graph::Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\t\t@property = property\n\t\tend\n\n\t\tattr_reader :from, :to\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.out_edges.each{|e|\n\t\t\tyield [e.to, e.length]\n\t\t}\n\tend\n\n\tdef each_in_connection_of(v)\n\t\tv.in_edges.each{|e|\n\t\t\tyield [e.from, e.length]\n\t\t}\n\tend\n\n#----------------------------------------------------------\n\n\tdef get_path_bfs(s, t)\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\tu.outgoings.each{|e|\n\t\t\t\tv = e.to\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tpath_edge[v] = e\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = []\n\t\t\t\t\twhile e = path_edge[v]\n\t\t\t\t\t\tpath.unshift e\n\t\t\t\t\t\tv = e.from\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_dfs(s, t, reached = Set.new)\n\t\treached << s\t\n\t\ts.outgoings.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\treturn [e] if v == t\n\t\t\t\n\t\t\tpath = get_path_dfs(v, t, reached) \n\t\t\treturn [e] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef layers_from(start)\n\t\treached = Set[*start]\n\t\tlayers = [start]\n\n\t\tloop {\n\t\t\tlayers << []\n\t\t\tlayers[-2].each{|u|\n\t\t\t\tu.to_nodes.each{|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tlayers[-1] << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\tif layers[-1].empty?\n\t\t\t\tlayers.pop\n\t\t\t\treturn layers\n\t\t\tend\n\t\t}\n\tend\nend\n\nloop {\n\tn = gets.to_i\n\tbreak if n == 0\n\t\n\tg = Digraph.new\n\n\tnodes = {}\n\tg_names = []\n\tn.times {\n\t\tname, *members = gets.chomp.split(/[:,.]/)\n\t\tg_names << name\n\t\tu = (nodes[name] ||= g.add_node)\n\t\tmembers.each{|m|\n\t\t\tv = (nodes[m] ||= g.add_node)\n\t\t\tg.add_edge(u, v)\n\t\t}\n\t}\n\n\tg_names.each{|name| nodes[name].property[:group] = true}\n\n\tdef count(s, reached)\n\t\treturn 0 if reached.include?(s)\n\t\treached << s\n\t\tif s.out_edges.empty?\n\t\t\ts.property[:group] ? 0 : 1\n\t\telse\n\t\t\ts.out_edges.map{|e|\n\t\t\t\tcount(e.to, reached)\n\t\t\t}.inject(0, :+)\n\t\tend\n\tend\n\n\tp count(nodes.to_a[0][1], Set.new)\n}", "label": 1, "name1": "s038642140.java", "name2": "s453301666.rb"}, {"id": 559, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tblood_groups();\n\t}\n\n\tprivate static void blood_groups() {\n\t\tint[] bg = new int[4];\n\n\t\twhile (sc.hasNext()) {\n\t\t\tString[] datas = sc.nextLine().split(\",\");\n\n\t\t\tswitch( datas[1] ) {\n\t\t\tcase \"A\":\n\t\t\t\tbg[0]++;\n\t\t\t\tbreak;\n\t\t\tcase \"B\":\n\t\t\t\tbg[1]++;\n\t\t\t\tbreak;\n\t\t\tcase \"AB\":\n\t\t\t\tbg[2]++;\n\t\t\t\tbreak;\n\t\t\tcase \"O\":\n\t\t\t\tbg[3]++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(bg[0]);\n\t\tSystem.out.println(bg[1]);\n\t\tSystem.out.println(bg[2]);\n\t\tSystem.out.println(bg[3]);\n\n\t}\n\n}\n\n", "code2": "a,b,c = gets.chomp.split.map(&:to_f)\n\ns = (a * b * Math.sin(c * Math::PI / 180)) * 0.5\nl = (a + b) + (a*a + b*b - 2*a*b*Math.cos(c * Math::PI / 180)) ** 0.5\nh = b * Math.sin(c * Math::PI / 180)\n\nputs s\nputs l\nputs h", "label": 0, "name1": "s776356865.java", "name2": "s128364594.rb"}, {"id": 303, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyScanner in = new MyScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        C solver = new C();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class C {\n        int N;\n        int M;\n\n        public void solve(int testNumber, MyScanner in, PrintWriter out) {\n            N = in.Int();\n            M = in.Int();\n            DSU dsu = new DSU(N);\n            for (int i = 0; i < M; i++) {\n                int A = in.Int() - 1;\n                int B = in.Int() - 1;\n                dsu.merge(A, B);\n            }\n            out.println(dsu.groups().size() - 1);\n        }\n\n    }\n\n    static class DSU {\n        private int n;\n        private int[] parentOrSize;\n\n        public DSU(int n) {\n            this.n = n;\n            this.parentOrSize = new int[n];\n            Arrays.fill(parentOrSize, -1);\n        }\n\n        int merge(int a, int b) {\n            if (!(0 <= a && a < n))\n                throw new IndexOutOfBoundsException(\"a=\" + a);\n            if (!(0 <= b && b < n))\n                throw new IndexOutOfBoundsException(\"b=\" + b);\n\n            int x = leader(a);\n            int y = leader(b);\n            if (x == y) return x;\n            if (-parentOrSize[x] < -parentOrSize[y]) {\n                int tmp = x;\n                x = y;\n                y = tmp;\n            }\n            parentOrSize[x] += parentOrSize[y];\n            parentOrSize[y] = x;\n            return x;\n        }\n\n        int leader(int a) {\n            if (parentOrSize[a] < 0) {\n                return a;\n            } else {\n                parentOrSize[a] = leader(parentOrSize[a]);\n                return parentOrSize[a];\n            }\n        }\n\n        ArrayList<ArrayList<Integer>> groups() {\n            int[] leaderBuf = new int[n];\n            int[] groupSize = new int[n];\n            for (int i = 0; i < n; i++) {\n                leaderBuf[i] = leader(i);\n                groupSize[leaderBuf[i]]++;\n            }\n            ArrayList<ArrayList<Integer>> result = new ArrayList<>(n);\n            for (int i = 0; i < n; i++) {\n                result.add(new ArrayList<>(groupSize[i]));\n            }\n            for (int i = 0; i < n; i++) {\n                result.get(leaderBuf[i]).add(i);\n            }\n            result.removeIf(ArrayList::isEmpty);\n            return result;\n        }\n\n    }\n\n    static class MyScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public MyScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    return null;\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int Int() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "code2": "class UnionFind\n\tNode = Struct.new(:p, :h)\n\tdef initialize(size); @p, @r = size.times.to_a, [0]*size; end\n\tdef unite(i, j); k, l = parent(i), parent(j); if @r[k] < @r[l]; @p[k] = l; @r[l] += 1 if @r[k] == @r[l]; else; @p[l] = k; end; end\n\tdef united?(i, j); parent(i) == parent(j); end\n\tdef parent(i); j = i; until i == @p[i]; j, i = i, @p[j] = @p[i]; end; i; end\nend\n\nn, m = gets.split.map &:to_i\nuf = UnionFind.new n\nm.times do\n  a, b = gets.split.map &:to_i\n  uf.unite(a-1, b-1)\nend\n\nrequire \"set\"\ns = Set.new\nn.times do |i|\n  s << uf.parent(i)\nend\n\np s.size-1", "label": 1, "name1": "s578903603.java", "name2": "s827373738.rb"}, {"id": 838, "code1": "import java.util.Scanner;\n\npublic class Main {\n    static int selectSort(int[] data) {\n        int ret = 0, n = data.length;\n        for (int i = 0; i < n; ++i) {\n            int minJ = i;\n            for (int j = i; j < n; ++j) {\n                if (data[j] < data[minJ]) minJ = j;\n            }\n            if(minJ != i) {\n                ++ret;\n                int tmp = data[minJ];\n                data[minJ] = data[i];\n                data[i] = tmp;\n            }\n        }\n        return ret;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int n = scanner.nextInt();\n        int[] data = new int[n];\n\n        for (int i = 0; i < n; ++i) {\n            data[i] = scanner.nextInt();\n        }\n\n        int cnt = selectSort(data);\n        for (int i = 0; i < n; ++i) {\n            System.out.print(data[i]);\n            if (i != n - 1) System.out.print(\" \");\n        }\n        System.out.println();\n        System.out.println(cnt);\n    }\n}\n", "code2": "n,l,t = gets.split.map(&:to_i)\nx = Array.new(n)\nw = Array.new(n)\nn.times do |i|\n    x[i],w[i] = gets.split.map(&:to_i)\nend\nu = 0\na = 0\nn.times do |i|\n    next if w[i] == 2\n    n.times do |j|\n        next if w[j] == 1\n        u += (2*t-(x[j]-x[i])%l+l-1)/l\n    end\n    a = i\n    break\nend\nn.times do |i|\n    x[i] += (w[i] == 1 ? t : -t)\n    x[i] %= l\nend\nb = x[a]\nx.sort!\nm = x.bsearch_index{|num|num >= b}\nn.times do |i|\n    puts x[(m+i-u-a)%n]\nend", "label": 0, "name1": "s945145574.java", "name2": "s700324516.rb"}, {"id": 36, "code1": "import java.util.Scanner;\n \npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            int[] s = new int[n];\n            double e = 0.0, v = 0.0;\n            for (int i = 0; i < n; i++) {\n                s[i] = sc.nextInt();\n                e += s[i];\n                v += s[i] * s[i];\n            }\n            e /= n;\n            v = v / n - e * e;\n            System.out.println(Math.sqrt(v));\n        }\n    }\n}\n", "code2": "until (n = gets.strip.to_i) == 0\n\tpoints = gets.strip.split(\" \").map {|i| i.to_f}\n\tavg = (points.reduce(0.0){|sum, p| sum += p}) / n.to_f\n\tvar = points.reduce(0.0){|sum, p| sum += (p - avg) ** 2} / n.to_f\n\tstd = var ** 0.5\n\tputs std.floor(4)\nend\n", "label": 1, "name1": "s749350396.java", "name2": "s105211939.rb"}, {"id": 672, "code1": "import java.io.File;\nimport java.io.IOException;\nimport java.util.*;\n \npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\t//File file = new File(\"input.txt\");\n\t\t//Scanner in = new Scanner(file);\n\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\t\n\t\tString SS = in.next();\n\t\tString T = in.next();\n\t\t\n\t\tint index = SS.length() - T.length();\n\t\t\n\t\twhile(index >= 0){\n\t\t\tString s = SS.substring(index, index + T.length());\n\t\t\t\n\t\t\tboolean tf = true;\n\t\t\tfor(int i = 0; i < T.length(); i++){\n\t\t\t\tif(s.charAt(i) != '?' && s.charAt(i) != T.charAt(i)){\n\t\t\t\t\ttf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(tf){\n\t\t\t\tSS = new StringBuilder(SS).replace(index, index + s.length(), T).toString();\n\t\t\t\tSS = SS.replace('?', 'a');\n\t\t\t\tSystem.out.println(SS);\n\t\t\t\treturn;\n\t\t\t}else{\n\t\t\t\tindex--;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"UNRESTORABLE\");\n\t}\n}", "code2": "j=0\nwhile true\n   line=gets\n   arr=line.split(\" \")\n   n,x=arr[0].to_i,arr[1].to_i\n\n   if n==0 and x==0\n      break\n   end\n\n   if n >= 3 and n <= 100\n      j=0\n      numbers=Array.new(n)\n      for i in 1..n\n         numbers[i-1]=i\n      end\n   end\n   numbers.combination(3) {|a,b,c| if a+b+c == x\n                                      j+=1\n                                   end}\nprintf(\"%d\\n\",j)\nend", "label": 0, "name1": "s419255365.java", "name2": "s730064206.rb"}, {"id": 743, "code1": "import java.util.Scanner;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tprivate static final int INF = (int)1e9;\n\n\tstatic class Pair {\n\t\tint first;\n\t\tint second;\n\n\t\tpublic Pair(int first, int second) {\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn first + second;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\tif (other instanceof Pair) {\n\t\t\t\tPair p = (Pair)other;\n\n\t\t\t\treturn p.first == first && p.second == second;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner in = new Scanner(System.in)) {\n\t\t\tint n = in.nextInt();\n\t\t\tList<Integer>[] g = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tg[i] = new ArrayList<>();\n\n\t\t\tint m = in.nextInt();\n\t\t\tint r = in.nextInt();\n\t\t\tMap<Pair, Integer> dist = new HashMap<>();\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint f = in.nextInt();\n\t\t\t\tint t = in.nextInt();\n\t\t\t\tint w = in.nextInt();\n\n\t\t\t\tg[f].add(t);\n\t\t\t\tdist.put(new Pair(f, t), w);\n\t\t\t}\n\n\t\t\tdijkstra(g, n, dist, r);\n\t\t} catch (Exception ex) {\n\t\t\tthrow new RuntimeException(ex);\n\t\t}\n\t}\n\n\tpublic static void dijkstra(List<Integer> g[], int n, Map<Pair, Integer> dist, int s) {\n\t\tint[] d = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\td[i] = INF;\n\n\t\td[s] = 0;\n\t\tPriorityQueue<Pair> pq = new PriorityQueue<>((x, y) -> x.second-y.second);\n\t\tpq.add(new Pair(s, 0));\n\n\t\twhile (!pq.isEmpty()) {\n\t\t\tPair p = pq.remove();\n\n\t\t\tfor (int v : g[p.first]) {\n\t\t\t\tint dd = d[p.first] + dist.get(new Pair(p.first, v));\n\t\t\t\tif (dd < d[v]) {\n\t\t\t\t\td[v] = dd;\n\t\t\t\t\tpq.add(new Pair(v, d[v]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (d[i] == INF)\n\t\t\t\tSystem.out.println(\"INF\");\n\t\t\telse\n\t\t\t\tSystem.out.println(d[i]);\n\t\t}\n\t}\n}", "code2": "h,w=gets.split.map &:to_i\nm=$<.map{|e|e.chomp[1..-2]}\n2.times{|i|h.times{|y|s=['#'*(w-2),m[y]][y%2^i];puts [\"##{s}.\",\".#{s}#\"][i]};puts}", "label": 0, "name1": "s004699498.java", "name2": "s463208227.rb"}, {"id": 712, "code1": "\npublic class Main {\n\n  static int mod = 1000003;\n  static int[][] fif = enumFIF(mod * 3, mod);\n\n  private static void solve() {\n    int q = ni();\n\n    for (int i = 0; i < q; i++) {\n      int x = ni();\n      int d = ni();\n      int n = ni();\n      out.println(f(x, d, n));\n    }\n  }\n\n  private static long f(int x, int d, int n) {\n    if (x == 0) {\n      return 0;\n    } else if (d == 0) {\n      return pow(x, n, mod);\n    }\n\n    int y = (int) (x * invl(d, mod) % mod);\n    if (n >= mod || y % mod > (y + n - 1) % mod) {\n      return 0;\n    }\n\n    long z = fif[0][y + n - 1] * invl(fif[0][y - 1], mod) % mod;\n    z *= pow(d, n, mod);\n    z %= mod;\n\n    return z;\n  }\n\n  public static long pow(long a, long n, long mod) {\n    // a %= mod;\n    long ret = 1;\n    int x = 63 - Long.numberOfLeadingZeros(n);\n    for (; x >= 0; x--) {\n      ret = ret * ret % mod;\n      if (n << 63 - x < 0)\n        ret = ret * a % mod;\n    }\n    return ret;\n  }\n\n\n  public static int[][] enumFIF(int n, int mod) {\n    int[] f = new int[n + 1];\n    int[] invf = new int[n + 1];\n    f[0] = 1;\n    for (int i = 1; i <= n; i++) {\n      f[i] = (int) ((long) f[i - 1] * i % mod);\n    }\n    long a = f[n];\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    invf[n] = (int) (p < 0 ? p + mod : p);\n    for (int i = n - 1; i >= 0; i--) {\n      invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n    }\n    return new int[][] {f, invf};\n  }\n\n  public static long invl(long a, long mod) {\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    return p < 0 ? p + mod : p;\n  }\n\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n\n", "code2": "# coding: utf-8\nlines = $stdin.read\narray = lines.split(\"\\n\")\n\na = array[0].split(\" \")[0].to_i\nb = array[0].split(\" \")[1].to_i\nc = array[0].split(\" \")[2].to_i\n\nab = a+b\nbc = b+c\nca = c+a\n\narr = [ab, bc, ca].sort\n\nputs arr[0]\n", "label": 0, "name1": "s606179301.java", "name2": "s342762132.rb"}, {"id": 38, "code1": "import java.util.Scanner;\n \npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            int[] s = new int[n];\n            double e = 0.0, v = 0.0;\n            for (int i = 0; i < n; i++) {\n                s[i] = sc.nextInt();\n                e += s[i];\n                v += s[i] * s[i];\n            }\n            e /= n;\n            v = v / n - e * e;\n            System.out.println(Math.sqrt(v));\n        }\n    }\n}\n", "code2": "res=Array.new\nloop do\nn=gets.to_i\nif n==0 then break end\nd=gets.split(' ').map(&:to_f)\nm=d.inject(0.00000){|r,i|r+=i}/d.size\ns=0\nd.each do |x|\n  s+=(x-m)*(x-m)\nend\nres.push(Math.sqrt(s/n))\nend\n\nres.each do |r|\n    printf(\"%f\\n\",r)\nend", "label": 1, "name1": "s749350396.java", "name2": "s936689019.rb"}, {"id": 4, "code1": "\nimport java.util.Scanner;\n\n/**\n * Created by enpingkuang on 2020/9/10 10:58 \u4e0b\u5348\n */\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String s = scanner.next();\n        long sum = 0;\n        int length = s.length();\n        for(int i = 0;i<length;i++){\n            sum += (s.charAt(i)-'0');\n        }\n        System.out.println(sum % 9==0?\"Yes\":\"No\");\n    }\n}\n", "code2": "n=gets.chomp\nx=0\nn = n.split('')\nn.each do |a|\n  x += a.to_i\nend\n\nputs (x%9==0) ? 'Yes' : 'No'", "label": 1, "name1": "s939687060.java", "name2": "s669617296.rb"}, {"id": 403, "code1": "import java.io.FileNotFoundException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tMaxHeapSort maxheap = new MaxHeapSort(new int[] {});\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tmaxheap.add(a[i]);\n\t\t}\n\t\ta = maxheap.sortedArray();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tSystem.out.print(a[i] + (i == n - 1 ? \"\\n\" : \" \"));\n\t\t}\n\t}\n\n\tclass MaxHeapSort {\n\t\tint n;\n\t\tint[] v;\n\n\t\tpublic MaxHeapSort(int[] v_) {\n\t\t\tif (v_.length > 1_000_000)\n\t\t\t\tthrow new AssertionError();\n\t\t\tv = Arrays.copyOf(v_, 1_000_000);\n\t\t\tn = v_.length;\n\t\t\tfor (int i = n; i >= 0; --i) {\n\t\t\t\tmaxHeapify(i);\n\t\t\t}\n\t\t}\n\n\t\tvoid add(int val) {\n\t\t\tv[n] = val;\n\t\t\tint cur = n;\n\t\t\t++n;\n\t\t\twhile (cur > 0) {\n\t\t\t\tcur = (cur - 1) / 2;\n\t\t\t\tmaxHeapify(cur);\n\t\t\t}\n\t\t}\n\n\t\tint[] sortedArray() {\n\t\t\tint sz = n;\n\t\t\tint[] ret = new int[sz];\n\t\t\tfor (int i = 0; i < sz; ++i) {\n\t\t\t\tret[sz - 1 - i] = poll();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tint poll() {\n\t\t\tint ret = v[0];\n\t\t\tv[0] = v[n - 1];\n\t\t\tv[n - 1] = ret;\n\t\t\t--n;\n\t\t\tmaxHeapify(0);\n\t\t\treturn ret;\n\t\t}\n\n\t\tvoid maxHeapify(int cur) {\n\t\t\tif (2 * cur + 1 >= n)\n\t\t\t\treturn;\n\t\t\tif (v[cur] >= v[2 * cur + 1] && (2 * cur + 2 >= n || v[cur] >= v[2 * cur + 2])) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint dst = -1;\n\t\t\tif (2 * cur + 2 >= n || v[2 * cur + 1] >= v[2 * cur + 2]) {\n\t\t\t\tdst = 2 * cur + 1;\n\t\t\t} else {\n\t\t\t\tdst = 2 * cur + 2;\n\t\t\t}\n\t\t\tint tmp = v[cur];\n\t\t\tv[cur] = v[dst];\n\t\t\tv[dst] = tmp;\n\t\t\tmaxHeapify(dst);\n\t\t}\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}", "code2": "class Array\n  def merge_sort\n    tmp = self.dup\n    return tmp if tmp.length <= 1\n    a, b = self.half.map { |e| e.merge_sort }\n    merge(a, b)\n  end\n\n  def half\n    mid = length/2\n    return slice(0...mid), slice(mid..-1)\n  end\n\n  def merge(a, b)\n    res = []\n    until a.empty? && b.empty?\n      res <<\n          case\n            when a.empty? then b.shift\n            when b.empty? then a.shift\n            when a.first < b.first then a.shift\n            else b.shift\n          end\n    end\n    res\n  end\nend\n\nn = gets.to_i\nputs gets.chomp.split(' ').map(&:to_i).merge_sort.join(' ')", "label": 1, "name1": "s534493670.java", "name2": "s887500587.rb"}, {"id": 243, "code1": "import java.util.*;\n\nclass Main {\n    public static void main(String[] args) {\n        new Solver().run();\n    }\n}\n\nclass Solver {\n\n    public void run() {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int[] a = new int[N];\n\n        for (int i = 0; i < N; i++) {\n            a[i] = sc.nextInt();\n            a[i]--;\n        }\n\n        int cnt = 0;\n        for (int i = 0; i < N; i++) {\n            if (i == a[a[i]]) cnt++;\n        }\n\n        System.out.println(cnt / 2);\n\n        return;\n    }\n\n}", "code2": "n = gets.to_i\na = gets.chomp.split(' ').map(&:to_i)\n\ncnt = 0\n\na.each_with_index do |num,idx|\n    if idx+1 < num\n        if a[num-1] == idx+1\n            cnt+=1\n        end\n    end\nend\n\nputs cnt", "label": 1, "name1": "s246692563.java", "name2": "s867955134.rb"}, {"id": 124, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.IntStream;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMain main = new Main();\n\t\tmain.solve();\n\t}\n\n\tprivate void solve() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tint[] a = new int[N];\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\ta[j] = sc.nextInt();\n\t\t}\n\t\tboolean[] dp = new boolean[K + 1];\n\t\tfor (int i = 0; i <= K; i++) {\n\t\t\tboolean isWin = false;\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (a[j] <= i && !dp[i - a[j]]) {\n\t\t\t\t\tisWin = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i] = isWin;\n\t\t}\n\t\tSystem.out.println(dp[K] ? \"First\" : \"Second\");\n\t}\n\n\tclass Scanner {\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int index;\n\t\tprivate int length;\n\n\t\tpublic Scanner(InputStream in) {\n\t\t\tthis.in = in;\n\t\t}\n\n\t\tprivate boolean isPrintableChar(int c) {\n\t\t\treturn '!' <= c && c <= '~';\n\t\t}\n\n\t\tprivate boolean isDigit(int c) {\n\t\t\treturn '0' <= c && c <= '9';\n\t\t}\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (index < length) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tlength = in.read(buffer);\n\t\t\t\t\tindex = 0;\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\treturn length > 0;\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[index])) {\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\treturn hasNextByte() ? buffer[index++] : -1;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) {\n\t\t\t\tthrow new RuntimeException(\"no input\");\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) {\n\t\t\t\tthrow new RuntimeException(\"no input\");\n\t\t\t}\n\t\t\tlong value = 0L;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tif (isDigit(b)) {\n\t\t\t\t\tvalue = value * 10 + (b - '0');\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn minus ? -value : value;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n\n\tinterface CombCalculator {\n\t\tlong comb(int n, int m);\n\t}\n\n\tinterface MobiusFunction {\n\t\tint get(int n);\n\t}\n\n\t/**\n\t * \u30e1\u30d3\u30a6\u30b9\u95a2\u6570\u3092\u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9\u3063\u307d\u304f\u524d\u8a08\u7b97\u3059\u308b\u30af\u30e9\u30b9\u3067\u3059\u3002\n\t * \u8a08\u7b97\u91cf\u306fO(1)\u3067\u3001\u524d\u8a08\u7b97\u3067O(N logN)\u3067\u3059\u3002\n\t */\n\tclass SieveMobiusFunction implements MobiusFunction {\n\t\tint size;\n\t\tint[] mobiusFunctionValues;\n\n\t\tpublic SieveMobiusFunction(int size) {\n\t\t\tthis.size = size;\n\t\t\tmobiusFunctionValues = new int[size];\n\n\t\t\tmobiusFunctionValues[0] = 0;\n\t\t\tmobiusFunctionValues[1] = 1;\n\t\t\tfor (int i = 2; i < size; i++) {\n\t\t\t\tmobiusFunctionValues[i] = 1;\n\t\t\t}\n\t\t\tfor (int i = 2; i * i < size; i++) {\n\t\t\t\tfor (int k = 1; i * i * k < size; k++) {\n\t\t\t\t\tmobiusFunctionValues[i * i * k] *= 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 2; i < size; i++) {\n\t\t\t\tif (mobiusFunctionValues[i] == 1) {\n\t\t\t\t\tfor (int k = 1; i * k < size; k++) {\n\t\t\t\t\t\tmobiusFunctionValues[i * k] *= -2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mobiusFunctionValues[i] > 1) {\n\t\t\t\t\tmobiusFunctionValues[i] = 1;\n\t\t\t\t}\n\t\t\t\tif (mobiusFunctionValues[i] < -1) {\n\t\t\t\t\tmobiusFunctionValues[i] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int get(int n) {\n\t\t\tif (n > size) {\n\t\t\t\tthrow new RuntimeException(\"n is greater than size.\");\n\t\t\t}\n\t\t\tif (n < 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn mobiusFunctionValues[n];\n\t\t}\n\t}\n\n\t/**\n\t * \u30e1\u30d3\u30a6\u30b9\u95a2\u6570\u3092\u5b9a\u7fa9\u901a\u308a\u8a08\u7b97\u3059\u308b\u30af\u30e9\u30b9\u3067\u3059\u3002\n\t * \u8a08\u7b97\u91cf\u306fO(logN)\u3067\u3059\u3002\n\t */\n\tclass PrimeFactorizationMobiusFunction implements MobiusFunction {\n\t\t@Override\n\t\tpublic int get(int n) {\n\t\t\tif (n <= 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (n == 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tint num = 0;\n\t\t\tfor (int i = 2; i < n; i++) {\n\t\t\t\tif (n % i == 0) {\n\t\t\t\t\tn /= i;\n\t\t\t\t\tnum++;\n\t\t\t\t\tif (n % i == 0) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn num % 2 == 0 ? -1 : 1;\n\t\t}\n\t}\n\n\t/**\n\t * \u7d44\u307f\u5408\u308f\u305b\u8a08\u7b97\u3092\u968e\u4e57\u306e\u5024\u3067\u884c\u3046\u30af\u30e9\u30b9\u3067\u3059(MOD\u5bfe\u5fdc)\n\t * \u968e\u4e57\u3068\u305d\u306e\u9006\u5143\u306f\u524d\u8a08\u7b97\u3057\u3066\u30c6\u30fc\u30d6\u30eb\u306b\u683c\u7d0d\u3057\u307e\u3059\u3002\n\t * C(N, N) % M \u306e\u8a08\u7b97\u91cf\u306f O(1)\u3001 \u524d\u8a08\u7b97\u3067O(max(N, logM))\u3067\u3059\u3002\n\t * size\u30921e8\u3088\u308a\u5927\u304d\u3044\u5024\u3067\u5b9f\u884c\u3059\u308b\u3068MLE\u306e\u5371\u967a\u6027\u304c\u3042\u308a\u307e\u3059\u3002\n\t * \u307e\u305f\u7d20\u6570\u4ee5\u5916\u306eMOD\u306b\u306f\u5bfe\u5fdc\u3057\u3066\u3044\u307e\u305b\u3093(\u9006\u5143\u306e\u8a08\u7b97\u306b\u7d20\u6570\u306e\u5270\u4f59\u74b0\u306e\u6027\u8cea\u3092\u5229\u7528\u3057\u3066\u3044\u308b\u305f\u3081)\u3002\n\t */\n\tclass FactorialTableCombCalculator implements CombCalculator {\n\t\tint size;\n\t\tlong[] factorialTable;\n\t\tlong[] inverseFactorialTable;\n\t\tlong mod;\n\n\t\tpublic FactorialTableCombCalculator(int size, long mod) {\n\t\t\tthis.size = size;\n\t\t\tfactorialTable = new long[size + 1];\n\t\t\tinverseFactorialTable = new long[size + 1];\n\t\t\tthis.mod = mod;\n\n\t\t\tfactorialTable[0] = 1L;\n\t\t\tfor (int i = 1; i <= size; i++) {\n\t\t\t\tfactorialTable[i] = (factorialTable[i - 1] * i) % mod;\n\t\t\t}\n\t\t\tinverseFactorialTable[size] = inverse(factorialTable[size], mod);\n\t\t\tfor (int i = size - 1; i >= 0; i--) {\n\t\t\t\tinverseFactorialTable[i] = (inverseFactorialTable[i + 1] * (i + 1)) % mod;\n\t\t\t}\n\t\t}\n\n\t\tprivate long inverse(long n, long mod) {\n\t\t\treturn pow(n, mod - 2, mod);\n\t\t}\n\n\t\tprivate long pow(long n, long p, long mod) {\n\t\t\tif (p == 0) {\n\t\t\t\treturn 1L;\n\t\t\t}\n\t\t\tlong half = pow(n, p / 2, mod);\n\t\t\tlong ret = (half * half) % mod;\n\t\t\tif (p % 2 == 1) {\n\t\t\t\tret = (ret * n) % mod;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic long comb(int n, int m) {\n\t\t\tif (n > size) {\n\t\t\t\tthrow new RuntimeException(\"n is greater than size.\");\n\t\t\t}\n\t\t\tif (n < 0 || m < 0 || n < m) {\n\t\t\t\treturn 0L;\n\t\t\t}\n\t\t\treturn (((factorialTable[n] * inverseFactorialTable[m]) % mod) * inverseFactorialTable[n - m]) % mod;\n\t\t}\n\t}\n\n\t/**\n\t * \u7d44\u307f\u5408\u308f\u305b\u8a08\u7b97\u3092\u30c6\u30fc\u30d6\u30eb\u3067\u5b9f\u88c5\u3057\u305f\u30af\u30e9\u30b9\u3067\u3059(MOD\u5bfe\u5fdc)\n\t * \u524d\u8a08\u7b97\u3067O(N^2), comb\u306fO(1)\u3067\u5b9f\u884c\u3067\u304d\u307e\u3059\n\t * size\u30922 * 1e4\u3088\u308a\u5927\u304d\u3044\u5024\u3067\u5b9f\u884c\u3059\u308b\u3068MLE\u306e\u5371\u967a\u6027\u304c\u3042\u308a\u307e\u3059\n\t */\n\tclass TableCombCalculator implements CombCalculator {\n\t\tlong[][] table;\n\t\tint size;\n\n\t\tpublic TableCombCalculator(int size, long mod) {\n\t\t\tthis.size = size;\n\t\t\ttable = new long[size + 1][];\n\n\t\t\ttable[0] = new long[1];\n\t\t\ttable[0][0] = 1L;\n\t\t\tfor (int n = 1; n <= size; n++) {\n\t\t\t\ttable[n] = new long[n + 1];\n\t\t\t\ttable[n][0] = 1L;\n\t\t\t\tfor (int m = 1; m < n; m++) {\n\t\t\t\t\ttable[n][m] = (table[n - 1][m - 1] + table[n - 1][m]) % mod;\n\t\t\t\t}\n\t\t\t\ttable[n][n] = 1L;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic long comb(int n, int m) {\n\t\t\tif (n > size) {\n\t\t\t\tthrow new RuntimeException(\"n is greater than size.\");\n\t\t\t}\n\t\t\tif (n < 0 || m < 0 || n < m) {\n\t\t\t\treturn 0L;\n\t\t\t}\n\t\t\treturn table[n][m];\n\t\t}\n\t}\n\n\tinterface Graph {\n\t\tvoid link(int from, int to, long cost);\n\t\tOptional<Long> getCost(int from, int to);\n\t\tint getVertexNum();\n\t}\n\n\tinterface FlowResolver {\n\t\tlong maxFlow(int from, int to);\n\t}\n\n\t/**\n\t * \u30b0\u30e9\u30d5\u306e\u884c\u5217\u306b\u3088\u308b\u5b9f\u88c5\n\t * \u63a5\u70b9\u6570\u306e\u5927\u304d\u3044\u30b0\u30e9\u30d5\u3067\u4f7f\u3046\u3068MLE\u3067\u6b7b\u306b\u305d\u3046\n\t */\n\tclass ArrayGraph implements Graph {\n\t\tprivate Long[][] costArray;\n\t\tprivate int vertexNum;\n\n\t\tpublic ArrayGraph(int n) {\n\t\t\tcostArray = new Long[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tcostArray[i] = new Long[n];\n\t\t\t}\n\t\t\tvertexNum = n;\n\t\t}\n\n\t\t@Override\n\t\tpublic void link(int from, int to, long cost) {\n\t\t\tcostArray[from][to] = new Long(cost);\n\t\t}\n\n\t\t@Override\n\t\tpublic Optional<Long> getCost(int from, int to) {\n\t\t\treturn Optional.ofNullable(costArray[from][to]);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getVertexNum() {\n\t\t\treturn vertexNum;\n\t\t}\n\t}\n\n\t/**\n\t * DFS(\u6df1\u3055\u512a\u5148\u63a2\u7d22)\u306b\u3088\u308b\u5b9f\u88c5\n\t * \u8a08\u7b97\u91cf\u306fO(E*MaxFlow)\u306e\u306f\u305a (E:\u8fba\u306e\u6570, MaxFlow:\u6700\u5927\u30d5\u30ed\u30fc)\n\t */\n\tclass DfsFlowResolver implements FlowResolver {\n\t\tprivate Graph graph;\n\t\tpublic DfsFlowResolver(Graph graph) {\n\t\t\tthis.graph = graph;\n\t\t}\n\n\t\t/**\n\t\t * \u6700\u5927\u30d5\u30ed\u30fc(\u6700\u5c0f\u30ab\u30c3\u30c8)\u3092\u6c42\u3081\u308b\n\t\t * @param from \u59cb\u70b9(source)\u306eID\n\t\t * @param to \u7d42\u70b9(target)\u306eID\n\t\t * @return \u6700\u5927\u30d5\u30ed\u30fc(\u6700\u5c0f\u30ab\u30c3\u30c8)\n\t\t */\n\t\tpublic long maxFlow(int from, int to) {\n\t\t\tlong sum = 0L;\n\t\t\tlong currentFlow;\n\t\t\tdo {\n\t\t\t\tcurrentFlow = flow(from, to, Long.MAX_VALUE / 3, new boolean[graph.getVertexNum()]);\n\t\t\t\tsum += currentFlow;\n\t\t\t} while (currentFlow > 0);\n\t\t\treturn sum;\n\t\t}\n\n\t\t/**\n\t\t * \u30d5\u30ed\u30fc\u306e\u5b9f\u884c \u30b0\u30e9\u30d5\u306e\u66f4\u65b0\u3082\u884c\u3046\n\t\t * @param from \u73fe\u5728\u3044\u308b\u7bc0\u70b9\u306eID\n\t\t * @param to \u7d42\u70b9(target)\u306eID\n\t\t * @param current_flow \u3053\u3053\u307e\u3067\u306e\u6d41\u91cf\n\t\t * @param passed \u65e2\u306b\u901a\u3063\u305f\u7bc0\u70b9\u304b\u5426\u304b\u3092\u683c\u7d0d\u3057\u305f\u914d\u5217\n\t\t * @return \u7d42\u70b9(target)\u306b\u6d41\u3057\u305f\u6d41\u91cf/\u623b\u308a\u306e\u30b0\u30e9\u30d5\u306e\u6d41\u91cf\n\t\t */\n\t\tprivate long flow(int from, int to, long current_flow, boolean[] passed) {\n\t\t\tpassed[from] = true;\n\t\t\tif (from == to) {\n\t\t\t\treturn current_flow;\n\t\t\t}\n\t\t\tfor (int id = 0; id < graph.getVertexNum(); id++) {\n\t\t\t\tif (passed[id]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tOptional<Long> cost = graph.getCost(from, id);\n\t\t\t\tif (cost.orElse(0L) > 0) {\n\t\t\t\t\tlong nextFlow = current_flow < cost.get() ? current_flow : cost.get();\n\t\t\t\t\tlong returnFlow = flow(id, to, nextFlow, passed);\n\t\t\t\t\tif (returnFlow > 0) {\n\t\t\t\t\t\tgraph.link(from, id, cost.get() - returnFlow);\n\t\t\t\t\t\tgraph.link(id, from, graph.getCost(id, from).orElse(0L) + returnFlow);\n\t\t\t\t\t\treturn returnFlow;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0L;\n\t\t}\n\t}\n\n\t/**\n\t * 1-indexed\u306eBIT\u914d\u5217\n\t */\n\tclass BinaryIndexedTree {\n\t\tprivate long[] array;\n\n\t\tpublic BinaryIndexedTree(int size) {\n\t\t\tthis.array = new long[size + 1];\n\t\t}\n\n\t\t/**\n\t\t * \u6307\u5b9a\u3057\u305f\u8981\u7d20\u306b\u5024\u3092\u52a0\u7b97\u3059\u308b\n\t\t * \u8a08\u7b97\u91cf\u306fO(logN)\n\t\t * @param index \u52a0\u7b97\u3059\u308b\u8981\u7d20\u306e\u6dfb\u5b57\n\t\t * @param value \u52a0\u7b97\u3059\u308b\u91cf\n\t\t */\n\t\tpublic void add(int index, long value) {\n\t\t\tfor (int i = index; i < array.length; i += (i & -i)) {\n\t\t\t\tarray[i] += value;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * 1\u301c\u6307\u5b9a\u3057\u305f\u8981\u7d20\u307e\u3067\u306e\u548c\u3092\u53d6\u5f97\u3059\u308b\n\t\t * \u8a08\u7b97\u91cf\u306fO(logN)\n\t\t * @param index \u548c\u306e\u7d42\u7aef\u3068\u306a\u308b\u8981\u7d20\u306e\u6dfb\u5b57\n\t\t * @return 1\u301cindex\u307e\u3067\u306e\u548c\n\t\t */\n\t\tpublic long getSum(int index) {\n\t\t\tlong sum = 0L;\n\t\t\tfor (int i = index; i > 0; i -= (i & -i)) {\n\t\t\t\tsum += array[i];\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\n\t/**\n\t * 1-indexed\u306e2\u6b21\u5143BIT\u914d\u5217\n\t */\n\tclass BinaryIndexedTree2D {\n\t\tprivate long[][] array;\n\n\t\tpublic BinaryIndexedTree2D(int size1, int size2) {\n\t\t\tthis.array = new long[size1 + 1][];\n\t\t\tfor (int i = 1; i <= size1; i++) {\n\t\t\t\tthis.array[i] = new long[size2 + 1];\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * \u6307\u5b9a\u3057\u305f\u8981\u7d20\u306b\u5024\u3092\u52a0\u7b97\u3059\u308b\n\t\t * \u8a08\u7b97\u91cf\u306fO(logN * logN)\n\t\t * @param index1 \u52a0\u7b97\u3059\u308b\u8981\u7d20\u306e1\u6b21\u5143\u76ee\u306e\u6dfb\u5b57\n\t\t * @param index2 \u52a0\u7b97\u3059\u308b\u8981\u7d20\u306e2\u6b21\u5143\u76ee\u306e\u6dfb\u5b57\n\t\t * @param value \u52a0\u7b97\u3059\u308b\u91cf\n\t\t */\n\t\tpublic void add(int index1, int index2, long value) {\n\t\t\tfor (int i1 = index1; i1 < array.length; i1 += (i1 & -i1)) {\n\t\t\t\tfor (int i2 = index2; i2 < array.length; i2 += (i2 & -i2)) {\n\t\t\t\t\tarray[i1][i2] += value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * (1,1)\u301c\u6307\u5b9a\u3057\u305f\u8981\u7d20\u307e\u3067\u306e\u77e9\u5f62\u548c\u3092\u53d6\u5f97\u3059\u308b\n\t\t * \u8a08\u7b97\u91cf\u306fO(logN * logN)\n\t\t * @param index1 \u548c\u306e\u7d42\u7aef\u3068\u306a\u308b\u8981\u7d20\u306e1\u6b21\u5143\u76ee\u306e\u6dfb\u5b57\n\t\t * @param index2 \u548c\u306e\u7d42\u7aef\u3068\u306a\u308b\u8981\u7d20\u306e2\u6b21\u5143\u76ee\u306e\u6dfb\u5b57\n\t\t * @return (1,1)\u301c(index1,index2)\u307e\u3067\u306e\u77e9\u5f62\u548c\n\t\t */\n\t\tpublic long getSum(int index1, int index2) {\n\t\t\tlong sum = 0L;\n\t\t\tfor (int i1 = index1; i1 > 0; i1 -= (i1 & -i1)) {\n\t\t\t\tfor (int i2 = index2; i2 > 0; i2 -= (i2 & -i2)) {\n\t\t\t\t\tsum += array[i1][i2];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\n\tinterface UnionFind {\n\t\tvoid union(int A, int B);\n\t\tboolean judge(int A, int B);\n\t\tSet<Integer> getSet(int id);\n\t}\n\n\t/**\n\t * ArrayUnionFind\u306e\u62e1\u5f35\n\t * MapSet\u3067\u6839\u306e\u6dfb\u5b57\u304b\u3089\u6839\u306b\u3076\u3089\u4e0b\u304c\u308b\u9802\u70b9\u306e\u96c6\u5408\u304c\u53d6\u5f97\u3067\u304d\u308b\u3088\u3046\u306b\u3057\u305f\n\t * getSet\u30e1\u30bd\u30c3\u30c9\u3092O(logN * logN)\u306b\u843d\u3068\u305b\u3066\u3044\u308b\u306f\u305a\n\t * \u305f\u3060\u3057union\u30e1\u30bd\u30c3\u30c9\u306f2\u500d\u306e\u8a08\u7b97\u91cf\u306b\u306a\u3063\u3066\u3044\u308b\u306e\u3067\u6ce8\u610f(\u30aa\u30fc\u30c0\u30fc\u306f\u5909\u308f\u3089\u306a\u3044\u306f\u305a)\n\t */\n\tclass SetUnionFind extends ArrayUnionFind {\n\t\tMap<Integer, Set<Integer>> map;\n\t\tpublic SetUnionFind(int size) {\n\t\t\tsuper(size);\n\t\t\tmap = new HashMap<>();\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tmap.put(i, new HashSet<>());\n\t\t\t\tmap.get(i).add(i);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tprotected void unionTo(int source, int dest) {\n\t\t\tsuper.unionTo(source, dest);\n\t\t\tmap.get(dest).addAll(map.get(source));\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<Integer> getSet(int id) {\n\t\t\treturn map.get(root(id));\n\t\t}\n\t}\n\n\t/**\n\t * \u914d\u5217\u306b\u3088\u308bUnionFind\u306e\u5b9f\u88c5\n\t * getSet\u30e1\u30bd\u30c3\u30c9\u306fO(NlogN)\u306a\u306e\u3067TLE\u306b\u6ce8\u610f\n\t */\n\tclass ArrayUnionFind implements UnionFind {\n\t\tint[] parent;\n\t\tint[] rank;\n\t\tint size;\n\t\tpublic ArrayUnionFind(int size) {\n\t\t\tparent = new int[size];\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tparent[i] = i;\n\t\t\t}\n\t\t\trank = new int[size];\n\t\t\tthis.size = size;\n\t\t}\n\n\t\t@Override\n\t\tpublic void union(int A, int B) {\n\t\t\tint rootA = root(A);\n\t\t\tint rootB = root(B);\n\t\t\tif (rootA != rootB) {\n\t\t\t\tif (rank[rootA] < rank[rootB]) {\n\t\t\t\t\tunionTo(rootA, rootB);\n\t\t\t\t} else {\n\t\t\t\t\tunionTo(rootB, rootA);\n\t\t\t\t\tif (rank[rootA] == rank[rootB]) {\n\t\t\t\t\t\trank[rootA]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprotected void unionTo(int source, int dest) {\n\t\t\tparent[source] = dest;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean judge(int A, int B) {\n\t\t\treturn root(A) == root(B);\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<Integer> getSet(int id) {\n\t\t\tSet<Integer> set = new HashSet<>();\n\t\t\tIntStream.range(0, size).filter(i -> judge(i, id)).forEach(set::add);\n\t\t\treturn set;\n\t\t}\n\n\t\tprotected int root(int id) {\n\t\t\tif (parent[id] == id) {\n\t\t\t\treturn id;\n\t\t\t}\n\t\t\tparent[id] = root(parent[id]);\n\t\t\treturn parent[id];\n\t\t}\n\t}\n\n\t/**\n\t * \u7d20\u6570\u306e\u30e6\u30fc\u30c6\u30a3\u30ea\u30c6\u30a3\n\t */\n\tclass PrimeNumberUtils {\n\t\tboolean[] isPrimeArray;\n\t\tList<Integer> primes;\n\n\t\t/**\n\t\t * \u7d20\u6570\u5224\u5b9a\u306e\u4e0a\u9650\u3068\u306a\u308b\u5024\u3092\u6307\u5b9a\u3057\u3066\u30e6\u30fc\u30c6\u30a3\u30ea\u30c6\u30a3\u3092\u521d\u671f\u5316\n\t\t * @param limit \u7d20\u6570\u5224\u5b9a\u306e\u4e0a\u9650(\u3053\u306e\u5024\u4ee5\u4e0a\u304c\u7d20\u6570\u3067\u3042\u308b\u304b\u5224\u5b9a\u3057\u306a\u3044)\n\t\t */\n\t\tpublic PrimeNumberUtils(int limit) {\n\t\t\tif (limit > 10000000) {\n\t\t\t\tSystem.err.println(\"\u4e0a\u9650\u306e\u5024\u304c\u9ad8\u3059\u304e\u308b\u305f\u3081\u7d20\u6570\u30e6\u30fc\u30c6\u30a3\u30ea\u30c6\u30a3\u306e\u521d\u671f\u5316\u3067TLE\u3059\u308b\u53ef\u80fd\u6027\u304c\u5927\u5909\u9ad8\u3044\u3067\u3059\");\n\t\t\t}\n\t\t\tprimes = new ArrayList<>();\n\t\t\tisPrimeArray = new boolean[limit];\n\t\t\tif (limit > 2) {\n\t\t\t\tprimes.add(2);\n\t\t\t\tisPrimeArray[2] = true;\n\t\t\t}\n\n\t\t\tfor (int i = 3; i < limit; i += 2) {\n\t\t\t\tif (isPrime(i, primes)) {\n\t\t\t\t\tprimes.add(i);\n\t\t\t\t\tisPrimeArray[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic List<Integer> getPrimeNumberList() {\n\t\t\treturn primes;\n\t\t}\n\n\t\tpublic boolean isPrime(int n) {\n\t\t\treturn isPrimeArray[n];\n\t\t}\n\n\t\tprivate boolean isPrime(int n, List<Integer> primes) {\n\t\t\tfor (int prime : primes) {\n\t\t\t\tif (n % prime == 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (prime > Math.sqrt(n)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tinterface BitSet {\n\t\tvoid set(int index, boolean bit);\n\t\tboolean get(int index);\n\t\tvoid shiftRight(int num);\n\t\tvoid shiftLeft(int num);\n\t\tvoid or(BitSet bitset);\n\t\tvoid and(BitSet bitset);\n\t}\n\n\t/**\n\t * Long\u306e\u914d\u5217\u306b\u3088\u308bBitSet\u306e\u5b9f\u88c5\n\t * get/set\u306fO(1)\n\t * shift/or/and\u306fO(size / 64)\n\t */\n\tclass LongBit implements BitSet {\n\t\tlong[] bitArray;\n\n\t\tpublic LongBit(int size) {\n\t\t\tbitArray = new long[((size + 63) / 64)];\n\t\t}\n\n\t\t@Override\n\t\tpublic void set(int index, boolean bit) {\n\t\t\tint segment = index / 64;\n\t\t\tint inIndex = index % 64;\n\t\t\tif (bit) {\n\t\t\t\tbitArray[segment] |= 1L << inIndex;\n\t\t\t} else {\n\t\t\t\tbitArray[segment] &= ~(1L << inIndex);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean get(int index) {\n\t\t\tint segment = index / 64;\n\t\t\tint inIndex = index % 64;\n\t\t\treturn (bitArray[segment] & (1L << inIndex)) != 0L;\n\t\t}\n\n\t\t@Override\n\t\tpublic void shiftRight(int num) {\n\t\t\tint shiftSeg = num / 64;\n\t\t\tint shiftInI = num % 64;\n\t\t\tfor (int segment = 0; segment < bitArray.length; segment++) {\n\t\t\t\tint sourceSeg = segment + shiftSeg;\n\t\t\t\tif (sourceSeg < bitArray.length) {\n\t\t\t\t\tbitArray[segment] = bitArray[sourceSeg] >>> shiftInI;\n\t\t\t\t\tif (shiftInI > 0 && sourceSeg + 1 < bitArray.length) {\n\t\t\t\t\t\tbitArray[segment] |= bitArray[sourceSeg + 1] << (64 - shiftInI);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbitArray[segment] = 0L;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void shiftLeft(int num) {\n\t\t\tint shiftSeg = num / 64;\n\t\t\tint shiftInI = num % 64;\n\t\t\tfor (int segment = bitArray.length - 1; segment >= 0; segment--) {\n\t\t\t\tint sourceSeg = segment - shiftSeg;\n\t\t\t\tif (sourceSeg >= 0) {\n\t\t\t\t\tbitArray[segment] = bitArray[sourceSeg] << shiftInI;\n\t\t\t\t\tif (shiftInI > 0 && sourceSeg > 0) {\n\t\t\t\t\t\tbitArray[segment] |= bitArray[sourceSeg - 1] >>> (64 - shiftInI);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbitArray[segment] = 0L;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic long getLong(int segment) {\n\t\t\treturn bitArray[segment];\n\t\t}\n\n\t\t@Override\n\t\tpublic void or(BitSet bitset) {\n\t\t\tif (!(bitset instanceof LongBit)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int segment = 0; segment < bitArray.length; segment++) {\n\t\t\t\tbitArray[segment] |= ((LongBit)bitset).getLong(segment);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void and(BitSet bitset) {\n\t\t\tif (!(bitset instanceof LongBit)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int segment = 0; segment < bitArray.length; segment++) {\n\t\t\t\tbitArray[segment] &= ((LongBit)bitset).getLong(segment);\n\t\t\t}\n\t\t}\n\t}\n\n}", "code2": "n, k = gets.split.map(&:to_i)\na = gets.split.map(&:to_i)\n\ndp = Array.new(k+1) {[nil, nil]}\n\n(k+1).times do |i|\n    2.times do |player|\n        a.each do |e|\n            break 1 if i < e\n\n            if dp[i-e][player ^ 1] == player\n                dp[i][player] = player\n                break\n            end\n        end or next\n        dp[i][player] = player ^ 1\n    end\nend\n\nputs dp[k][0] == 0 ? \"First\" : \"Second\"", "label": 1, "name1": "s208804589.java", "name2": "s959450124.rb"}, {"id": 114, "code1": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        int c = sc.nextInt();\n\n        int min = Math.min(a, b);\n        int max = Math.max(a, b);\n        \n        boolean ans = false;\n        if (min < c && c < max)\n            ans = true;\n        System.out.println(ans ? \"Yes\" : \"No\");\n    }\n}", "code2": "# frozen_string_literal: true\n\na, b, c = gets.split.map(&:to_i)\n\nif a < c && c < b || b < c && c < a\n  puts :Yes\nelse\n  puts :No\nend", "label": 1, "name1": "s912321420.java", "name2": "s741716266.rb"}, {"id": 446, "code1": "import java.util.*;\nclass Main\n{\n    static long mod = 1000000007;\n    public static void main (String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long[] a = new long[n];\n        for(int i = 0; i < n; i++){\n            a[i] = sc.nextLong();\n        }\n        long[] b = new long[n+1];\n        b[0] = 0;\n        for(int i = 1; i <= n; i++){\n            b[i] = (b[i-1] + pow(i, mod - 2)) % mod;\n        }\n        long ans = 0;\n        for(int i = 0; i < n; i++){\n            ans += a[i] * (b[i+1] + b[n - i] - 1);\n            ans %= mod;\n        }\n        for(int i = 1; i <= n; i++){\n            ans *= i;\n            ans %= mod;\n        }\n        System.out.println(ans);\n    }\n    static long pow(long a, long p){\n        if(p == 0) return 1;\n        else if(p % 2 == 0){\n            long d = pow(a, p/2);\n            return d * d % mod;\n        }\n        else return pow(a, p-1) * a % mod;\n    }\n}", "code2": "class Integer\n  def mod_pow(n, mod)\n    x = self\n    res = 1\n\n    while n > 0\n      res = res * x % mod if n[0] == 1\n      x = x * x % mod\n      n >>= 1\n    end\n\n    res\n  end\n\n  def mod_inverse(mod)\n    mod_pow(mod - 2, mod)\n  end\nend\n\nN = gets.to_i\nA = gets.split.map(&:to_i)\nMOD = 10 ** 9 + 7\n\nRUI = []\n\nk = 1\n\n1.upto(N) do |i|\n  k = k * i % MOD\n\n  if i == 1\n    RUI << i.mod_inverse(MOD)\n  else\n    RUI << RUI.last + i.mod_inverse(MOD)\n  end\nend\n\nans = 0\n\nA.each_with_index do |a, i|\n  r = 0\n\n  r += RUI[i]\n  r += RUI[N - i - 1]\n\n  v = a * k * (r - 1.mod_inverse(MOD))\n\n  ans += v.to_i\n  ans %= MOD\nend\n\nputs ans\n", "label": 1, "name1": "s041637006.java", "name2": "s063449734.rb"}, {"id": 900, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    int n, m;\n\n    public static void main(String args[]) {\n        new Main().run();\n    }\n\n    void run() {\n        FastReader sc = new FastReader();\n        n = sc.nextInt();\n        m = sc.nextInt();\n        solve();\n    }\n\n    void solve() {\n        int ans = n * 100 + 1800 * m;\n        System.out.println(ans * pow(2, m));\n    }\n\n    long pow(long x, int n) {\n        long ans = 1;\n        while (n > 0) {\n            if ((n & 1) == 1) {\n                ans = ans * x;\n            }\n            x = x * x;\n            n >>= 1;\n        }\n        return ans;\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n", "code2": "def main(argv)\n  (h, w) = gets.chomp.split(' ').map(&:to_i)\n  a = [nil] * h\n  h.times{|y| a[y] = gets.chomp }\n\n  counter = [0] * 26\n  h.times{|y| w.times{|x| counter[a[y][x].ord - 'a'.ord] += 1 }}\n\n  x = w / 2\n  y = h / 2\n\n  div4 = 0\n  counter.size.times do |i|\n    div4 += counter[i] / 4\n    counter[i] = counter[i] % 4\n  end\n\n  if div4 < x * y then\n    puts 'No'\n    return\n  end\n\n  div2 = (div4 - (x * y)) * 2\n  counter.size.times do |i|\n    div2 += counter[i] / 2\n    counter[i] = counter[i] % 2\n  end\n\n  flag = true\n  if h % 2 == 0 then\n    if w % 2 == 0 then\n      flag = true\n    else # w % 2 == 1\n      flag = div2 == y\n    end\n  else # h % 2 == 1\n    if w % 2 == 0 then\n      flag = div2 == x\n    else # w % 2 == 1\n      flag = div2 == x + y\n    end\n  end\n  puts (flag ? 'Yes' : 'No')\nend\n\nif self.to_s == 'main' then\n  main(ARGV)\nend", "label": 0, "name1": "s298791552.java", "name2": "s841406733.rb"}, {"id": 897, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    int n, m;\n\n    public static void main(String args[]) {\n        new Main().run();\n    }\n\n    void run() {\n        FastReader sc = new FastReader();\n        n = sc.nextInt();\n        m = sc.nextInt();\n        solve();\n    }\n\n    void solve() {\n        int ans = n * 100 + 1800 * m;\n        System.out.println(ans * pow(2, m));\n    }\n\n    long pow(long x, int n) {\n        long ans = 1;\n        while (n > 0) {\n            if ((n & 1) == 1) {\n                ans = ans * x;\n            }\n            x = x * x;\n            n >>= 1;\n        }\n        return ans;\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n", "code2": "require 'prime'\nn = gets.to_i\n\nuntil n.prime? do\n  n += 1\nend\n\nputs n\n", "label": 0, "name1": "s298791552.java", "name2": "s001969879.rb"}, {"id": 478, "code1": "import java.util.*;\n\npublic class Main {\n\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    int cnt = 0;\n\n    List<Integer>[] lists = new ArrayList[n];\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    void run() {\n\n        for (int i=0; i<n; i++) lists[i] = new ArrayList<>();\n\n        int m = sc.nextInt();\n        for (int i=0; i<m; i++) {\n            int s = sc.nextInt() - 1;\n            int t = sc.nextInt() - 1;\n            lists[s].add(t);\n            lists[t].add(s);\n        }\n\n        dfs(\"\", n);\n\n        System.out.println(cnt);\n\n    }\n\n    void dfs(String s, int n) {\n\n        if (s.length() == n) {\n//            System.out.println(s);\n            if (s.charAt(0) == '0') {\n                boolean check = true;\n                for (int i=0; i<s.length()-1; i++) {\n                    if (!lists[s.charAt(i) - 48].contains(s.charAt(i+1) - 48)) {\n                        check = false;\n                        break;\n                    }\n                }\n                if (check) cnt++;\n            }\n\n        } else {\n            for (int i=0; i<n; i++) {\n                if (s.contains(String.valueOf(i))) continue;\n                dfs(s + i, n);\n            }\n        }\n    }\n\n\n}\n\n", "code2": "N, M = gets.split.map(&:to_i)\ngraph = Array.new(N + 1) { [] }\nM.times do\n  a, b = gets.split.map(&:to_i)\n  graph[a] << b\n  graph[b] << a\nend\n\nans = 0\n(2..N).to_a.permutation(N - 1).each do |p|\n  p.unshift(1)\n  ans += 1 if (1...N).all? { |i| graph[p[i - 1]].include?(p[i]) }\nend\nputs ans\n", "label": 1, "name1": "s337668331.java", "name2": "s112297491.rb"}, {"id": 22, "code1": "import java.util.*;\n \npublic class Main{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    double H = sc.nextDouble();\n    double W = sc.nextDouble();\n    if (H != 1 && W != 1)\n\t\t\tSystem.out.println((long) Math.ceil(H * W / 2));\n\t\telse\n\t\t\tSystem.out.println(1);\n  }\n}\n    ", "code2": "H, W = gets.split.map(&:to_f)\nif H == 1 || W == 1 then\n  p 1\nelse\n  p (H*W / 2).ceil\nend\n\n", "label": 1, "name1": "s603185414.java", "name2": "s709033779.rb"}, {"id": 686, "code1": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String args[])\n    {\n        Scanner sc=new Scanner(System.in);\n       int ar[]=new int[] {0,0,0,0};\n       for(int i=0;i<3;i++)\n       {\n           int a=sc.nextInt();\n           int b=sc.nextInt();\n           ar[a-1]+=1;\n           ar[b-1]+=1;\n       }\n       \n       for(int i = 0; i < 4; i++) {\n\t\t\tif(ar[i] < 1 || ar[i] > 2) {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"YES\");\n       \n//       for(int i:ar)\n//       {\n//           if(i>2)\n//           {\n//               System.out.println(\"NO\");\n//               System.exit(0);\n//           }\n//       }\n//       System.out.println(\"YES\");\n    }\n}", "code2": "n, m = gets.split.map(&:to_i)\nxs = gets.split.map(&:to_i).sort\n\nif n >= m\n  puts 0\n  exit\nend\ndiffs = (xs.size - 1).times.map { |i| xs[i + 1] - xs[i] }.sort\nputs diffs[0..-n].inject(&:+)\n", "label": 0, "name1": "s048278962.java", "name2": "s162653365.rb"}, {"id": 575, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint a = Integer.parseInt(sc.next());\n\t\tint b = Integer.parseInt(sc.next());\n\t\tint c = Integer.parseInt(sc.next());\n\n\t\tif (a < c && c < b || b < c && c < a){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t}else {\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t}\n}", "code2": "d=*1..gets.to_i\ngets.bytes{|c|x=0\nN=d.pop\nd.map!{x+=-c%3*N+_1*(1-c%3)\nx%=10**9+7}}\np N", "label": 0, "name1": "s898770223.java", "name2": "s937516961.rb"}, {"id": 493, "code1": "import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        int A = scan.nextInt();\n        int B = scan.nextInt();\n        int C = scan.nextInt();\n        if(A == B && A== C){\n            System.out.println(\"No\");\n        }\n        else if(A == B || A == C || B == C){\n            System.out.println(\"Yes\");\n        }\n        else{\n            System.out.println(\"No\");\n        }\n    }\n}", "code2": "arr = gets.chomp.split(\" \").map(&:to_i)\nif arr.uniq.length == 2 then\n  puts \"Yes\"\nelse\n  puts \"No\"\nend\n", "label": 1, "name1": "s236930555.java", "name2": "s944100071.rb"}, {"id": 324, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[] total = new int[3];\n\n\t\ttotal[0] = sc.nextInt();\n\t\ttotal[1] = sc.nextInt();\n\t\ttotal[2] = sc.nextInt();\n\n\t\tsc.close();\n\n\t\tArrays.sort(total);\n\n\t\tSystem.out.println(total[0] + total[1]);\n\t}\n}", "code2": "puts gets.split.map(&:to_i).combination(2).map {|x,y| x+y}.min", "label": 1, "name1": "s443302375.java", "name2": "s609833635.rb"}, {"id": 297, "code1": "import java.util.*;\npublic class Main {\n\tstatic int yono;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tArrayList<Integer> al = new ArrayList<Integer>();\n\t\tint N = Integer.parseInt(sc.next());\n\t\tyono = N - 1;\n\t\tint M = sc.nextInt();\n\t\ttree = new int[N];\n\t\tArrays.fill(tree, -1);\n\t\tfor (int i = 0; i < M; i++)union(Integer.parseInt(sc.next()) - 1, Integer.parseInt(sc.next()) - 1);\n\t\tSystem.out.println(yono);\n\t}\n\t\n\tstatic int[] tree;\n\tstatic void union(int x, int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif(x != y) {\n\t\t\tyono--;\n\t\t\tif(tree[x] < tree[y]) {\n\t\t\t\tx ^= y; y ^= x; x^= y;\n\t\t\t}\n\t\t\ttree[x] += tree[y];\n\t\t\ttree[y] = x;\n\t\t}\n\t}\n\tstatic boolean find(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tstatic int root(int x) {\n\t\treturn tree[x] < 0 ? x : (tree[x] = root(tree[x]));\n\t}\n}", "code2": "class DisjointSet\n\tdef initialize(n)\n\t\t@parent = Array.new(n){-1}\n\tend\n\tdef find(a)\n\t\treturn a if @parent[a]<0\n\t\t@parent[a] = find(@parent[a])\n\tend\n\tdef union(a, b)\n\t\tx = find(a)\n\t\ty = find(b)\n\t\treturn x if x == y\n\t\tif size(x) < size(y)\n\t\t\tt = x\n\t\t\tx = y\n\t\t\ty = t\n\t\tend\n\t\t@parent[x] += @parent[y]\n\t\t@parent[y] = x\n\t\tx\n\tend\n\tdef size(a)\n\t\t-@parent[find(a)]\n\tend\nend\n\nN,M=gets.split.map(&:to_i)\nds=DisjointSet.new(N)\nM.times{\n\ta,b=gets.split.map(&:to_i)\n\tds.union(a-1,b-1)\n}\nr=0\n(1 .. N-1).each{|i|\n\tif ds.find(i)!=ds.find(0)\n\t\tds.union(i,0)\n\t\tr+=1\n\tend\n}\nputs r\n", "label": 1, "name1": "s179713562.java", "name2": "s385678464.rb"}, {"id": 415, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.util.NoSuchElementException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author HBonsai\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CMultipleClocks solver = new CMultipleClocks();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CMultipleClocks {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int N = in.nextInt();\n            long[] T = in.nextLongArray(N);\n            long ans = T[0];\n            for (int i = 1; i < N; i++) {\n                long gcd = gcd(ans, T[i]);\n                ans = T[i] * (ans / gcd);\n            }\n            out.println(ans);\n        }\n\n        private static long gcd(long m, long n) {\n            if (m < n) return gcd(n, m);\n            if (n == 0) return m;\n            return gcd(n, m % n);\n        }\n\n    }\n\n    static class FastScanner implements Closeable {\n        private final InputStream in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        public FastScanner(InputStream in) {\n            this.in = in;\n        }\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        public boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n            return hasNextByte();\n        }\n\n        public long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        public int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] res = new long[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextLong();\n            }\n            return res;\n        }\n\n        public void close() {\n            try {\n                in.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n}\n\n", "code2": "def main()\n  n = gets.chomp.to_i\n  x = []\n  for i in 0..n-1 do\n     x << gets.chomp.to_i\n  end\n  puts x.inject(:lcm)\nend\n\nmain()", "label": 1, "name1": "s654794279.java", "name2": "s027645540.rb"}, {"id": 164, "code1": "import java.util.Scanner;\nimport java.util.Stack;\n\nclass Main{\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tString str=sc.next();\n\t\t\tStack<Integer> st=new Stack<Integer>();\n\t\t\tfor(int i=0;i<str.length();i++){\n\t\t\t\tif(st.isEmpty() || st.peek()==1 || str.charAt(i)=='S') st.add(str.charAt(i)=='S' ? 0 : 1);\n\t\t\t\telse st.pop();\n\t\t\t}\n\t\t\tSystem.out.println(st.size());\n\t\t}\n\t}\n}", "code2": "r=0;gets.bytes.map{|c|c>83?r<0&&r+=1:r-=1};p~r*2", "label": 1, "name1": "s831441158.java", "name2": "s239261496.rb"}, {"id": 213, "code1": "import java.util.*;\npublic class Main{\n    public static void main(String args[]) {\n        Scanner cin = new Scanner(System.in);\n        while(cin.hasNext()){\n        \tint n = cin.nextInt();\n        \tint[][] vote = readMatrix(cin,n,2);\n        \tSystem.out.println(getNum(vote,n));\n        }\n    }\n    public static long getNum(int[][] vote, int n){\n    \tlong[] result={vote[0][0],vote[0][1]};\n    \tlong result1;\n    \tfor(int i=1;i<n;i++){\n    \t\tresult1 = result[1];\n    \t\tif(result[0]>vote[i][0]){\n    \t\t\tif(result[0]%vote[i][0]!=0) result[0] += vote[i][0]-result[0]%vote[i][0];\n    \t\t}else{result[0]=vote[i][0];}\n    \t\tresult[1] = result[0]/vote[i][0]*vote[i][1];\n    \t\tif(result1>result[1]){\n    \t\t\tresult[1] = result1;\n    \t\t\tif(result[1]%vote[i][1]!=0) result[1] += vote[i][1]-result[1]%vote[i][1];\n    \t\t\t result[0] = result[1]/vote[i][1]*vote[i][0];\n    \t\t}\n    \t}\n    \treturn result[0]+result[1];\n    }\n    public static int[][] readMatrix(Scanner in,int n,int m){\n    \tint[][] mtx = new int[n][m];\n    \tfor(int i=0;i<n;i++){\n    \t\tfor(int j=0;j<m;j++){\n    \t\t\tmtx[i][j] = in.nextInt();\n    \t\t}\n    \t}\n    \treturn mtx;\n    }\n    \n}", "code2": "n = gets.to_i\nratio = gets.split(\" \").map(&:to_i)\n\n(n - 1).times do\n  new_ratio = gets.split(\" \").map(&:to_i)\n  amp = new_ratio.zip(ratio).map do |nr, r|\n    r / nr + (r % nr == 0 ? 0 : 1)\n  end.max\n  ratio = new_ratio.map { |r| r * amp }\nend\n\nputs ratio.inject(&:+)", "label": 1, "name1": "s502019413.java", "name2": "s730519785.rb"}, {"id": 454, "code1": "import java.util.*;\nimport java.text.*;\nimport java.math.*;\n\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tScanner in = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint m = in.nextInt();\n\t\t\tint d = in.nextInt();\n\t\t\tif((m|d) == 0) break;\n\t\t\tint day = d;\n\t\t\tswitch(m){\n\t\t\tcase 12:\n\t\t\t\tday += 335;\n\t\t\t\tbreak;\n\t\t\tcase 11:\n\t\t\t\tday += 305;\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tday += 274;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tday += 244;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tday += 213;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tday += 182;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tday += 152;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tday += 121;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tday += 91;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tday += 60;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tday += 31;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t}\n\t\t\tswitch(day%7){\n\t\t\tcase 1:\n\t\t\t\tSystem.out.println(\"Thursday\");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tSystem.out.println(\"Friday\");\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tSystem.out.println(\"Saturday\");\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tSystem.out.println(\"Sunday\");\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tSystem.out.println(\"Monday\");\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tSystem.out.println(\"Tuesday\");\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tSystem.out.println(\"Wednesday\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "code2": "day=[\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\"]\nwhile true\n\tm,d=gets.chomp.split(\" \").map{|s| s.to_i}\n\tbreak if m==0&&d==0\n\tcount=2\n\tfor i in (1..m-1) do\n\t\tif(i==2) then \n\t\t\tcount+=29\n\t\telsif (i==4||i==6||i==9||i==11) then\n\t\t\tcount+=30\n\t\telse\n\t\t\tcount+=31\n\t\tend\t\n\tend\n\tcount+=d\n\tcount%=7\n\tputs day[count]\nend\n", "label": 1, "name1": "s648991274.java", "name2": "s196769013.rb"}, {"id": 92, "code1": "import java.util.*;\n\npublic class Main{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    long n = sc.nextLong();\n    long k = sc.nextLong();\n\n    long a = n % k;\n    long b = Math.abs(a - k);\n\n    if(a>b){\n      System.out.println(b);\n    }else{\n      System.out.println(a);\n    }\n\n\n  }\n}", "code2": "n,k=gets.split.map &:to_i\nn%=k\np [n,k-n].min", "label": 1, "name1": "s483882254.java", "name2": "s028993927.rb"}, {"id": 513, "code1": "import java.util.*;\n \npublic class Main{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    double H = sc.nextDouble();\n    double W = sc.nextDouble();\n    if (H != 1 && W != 1)\n\t\t\tSystem.out.println((long) Math.ceil(H * W / 2));\n\t\telse\n\t\t\tSystem.out.println(1);\n  }\n}\n    ", "code2": "n,a,b = gets.chomp.split(\" \").map(&:to_i)\nx = gets.chomp.split(\" \").map(&:to_i)\nborder = b/a\nnow = x[0]\nmp = 0\n(n-1).times do |i|\n  if x[i+1] - now > border\n    mp += b\n    now = x[i+1]\n  else\n    mp += (x[i+1] - now) * a\n    now = x[i+1]\n  end\nend\nputs mp", "label": 0, "name1": "s603185414.java", "name2": "s543935050.rb"}, {"id": 225, "code1": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\t\n\tint n;\n\tint[][] es;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\tes = new int[n][n];\n\t\tfor (int[] a: es) fill(a, INF);\n\t\tfor (int i=0;i<n;i++) es[i][i] = 0;\n\t\tfor (int i=0;i<n;i++) {\n\t\t\tint r = sc.nextInt()-1, k = sc.nextInt();\n\t\t\tfor (int j=0;j<k;j++) {\n\t\t\t\tint t = sc.nextInt()-1;\n\t\t\t\tes[r][t] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int k=0;k<n;k++) for (int i=0;i<n;i++) for (int j=0;j<n;j++) {\n\t\t\tes[i][j] = min(es[i][j], es[i][k] + es[k][j]);\n\t\t}\n\t\tint p = sc.nextInt();\n\t\tfor (int i=0;i<p;i++) {\n\t\t\tint s = sc.nextInt()-1, d = sc.nextInt()-1, v = sc.nextInt();\n\t\t\tSystem.out.println((es[s][d] + 1 <= v ? es[s][d] + 1 : \"NA\"));\n\t\t}\n\t}\n\t\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}", "code2": "def g;gets.split.map &:to_i;end\nr=1..n=g[0]\nw=[[]]+r.map{[0]+[1e9]*n}\nr.map{f,_,*t=g;t.map{|i|w[f][i]=1}}\nr.map{|k|w.map!{|i|i=i.zip(w[k]).map{|a,b|[a,b+i[k]].min}}}\ng[0].times{s,d,v=g;puts v<(c=w[s][d]+1)?:NA:c}", "label": 1, "name1": "s834155894.java", "name2": "s352888283.rb"}, {"id": 65, "code1": "import java.util.*;\nclass Main {\n\tstatic int n;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\tint maxDistance = 0;\n\t\t\tMap<Integer, Integer> map = new HashMap<Integer, Integer>(n);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tint d = sc.nextInt() + sc.nextInt();\n\t\t\t\tmap.put(d, p);\n\t\t\t\tmaxDistance = Math.max(d, maxDistance);\n\t\t\t}\n\t\t\tSystem.out.printf(\"%d %d\\n\", map.get(maxDistance), maxDistance);\n\t\t}\n\t}\n}", "code2": "while (n=gets.chomp)!=\"0\"\n  id,d = 0,0\n  n.to_i.times do\n    p,d1,d2 = gets.split.map!(&:to_i)\n    if d<d1+d2\n      d=d1+d2\n      id=p\n    end\n  end\n  puts [id,d].join(' ')\nend", "label": 1, "name1": "s188031790.java", "name2": "s045283570.rb"}, {"id": 737, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.util.NoSuchElementException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author HBonsai\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CMultipleGift solver = new CMultipleGift();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CMultipleGift {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            long X = in.nextLong();\n            long Y = in.nextLong();\n            int ans = 1;\n            long A = X;\n            while (A <= Y) {\n                A *= 2;\n                if (A > Y) break;\n                ans++;\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class FastScanner implements Closeable {\n        private final InputStream in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        public FastScanner(InputStream in) {\n            this.in = in;\n        }\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        public boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n            return hasNextByte();\n        }\n\n        public long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        public void close() {\n            try {\n                in.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n}\n\n", "code2": "ai, ao, at, aj, al, as, az = gets.split.map(&:to_i)\ntmp = ai/2*2 + aj/2*2 + al/2*2\nif [ai, aj, al].min > 0\n    ai -= 1\n    aj -= 1\n    al -= 1\n    tmp2 = ai/2*2 + aj/2*2 + al/2*2 + 3\n    tmp = [tmp, tmp2].max\nend\nputs ao + tmp", "label": 0, "name1": "s947131740.java", "name2": "s077778491.rb"}, {"id": 19, "code1": "import java.util.Scanner;\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\n\t\tlong h = stdIn.nextLong();\n\t\tlong w = stdIn.nextLong();\n\t\t\n\t\tlong cnt = 0;\n\t\tif(h==1 || w == 1) {\n\t\t\tSystem.out.println(1);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(h % 2 == 0 && w % 2 == 0) { //h\u5076\u6570\u3001w\u5076\u6570\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tcnt += w/2;\n\t\t\t}\n\t\t}else if(h % 2 == 0 && w % 2 != 0) { //h\u5076\u6570\u3001w\u5947\u6570\n\t\t\tfor(int i = 0; i < h ; i++) {\n\t\t\t\tif(i % 2 == 0) {\n\t\t\t\t\tcnt += (w+1)/2;\n\t\t\t\t}else {\n\t\t\t\t\tcnt += w/2;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( h % 2 != 0 && w % 2 == 0) { // h\u5947\u6570,w\u5076\u6570\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tcnt += w/2;\n\t\t\t}\n\t\t}else {                                //h\u5947\u6570,w\u5947\u6570\n\t\t\tfor(int i = 0; i < h ; i++) {\n\t\t\t\tif(i % 2 == 0) {\n\t\t\t\t\tcnt += (w+1)/2;\n\t\t\t\t}else {\n\t\t\t\t\tcnt += w/2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(cnt);\n\n\t}\n\n}\n", "code2": "h, w = gets.chomp.split.map(&:to_i)\nif (h == 1 || w == 1 )\n  puts \"1\"\nelse\n  puts \"#{(h * w / 2.0).round}\"\nend\n", "label": 1, "name1": "s990691093.java", "name2": "s520164559.rb"}, {"id": 73, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main{\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint unko=sc.nextInt();\n\t\tboolean ike=false;\n\t\tint N=0;\n\t\tfor(int i=0; i<=500; i++) {\n\t\t\tif(unko==i*(i+1)/2) {\n\t\t\t\tike=true;\n\t\t\t\tN=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(unko<i*(i+1)/2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ike) {\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\tSystem.out.println(N+1);\n\t\t\tint[][] ary=new int[N+1][N];\n\t\t\tint[] kaz=new int[N+2];\n\t\t\tfor(int i=0; i<=N; i++) {\n\t\t\t\tfor(int j=0; j<N; j++) {\n\t\t\t\t\tary[i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<=N+1; i++) {\n\t\t\t\tkaz[i]=0;\n\t\t\t}\n\t\t\tint counter=1;\n\t\t\tfor(int i=1; i<=N+1; i++) {\n\t\t\t\tfor(int j=1; j<i; j++) {\n\t\t\t\t\tary[i-1][kaz[i-1]]=counter;\n\t\t\t\t\tkaz[i-1]++;\n\t\t\t\t\tary[j-1][kaz[j-1]]=counter;\n\t\t\t\t\tkaz[j-1]++;\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tString buri=\"\";\n\t\t\tfor(int i=0; i<N+1; i++) {\n\t\t\t\tburi=Arrays.toString(ary[i]);\n\t\t\t\tburi=buri.replaceAll(\",\",\"\");\n\t\t\t\tburi=buri.replace(\"[\",\" \");\n\t\t\t\tburi=buri.replace(\"]\",\"\");\n\t\t\t\tSystem.out.println(N+buri);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t}\n}", "code2": "def  nnp1(n)\n    a=((n*2)**(0.5)).to_i\n    return a*(a+1)==n*2\nend\n\ndef  nnp(n)\n    a=((n*2)**(0.5)).to_i\n    return a\nend\n\nn=gets.strip.to_i\n\nif nnp1(n) == false \n    puts 'No'\n    exit\nend\nputs 'Yes'\na=nnp(n)\nx=Array.new(a+1).map{Array.new(a)}\nc=1\nputs a+1\n(0..a-1).each{|i|\n    \n    cc=c\n    (i..a-1).each{|j|\n        x[i][j]=cc\n        cc+=1\n    }\n\n    cc=c\n    (i+1..a).each{|j|\n        x[j][i]=cc\n        cc+=1\n    }\n    c=cc\n}\n\nx.each do |i|\n    print a.to_s + \" \"\n    puts i.join(\" \")\n\nend", "label": 1, "name1": "s468399402.java", "name2": "s713749025.rb"}, {"id": 528, "code1": "import java.util.Scanner;\npublic class Main { \n    public static void main(String[] args) {\n        try (Scanner sc = new Scanner(System.in)) { \n        while (true) { \n        int n = sc.nextInt(); \n            if (n == 0) { \n            break; \n            } \n            int[] scores = new int[n]; \n            for (int i = 0; i < scores.length; i++) { \n            scores[i] = sc.nextInt(); \n            } \n            double average = 0, variance = 0;\n            for(int i = 0; i < scores.length; i++){ \n                average += scores[i]; \n            } \n            average = average/n; \n            for(int i = 0; i < scores.length; i++){ \n                variance += (scores[i]-average)*(scores[i]-average); \n            }\n            variance = variance/n;\n            System.out.println(Math.sqrt(variance)); \n            } \n        } \n    }\n}\n", "code2": "a=gets.to_i\nb=gets.to_i\nc=gets.to_i\nd=gets.to_i\na=a+b\na=a+c\na=a+d\nsec=a%60\na=a-sec\nmin=a/60\nprint(\"#{min}\\n#{sec}\\n\")", "label": 0, "name1": "s272580744.java", "name2": "s727924665.rb"}, {"id": 881, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author GYSHGX868\n */\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    OutputWriter out = new OutputWriter(outputStream);\n    TaskA solver = new TaskA();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskA {\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n      char a = in.nextChar();\n      char b = in.nextChar();\n      if (a == 'H') {\n        out.printLine(b);\n      } else {\n        out.printLine(b == 'H' ? 'D' : 'H');\n      }\n    }\n\n  }\n\n  static class InputReader {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private InputReader.SpaceCharFilter filter;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public int read() {\n      if (numChars == -1) {\n        throw new InputMismatchException();\n      }\n      if (curChar >= numChars) {\n        curChar = 0;\n        try {\n          numChars = stream.read(buf);\n        } catch (IOException e) {\n          throw new InputMismatchException();\n        }\n        if (numChars <= 0) {\n          return -1;\n        }\n      }\n      return buf[curChar++];\n    }\n\n    public boolean isSpaceChar(int c) {\n      if (filter != null) {\n        return filter.isSpaceChar(c);\n      }\n      return isWhitespace(c);\n    }\n\n    public static boolean isWhitespace(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public char nextChar() {\n      int c = read();\n      while (isSpaceChar(c)) {\n        c = read();\n      }\n      return (char) c;\n    }\n\n    public interface SpaceCharFilter {\n      boolean isSpaceChar(int ch);\n\n    }\n\n  }\n\n  static class OutputWriter {\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n      this.writer = new PrintWriter(writer);\n    }\n\n    public void printLine(char i) {\n      writer.println(i);\n    }\n\n    public void close() {\n      writer.close();\n    }\n\n  }\n}\n\n", "code2": "1000.times {\n\tputs \"Hello World\"\n}", "label": 0, "name1": "s595866024.java", "name2": "s880313677.rb"}, {"id": 344, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tprivate void solve() {\n\t\tScanner io = new Scanner(System.in);\n\t\tint N = io.nextInt();\n\t\tint M = io.nextInt();\n\t\tboolean[] medium = new boolean[N];\n\t\tboolean[] ableToN = new boolean[N];\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint a = io.nextInt()-1;\n\t\t\tint b = io.nextInt()-1;\n\t\t\tif(a==0) medium[b] = true;\n\t\t\tif(b==0) medium[a] = true;\n\t\t\tif(a==N-1) ableToN[b] = true;\n\t\t\tif(b==N-1) ableToN[a] = true;\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(medium[i] && ableToN[i]){\n\t\t\t\tSystem.out.println(\"POSSIBLE\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"IMPOSSIBLE\");\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\n}", "code2": "N, M = gets.split.map(&:to_i)\nneighbor = Array.new(N+1){Hash.new}\nM.times do |i|\n    a, b = gets.split.map(&:to_i)\n    neighbor[a][b] = true\nend\n\n(2..(N-1)).each do |i|\n    if neighbor[1][i] && neighbor[i][N]\n        puts 'POSSIBLE'\n        exit\n    end\nend\nputs 'IMPOSSIBLE'", "label": 1, "name1": "s464102860.java", "name2": "s467668333.rb"}, {"id": 898, "code1": "// package arc.arc085;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int m = in.nextInt();\n        long time = m * 1900 + (n - m) * 100;\n\n        out.println(time * (1<<m));\n        out.flush();\n    }\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}", "code2": "require 'prime'\nx = gets.chomp.to_i\ni = x\n\nwhile i > 0\n  if i.prime?\n\t\tputs i\n\t\tbreak\n  end\n\ti += 1\nend\n", "label": 0, "name1": "s269596398.java", "name2": "s105042152.rb"}, {"id": 560, "code1": "import java.util.*;\n\npublic class Main{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    long n = sc.nextLong();\n    long k = sc.nextLong();\n\n    long a = n % k;\n    long b = Math.abs(a - k);\n\n    if(a>b){\n      System.out.println(b);\n    }else{\n      System.out.println(a);\n    }\n\n\n  }\n}", "code2": "a, b, c = gets.chomp.split.map(&:to_i)\n\nrad_c = Float(c) / 180 * Math::PI\ns = 0.5 * a * b * Math.sin(rad_c)\nputs format(\"%.6f\", s)\n\nc = Math.sqrt(a * a + b * b - 2 * a * b * Math.cos(rad_c))\nputs format(\"%.6f\", a + b + c)\n\nh = 2 * s / a\nputs format(\"%.6f\", h)\n\n", "label": 0, "name1": "s483882254.java", "name2": "s761885510.rb"}, {"id": 294, "code1": "import java.util.*;\npublic class Main {\n        static Scanner sc = new Scanner(System.in);\n        static void myout(Object t){System.out.println(t);}//standard output\n        static void myerr(Object t){System.err.println(t);}//standard error\n        static String getStr(){return sc.next();}\n        static int getInt(){return Integer.parseInt(getStr());}\n        static long getLong(){return Long.parseLong(getStr());}\n        static boolean isNext(){return sc.hasNext();}\n        static String[] mySplit(String str){return str.split(\"\");}\n        public static void main(String[] args){\n          int N = getInt();\n          int M = getInt();\n          if(N >= M){\n            myout(0);\n            return;\n          }\n          long output = 0;\n          ArrayList<Integer> list = new ArrayList<Integer>(M);\n          for(int i = 0; i < M; i++){\n            list.add(getInt());\n          }\n          Collections.sort(list);\n          //myout(list);\n          PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\n          for(int i = 1; i < M; i++){\n            pq.add(Math.abs(list.get(i)-list.get(i-1)));\n          }\n          for(int i = 0; i < N-1; i++){\n            pq.poll();\n          }\n          while(pq.size() != 0){\n            output += pq.poll();\n          }\n          myout(output);\n        }\n        //\u4fbf\u5229\u30e1\u30bd\u30c3\u30c9\u8ffd\u52a0\u67a0\u3053\u3053\u304b\u3089\n\n        //\u4fbf\u5229\u30e1\u30bd\u30c3\u30c9\u8ffd\u52a0\u67a0\u3053\u3053\u307e\u3067\n}\n", "code2": "n, m = gets.chomp.split(\" \").map(&:to_i)\nxs = gets.chomp.split(\" \").map(&:to_i).sort\ndiffs = []\ni = 0\nwhile i < (xs.size - 1) do\n  diffs.push xs[i+1] - xs[i]\n  i += 1\nend\n\nputs diffs.sort.reverse.drop(n-1).reduce(&:+) || 0\n", "label": 1, "name1": "s460372083.java", "name2": "s974088402.rb"}, {"id": 59, "code1": "import java.util.*;\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int x = 0, y = 0; \n\tstatic String second;\n\tstatic int second_ = 0;\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO \u30c4\u7be0\u30a5\u30c4\u7763\u30e7\u30c4\u9752\u30ab\u30c4\u9752\u30e3\u30c4\u3064\u30a6\u30c4\u3065\u30a7\u30c4\u3064\u30b9\u30c4\u03b4\u30bd\u30c4\u30c3\u30c4\u30c9\u30c4\u30fb\u30c4\u30b9\u30c4\u30bf\u30c4\u30d6\n\t\tread();\t\n\t\tslove();\n\t\t\n\t}\n\tstatic boolean read(){\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tsecond = sc.next();\n\t\t\tsecond_ = second_ + Integer.parseInt(second);\n\t\t}\n\t\t//System.out.println(second_);\n\t\treturn true;\n\t}\n\tstatic void slove(){\n\t\tx = second_/60;\n\t\ty = second_ % 60;\n\t\tSystem.out.println(x);\n\t\tSystem.out.println(y);\n\t}\n}", "code2": "x = gets.to_i\nx += gets.to_i\nx += gets.to_i\nx += gets.to_i\nputs x/60\nputs x%60\n", "label": 1, "name1": "s543682667.java", "name2": "s649714862.rb"}, {"id": 935, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.UncheckedIOException;\nimport java.util.StringTokenizer;\n\n\nclass Main{\n\tstatic int[][] ban;\n\tstatic boolean[][] visited;\n\tstatic long sum=0;\n\tstatic int H,W;\n\tstatic long kuro=0;\n\tstatic long siro=0;\n\tpublic static void main(String[] args) {\n\t\tSC sc=new SC(System.in);\n\t\tH=sc.nextInt();\n\t\tW=sc.nextInt();\n\t\tvisited=new boolean[H][W];\n\t\tban=new int[H][W];\n\t\tString s;\n\t\tfor(int i=0; i<H; i++){\n\t\t\ts=sc.next();\n\t\t\tfor(int j=0; j<W; j++){\n\t\t\t\tif(s.charAt(j)=='#'){\n\t\t\t\t\tban[i][j]=1;\t//\u9ed2\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tban[i][j]=0;\t//\u767d\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<H; i++){\t\t//\u3057\u3089\u3079\u308b\n\t\t\tfor(int j=0; j<W; j++){\n\t\t\t\tif(ban[i][j]==1 && !visited[i][j]){\n\t\t\t\t\tkuro=0; siro=0;\n\t\t\t\t\tdfs(i,j);\n\t\t\t\t\tsum+=kuro*siro;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpl(sum);\n\t}\n\n\tpublic static void dfs(int y,int x){\n\t\tint[] vx={0,1,0,-1};\n\t\tint[] vy={-1,0,1,0};\n\t\tif(ban[y][x]==1){\n\t\t\tkuro++;\n\t\t}\n\t\telse{\n\t\t\tsiro++;\n\t\t}\n\t\tvisited[y][x]=true;\n\t\tfor(int i=0; i<4; i++){\n\t\t\tif(x+vx[i]>=0 && x+vx[i]<W && y+vy[i]>=0 && y+vy[i]<H){\n\t\t\t\tif(ban[y][x]!=ban[y+vy[i]][x+vx[i]] && !visited[y+vy[i]][x+vx[i]]){\n\t\t\t\t\tdfs(y+vy[i],x+vx[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void pl(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\tpublic static void pl() {\n\t\tSystem.out.println();\n\t}\n\tpublic static void p(Object o) {\n\t\tSystem.out.print(o);\n\t}\n\tstatic class SC {\n\t\tprivate BufferedReader reader = null;\n\t\tprivate StringTokenizer tokenizer = null;\n\t\tpublic SC(InputStream in) {\n\t\t\treader = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\t\tpublic String next() {\n\t\t\tif (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new UncheckedIOException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new UncheckedIOException(e);\n\t\t\t}\n\t\t}\n\t}\n}", "code2": "D = gets.to_i\nC = gets.chomp.split.map(&:to_i)\ns = D.times.map{gets.split.map(&:to_i)}\nc = Array.new(26, 0)\nt = []\n\n(0..D-1).each do |i|\n\n  (0..25).each do |l|\n    c[l] += C[l]\n  end\nans = 0\nboder = s[i][0]+9*c[0]\n\n  (1..25).each do |e|\n    if s[i][e]+9*c[e] >= boder\n      ans = e\n      boder = s[i][e]+9*c[e]\n    end\n  end\nc[ans] = 0\nputs ans+1\nend\n\n\n  \n\n", "label": 0, "name1": "s037642808.java", "name2": "s375164204.rb"}, {"id": 39, "code1": "import java.util.Scanner;\npublic class Main { \n    public static void main(String[] args) {\n        try (Scanner sc = new Scanner(System.in)) { \n        while (true) { \n        int n = sc.nextInt(); \n            if (n == 0) { \n            break; \n            } \n            int[] scores = new int[n]; \n            for (int i = 0; i < scores.length; i++) { \n            scores[i] = sc.nextInt(); \n            } \n            double average = 0, variance = 0;\n            for(int i = 0; i < scores.length; i++){ \n                average += scores[i]; \n            } \n            average = average/n; \n            for(int i = 0; i < scores.length; i++){ \n                variance += (scores[i]-average)*(scores[i]-average); \n            }\n            variance = variance/n;\n            System.out.println(Math.sqrt(variance)); \n            } \n        } \n    }\n}\n", "code2": "while true do\n    n = gets.to_i\n    break if n == 0\n    array=gets.chomp.split(\" \").map(&:to_f)\n    average = array.inject(:+)/n\n    puts format(\"%0.5f\", (array.map {|e| (e-average)**2}.inject(:+)/n)**0.5)\nend\n", "label": 1, "name1": "s272580744.java", "name2": "s834861200.rb"}, {"id": 291, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.AbstractCollection;\nimport java.util.PriorityQueue;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CStreamline solver = new CStreamline();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CStreamline {\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            int[] x = in.nextIntArray(m);\n            Arrays.sort(x);\n            int ans = x[m - 1] - x[0];\n            PriorityQueue<Integer> q = new PriorityQueue<>();\n            for (int i = 0; i < m - 1; i++) {\n                q.add(-(x[i + 1] - x[i]));\n            }\n            for (int i = 0; i < n - 1 && !q.isEmpty(); i++) {\n                ans += q.poll();\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        public int[] nextIntArray(final int n) {\n            final int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt();\n            }\n            return res;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n", "code2": "input = STDIN.read.split(\"\\n\").map{|l| l.split(\" \").map{|a| a.to_i}}\n\nN = input[0][0]\nM = input[0][1]\n\nX = input[1].sort\n\n\ndef main() \n    diffs = []\n\n    if N >= M \n        return 0\n    end\n\n    for i in 0..(M - 2)\n        d = X[i + 1] - X[i] \n        diffs.push([i, d])\n    end\n\n    ds = diffs.sort_by{|x| x[1]}.reverse.slice(0, N - 1).sort_by{|x| x[0]}\n    moves = 0\n\n    if ds.length > 0\n        for i in 0..(N - 1)\n            if i == 0\n                st = 0\n                ed = ds[i][0]\n            elsif i == (N - 1)\n                st = ds[i - 1][0] + 1\n                ed = M - 1\n            else\n                st = ds[i - 1][0] + 1\n                ed = ds[i][0]\n            end\n            moves = moves + (X[ed] - X[st]).abs\n        end\n    else\n        moves = (X.first - X.last).abs\n    end\n    return moves\nend\n\nputs main()", "label": 1, "name1": "s975956716.java", "name2": "s016750008.rb"}, {"id": 479, "code1": "import java.util.*;\n\npublic class Main {\n\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    int cnt = 0;\n\n    List<Integer>[] lists = new ArrayList[n];\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    void run() {\n\n        for (int i=0; i<n; i++) lists[i] = new ArrayList<>();\n\n        int m = sc.nextInt();\n        for (int i=0; i<m; i++) {\n            int s = sc.nextInt() - 1;\n            int t = sc.nextInt() - 1;\n            lists[s].add(t);\n            lists[t].add(s);\n        }\n\n        dfs(\"\", n);\n\n        System.out.println(cnt);\n\n    }\n\n    void dfs(String s, int n) {\n\n        if (s.length() == n) {\n//            System.out.println(s);\n            if (s.charAt(0) == '0') {\n                boolean check = true;\n                for (int i=0; i<s.length()-1; i++) {\n                    if (!lists[s.charAt(i) - 48].contains(s.charAt(i+1) - 48)) {\n                        check = false;\n                        break;\n                    }\n                }\n                if (check) cnt++;\n            }\n\n        } else {\n            for (int i=0; i<n; i++) {\n                if (s.contains(String.valueOf(i))) continue;\n                dfs(s + i, n);\n            }\n        }\n    }\n\n\n}\n\n", "code2": "require \"set\"\n\nn, m = gets.split(\" \").map(&:to_i)\nedges = {}\nnodes = Set.new\nm.times do |i|\n  a, b = gets.split(\" \").map(&:to_i)\n  edges[a] ||= []\n  edges[a] << b\n  edges[b] ||= []\n  edges[b] << a\n  nodes << a\n  nodes << b\nend\n\ndef one_line s, n, nodes, edges\n  # p \"[debug] set: #{s}, node: #{n}\"\n  new_s = s.clone\n  new_s << n\n  if new_s == nodes then\n    return 1\n  end\n\n  res = 0\n  ((edges[n] || []) - new_s.to_a).each do |b|\n    res += one_line new_s, b, nodes, edges\n  end\n  return res\nend\n\nputs one_line(Set.new, 1, nodes, edges)", "label": 1, "name1": "s337668331.java", "name2": "s002122536.rb"}, {"id": 580, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.IntStream;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMain main = new Main();\n\t\tmain.solve();\n\t}\n\n\tprivate void solve() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tint[] a = new int[N];\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\ta[j] = sc.nextInt();\n\t\t}\n\t\tboolean[] dp = new boolean[K + 1];\n\t\tfor (int i = 0; i <= K; i++) {\n\t\t\tboolean isWin = false;\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (a[j] <= i && !dp[i - a[j]]) {\n\t\t\t\t\tisWin = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i] = isWin;\n\t\t}\n\t\tSystem.out.println(dp[K] ? \"First\" : \"Second\");\n\t}\n\n\tclass Scanner {\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int index;\n\t\tprivate int length;\n\n\t\tpublic Scanner(InputStream in) {\n\t\t\tthis.in = in;\n\t\t}\n\n\t\tprivate boolean isPrintableChar(int c) {\n\t\t\treturn '!' <= c && c <= '~';\n\t\t}\n\n\t\tprivate boolean isDigit(int c) {\n\t\t\treturn '0' <= c && c <= '9';\n\t\t}\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (index < length) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tlength = in.read(buffer);\n\t\t\t\t\tindex = 0;\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\treturn length > 0;\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[index])) {\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\treturn hasNextByte() ? buffer[index++] : -1;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) {\n\t\t\t\tthrow new RuntimeException(\"no input\");\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) {\n\t\t\t\tthrow new RuntimeException(\"no input\");\n\t\t\t}\n\t\t\tlong value = 0L;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tif (isDigit(b)) {\n\t\t\t\t\tvalue = value * 10 + (b - '0');\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn minus ? -value : value;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n\n\tinterface CombCalculator {\n\t\tlong comb(int n, int m);\n\t}\n\n\tinterface MobiusFunction {\n\t\tint get(int n);\n\t}\n\n\t/**\n\t * \u30e1\u30d3\u30a6\u30b9\u95a2\u6570\u3092\u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9\u3063\u307d\u304f\u524d\u8a08\u7b97\u3059\u308b\u30af\u30e9\u30b9\u3067\u3059\u3002\n\t * \u8a08\u7b97\u91cf\u306fO(1)\u3067\u3001\u524d\u8a08\u7b97\u3067O(N logN)\u3067\u3059\u3002\n\t */\n\tclass SieveMobiusFunction implements MobiusFunction {\n\t\tint size;\n\t\tint[] mobiusFunctionValues;\n\n\t\tpublic SieveMobiusFunction(int size) {\n\t\t\tthis.size = size;\n\t\t\tmobiusFunctionValues = new int[size];\n\n\t\t\tmobiusFunctionValues[0] = 0;\n\t\t\tmobiusFunctionValues[1] = 1;\n\t\t\tfor (int i = 2; i < size; i++) {\n\t\t\t\tmobiusFunctionValues[i] = 1;\n\t\t\t}\n\t\t\tfor (int i = 2; i * i < size; i++) {\n\t\t\t\tfor (int k = 1; i * i * k < size; k++) {\n\t\t\t\t\tmobiusFunctionValues[i * i * k] *= 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 2; i < size; i++) {\n\t\t\t\tif (mobiusFunctionValues[i] == 1) {\n\t\t\t\t\tfor (int k = 1; i * k < size; k++) {\n\t\t\t\t\t\tmobiusFunctionValues[i * k] *= -2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mobiusFunctionValues[i] > 1) {\n\t\t\t\t\tmobiusFunctionValues[i] = 1;\n\t\t\t\t}\n\t\t\t\tif (mobiusFunctionValues[i] < -1) {\n\t\t\t\t\tmobiusFunctionValues[i] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int get(int n) {\n\t\t\tif (n > size) {\n\t\t\t\tthrow new RuntimeException(\"n is greater than size.\");\n\t\t\t}\n\t\t\tif (n < 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn mobiusFunctionValues[n];\n\t\t}\n\t}\n\n\t/**\n\t * \u30e1\u30d3\u30a6\u30b9\u95a2\u6570\u3092\u5b9a\u7fa9\u901a\u308a\u8a08\u7b97\u3059\u308b\u30af\u30e9\u30b9\u3067\u3059\u3002\n\t * \u8a08\u7b97\u91cf\u306fO(logN)\u3067\u3059\u3002\n\t */\n\tclass PrimeFactorizationMobiusFunction implements MobiusFunction {\n\t\t@Override\n\t\tpublic int get(int n) {\n\t\t\tif (n <= 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (n == 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tint num = 0;\n\t\t\tfor (int i = 2; i < n; i++) {\n\t\t\t\tif (n % i == 0) {\n\t\t\t\t\tn /= i;\n\t\t\t\t\tnum++;\n\t\t\t\t\tif (n % i == 0) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn num % 2 == 0 ? -1 : 1;\n\t\t}\n\t}\n\n\t/**\n\t * \u7d44\u307f\u5408\u308f\u305b\u8a08\u7b97\u3092\u968e\u4e57\u306e\u5024\u3067\u884c\u3046\u30af\u30e9\u30b9\u3067\u3059(MOD\u5bfe\u5fdc)\n\t * \u968e\u4e57\u3068\u305d\u306e\u9006\u5143\u306f\u524d\u8a08\u7b97\u3057\u3066\u30c6\u30fc\u30d6\u30eb\u306b\u683c\u7d0d\u3057\u307e\u3059\u3002\n\t * C(N, N) % M \u306e\u8a08\u7b97\u91cf\u306f O(1)\u3001 \u524d\u8a08\u7b97\u3067O(max(N, logM))\u3067\u3059\u3002\n\t * size\u30921e8\u3088\u308a\u5927\u304d\u3044\u5024\u3067\u5b9f\u884c\u3059\u308b\u3068MLE\u306e\u5371\u967a\u6027\u304c\u3042\u308a\u307e\u3059\u3002\n\t * \u307e\u305f\u7d20\u6570\u4ee5\u5916\u306eMOD\u306b\u306f\u5bfe\u5fdc\u3057\u3066\u3044\u307e\u305b\u3093(\u9006\u5143\u306e\u8a08\u7b97\u306b\u7d20\u6570\u306e\u5270\u4f59\u74b0\u306e\u6027\u8cea\u3092\u5229\u7528\u3057\u3066\u3044\u308b\u305f\u3081)\u3002\n\t */\n\tclass FactorialTableCombCalculator implements CombCalculator {\n\t\tint size;\n\t\tlong[] factorialTable;\n\t\tlong[] inverseFactorialTable;\n\t\tlong mod;\n\n\t\tpublic FactorialTableCombCalculator(int size, long mod) {\n\t\t\tthis.size = size;\n\t\t\tfactorialTable = new long[size + 1];\n\t\t\tinverseFactorialTable = new long[size + 1];\n\t\t\tthis.mod = mod;\n\n\t\t\tfactorialTable[0] = 1L;\n\t\t\tfor (int i = 1; i <= size; i++) {\n\t\t\t\tfactorialTable[i] = (factorialTable[i - 1] * i) % mod;\n\t\t\t}\n\t\t\tinverseFactorialTable[size] = inverse(factorialTable[size], mod);\n\t\t\tfor (int i = size - 1; i >= 0; i--) {\n\t\t\t\tinverseFactorialTable[i] = (inverseFactorialTable[i + 1] * (i + 1)) % mod;\n\t\t\t}\n\t\t}\n\n\t\tprivate long inverse(long n, long mod) {\n\t\t\treturn pow(n, mod - 2, mod);\n\t\t}\n\n\t\tprivate long pow(long n, long p, long mod) {\n\t\t\tif (p == 0) {\n\t\t\t\treturn 1L;\n\t\t\t}\n\t\t\tlong half = pow(n, p / 2, mod);\n\t\t\tlong ret = (half * half) % mod;\n\t\t\tif (p % 2 == 1) {\n\t\t\t\tret = (ret * n) % mod;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic long comb(int n, int m) {\n\t\t\tif (n > size) {\n\t\t\t\tthrow new RuntimeException(\"n is greater than size.\");\n\t\t\t}\n\t\t\tif (n < 0 || m < 0 || n < m) {\n\t\t\t\treturn 0L;\n\t\t\t}\n\t\t\treturn (((factorialTable[n] * inverseFactorialTable[m]) % mod) * inverseFactorialTable[n - m]) % mod;\n\t\t}\n\t}\n\n\t/**\n\t * \u7d44\u307f\u5408\u308f\u305b\u8a08\u7b97\u3092\u30c6\u30fc\u30d6\u30eb\u3067\u5b9f\u88c5\u3057\u305f\u30af\u30e9\u30b9\u3067\u3059(MOD\u5bfe\u5fdc)\n\t * \u524d\u8a08\u7b97\u3067O(N^2), comb\u306fO(1)\u3067\u5b9f\u884c\u3067\u304d\u307e\u3059\n\t * size\u30922 * 1e4\u3088\u308a\u5927\u304d\u3044\u5024\u3067\u5b9f\u884c\u3059\u308b\u3068MLE\u306e\u5371\u967a\u6027\u304c\u3042\u308a\u307e\u3059\n\t */\n\tclass TableCombCalculator implements CombCalculator {\n\t\tlong[][] table;\n\t\tint size;\n\n\t\tpublic TableCombCalculator(int size, long mod) {\n\t\t\tthis.size = size;\n\t\t\ttable = new long[size + 1][];\n\n\t\t\ttable[0] = new long[1];\n\t\t\ttable[0][0] = 1L;\n\t\t\tfor (int n = 1; n <= size; n++) {\n\t\t\t\ttable[n] = new long[n + 1];\n\t\t\t\ttable[n][0] = 1L;\n\t\t\t\tfor (int m = 1; m < n; m++) {\n\t\t\t\t\ttable[n][m] = (table[n - 1][m - 1] + table[n - 1][m]) % mod;\n\t\t\t\t}\n\t\t\t\ttable[n][n] = 1L;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic long comb(int n, int m) {\n\t\t\tif (n > size) {\n\t\t\t\tthrow new RuntimeException(\"n is greater than size.\");\n\t\t\t}\n\t\t\tif (n < 0 || m < 0 || n < m) {\n\t\t\t\treturn 0L;\n\t\t\t}\n\t\t\treturn table[n][m];\n\t\t}\n\t}\n\n\tinterface Graph {\n\t\tvoid link(int from, int to, long cost);\n\t\tOptional<Long> getCost(int from, int to);\n\t\tint getVertexNum();\n\t}\n\n\tinterface FlowResolver {\n\t\tlong maxFlow(int from, int to);\n\t}\n\n\t/**\n\t * \u30b0\u30e9\u30d5\u306e\u884c\u5217\u306b\u3088\u308b\u5b9f\u88c5\n\t * \u63a5\u70b9\u6570\u306e\u5927\u304d\u3044\u30b0\u30e9\u30d5\u3067\u4f7f\u3046\u3068MLE\u3067\u6b7b\u306b\u305d\u3046\n\t */\n\tclass ArrayGraph implements Graph {\n\t\tprivate Long[][] costArray;\n\t\tprivate int vertexNum;\n\n\t\tpublic ArrayGraph(int n) {\n\t\t\tcostArray = new Long[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tcostArray[i] = new Long[n];\n\t\t\t}\n\t\t\tvertexNum = n;\n\t\t}\n\n\t\t@Override\n\t\tpublic void link(int from, int to, long cost) {\n\t\t\tcostArray[from][to] = new Long(cost);\n\t\t}\n\n\t\t@Override\n\t\tpublic Optional<Long> getCost(int from, int to) {\n\t\t\treturn Optional.ofNullable(costArray[from][to]);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getVertexNum() {\n\t\t\treturn vertexNum;\n\t\t}\n\t}\n\n\t/**\n\t * DFS(\u6df1\u3055\u512a\u5148\u63a2\u7d22)\u306b\u3088\u308b\u5b9f\u88c5\n\t * \u8a08\u7b97\u91cf\u306fO(E*MaxFlow)\u306e\u306f\u305a (E:\u8fba\u306e\u6570, MaxFlow:\u6700\u5927\u30d5\u30ed\u30fc)\n\t */\n\tclass DfsFlowResolver implements FlowResolver {\n\t\tprivate Graph graph;\n\t\tpublic DfsFlowResolver(Graph graph) {\n\t\t\tthis.graph = graph;\n\t\t}\n\n\t\t/**\n\t\t * \u6700\u5927\u30d5\u30ed\u30fc(\u6700\u5c0f\u30ab\u30c3\u30c8)\u3092\u6c42\u3081\u308b\n\t\t * @param from \u59cb\u70b9(source)\u306eID\n\t\t * @param to \u7d42\u70b9(target)\u306eID\n\t\t * @return \u6700\u5927\u30d5\u30ed\u30fc(\u6700\u5c0f\u30ab\u30c3\u30c8)\n\t\t */\n\t\tpublic long maxFlow(int from, int to) {\n\t\t\tlong sum = 0L;\n\t\t\tlong currentFlow;\n\t\t\tdo {\n\t\t\t\tcurrentFlow = flow(from, to, Long.MAX_VALUE / 3, new boolean[graph.getVertexNum()]);\n\t\t\t\tsum += currentFlow;\n\t\t\t} while (currentFlow > 0);\n\t\t\treturn sum;\n\t\t}\n\n\t\t/**\n\t\t * \u30d5\u30ed\u30fc\u306e\u5b9f\u884c \u30b0\u30e9\u30d5\u306e\u66f4\u65b0\u3082\u884c\u3046\n\t\t * @param from \u73fe\u5728\u3044\u308b\u7bc0\u70b9\u306eID\n\t\t * @param to \u7d42\u70b9(target)\u306eID\n\t\t * @param current_flow \u3053\u3053\u307e\u3067\u306e\u6d41\u91cf\n\t\t * @param passed \u65e2\u306b\u901a\u3063\u305f\u7bc0\u70b9\u304b\u5426\u304b\u3092\u683c\u7d0d\u3057\u305f\u914d\u5217\n\t\t * @return \u7d42\u70b9(target)\u306b\u6d41\u3057\u305f\u6d41\u91cf/\u623b\u308a\u306e\u30b0\u30e9\u30d5\u306e\u6d41\u91cf\n\t\t */\n\t\tprivate long flow(int from, int to, long current_flow, boolean[] passed) {\n\t\t\tpassed[from] = true;\n\t\t\tif (from == to) {\n\t\t\t\treturn current_flow;\n\t\t\t}\n\t\t\tfor (int id = 0; id < graph.getVertexNum(); id++) {\n\t\t\t\tif (passed[id]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tOptional<Long> cost = graph.getCost(from, id);\n\t\t\t\tif (cost.orElse(0L) > 0) {\n\t\t\t\t\tlong nextFlow = current_flow < cost.get() ? current_flow : cost.get();\n\t\t\t\t\tlong returnFlow = flow(id, to, nextFlow, passed);\n\t\t\t\t\tif (returnFlow > 0) {\n\t\t\t\t\t\tgraph.link(from, id, cost.get() - returnFlow);\n\t\t\t\t\t\tgraph.link(id, from, graph.getCost(id, from).orElse(0L) + returnFlow);\n\t\t\t\t\t\treturn returnFlow;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0L;\n\t\t}\n\t}\n\n\t/**\n\t * 1-indexed\u306eBIT\u914d\u5217\n\t */\n\tclass BinaryIndexedTree {\n\t\tprivate long[] array;\n\n\t\tpublic BinaryIndexedTree(int size) {\n\t\t\tthis.array = new long[size + 1];\n\t\t}\n\n\t\t/**\n\t\t * \u6307\u5b9a\u3057\u305f\u8981\u7d20\u306b\u5024\u3092\u52a0\u7b97\u3059\u308b\n\t\t * \u8a08\u7b97\u91cf\u306fO(logN)\n\t\t * @param index \u52a0\u7b97\u3059\u308b\u8981\u7d20\u306e\u6dfb\u5b57\n\t\t * @param value \u52a0\u7b97\u3059\u308b\u91cf\n\t\t */\n\t\tpublic void add(int index, long value) {\n\t\t\tfor (int i = index; i < array.length; i += (i & -i)) {\n\t\t\t\tarray[i] += value;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * 1\u301c\u6307\u5b9a\u3057\u305f\u8981\u7d20\u307e\u3067\u306e\u548c\u3092\u53d6\u5f97\u3059\u308b\n\t\t * \u8a08\u7b97\u91cf\u306fO(logN)\n\t\t * @param index \u548c\u306e\u7d42\u7aef\u3068\u306a\u308b\u8981\u7d20\u306e\u6dfb\u5b57\n\t\t * @return 1\u301cindex\u307e\u3067\u306e\u548c\n\t\t */\n\t\tpublic long getSum(int index) {\n\t\t\tlong sum = 0L;\n\t\t\tfor (int i = index; i > 0; i -= (i & -i)) {\n\t\t\t\tsum += array[i];\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\n\t/**\n\t * 1-indexed\u306e2\u6b21\u5143BIT\u914d\u5217\n\t */\n\tclass BinaryIndexedTree2D {\n\t\tprivate long[][] array;\n\n\t\tpublic BinaryIndexedTree2D(int size1, int size2) {\n\t\t\tthis.array = new long[size1 + 1][];\n\t\t\tfor (int i = 1; i <= size1; i++) {\n\t\t\t\tthis.array[i] = new long[size2 + 1];\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * \u6307\u5b9a\u3057\u305f\u8981\u7d20\u306b\u5024\u3092\u52a0\u7b97\u3059\u308b\n\t\t * \u8a08\u7b97\u91cf\u306fO(logN * logN)\n\t\t * @param index1 \u52a0\u7b97\u3059\u308b\u8981\u7d20\u306e1\u6b21\u5143\u76ee\u306e\u6dfb\u5b57\n\t\t * @param index2 \u52a0\u7b97\u3059\u308b\u8981\u7d20\u306e2\u6b21\u5143\u76ee\u306e\u6dfb\u5b57\n\t\t * @param value \u52a0\u7b97\u3059\u308b\u91cf\n\t\t */\n\t\tpublic void add(int index1, int index2, long value) {\n\t\t\tfor (int i1 = index1; i1 < array.length; i1 += (i1 & -i1)) {\n\t\t\t\tfor (int i2 = index2; i2 < array.length; i2 += (i2 & -i2)) {\n\t\t\t\t\tarray[i1][i2] += value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * (1,1)\u301c\u6307\u5b9a\u3057\u305f\u8981\u7d20\u307e\u3067\u306e\u77e9\u5f62\u548c\u3092\u53d6\u5f97\u3059\u308b\n\t\t * \u8a08\u7b97\u91cf\u306fO(logN * logN)\n\t\t * @param index1 \u548c\u306e\u7d42\u7aef\u3068\u306a\u308b\u8981\u7d20\u306e1\u6b21\u5143\u76ee\u306e\u6dfb\u5b57\n\t\t * @param index2 \u548c\u306e\u7d42\u7aef\u3068\u306a\u308b\u8981\u7d20\u306e2\u6b21\u5143\u76ee\u306e\u6dfb\u5b57\n\t\t * @return (1,1)\u301c(index1,index2)\u307e\u3067\u306e\u77e9\u5f62\u548c\n\t\t */\n\t\tpublic long getSum(int index1, int index2) {\n\t\t\tlong sum = 0L;\n\t\t\tfor (int i1 = index1; i1 > 0; i1 -= (i1 & -i1)) {\n\t\t\t\tfor (int i2 = index2; i2 > 0; i2 -= (i2 & -i2)) {\n\t\t\t\t\tsum += array[i1][i2];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\n\tinterface UnionFind {\n\t\tvoid union(int A, int B);\n\t\tboolean judge(int A, int B);\n\t\tSet<Integer> getSet(int id);\n\t}\n\n\t/**\n\t * ArrayUnionFind\u306e\u62e1\u5f35\n\t * MapSet\u3067\u6839\u306e\u6dfb\u5b57\u304b\u3089\u6839\u306b\u3076\u3089\u4e0b\u304c\u308b\u9802\u70b9\u306e\u96c6\u5408\u304c\u53d6\u5f97\u3067\u304d\u308b\u3088\u3046\u306b\u3057\u305f\n\t * getSet\u30e1\u30bd\u30c3\u30c9\u3092O(logN * logN)\u306b\u843d\u3068\u305b\u3066\u3044\u308b\u306f\u305a\n\t * \u305f\u3060\u3057union\u30e1\u30bd\u30c3\u30c9\u306f2\u500d\u306e\u8a08\u7b97\u91cf\u306b\u306a\u3063\u3066\u3044\u308b\u306e\u3067\u6ce8\u610f(\u30aa\u30fc\u30c0\u30fc\u306f\u5909\u308f\u3089\u306a\u3044\u306f\u305a)\n\t */\n\tclass SetUnionFind extends ArrayUnionFind {\n\t\tMap<Integer, Set<Integer>> map;\n\t\tpublic SetUnionFind(int size) {\n\t\t\tsuper(size);\n\t\t\tmap = new HashMap<>();\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tmap.put(i, new HashSet<>());\n\t\t\t\tmap.get(i).add(i);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tprotected void unionTo(int source, int dest) {\n\t\t\tsuper.unionTo(source, dest);\n\t\t\tmap.get(dest).addAll(map.get(source));\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<Integer> getSet(int id) {\n\t\t\treturn map.get(root(id));\n\t\t}\n\t}\n\n\t/**\n\t * \u914d\u5217\u306b\u3088\u308bUnionFind\u306e\u5b9f\u88c5\n\t * getSet\u30e1\u30bd\u30c3\u30c9\u306fO(NlogN)\u306a\u306e\u3067TLE\u306b\u6ce8\u610f\n\t */\n\tclass ArrayUnionFind implements UnionFind {\n\t\tint[] parent;\n\t\tint[] rank;\n\t\tint size;\n\t\tpublic ArrayUnionFind(int size) {\n\t\t\tparent = new int[size];\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tparent[i] = i;\n\t\t\t}\n\t\t\trank = new int[size];\n\t\t\tthis.size = size;\n\t\t}\n\n\t\t@Override\n\t\tpublic void union(int A, int B) {\n\t\t\tint rootA = root(A);\n\t\t\tint rootB = root(B);\n\t\t\tif (rootA != rootB) {\n\t\t\t\tif (rank[rootA] < rank[rootB]) {\n\t\t\t\t\tunionTo(rootA, rootB);\n\t\t\t\t} else {\n\t\t\t\t\tunionTo(rootB, rootA);\n\t\t\t\t\tif (rank[rootA] == rank[rootB]) {\n\t\t\t\t\t\trank[rootA]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprotected void unionTo(int source, int dest) {\n\t\t\tparent[source] = dest;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean judge(int A, int B) {\n\t\t\treturn root(A) == root(B);\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<Integer> getSet(int id) {\n\t\t\tSet<Integer> set = new HashSet<>();\n\t\t\tIntStream.range(0, size).filter(i -> judge(i, id)).forEach(set::add);\n\t\t\treturn set;\n\t\t}\n\n\t\tprotected int root(int id) {\n\t\t\tif (parent[id] == id) {\n\t\t\t\treturn id;\n\t\t\t}\n\t\t\tparent[id] = root(parent[id]);\n\t\t\treturn parent[id];\n\t\t}\n\t}\n\n\t/**\n\t * \u7d20\u6570\u306e\u30e6\u30fc\u30c6\u30a3\u30ea\u30c6\u30a3\n\t */\n\tclass PrimeNumberUtils {\n\t\tboolean[] isPrimeArray;\n\t\tList<Integer> primes;\n\n\t\t/**\n\t\t * \u7d20\u6570\u5224\u5b9a\u306e\u4e0a\u9650\u3068\u306a\u308b\u5024\u3092\u6307\u5b9a\u3057\u3066\u30e6\u30fc\u30c6\u30a3\u30ea\u30c6\u30a3\u3092\u521d\u671f\u5316\n\t\t * @param limit \u7d20\u6570\u5224\u5b9a\u306e\u4e0a\u9650(\u3053\u306e\u5024\u4ee5\u4e0a\u304c\u7d20\u6570\u3067\u3042\u308b\u304b\u5224\u5b9a\u3057\u306a\u3044)\n\t\t */\n\t\tpublic PrimeNumberUtils(int limit) {\n\t\t\tif (limit > 10000000) {\n\t\t\t\tSystem.err.println(\"\u4e0a\u9650\u306e\u5024\u304c\u9ad8\u3059\u304e\u308b\u305f\u3081\u7d20\u6570\u30e6\u30fc\u30c6\u30a3\u30ea\u30c6\u30a3\u306e\u521d\u671f\u5316\u3067TLE\u3059\u308b\u53ef\u80fd\u6027\u304c\u5927\u5909\u9ad8\u3044\u3067\u3059\");\n\t\t\t}\n\t\t\tprimes = new ArrayList<>();\n\t\t\tisPrimeArray = new boolean[limit];\n\t\t\tif (limit > 2) {\n\t\t\t\tprimes.add(2);\n\t\t\t\tisPrimeArray[2] = true;\n\t\t\t}\n\n\t\t\tfor (int i = 3; i < limit; i += 2) {\n\t\t\t\tif (isPrime(i, primes)) {\n\t\t\t\t\tprimes.add(i);\n\t\t\t\t\tisPrimeArray[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic List<Integer> getPrimeNumberList() {\n\t\t\treturn primes;\n\t\t}\n\n\t\tpublic boolean isPrime(int n) {\n\t\t\treturn isPrimeArray[n];\n\t\t}\n\n\t\tprivate boolean isPrime(int n, List<Integer> primes) {\n\t\t\tfor (int prime : primes) {\n\t\t\t\tif (n % prime == 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (prime > Math.sqrt(n)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tinterface BitSet {\n\t\tvoid set(int index, boolean bit);\n\t\tboolean get(int index);\n\t\tvoid shiftRight(int num);\n\t\tvoid shiftLeft(int num);\n\t\tvoid or(BitSet bitset);\n\t\tvoid and(BitSet bitset);\n\t}\n\n\t/**\n\t * Long\u306e\u914d\u5217\u306b\u3088\u308bBitSet\u306e\u5b9f\u88c5\n\t * get/set\u306fO(1)\n\t * shift/or/and\u306fO(size / 64)\n\t */\n\tclass LongBit implements BitSet {\n\t\tlong[] bitArray;\n\n\t\tpublic LongBit(int size) {\n\t\t\tbitArray = new long[((size + 63) / 64)];\n\t\t}\n\n\t\t@Override\n\t\tpublic void set(int index, boolean bit) {\n\t\t\tint segment = index / 64;\n\t\t\tint inIndex = index % 64;\n\t\t\tif (bit) {\n\t\t\t\tbitArray[segment] |= 1L << inIndex;\n\t\t\t} else {\n\t\t\t\tbitArray[segment] &= ~(1L << inIndex);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean get(int index) {\n\t\t\tint segment = index / 64;\n\t\t\tint inIndex = index % 64;\n\t\t\treturn (bitArray[segment] & (1L << inIndex)) != 0L;\n\t\t}\n\n\t\t@Override\n\t\tpublic void shiftRight(int num) {\n\t\t\tint shiftSeg = num / 64;\n\t\t\tint shiftInI = num % 64;\n\t\t\tfor (int segment = 0; segment < bitArray.length; segment++) {\n\t\t\t\tint sourceSeg = segment + shiftSeg;\n\t\t\t\tif (sourceSeg < bitArray.length) {\n\t\t\t\t\tbitArray[segment] = bitArray[sourceSeg] >>> shiftInI;\n\t\t\t\t\tif (shiftInI > 0 && sourceSeg + 1 < bitArray.length) {\n\t\t\t\t\t\tbitArray[segment] |= bitArray[sourceSeg + 1] << (64 - shiftInI);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbitArray[segment] = 0L;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void shiftLeft(int num) {\n\t\t\tint shiftSeg = num / 64;\n\t\t\tint shiftInI = num % 64;\n\t\t\tfor (int segment = bitArray.length - 1; segment >= 0; segment--) {\n\t\t\t\tint sourceSeg = segment - shiftSeg;\n\t\t\t\tif (sourceSeg >= 0) {\n\t\t\t\t\tbitArray[segment] = bitArray[sourceSeg] << shiftInI;\n\t\t\t\t\tif (shiftInI > 0 && sourceSeg > 0) {\n\t\t\t\t\t\tbitArray[segment] |= bitArray[sourceSeg - 1] >>> (64 - shiftInI);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbitArray[segment] = 0L;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic long getLong(int segment) {\n\t\t\treturn bitArray[segment];\n\t\t}\n\n\t\t@Override\n\t\tpublic void or(BitSet bitset) {\n\t\t\tif (!(bitset instanceof LongBit)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int segment = 0; segment < bitArray.length; segment++) {\n\t\t\t\tbitArray[segment] |= ((LongBit)bitset).getLong(segment);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void and(BitSet bitset) {\n\t\t\tif (!(bitset instanceof LongBit)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int segment = 0; segment < bitArray.length; segment++) {\n\t\t\t\tbitArray[segment] &= ((LongBit)bitset).getLong(segment);\n\t\t\t}\n\t\t}\n\t}\n\n}", "code2": "d=*1..gets.to_i;\ngets.chop.bytes{|c|\n\tx=0;n=d.pop;\n\td.map!{|a|x=(x+n*c[1]+(1-c%3)*a).%10**9+7}\n}\np *d", "label": 0, "name1": "s208804589.java", "name2": "s587396214.rb"}, {"id": 447, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        BRemovingBlocks solver = new BRemovingBlocks();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BRemovingBlocks {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            long[] a = in.readLongArray(n);\n\n            Modulo.mod = MiscUtils.MOD7;\n\n            long[] s = new long[n];\n            s[0] = 1;\n            for (int i = 1; i < n; i++) {\n                s[i] = Modulo.add(s[i - 1], Modulo.rev(i + 1));\n            }\n\n            long ans = 0;\n            for (int i = 0; i < n; i++) {\n                long sum = Modulo.mlt(a[i], s[i] + s[n - 1 - i] - 1);\n                ans = Modulo.add(ans, sum);\n            }\n            for (int i = 1; i <= n; i++) ans = Modulo.mlt(ans, i);\n            out.printLine(ans);\n        }\n\n    }\n\n    static class Modulo {\n        public static long mod;\n        private long value;\n\n        public Modulo(long value) {\n            this.value = (value % mod + mod) % mod;\n        }\n\n        public static long add(long a, long b) {\n            return ((a + b) % mod + mod) % mod;\n        }\n\n        public static long mlt(long a, long b) {\n            return ((a % mod + mod) * (b % mod + mod)) % mod;\n        }\n\n        public static long rev(long a) {\n            //return pow(a, mod - 2);\n            return (Euclid.extgcd(a, mod, new long[3])[0] % mod + mod) % mod;\n        }\n\n        public String toString() {\n            return \"\" + value;\n        }\n\n    }\n\n    static class Euclid {\n        public static long[] extgcd(long a, long b, long[] is) {\n            if (a == 0) {\n                is[0] = 0;\n                is[1] = 1;\n                is[2] = b;\n            } else {\n                extgcd(b % a, a, is);\n                long x = is[1] - b / a * is[0];\n                is[1] = is[0];\n                is[0] = x;\n            }\n            return is;\n        }\n\n    }\n\n    static class MiscUtils {\n        public static final int MOD7 = (int) (1e9 + 7);\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public long[] readLongArray(int size) {\n            long[] array = new long[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readLong();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long readLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "code2": "n=gets.to_i\na=gets.split.map &:to_i\n\ndef pow(a,b,mod)\n  return 1 if b==0\n  return (a**b[0]*pow(a,b/2,mod)**2)%mod\nend\n\ndef inv(a,mod)\n  pow(a,mod-2,mod)\nend\n\nmod=10**9+7\n\nf=1\n1.upto(n){|i|f=f*i%mod}\n\nd=0,*(1..n).map{|j|f*inv(j,mod)%mod}\n\ns=d.dup\n1.upto(n){|i|s[i]+=s[i-1];s[i]%=mod}\n\nr=0\n\nn.times{|i|\n  #q=[1,*2..(n-i),*2..(i+1)].map{|j|ff/j}.reduce(:+)\n  q=f+s[n-i]-s[1]+s[i+1]-s[1]\n  r=(r+a[i]*q)%mod\n}\n\np r", "label": 1, "name1": "s003754625.java", "name2": "s199570329.rb"}, {"id": 341, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        PrintWriter out = new PrintWriter(System.out);\n        InputStreamScanner in = new InputStreamScanner(System.in);\n        new Main().solve(in, out);\n        out.flush();\n    }\n\n    private void solve(InputStreamScanner in, PrintWriter out) {\n        String s = in.next();\n\n        long t = 0;\n        for (int i = 0; i < 1 << (s.length() - 1); i++) {\n            int p = 0;\n            for (int j = 0; j < s.length() - 1; j++) {\n                if ((1 & i >> j) == 1) {\n                    t += Long.parseLong(s.substring(p, j + 1));\n                    p = j + 1;\n                }\n            }\n            t += Long.parseLong(s.substring(p));\n        }\n\n        out.println(t);\n    }\n\n    static class InputStreamScanner {\n\n        private InputStream in;\n\n        private byte[] buf = new byte[1024];\n        private int len = 0;\n        private int off = 0;\n\n        InputStreamScanner(InputStream in)\t{\n            this.in = in;\n        }\n\n        String next() {\n            StringBuilder sb = new StringBuilder();\n            for (int b = skip(); !isSpace(b);){\n                sb.appendCodePoint(b);\n                b = read();\n            }\n            return sb.toString();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        char nextChar() {\n            return (char)skip();\n        }\n\n        int skip() {\n            for (int b; (b = read()) != -1;) {\n                if (!isSpace(b)) {\n                    return b;\n                }\n            }\n            return -1;\n        }\n\n        private boolean isSpace(int c) {\n            return c < 33 || c > 126;\n        }\n\n        private int read() {\n            if (len == -1) {\n                throw new InputMismatchException(\"End of Input\");\n            }\n            if (off >= len){\n                off = 0;\n                try {\n                    len = in.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException(e.getMessage());\n                }\n                if (len <= 0) {\n                    return -1;\n                }\n            }\n            return buf[off++];\n        }\n    }\n}", "code2": "def f s;if s.empty? then [1,0] else (1..s.size).map{|i|l=s[0...i].to_i;b,r=f(s[i..-1]);[b, b*l+r]}.reduce([0,0]){|(x,y),(a,b)|[x+a, y+b]}end end\nputs (f gets.chomp)[1]", "label": 1, "name1": "s838868939.java", "name2": "s213753832.rb"}, {"id": 532, "code1": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt(), result = 0, combo = 0, color = 0;\n        for (int i = 0; i < n; i++) {\n            int j = scanner.nextInt();\n            combo++;\n\n            if (j != color) {\n                result += combo / 2;\n                combo = 0;\n                color = j;\n            }\n        }\n        System.out.println(result + ++combo / 2);\n    }\n}", "code2": "### main\n\nsec = 0\n4.times do\n  sec += gets.strip.to_i\nend\n\nputs sec / 60\nputs sec % 60", "label": 0, "name1": "s379654146.java", "name2": "s928347272.rb"}, {"id": 561, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        final Scanner sc = new Scanner(System.in);\n\n        final long n = sc.nextLong();\n        final long k = sc.nextLong();\n\n        final long t = n % k;\n        System.out.println(Math.min(t, k-t));\n    }\n}\n", "code2": "a,b,c = gets.split.map(&:to_f)\nr = c * Math::PI / 180\nh = b * Math.sin(r)\ns = a * h / 2\nw = b * Math.cos(r)\nd = Math.hypot(a-w,h)\nl = a + b + d\nputs [s,l,h] * \"\\n\"", "label": 0, "name1": "s071954198.java", "name2": "s377972091.rb"}, {"id": 998, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args){\n    \tScanner sc = new Scanner(System.in);\n        int t = sc.nextInt();\n        do{\n        \tint n = sc.nextInt();\n        \tint sum = 0;\n        \tfor(int i = 0;i < n;i++){\n        \t\tsum += Math.abs(sc.nextInt() - sc.nextInt());\n        \t}\n        \tif(sum >= t){\n        \t\tSystem.out.println(\"OK\");\n        \t}else{\n        \t\tSystem.out.println(t - sum);\n        \t}\n        } while((t = sc.nextInt()) != 0);\n    }\n}\n", "code2": "N, T, A, *H = gets(p).split.map &:to_i\np H.map.with_index(1){|h, i|[(A - (T - h*0.006)).abs, i]}.min[1]", "label": 0, "name1": "s454750992.java", "name2": "s610653651.rb"}, {"id": 212, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    void solve() throws IOException {\n    \tint N = ni();\n\n    \tint[] T = new int[N];\n    \tint[] A = new int[N];\n\n    \tfor (int i=0; i<N; i++) {\n\t\t\tT[i] = ni();\n\t\t\tA[i] = ni();\n\t\t}\n\n    \tlong t = T[0];\n    \tlong a = A[0];\n\n    \tfor (int i=1; i<N; i++) {\n    \t\tlong x = (t%T[i]==0)? t/T[i] : (t/T[i] + 1);\n    \t\tlong y = (a%A[i]==0)? a/A[i] : (a/A[i] + 1);\n    \t\tt = T[i] * Math.max(x, y);\n    \t\ta = A[i] * Math.max(x, y);\n    \t}\n\n    \tout.println(t + a);\n    }\n\n    String ns() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine(), \" \");\n        }\n        return tok.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.parseInt(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.parseLong(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.parseDouble(ns());\n    }\n\n    String[] nsa(int n) throws IOException {\n        String[] res = new String[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ns();\n        }\n        return res;\n    }\n\n    int[] nia(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ni();\n        }\n        return res;\n    }\n\n    long[] nla(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nl();\n        }\n        return res;\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        tok = new StringTokenizer(\"\");\n        Main main = new Main();\n        main.solve();\n        out.close();\n    }\n}\n", "code2": "n = gets.to_i\nta = 1\naa = 1\n\nn.times{\n  t,a = gets.split.map &:to_i\n  x = [(ta+(t-1))/t, (aa+(a-1))/a].max\n  ta = t*x\n  aa = a*x\n}\n\np ta+aa\n", "label": 1, "name1": "s760488688.java", "name2": "s479644097.rb"}, {"id": 839, "code1": "import java.util.Scanner;\n\tpublic class Main {\n\tprivate static Scanner scanner;\n\tpublic static void main(String args[]) {\n\n\t\tscanner = new Scanner(System.in);\n\t\tint a = scanner.nextInt();\n\t\tint[] b = new int[a];\n\t\tint minj,count = 0;\n\t\tfor(int i=0;i < a;i++) b[i] = scanner.nextInt();\n\n\t\tfor(int i = 0;i < a;i++) {\n\t\t\tminj = i;\n\t\t\tfor(int j = i;j < a;j++) {\n\t\t\t\tif(b[j] < b[minj]) {\n\t\t\t\t\tminj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tif(minj != i) {\n\t\t\t\t\tint tmp = b[i];\n\t\t\t\t\tb[i] = b[minj];\n\t\t\t\t\tb[minj] = tmp;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t}\n\t\tfor(int i=0;i < a;i++) {\n\t\t\tSystem.out.print(b[i]);\n\t\t\tif(i == a-1) System.out.println(\"\");\n\t\t\telse System.out.print(\" \");\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n\t}\n\n", "code2": "rs = []\nbs = []\n24.times.map { p, t = gets.split; [t.to_f, p.to_i] }.each_slice(8).map(&:sort).each {|as| rs += as[0...2]; bs += as[2..-1] }\nbs.sort!\nrs += bs[0...2]\nrs.each {|t, p| puts '%d %.2f' % [p, t] }", "label": 0, "name1": "s404045978.java", "name2": "s863098923.rb"}, {"id": 599, "code1": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint[] pri = new int[25000];\n\t\tpri[0] = 2;\n\t\tpri[1] = 3;\n\t\tpri[2] = 5;\n\t\tpri[3] = 7;\n\t\tpri[4] = 11;\n\t\tpri[5] = 13;\n\t\tpri[6] = 17;\n\t\tpri[7] = 19;\n\t\tpri[8] = 23;\n\t\tpri[9] = 29;\n\t\tint fl = 0;\n\t\tint a=0;\n\t\tint b=0;\n\t\tint c=0;\n\t\twhile(pri[a]<=250000){\n\t\t\tfl++;\n\t\t\tfor(int i=0;i<8;i++){\n\t\t\t\ta=0;\n\t\t\t\tb=0;\n\t\t\t\tc=0;\t\t\t\t\n\t\t\t\tif(i==0){\n\t\t\t\t\tc=1;\n\t\t\t\t}else if(i>0){\n\t\t\t\t\tc=pri[2+i];\n\t\t\t\t}\n\t\t\t\twhile(pri[a]!=0){\n\t\t\t\t\tif((30*fl + c)%pri[a]==0){\n\t\t\t\t\t\tb=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ta++;\n\t\t\t\t}\n\t\t\t\tif(b==0){\n\t\t\t\t\tpri[a]=(30*fl + c);\n\t\t\t\t}\n\t\t\t}\t\t\t\t\t\n\t\t}\n\t\t\n\t\tboolean exit = true;\n\t\twhile(exit==true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)exit=false;\n\t\t\tif(exit==true){\n\t\t\t\tint sum=-1;\n\t\t\t\tint i=0;\n\t\t\t\twhile(true){\n\t\t\t\t\tif(pri[i]>n)sum++;\n\t\t\t\t\tif(pri[i]>2*n)break;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(sum);\n\t\t\t}\n\t\t}\n\t}\n\t\n}", "code2": "a = []\na = gets.chomp.split(\"\")\n#p a\ns =[]\na.each do |i|\n    #p i\n    if i == \"S\"\n        #p i\n        s.push(i)\n    elsif i == \"T\"\n        #p i\n        if s[-1] == \"T\" || s.length == 0\n            s.push(i)\n        elsif s[-1] == \"S\"\n            s.pop\n        end\n    end\nend\n#p s\nputs s.length", "label": 0, "name1": "s593802453.java", "name2": "s966060238.rb"}, {"id": 305, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyScanner in = new MyScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        C solver = new C();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class C {\n        int N;\n        int M;\n\n        public void solve(int testNumber, MyScanner in, PrintWriter out) {\n            N = in.Int();\n            M = in.Int();\n            DSU dsu = new DSU(N);\n            for (int i = 0; i < M; i++) {\n                int A = in.Int() - 1;\n                int B = in.Int() - 1;\n                dsu.merge(A, B);\n            }\n            out.println(dsu.groups().size() - 1);\n        }\n\n    }\n\n    static class DSU {\n        private int n;\n        private int[] parentOrSize;\n\n        public DSU(int n) {\n            this.n = n;\n            this.parentOrSize = new int[n];\n            Arrays.fill(parentOrSize, -1);\n        }\n\n        int merge(int a, int b) {\n            if (!(0 <= a && a < n))\n                throw new IndexOutOfBoundsException(\"a=\" + a);\n            if (!(0 <= b && b < n))\n                throw new IndexOutOfBoundsException(\"b=\" + b);\n\n            int x = leader(a);\n            int y = leader(b);\n            if (x == y) return x;\n            if (-parentOrSize[x] < -parentOrSize[y]) {\n                int tmp = x;\n                x = y;\n                y = tmp;\n            }\n            parentOrSize[x] += parentOrSize[y];\n            parentOrSize[y] = x;\n            return x;\n        }\n\n        int leader(int a) {\n            if (parentOrSize[a] < 0) {\n                return a;\n            } else {\n                parentOrSize[a] = leader(parentOrSize[a]);\n                return parentOrSize[a];\n            }\n        }\n\n        ArrayList<ArrayList<Integer>> groups() {\n            int[] leaderBuf = new int[n];\n            int[] groupSize = new int[n];\n            for (int i = 0; i < n; i++) {\n                leaderBuf[i] = leader(i);\n                groupSize[leaderBuf[i]]++;\n            }\n            ArrayList<ArrayList<Integer>> result = new ArrayList<>(n);\n            for (int i = 0; i < n; i++) {\n                result.add(new ArrayList<>(groupSize[i]));\n            }\n            for (int i = 0; i < n; i++) {\n                result.get(leaderBuf[i]).add(i);\n            }\n            result.removeIf(ArrayList::isEmpty);\n            return result;\n        }\n\n    }\n\n    static class MyScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public MyScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    return null;\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int Int() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "code2": "class UFTree\n  def initialize(n)\n    @p = Array.new(n + 1, -1)\n  end\n  def find(x)\n    @p[x] < 0 ? x : @p[x] = find(@p[x])\n  end\n  def unite(a, b)\n    x = find(a)\n    y = find(b)\n    if x != y\n      x, y = y, x if @p[y] < @p[x]\n      @p[y] = x\n    end\n  end\n  def parents\n    @p\n  end\nend\n\nN, M = gets.split.map(&:to_i)\n\ntree = UFTree.new(N)\nM.times do\n  a, b = gets.split.map(&:to_i)\n  tree.unite(a, b)\nend\nputs tree.parents.count{|x| x < 0} - 2\n", "label": 1, "name1": "s578903603.java", "name2": "s077496023.rb"}, {"id": 394, "code1": "\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scn = new Scanner(System.in);\n\n        long a = scn.nextLong(), b = scn.nextLong(), x = scn.nextLong();\n        long ans = 0;\n\n        ans = (b / x) - (a / x);\n\n        if(a % x == 0){\n            ans++;\n        }\n\n        System.out.println(ans);\n\n    }\n\n}", "code2": "w=gets.chomp\nw=w.split(\" \")\na=w[0].to_i\nb=w[1].to_i\nx=w[2].to_i\nans=b / x - (a - 1) / x\nputs ans", "label": 1, "name1": "s378055358.java", "name2": "s552722041.rb"}, {"id": 232, "code1": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-9;\n\n\tint n;\n\tint start, goal, ttl;\n\tLinkedList<Integer>[] graph;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tn = sc.nextInt();\n\t\tgraph = new LinkedList[n];\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint u = sc.nextInt() - 1;// \u0083\u008b\u0081[\u0083^\u0094\u00d4\u008d\u0086\n\t\t\tint m = sc.nextInt();\n\t\t\tgraph[u] = new LinkedList<Integer>();\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint v = sc.nextInt() - 1;\n\t\t\t\tgraph[u].add(v);\n\t\t\t}\n\t\t}\n\t\tint p = sc.nextInt();\n\t\tfor (int i = 0; i < p; i++) {\n\t\t\tstart = sc.nextInt() - 1;\n\t\t\tgoal = sc.nextInt() - 1;\n\t\t\tttl = sc.nextInt();\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve() {\n\t\tLinkedList<Integer> que = new LinkedList<Integer>();\n\t\tboolean[] visited = new boolean[n];\n\t\tint[] d = new int[n];\n\t\tArrays.fill(d, INF);\n\t\tque.offer(start);\n\t\td[start] = 1;\n\t\tvisited[start] = true;\n\t\tfor (; !que.isEmpty();) {\n\t\t\tint u = que.poll();\n\t\t\tfor (int v : graph[u]) {\n\t\t\t\tif (!visited[v]) {\n\t\t\t\t\tque.offer(v);\n\t\t\t\t\td[v] = d[u] + 1;\n\t\t\t\t\tvisited[v] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[goal] <= ttl) {\n\t\t\tprintln(\"\" + d[goal]);\n\t\t} else {\n\t\t\tprintln(\"NA\");\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s) {\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s) {\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}", "code2": "n = gets.to_i\ndp = Array.new(n) { Array.new n }\nn.times do |i|\n  r, _, *ts = gets.split.map(&:to_i)\n  ts.each {|j| dp[r-1][j-1] = 1 }\n  dp[i][i] = 0\nend\nn.times do |k|\n  n.times do |i|\n    n.times do |j|\n      dp[i][j] = dp[i][k] + dp[k][j] if dp[i][k] && dp[k][j] && (!dp[i][j] || dp[i][k] + dp[k][j] < dp[i][j])\n    end\n  end\nend\ngets.to_i.times do\n  s, d, v = gets.split.map(&:to_i)\n  puts dp[s-1][d-1] && dp[s-1][d-1] + 1 <= v ? dp[s-1][d-1] + 1 : 'NA'\nend", "label": 1, "name1": "s019260377.java", "name2": "s305207862.rb"}, {"id": 566, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in);) {\n\t\t\tdouble a = sc.nextDouble();\n\t\t\tdouble b = sc.nextDouble();\n\t\t\tdouble c = sc.nextDouble();\n\t\t\t//\uff12\u70b9\u9593\u306e\u8ddd\u96e2\n\t\t\tdouble s = (a * b / 2 * Math.sin(Math.toRadians(c)));\n\t\t\t\tSystem.out.println(s);\n\t\t\tdouble l = (a + b +Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) - 2 * a * b\n\t\t\t\t\t* Math.cos(Math.toRadians(c))));\n\t\t\t\tSystem.out.println(l);\n\t\t\tdouble h = (b * Math.sin(Math.toRadians(c)));\n\t\t\t\tSystem.out.println(h);\n\t\t}\n\t}\n}\n", "code2": "#! /usr/bin/env ruby\n\nabc = gets.split(\" \")\n\na = abc[0].to_i\nb = abc[1].to_i\nc = abc[2].to_i\n\n\n\n\nif( (a <= c && b >= c) || (a >= c && b <= c) )\n\n    puts \"Yes\"\n  else\n    puts \"No\" \nend", "label": 0, "name1": "s947759194.java", "name2": "s075380624.rb"}, {"id": 443, "code1": "import java.io.*;\nimport java.util.*;\n \npublic class Main {\n\tstatic final Reader in = new Reader();\n\tstatic final long M=(long)1e9+7;\n\t\n\tpublic static void main(String[] args) {\n\t\tint n=in.nextInt();\n\t\tlong[] ps = new long[n+1];\n\t\tlong nf=1;\n\t\tfor(int i=1; i<=n; ++i) {\n\t\t\tps[i]=(ps[i-1]+in.nextInt())%M;\n\t\t\tnf=nf*i%M;\n\t\t}\n\t\tlong ans=nf*ps[n]%M, s=0;\n\t\tfor(int i=1; i<=n-1; ++i) {\n\t\t\ts=(s+ps[n-i]-ps[i]+M)%M;\n\t\t\tans=(ans+nf*modI((long)(i+1)*(i>=n-1?1:i+2), M)%M*2*s+nf*modI(i+1, M)%M*(ps[i]+ps[n]-ps[n-i]+M))%M;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\t\n\tstatic long modI(long a, long m) {\n\t\treturn (a%=m)<=1?1:(1-modI(m%a, a)*m)/a+m;\n\t}\n\t\n\tstatic class Reader {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st;\n\t\tString next() {\n\t\t\twhile(st==null||!st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch(Exception e) {}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t}\n}", "code2": "n=gets.to_i\na=gets.split.map &:to_i\n\ndef pow(a,b,mod)\n  return 1 if b==0\n  return (a**b[0]*pow(a,b/2,mod)**2)%mod\nend\n\ndef inv(a,mod)\n  pow(a,mod-2,mod)\nend\n\nmod=10**9+7\n\nf=1\n1.upto(n){|i|f=f*i%mod}\n\nd=0,*(1..n).map{|j|f*inv(j,mod)%mod}\n\ns=d.dup\n1.upto(n){|i|s[i]+=s[i-1];s[i]%=mod}\n\nr=0\n\nn.times{|i|\n  #q=[1,*2..(n-i),*2..(i+1)].map{|j|ff/j}.reduce(:+)\n  q=f+s[n-i]-s[1]+s[i+1]-s[1]\n  r=(r+a[i]*q)%mod\n}\n\np r", "label": 1, "name1": "s013996602.java", "name2": "s199570329.rb"}, {"id": 238, "code1": "import java.util.*;\nimport java.io.*;\n\nclass Main {\n    static int searchP(long p,int[] ws){\n        int count = 1;\n        int sum = 0; \n        for(int i = 0; i < ws.length; i++){\n            if(sum + ws[i] <= p) {\n            sum += ws[i];\n            } else {\n                count++;\n                if(ws[i] <= p){\n                sum = ws[i];\n                } else{\n                    count += 99999;\n                }\n            }\n        }\n        return count;\n    }\n    static long solve(long p, int[] ws, long k){\n        long right = p;\n        long left = 0;\n        long mid;\n        while(right - left > 1) {\n            mid = (left + right) / 2;\n            int v = searchP(mid,ws);\n            if(k >= v) {\n                right = mid;\n            } else {\n               left = mid;\n                \n            }\n        }\n    return right;\n    }\n    public static void main(String...args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        \n        String[] info = br.readLine().split(\" \");\n        int n = Integer.parseInt(info[0]);\n        int k = Integer.parseInt(info[1]);\n        int[] ws = new int[n];\n        for(int i = 0; i < n; i++) {\n            ws[i] = Integer.parseInt(br.readLine());\n        }\n        long p = 100000 * 10000;\n        System.out.println(solve(p,ws,k));\n        \n    }\n}\n\n\n\n", "code2": "n, k = gets.chomp.split(' ').map(&:to_i)\nw = n.times.map{gets.chomp.to_i}\n\nN_MAX = K_MAX = 100000\nW_MAX = 10000\n\nleft = 0\nright = N_MAX * W_MAX\nmid = nil\n\nload_buggage = -> (p) do\n  i = 0\n  0.step(k-1) do |j|\n    s = 0\n    #STDERR.puts \"  kj=#{j}\"\n    while s + w[i] <= p\n      s += w[i]\n      #STDERR.puts \"    #{i}: w[#{i}]=#{w[i]}, s=#{s}\"\n      i += 1\n      break if i == n\n    end\n    break if i == n\n  end\n  #STDERR.puts \"load: #{i}\"\n  i\nend\n\nuntil (right - left) == 1 do\n  mid = (left + right) / 2\n  #STDERR.puts \"L=#{left}, M=#{mid}, R=#{right}\"\n  v = load_buggage.(mid)\n  if (v >= n)\n    right = mid\n  else\n    left = mid\n  end\nend\n\nputs right\n", "label": 1, "name1": "s705576178.java", "name2": "s107592187.rb"}, {"id": 318, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author cunbidun\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        EProductOfArithmeticProgression solver = new EProductOfArithmeticProgression();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EProductOfArithmeticProgression {\n        private static final int MOD = (int) 1e6 + 3;\n        private InputReader in;\n        private PrintWriter out;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            this.in = in;\n            this.out = out;\n            int q = in.nextInt();\n\n            int[] fac = new int[MOD + 1];\n            int[] inv = new int[MOD + 1];\n            fac[0] = 1;\n            inv[0] = Op.inv(1, MOD);\n            for (int i = 1; i <= MOD; i++) {\n                fac[i] = Op.mulMod(fac[i - 1], i, MOD);\n                inv[i] = Op.inv(fac[i], MOD);\n            }\n\n            while (q-- > 0) {\n                int x = in.nextInt();\n                int d = in.nextInt();\n                int n = in.nextInt();\n                if (d == 0) {\n                    out.println(Op.powMod(x, n, MOD));\n                    continue;\n                }\n                x = Op.mulMod(x, Op.inv(d, MOD), MOD);\n                int ans;\n                if (x + n - 1 >= MOD || x == 0) ans = 0;\n                else\n                    ans = Op.mulMod(fac[x + n - 1], inv[x - 1], MOD);\n                out.println(Op.mulMod(ans, Op.powMod(d, n, MOD), MOD));\n            }\n        }\n\n    }\n\n    static class Op {\n        public static int mulMod(int x, int y, int MOD) {\n            return (int) (((long) x * y) % MOD);\n        }\n\n        public static int powMod(int x, long p, int MOD) {\n            if (p == 0) return 1;\n            int t = powMod(x, p / 2, MOD);\n            if ((p & 1) == 1)\n                return mulMod(mulMod(t, t, MOD), x, MOD);\n            return mulMod(t, t, MOD);\n        }\n\n        public static int inv(int x, int MOD) {\n            return powMod(x, MOD - 2, MOD);\n        }\n\n    }\n\n    static class InputReader extends InputStream {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private static boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n", "code2": "M=1000003\no=->a,n{n<1?1:(n%2>0?a:1)*o[a,n/2]**2%M}\n*f=1\n1.upto(M){|i|f<<f[i-1]*i%M}\ngets\n$<.map{|s|x,d,n=s.split.map &:to_i\nt=x*o[d,M-2]%M\np d<1?o[x,n]:M<t+n||t<1?0:f[t+n-1]*o[f[t-1],M-2]*o[d,n]%M}", "label": 1, "name1": "s606724970.java", "name2": "s699536087.rb"}, {"id": 37, "code1": "import java.util.Scanner;\n \npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            int[] s = new int[n];\n            double e = 0.0, v = 0.0;\n            for (int i = 0; i < n; i++) {\n                s[i] = sc.nextInt();\n                e += s[i];\n                v += s[i] * s[i];\n            }\n            e /= n;\n            v = v / n - e * e;\n            System.out.println(Math.sqrt(v));\n        }\n    }\n}\n", "code2": "while true do\n    n = gets.to_i\n    break if n == 0\n    array=gets.chomp.split(\" \").map(&:to_f)\n    average = array.inject(:+)/n\n    puts format(\"%0.5f\", (array.map {|e| (e-average)**2}.inject(:+)/n)**0.5)\nend\n", "label": 1, "name1": "s749350396.java", "name2": "s834861200.rb"}, {"id": 456, "code1": "/*\n *           AUTHOR: Maria Theresa M. Padayhag\n *             DATE: 20160326\n *  PRE-REQUIREMENT: JDK 1.8\n */\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.time.*;\nimport java.time.format.TextStyle;\nimport java.util.Locale;\n\nclass DayIndentifier\n{\n\tLocalDate date = null;\n\t\n\tpublic \tDayIndentifier( String inMonth, String inDay )\n\t{\n\t\t// NumberFormatException might be thrown here\n\t\t// but it will be handled by the caller.\n\t\tint month = Integer.parseInt( inMonth );\n\t\tint day   = Integer.parseInt( inDay );\n\t\t\n\t\t// DateTimeException might be thrown here\n\t\t// but it will be handled by the caller.\n\t\tdate = LocalDate.of( 2004, month, day );\n\t}\n\t\n\tpublic String getDayOfWeek()\n\t{\n\t\t// NullPointerException might be thrown here\n\t\t// but it will handled by the caller.\n\t\treturn date.getDayOfWeek().getDisplayName(TextStyle.FULL, Locale.ENGLISH);\n\t}\n}\n\npublic class Main\n{\n\tpublic static boolean toExit( String[] dataset )\n\t{\n\t\tfor(String data: dataset)\n\t\t{\n\t\t\tif(data.equals(\"0\"))\n\t\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic static void main( String args[] ) throws IOException\n\t{\n\t\tBufferedReader br = new BufferedReader( new InputStreamReader( System.in ) );\n\t\tString input;\n\t\tString dataset[];\n\t\tDayIndentifier di;\n\t\t\n\t\tREAD: \n\t\twhile( ( input = br.readLine() ) != null ) {\n\t\t\ttry {\n\t\t\t\tdataset = input.split(\" \");\n\t\t\t\n\t\t\t\tif( toExit( dataset ) ) {\n\t\t\t\t\tbreak READ;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif( dataset.length != 2 ) {\n\t\t\t\t\tSystem.out.println(\"Invalid input.\");\n\t\t\t\t\tcontinue READ;\n\t\t\t\t} \t\t\n\t\t\t\t\n\t\t\t\tdi = new DayIndentifier(dataset[0], dataset[1]);\n\t\t\t\tSystem.out.println( di.getDayOfWeek() );\n\t\t\t} catch( Exception e ) {\n\t\t\t\tSystem.out.println(\"Invalid input.\");\n\t\t\t\tcontinue READ;\n\t\t\t}\t\t\n\t\t}\n\t}\n}", "code2": "day=[\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\"]\nwhile true\n\tm,d=gets.chomp.split(\" \").map{|s| s.to_i}\n\tbreak if m==0&&d==0\n\tcount=2\n\tfor i in (1..m-1) do\n\t\tif(i==2) then \n\t\t\tcount+=29\n\t\telsif (i==4||i==6||i==9||i==11) then\n\t\t\tcount+=30\n\t\telse\n\t\t\tcount+=31\n\t\tend\t\n\tend\n\tcount+=d\n\tcount%=7\n\tputs day[count]\nend\n", "label": 1, "name1": "s944901694.java", "name2": "s196769013.rb"}, {"id": 697, "code1": "import java.util.*;\npublic class Main {\n        static Scanner sc = new Scanner(System.in);\n        static void myout(Object t){System.out.println(t);}//standard output\n        static void myerr(Object t){System.err.println(t);}//standard error\n        static String getStr(){return sc.next();}\n        static int getInt(){return Integer.parseInt(getStr());}\n        static long getLong(){return Long.parseLong(getStr());}\n        static boolean isNext(){return sc.hasNext();}\n        static String[] mySplit(String str){return str.split(\"\");}\n        public static void main(String[] args){\n          int N = getInt();\n          int M = getInt();\n          if(N >= M){\n            myout(0);\n            return;\n          }\n          long output = 0;\n          ArrayList<Integer> list = new ArrayList<Integer>(M);\n          for(int i = 0; i < M; i++){\n            list.add(getInt());\n          }\n          Collections.sort(list);\n          //myout(list);\n          PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\n          for(int i = 1; i < M; i++){\n            pq.add(Math.abs(list.get(i)-list.get(i-1)));\n          }\n          for(int i = 0; i < N-1; i++){\n            pq.poll();\n          }\n          while(pq.size() != 0){\n            output += pq.poll();\n          }\n          myout(output);\n        }\n        //\u4fbf\u5229\u30e1\u30bd\u30c3\u30c9\u8ffd\u52a0\u67a0\u3053\u3053\u304b\u3089\n\n        //\u4fbf\u5229\u30e1\u30bd\u30c3\u30c9\u8ffd\u52a0\u67a0\u3053\u3053\u307e\u3067\n}\n", "code2": "a,b,c=gets.chomp.split.map(&:to_i)\nif c-(a-b)<0\n  puts \"0\"\nelse\n  puts c-(a-b)\nend\n\n", "label": 0, "name1": "s460372083.java", "name2": "s801690691.rb"}, {"id": 719, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[] total = new int[3];\n\n\t\ttotal[0] = sc.nextInt();\n\t\ttotal[1] = sc.nextInt();\n\t\ttotal[2] = sc.nextInt();\n\n\t\tsc.close();\n\n\t\tArrays.sort(total);\n\n\t\tSystem.out.println(total[0] + total[1]);\n\t}\n}", "code2": "n,m=gets.split.map &:to_i\nmin=[]\nmax=[]\nm.times do\n  x,y=gets.split.map &:to_i\n  if x==1 || y==1\n    min<< [x,y].max\n  end\n  if x==n || y==n\n    max<< [x,y].min\n  end\n  \n  \nend\nputs min & max == [] ? :IMPOSSIBLE : :POSSIBLE\n  ", "label": 0, "name1": "s443302375.java", "name2": "s240457577.rb"}, {"id": 215, "code1": "import java.util.*;\npublic class Main{\n    public static void main(String args[]) {\n        Scanner cin = new Scanner(System.in);\n        while(cin.hasNext()){\n        \tint n = cin.nextInt();\n        \tint[][] vote = readMatrix(cin,n,2);\n        \tSystem.out.println(getNum(vote,n));\n        }\n    }\n    public static long getNum(int[][] vote, int n){\n    \tlong[] result={vote[0][0],vote[0][1]};\n    \tlong result1;\n    \tfor(int i=1;i<n;i++){\n    \t\tresult1 = result[1];\n    \t\tif(result[0]>vote[i][0]){\n    \t\t\tif(result[0]%vote[i][0]!=0) result[0] += vote[i][0]-result[0]%vote[i][0];\n    \t\t}else{result[0]=vote[i][0];}\n    \t\tresult[1] = result[0]/vote[i][0]*vote[i][1];\n    \t\tif(result1>result[1]){\n    \t\t\tresult[1] = result1;\n    \t\t\tif(result[1]%vote[i][1]!=0) result[1] += vote[i][1]-result[1]%vote[i][1];\n    \t\t\t result[0] = result[1]/vote[i][1]*vote[i][0];\n    \t\t}\n    \t}\n    \treturn result[0]+result[1];\n    }\n    public static int[][] readMatrix(Scanner in,int n,int m){\n    \tint[][] mtx = new int[n][m];\n    \tfor(int i=0;i<n;i++){\n    \t\tfor(int j=0;j<m;j++){\n    \t\t\tmtx[i][j] = in.nextInt();\n    \t\t}\n    \t}\n    \treturn mtx;\n    }\n    \n}", "code2": "N = gets.to_i\nT, A = [], []\nN.times{t, a = gets.split.map(&:to_i); T << t; A << a}\n\nvotes = (0 ... N).inject([0, 0]) do |(t, a), i|\n  if T[i] >= t && A[i] >= a\n    [T[i], A[i]]\n  else\n    m = [(t + T[i] - 1)/T[i], (a + A[i] - 1)/A[i]].max\n    [m*T[i], m*A[i]]\n  end\nend\nputs votes.inject(:+)\n", "label": 1, "name1": "s502019413.java", "name2": "s696031872.rb"}, {"id": 343, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tprivate void solve() {\n\t\tScanner io = new Scanner(System.in);\n\t\tint N = io.nextInt();\n\t\tint M = io.nextInt();\n\t\tboolean[] medium = new boolean[N];\n\t\tboolean[] ableToN = new boolean[N];\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint a = io.nextInt()-1;\n\t\t\tint b = io.nextInt()-1;\n\t\t\tif(a==0) medium[b] = true;\n\t\t\tif(b==0) medium[a] = true;\n\t\t\tif(a==N-1) ableToN[b] = true;\n\t\t\tif(b==N-1) ableToN[a] = true;\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(medium[i] && ableToN[i]){\n\t\t\t\tSystem.out.println(\"POSSIBLE\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"IMPOSSIBLE\");\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\n}", "code2": "n,*z=$<.map &:split;y=z.to_h;puts\"#{z.all?{|a,b|a>?1||y[b]!=n[0]}?:IM:\"\"}POSSIBLE\"", "label": 1, "name1": "s464102860.java", "name2": "s984752060.rb"}, {"id": 503, "code1": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String str = sc.next();\n        int n = str.length();\n        int digitSum = 0;\n        for (int i = 0; i < n; i++)\n            digitSum += (str.charAt(i) - '0');\n        if(digitSum % 9 == 0) {\n            System.out.println(\"Yes\");\n        }\n        else {\n            System.out.println(\"No\");\n        }\n    }\n}\n\n", "code2": "h,w = gets.chomp.split.map(&:to_i)\nif h == 1 || w == 1\n  ans = 1\nelse\n  ans = ((w/2 + w%2) * (h/2 + h%2)) + ((w/2) * (h/2))\nend\nputs ans", "label": 0, "name1": "s204970720.java", "name2": "s041871374.rb"}, {"id": 285, "code1": "import java.util.*;\n\nclass Main{\n  public static void main(String[] args)\n  {\n    Scanner scanner = new Scanner(System.in);\n    int[] a = new int[3];\n    int[] b = new int[3];\n\n    int iti = 0,ni=0,san=0,si =0;\n\n    int odd=0, even=0;\n\n    for(int i=0; i<3; i++){\n      a[i] = scanner.nextInt();\n      b[i] = scanner.nextInt();\n    }\n\n    for(int i=0; i<3; i++){\n      if(a[i] == 1){\n        iti++;\n      }\n      else if(a[i]==2)\n      {\n        ni++;\n      }else if(a[i] == 3)\n      {\n        san++;\n      }else if(a[i] == 4){\n        si++;\n      }\n\n      if(b[i] == 1){\n        iti++;\n      }\n      else if(b[i]==2)\n      {\n        ni++;\n      }else if(b[i] == 3)\n      {\n        san++;\n      }else if(b[i] == 4){\n        si++;\n      }\n    }\n\n    if(checkEven(iti)){\n      even++;\n    }else{\n      odd++;\n    }\n    if(checkEven(ni)){\n      even++;\n    }else{\n      odd++;\n    }\n    if(checkEven(san)){\n      even++;\n    }else{\n      odd++;\n    }\n\n    if(checkEven(si)){\n      even++;\n    }else{\n      odd++;\n    }\n\n      if(odd == 2 && even == 2)\n      {\n        System.out.println(\"YES\");\n      }else{\n        System.out.println(\"NO\");\n      }\n\n  }\n\n  public static boolean checkEven(int num){\n    if(num %2 == 0){\n      return true;\n    }\n    return false;\n  }\n\n}", "code2": "path_list = 3.times.map { gets.split(' ').map(&:to_i) }\nedge_to_count = Hash.new(0)\npath_list.each do |(a, b)|\n  edge_to_count[a] += 1\n  edge_to_count[b] += 1\nend\n\nans = edge_to_count.keys.size == 4 && edge_to_count.values.max < 3\nputs(ans ? 'YES': 'NO')\n", "label": 1, "name1": "s151827431.java", "name2": "s267170093.rb"}, {"id": 638, "code1": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\t\n\tpublic static void main(String[] args){\n\t\tnew Main();\n\t}\n\tpublic Main(){\n\t\tnew A().doIt();\n\t}\n\tclass A{\n\t\tlong euclid(long a, long b){\n\t\t    long temp;\n\n\t\t    if(a < b) { \n\t\t    \ttemp = a;\n\t\t    \ta = b;\n\t\t    \tb = temp;\n\t\t    }\n\t\t    if(a % b == 0) return b;\n\t\t    return euclid( b, a % b );\n\t\t}\n\t\tvoid doIt(){\n\t\t\tint n = sc.nextInt();\n\t\t\tlong A = 1;\n\t\t\tlong B = 1;\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tlong aa = sc.nextLong();\n\t\t\t\tlong bb = sc.nextLong();\n\t\t\t\tif(A % aa != 0)A = A + aa - (A % aa);\n\t\t\t\tif(B % bb != 0)B = B + bb - (B % bb);\n\t\t\t\tlong max = Math.max(A/aa,B/bb);\n\t\t\t\tA = max * aa;\n\t\t\t\tB = max * bb;\n//\t\t\t\tSystem.out.println(A+\" \"+B);\n\t\t\t}\n\t\t\tSystem.out.println(A+B);\n\t\t}\n\t}\n}\n", "code2": "def factorial(x)\n  product = 1\n  for i in 1..x do\n    product *= i\n  end\n  return product\nend\n\nn = gets.to_i\np = gets.split.map(&:to_i)\nq = gets.split.map(&:to_i)\npp = (1..n).to_a\nqq = (1..n).to_a\na = 0\nb = 0\nfor i in 0...n do\n  a += pp.index(p[i]) * factorial(n-i-1)\n  b += qq.index(q[i]) * factorial(n-i-1)\n  pp.delete(p[i])\n  qq.delete(q[i])\nend\nputs (a-b).abs\n", "label": 0, "name1": "s857617870.java", "name2": "s622115708.rb"}, {"id": 75, "code1": "import java.util.*;\n\nclass Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int k = findK(n);\n        if(k==-1){\n            System.out.println(\"No\");\n            System.exit(0);\n        }\n        int[][] res = new int[k][k-1];\n        for(int i=0;i<k-1;i++) res[0][i] = i+1;\n        int[] index = new int[k];\n        for(int i=0;i<k;i++) index[i]=i;\n        for(int row=1;row<k;row++){\n            int idx = 0;\n            for(int j=0;j<row;j++) res[row][idx++] = res[j][index[j]++];\n            if(row==k-1) continue;\n            res[row][idx++]=res[row-1][k-2]+1;\n            while(idx<k-1){\n                res[row][idx] = res[row][idx-1]+1;\n                idx++;\n            }\n        }\n        System.out.println(\"Yes\");\n        System.out.println(k);\n        for(int i=0;i<k;i++){\n            System.out.print(Integer.toString(k-1)+\" \");\n            for(int j=0;j<k-1;j++){\n                System.out.print(Integer.toString(res[i][j])+\" \");\n            }\n            System.out.println(\"\");\n        }\n    }\n    static int findK(int n){\n        int k=1;\n        while(k*(k-1)<=2*n){\n            if(k*(k-1)==2*n) return k;\n            k++;\n        }\n        return -1;\n    }\n}\n", "code2": "def  nnp1(n)\n    a=((n*2)**(0.5)).to_i\n    return a*(a+1)==n*2\nend\n\ndef  nnp(n)\n    a=((n*2)**(0.5)).to_i\n    return a\nend\n\nn=gets.strip.to_i\n\nif nnp1(n) == false \n    puts 'No'\n    exit\nend\nputs 'Yes'\na=nnp(n)\nx=Array.new(a+1).map{Array.new(a)}\nc=1\nputs a+1\n(0..a-1).each{|i|\n    \n    cc=c\n    (i..a-1).each{|j|\n        x[i][j]=cc\n        cc+=1\n    }\n\n    cc=c\n    (i+1..a).each{|j|\n        x[j][i]=cc\n        cc+=1\n    }\n    c=cc\n}\n\nx.each do |i|\n    print a.to_s + \" \"\n    puts i.join(\" \")\n\nend", "label": 1, "name1": "s741808618.java", "name2": "s713749025.rb"}, {"id": 524, "code1": "import java.util.Scanner;\n \npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            int[] s = new int[n];\n            double e = 0.0, v = 0.0;\n            for (int i = 0; i < n; i++) {\n                s[i] = sc.nextInt();\n                e += s[i];\n                v += s[i] * s[i];\n            }\n            e /= n;\n            v = v / n - e * e;\n            System.out.println(Math.sqrt(v));\n        }\n    }\n}\n", "code2": "n = gets.to_i\na = gets.split.map(&:to_i)\nans = 0\nfor i in 1..n-1\n    if a[i] == a[i-1]\n        ans += 1\n        a[i] = 0\n    end\nend\nputs ans", "label": 0, "name1": "s749350396.java", "name2": "s614056368.rb"}, {"id": 49, "code1": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic long LINF = 1L << 55;\n\tstatic int MOD = 1000000007;\n\tstatic int[] mh4 = { 0, -1, 1, 0 };\n\tstatic int[] mw4 = { -1, 0, 0, 1 };\n\tstatic int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\tstatic int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n\tstatic class TaskX {\n\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tint n = in.nextInt();\n\t\t\tint[] a = in.nextIntArray(n);\n\n\t\t\tint count = 0;\n\n\t\t\tfor (int l = 0, r = 0; l < n; l = r) {\n\t\t\t\twhile (r < n && a[l] == a[r]) {\n\t\t\t\t\tr++;\n\t\t\t\t}\n\t\t\t\tint len = r-l;\n\t\t\t\tcount += len/2;\n\t\t\t}\n\n\t\t\tout.println(count);\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\t}\n\n}\n", "code2": "n=gets.to_i\ns=gets.split.map(&:to_i)\na=0\nc=1\n(n-1).times do |i|\n  if s[i+1]==s[i]\n    c+=1\n  else\n    a+=c/2\n    c=1\n  end\nend\np a+c/2", "label": 1, "name1": "s729269653.java", "name2": "s006140136.rb"}, {"id": 764, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String args[]){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tInteger[] num = new Integer[n];\n\t\tStringBuilder s = new StringBuilder(\"\");\n\t\tfor(int i=0;i<n;i++){\n\t\t\tnum[i] = scan.nextInt();\n\t\t}\n\t\tArrays.sort(num);\n\t\t\n\t\ts.append(num[0]);\n\t\tfor(int i=1;i<num.length;i++){\n\t\t\ts.append(\" \"+num[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(s);\n\t}\n}", "code2": "n = gets.to_i\na = gets.split.map(&:to_i)\nsum = x = 0\na << 0\n\na.each do |e|\n  sum += (x - e).abs\n  x = e\nend\n\ndef d(x, y)\n  (x - y).abs\nend\n\nn.times do |i|\n  puts sum - d(a[i], a[i - 1]) - d(a[i + 1], a[i]) + d(a[i - 1], a[i + 1])\nend", "label": 0, "name1": "s177932526.java", "name2": "s135141866.rb"}, {"id": 906, "code1": "import java.util.*; \n\nclass Main{\npublic static void main(String[] args){\n\tScanner sc=new Scanner(System.in);\n        int x=sc.nextInt();\n  \t\tint t=0;\n  if(x==2){\n \t System.out.println(x);\n  }else{\n  \n   for(int x1=x;x1>0;x1++){\n     for(int c=2;c<x1;c++){\n         if(x1%c==0){\n           t=0;\n           break;\n          }else{\n           t++;\n         }\n    \t }\n     if(t>0){\n        System.out.println(x1);\n           return;\n     } \n   }\n\n  }\n    }\n}", "code2": "a=[]\na[0] = gets.chomp.split(//)\na[1] = gets.chomp.split(//)\na[2] = gets.chomp.split(//)\nhash={'a'=> 0, 'b'=> 1, 'c'=> 2}\nturn = 'a'\nwhile true\n  if a[hash[turn]].empty?\n    puts turn.upcase\n    break\n  end\n  turn = a[hash[turn]].shift\nend\n\n\n", "label": 0, "name1": "s993503161.java", "name2": "s231209920.rb"}, {"id": 29, "code1": "import java.util.*;\nimport java.io.*;\n\nimport static java.lang.System.in;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long A = sc.nextLong();\n        long B = sc.nextLong();\n        long[] x = new long[n];\n        for(int i=0;i<n;i++) x[i]=sc.nextLong();\n        long ans= 0;\n        for(int i=0;i<n-1;i++){\n            ans += Math.min(A*(x[i+1]-x[i]),B);\n        }\n        PrintWriter out = new PrintWriter(System.out);\n        out.println(ans);\n        out.flush();\n    }\n}\n", "code2": "n,a,b=gets.split.map(&:to_i)\nx=gets.split.map(&:to_i)\nc=0\n(n-1).times do |i|\n  if (x[i+1]-x[i])*a>b\n    c+=b\n  else\n    c+=(x[i+1]-x[i])*a\n  end\nend\nputs c\n", "label": 1, "name1": "s316016733.java", "name2": "s333982418.rb"}, {"id": 150, "code1": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String args[]) {\n\tScanner sc = new Scanner(System.in);\n\n\twhile (true) {\n\t    int n = sc.nextInt();\n\t    int ans = 0;\n\t    if (n == 0) {\n\t\tbreak;\n\t    }\n\t    \n\t    ans = solve(n);\n\t    System.out.println(ans);\n\t}\n    }\n\n    public static int solve(int n) {\n\t//int max = 123456 * 2;\n\t//int prime[] = new prime[123456 * 2 + 1];\n\tboolean is_prime[] = new boolean[123456 * 2 + 1];\n\tint count = 0;\n\n\t//int p = 0;\n\tfor (int i = 0; i <= 2 * n; i++) {\n\t    is_prime[i] = true;\n\t}\n\n\tis_prime[0] = is_prime[1] = false;\n\tfor (int i = 2; i <= 2 * n; i++) {\n\t    if (is_prime[i]) {\n\t\t// prime[p++] = i;\n\t\tfor (int j = 2 * i; j <= 2 * n; j += i) {\n\t\t    is_prime[j] = false;\n\t\t}\n\t    }\n\t}\n\tfor (int i = n + 1; i <= 2 * n; i++) {\n\t    if (is_prime[i]) {\n\t\tcount++;\n\t    }\n\t}\n\t\n\treturn count;\n    }\n}", "code2": "require 'prime'\nwhile n = gets.to_i\n  break if n == 0\n  p Prime.each(2 * n).drop_while{ |p| p <= n }.size\nend", "label": 1, "name1": "s027703193.java", "name2": "s276322945.rb"}, {"id": 829, "code1": "import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        int A = scan.nextInt();\n        int B = scan.nextInt();\n        int C = scan.nextInt();\n        if(A == B && A== C){\n            System.out.println(\"No\");\n        }\n        else if(A == B || A == C || B == C){\n            System.out.println(\"Yes\");\n        }\n        else{\n            System.out.println(\"No\");\n        }\n    }\n}", "code2": "def selection_sort! size, target_array\n  count = 0\n  size.times {|i|\n    unsorted = target_array[i..(size - 1)]\n    min = unsorted.min\n    index_min = unsorted.index(min)\n    if min < target_array[i]\n      target_array[i], target_array[i + index_min] = target_array[i + index_min], target_array[i]\n      count += 1\n    end\n  }\n  count\nend\n\n\nsize = STDIN.gets.chomp.to_i\ntarget_array = STDIN.gets.chomp.split(' ').map{|n|n.to_i}\n\ncount = selection_sort!(size, target_array)\nputs target_array.join ' '\nputs count", "label": 0, "name1": "s236930555.java", "name2": "s018060842.rb"}, {"id": 804, "code1": "import java.util.*;\nimport java.text.*;\nimport java.math.*;\n\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tScanner in = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint m = in.nextInt();\n\t\t\tint d = in.nextInt();\n\t\t\tif((m|d) == 0) break;\n\t\t\tint day = d;\n\t\t\tswitch(m){\n\t\t\tcase 12:\n\t\t\t\tday += 335;\n\t\t\t\tbreak;\n\t\t\tcase 11:\n\t\t\t\tday += 305;\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tday += 274;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tday += 244;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tday += 213;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tday += 182;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tday += 152;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tday += 121;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tday += 91;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tday += 60;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tday += 31;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t}\n\t\t\tswitch(day%7){\n\t\t\tcase 1:\n\t\t\t\tSystem.out.println(\"Thursday\");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tSystem.out.println(\"Friday\");\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tSystem.out.println(\"Saturday\");\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tSystem.out.println(\"Sunday\");\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tSystem.out.println(\"Monday\");\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tSystem.out.println(\"Tuesday\");\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tSystem.out.println(\"Wednesday\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "code2": "n = gets.chomp.to_i\na_arr = gets.chomp.split(\" \").map(&:to_i)\nb_arr = gets.chomp.split(\" \").map(&:to_i)\n\nsum_a = 0\nsum_b = 0\ncount1 = 0\ncount2 = 0\n(0..n-1).each do |i|\n  sum_a += a_arr[i]\n  sum_b += b_arr[i]\n  if a_arr[i] > b_arr[i]\n    count1 += a_arr[i] - b_arr[i]\n  else\n    count2 += ((b_arr[i] - a_arr[i]) / 2.to_f).ceil\n  end\nend\nif sum_b - sum_a >= [count1, count2].max\n  puts \"Yes\"\nelse\n  puts \"No\"\nend\n", "label": 0, "name1": "s648991274.java", "name2": "s183505009.rb"}, {"id": 950, "code1": "import java.util.*;\npublic class Main{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    String N = sc.next();\n    int count = 0;\n    for(int i = 0; i < N.length(); i++){\n      if(N.charAt(i) == '2') count++;\n    }\n    System.out.println(count);\n  }\n}", "code2": "N,M,K=gets.split.map &:to_i;puts (0..N).any?{|k|x=K-k*M;y=N-2*k;y==0?x==0:(l=x/y;x%y==0&&0<=l&&l<=M)}?:Yes: :No", "label": 0, "name1": "s986275992.java", "name2": "s741962711.rb"}, {"id": 171, "code1": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t\n\tint cmp (String p1, String p2) {\n\t\tif( p1.length() != p2.length() ) return p2.length() - p1.length();\n\t\treturn p2.compareTo(p1);\n\t}\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif((w|h) == 0 ) break;\n\t\t\t\n\t\t\tString[][] dp = new String[h+1][w+1];\n\t\t\tString pass = \"\";\n\t\t\tchar[][] map = new char[h+1][w+1];\n\t\t\t\n\t\t\tfor(String[] a: dp) fill(a, \"\");\n\t\t\t\n\t\t\tfor(int i=1;i<=h;i++) {\n\t\t\t\tString str = sc.next();\n\t\t\t\tfor(int j=1;j<=w;j++) {\n\t\t\t\t\tmap[i][j] = str.charAt(j-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=1;i<=h;i++) for(int j=1;j<=w;j++) {\n\t\t\t\tif( '0' <= map[i][j] && map[i][j] <= '9' ) {\n\t\t\t\t\tif( map[i][j] == '0' && dp[i-1][j].equals(\"\") && dp[i][j-1].equals(\"\") ) continue;\n\t\t\t\t\tdp[i][j] = ( cmp(dp[i-1][j], dp[i][j-1])<0? dp[i-1][j]: dp[i][j-1] ) + (char)map[i][j];\n\t\t\t\t}\n\t\t\t\tpass = cmp(pass, dp[i][j])<0? pass: dp[i][j];\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(pass);\n\t\t\t\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}", "code2": "# The Secret Number from Aizu Online Judge\n\n# \u6f38\u5316\u5f0f:\n#    S(i, j) = max( S(i-1,j), S(i,j-1) ) D_ij if D_ij \u2208 { 0,1,2,3,4,5,6,7,8,9 }\n#            = \u03c6 otherwise\n\ndef secret_number(w, h, matrix)\n  subsol = Array.new(h+1) { |i| Array.new(w+1) { |j| i*j==0 ? '' : nil } }\n  1.upto h do |i|\n    1.upto w do |j|\n      c = matrix[i-1][j-1]\n      subsol[i][j] = if c =~ /\\d/\n                       [subsol[i-1][j], subsol[i][j-1]].max_by(&:to_i) + c\n                     else\n                       ''\n                     end\n    end\n  end\n  subsol.map { |row| row.max_by(&:to_i) }.max_by(&:to_i).to_i\nend\n\n# ----------------------------------------\nloop do\n  w, h = gets.split.map(&:to_i)\n  break if [w,h] == [0,0]\n\n  matrix = h.times.map { gets.chomp.chars }\n  ans = secret_number(w, h, matrix)\n  puts ans\nend", "label": 1, "name1": "s246113848.java", "name2": "s488110677.rb"}, {"id": 552, "code1": "import java.util.*;\n\nclass Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int k = findK(n);\n        if(k==-1){\n            System.out.println(\"No\");\n            System.exit(0);\n        }\n        int[][] res = new int[k][k-1];\n        for(int i=0;i<k-1;i++) res[0][i] = i+1;\n        int[] index = new int[k];\n        for(int i=0;i<k;i++) index[i]=i;\n        for(int row=1;row<k;row++){\n            int idx = 0;\n            for(int j=0;j<row;j++) res[row][idx++] = res[j][index[j]++];\n            if(row==k-1) continue;\n            res[row][idx++]=res[row-1][k-2]+1;\n            while(idx<k-1){\n                res[row][idx] = res[row][idx-1]+1;\n                idx++;\n            }\n        }\n        System.out.println(\"Yes\");\n        System.out.println(k);\n        for(int i=0;i<k;i++){\n            System.out.print(Integer.toString(k-1)+\" \");\n            for(int j=0;j<k-1;j++){\n                System.out.print(Integer.toString(res[i][j])+\" \");\n            }\n            System.out.println(\"\");\n        }\n    }\n    static int findK(int n){\n        int k=1;\n        while(k*(k-1)<=2*n){\n            if(k*(k-1)==2*n) return k;\n            k++;\n        }\n        return -1;\n    }\n}\n", "code2": "n,k = gets.split.map(&:to_i)\np [n%k, k-n%k].min\n", "label": 0, "name1": "s741808618.java", "name2": "s519723899.rb"}, {"id": 462, "code1": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t// \u5165\u529b\n\t\tint n = sc.nextInt();\n\t\tGraph g = new Graph(n, false);\n\t\tfor(int i = 0; i < n-1; i++){\n\t\t    int a = sc.nextInt() - 1;\n\t\t    int b = sc.nextInt() - 1;\n\t\t    g.add(a, b);\n\t\t}\n\t\t\n\t\t// \u8a08\u7b97\n\t\tString result = \"Snuke\";\n\t\tlong[] distFromB = g.dijkstra(0);\n\t\tlong[] distFromW = g.dijkstra(n-1);\n\t\tint cnt = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t    if(distFromB[i] <= distFromW[i]) cnt++;\n\t\t}\n\t\tif(cnt > (n-cnt)) result = \"Fennec\";\n\t\t\n\t\t// \u51fa\u529b\n\t\tSystem.out.println(result);\n\t}\n\n}\n\nclass Graph {\n\tint n;\n\tboolean directed;\n\tArrayList<Edge>[] adjList;\n\tint m;\n\tlong[] dist;\n\tlong[][] distWF;\n\tint start;\n\tint[] prev;\n\tArrayList<Integer> path;\n\tlong INF = 1001001001001001001L;\n\n\tpublic Graph (int n, boolean directed) {\n\t\tthis.n = n;\n\t\tthis.m = 0;\n\t\tthis.directed = directed;\n\t\tthis.adjList = new ArrayList[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tadjList[i] = new ArrayList<Edge>();\n\t\t}\n\t}\n\t\n\tpublic void add(int from, int to) {\n\t\tadd(from, to, 1);\n\t}\n\tpublic void add(int from, int to, int w) {\n\t\tadjList[from].add(new Edge(from, to, w));\n\t\tthis.m++;\n\t\tif(!directed){\n\t\t\tadjList[to].add(new Edge(to, from, w));\n\t\t\tthis.m++;\n\t\t}\n\t}\n\t\n\tpublic long[] bfs(int start) { // O(M)\n\t\tthis.start = start;\n\t\tthis.prev = new int[n];\n\t\tArrays.fill(prev, -1);\n\t\tprev[start] = start;\n\t\tthis.dist = new long[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[start] = 0;\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tq.add(start);\n\t\twhile(!q.isEmpty()){\n\t\t\tint now = q.poll();\n\t\t\tfor(Edge e : adjList[now]){\n\t\t\t\tif(dist[e.to] != INF) continue;\n\t\t\t\tdist[e.to] = dist[now] + e.w;\n\t\t\t\tprev[e.to] = now;\n\t\t\t\tq.add(e.to);\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\t\n\tpublic long[] dijkstra(int start) { // O(MlogM)\n\t\tthis.start = start;\n\t\tthis.prev = new int[n];\n\t\tArrays.fill(prev, -1);\n\t\tprev[start] = start;\n\t\tthis.dist = new long[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[start] = 0;\n\t\tPriorityQueue<Vertex> q = new PriorityQueue<Vertex>((x, y) -> Long.compare(x.distance, y.distance));\n\t\tq.add(new Vertex(start, 0));\n\t\twhile(!q.isEmpty()){\n\t\t\tVertex now = q.poll();\n\t\t\tif(now.distance > dist[now.id]) continue; \n\t\t\tfor(Edge e : adjList[now.id]){\n\t\t\t\tlong newDist = now.distance + e.w;\n\t\t\t\tif(dist[e.to] <= newDist) continue;\n\t\t\t\tdist[e.to] = newDist;\n\t\t\t\tprev[e.to] = now.id;\n\t\t\t\tq.add(new Vertex(e.to, newDist));\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\t\n\tpublic long[][] wf() { // O(N^3)\n\t\tthis.distWF = new long[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tArrays.fill(distWF[i], INF);\n\t\t\tdistWF[i][i] = 0;\n\t\t}\n\t\tfor(ArrayList<Edge> list : adjList){\n\t\t\tfor(Edge e : list){\n\t\t\t\tdistWF[e.from][e.to] = e.w;\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < n; k++){\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tdistWF[i][j] = min(distWF[i][j], distWF[i][k] + distWF[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn distWF;\n\t}\n\t\n\tpublic boolean bf(int start) { // O(NM)\n\t\tthis.start = start;\n\t\tthis.prev = new int[n];\n\t\tArrays.fill(prev, -1);\n\t\tprev[start] = start;\n\t\tthis.dist = new long[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[start] = 0;\n\t\tboolean hasNegativeLoop = false;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tfor(Edge e : adjList[j]){\n\t\t\t\t\tif(dist[e.to] <= dist[e.from] + e.w) continue;\n\t\t\t\t\tdist[e.to] = dist[e.from] + e.w;\n\t\t\t\t\tprev[e.to] = e.from;\n\t\t\t\t\tif(i == n-1) hasNegativeLoop = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn hasNegativeLoop;\n\t}\n\t\n\tpublic ArrayList<Integer> pathTo(int to){\n\t\tthis.path = new ArrayList<Integer>();\n\t\treturn pathToRec(to);\n\t}\n\t\n\tprivate ArrayList<Integer> pathToRec(int to){\n\t\tif(to != start) pathToRec(prev[to]);\n\t\tpath.add(to);\n\t\treturn path;\n\t}\n\t\n\tpublic String toString(){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(ArrayList<Edge> list : adjList){\n\t\t\tfor(Edge e : list){\n\t\t\t\tsb.append(e.toString());\n\t\t\t\tsb.append(\"\\n\");\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tpublic String distToString(){\n\t\tif(dist != null) return Arrays.toString(dist);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(distWF[i][j] == INF){\n\t\t\t\t\tsb.append(\"from:\" + i + \" to:\" + j + \" dist:INF\" + \"\\n\");\n\t\t\t\t}else{\n\t\t\t\t\tsb.append(\"from:\" + i + \" to:\" + j + \" dist:\" + distWF[i][j] + \"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tclass Edge {\n\t\tint from;\n\t\tint to;\n\t\tint w;\n\t\t\n\t\tEdge(int from, int to, int w){\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"from:\" + from + \" to:\" + to + \" w:\" + w;\n\t\t}\n\t}\n\t\n\tclass Vertex {\n\t\tint id;\n\t\tlong distance;\n\t\t\n\t\tVertex(int id, long distance){\n\t\t\tthis.id = id;\n\t\t\tthis.distance = distance;\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"id:\" + id + \" distance:\" + distance;\n\t\t}\n\t}\n}\n", "code2": "n = gets.to_i\nadj = Array.new(n).map{Array.new}\n(n-1).times do\n  a,b = gets.chomp.split(\" \").map{|i|i.to_i-1}\n  adj[a] << b\n  adj[b] << a\nend\nvst = Array.new(n,false)\nvst[0] = true\nvst[n-1] = true\nsum = [1,1]\nq = [[],[]]\nf = [[0],[n-1]]\nwhile vst.include?(false)\n  q = Marshal.load(Marshal.dump(f))\n  f = [[],[]]\n  2.times do |i|\n    q[i].each do |j|\n      adj[j].each do |k|\n        if vst[k] == false\n          vst[k] = true\n          f[i] << k\n        end\n      end\n    end\n    sum[i] += f[i].size\n  end\nend\nif sum[0] > sum[1]\n  puts \"Fennec\"\nelse\n  puts \"Snuke\"\nend", "label": 1, "name1": "s816087530.java", "name2": "s543014556.rb"}, {"id": 495, "code1": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tstatic final long mod = (long) 1e9 + 7;\n\tstatic final int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };\n\tstatic final int[] dx8 = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\tstatic final int inf = Integer.MAX_VALUE / 3;\n\tstatic final long linf = Long.MAX_VALUE / 3;\n\tstatic final double dinf = Double.MAX_VALUE / 3;\n\tstatic final double eps = 1e-10;\n\tstatic final double pi = Math.PI;\n\tstatic StringBuilder sb = new StringBuilder();\n\n\tstatic void solve() {\n\t\tint n = ni();\n\t\tchar s[] = ns(n);\n\t\t//\u5de6\u304b\u3089W\u3092\u5411\u3044\u3066\u308b\u4eba\u3001\u53f3\u304b\u3089E\u3092\u5411\u3044\u3066\u308b\u4eba\u3092\u6570\u3048\u308b\n\t\tint suml[] = new int[n+1];\n\t\tint sumr[] = new int[n+1];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tsuml[i+1] = suml[i] + (s[i]=='W'?1:0);\n\t\t\tsumr[n-i-1] = sumr[n-i] + (s[n-1-i]=='E'?1:0);\n\t\t}\n\t\t\n\t\tint ans = inf;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint t = suml[i]+sumr[i+1];\n\t\t\tans = min(ans, t);\n\t\t}\n\t\tout.println(ans);\n\t\t\n\t}\n\n\t//libraries\n\tstatic void reverse(int ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tint t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(long ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tlong t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(double ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tdouble t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(char ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tchar t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic String getReverse(String s) {\n\t\tchar c[] = s.toCharArray();\n\t\treverse(c);\n\t\ts = String.valueOf(c);\n\t\treturn s;\n\t}\n\n\tstatic <T> void reverse(List<T> ls) {\n\t\tint sz = ls.size();\n\t\tfor (int i = 0; i < sz / 2; i++) {\n\t\t\tT t = ls.get(i);\n\t\t\tls.set(i, ls.get(sz - 1 - i));\n\t\t\tls.set(sz - 1 - i, t);\n\t\t}\n\t}\n\n\tstatic void sbnl() {//StringBuilder\u306b\u6539\u884c\u6587\u5b57\u3092append\u3059\u308b\n\t\tsb.append(\"\\n\");\n\t}\n\n\tstatic int lowerBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int lowerBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int lowerBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic <T> int lowerBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) >= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) >= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) >= 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int upperBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) > 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) > 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) > 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int rupperBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) < 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) < 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) < 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int rlowerBound(List<T> ls, T x) {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) <= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) <= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) <= 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic int[] concat(int x, int arr[]) {\n\t\tint ret[] = new int[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 1, ret.length - 1);\n\t\tret[0] = x;\n\t\treturn ret;\n\t}\n\n\tstatic int[] concat(int arr[], int x) {\n\t\tint ret[] = new int[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 0, ret.length - 1);\n\t\tret[ret.length - 1] = x;\n\t\treturn ret;\n\t}\n\n\tstatic long[] concat(long x, long arr[]) {\n\t\tlong ret[] = new long[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 1, ret.length - 1);\n\t\tret[0] = x;\n\t\treturn ret;\n\t}\n\n\tstatic long[] concat(long arr[], long x) {\n\t\tlong ret[] = new long[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 0, ret.length - 1);\n\t\tret[ret.length - 1] = x;\n\t\treturn ret;\n\t}\n\n\tstatic int max(int x, int y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic int min(int x, int y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic int max(int x, int y, int z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic int min(int x, int y, int z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic long max(long x, long y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic long min(long x, long y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic long max(long x, long y, long z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic long min(long x, long y, long z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic double max(double x, double y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic double min(double x, double y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic double max(double x, double y, double z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic double min(double x, double y, double z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic void sort(int[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void sort(long[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void sort(double[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void rsort(int[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tint tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void rsort(long[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tlong tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void rsort(double[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tdouble tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void fill(int arr[], int x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(long arr[], long x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(boolean arr[], boolean x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(double arr[], double x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(int arr[][], int x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(long arr[][], long x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(double arr[][], double x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(boolean arr[][], boolean x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\t//MOD culc\n\tstatic long plus(long x, long y) {\n\t\tlong res = (x + y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long sub(long x, long y) {\n\t\tlong res = (x - y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long mul(long x, long y) {\n\t\tlong res = (x * y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long div(long x, long y) {\n\t\tlong res = x * pow(y, mod - 2) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long pow(long x, long y) {\n\t\tif (y < 0)\n\t\t\treturn 0;\n\t\tif (y == 0)\n\t\t\treturn 1;\n\t\tif (y % 2 == 1)\n\t\t\treturn (x * pow(x, y - 1)) % mod;\n\t\tlong root = pow(x, y / 2);\n\t\treturn root * root % mod;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\t//input\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static long[] nla(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n}\n", "code2": "# frozen_string_literal: true\n\ndef read\n  [gets.to_i, gets.chomp]\nend\n\ndef solve(_, s)\n  min = Float::INFINITY\n  cnt = { e: 0, w: 0 }\n  table = [cnt.dup]\n  s.chars.each_with_index do |c, i|\n    k = if c == 'W' then :w\n        else :e\n        end\n    cnt[k] += 1\n    table[i + 1] = cnt.dup\n  end\n  table.each do |el|\n    c = el[:w] + table.last[:e] - el[:e]\n    min = c if c < min\n  end\n  min\nend\n\nputs solve(*read)\n# puts [\n#   solve(5, 'WEEWW') == 1,\n#   solve(12, 'WEWEWEEEWWWE') == 4,\n#   solve(8, 'WWWWWEEE') == 3\n# ].all?\n", "label": 1, "name1": "s594845311.java", "name2": "s025378271.rb"}, {"id": 449, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        BRemovingBlocks solver = new BRemovingBlocks();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BRemovingBlocks {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            long[] a = in.readLongArray(n);\n\n            Modulo.mod = MiscUtils.MOD7;\n\n            long[] s = new long[n];\n            s[0] = 1;\n            for (int i = 1; i < n; i++) {\n                s[i] = Modulo.add(s[i - 1], Modulo.rev(i + 1));\n            }\n\n            long ans = 0;\n            for (int i = 0; i < n; i++) {\n                long sum = Modulo.mlt(a[i], s[i] + s[n - 1 - i] - 1);\n                ans = Modulo.add(ans, sum);\n            }\n            for (int i = 1; i <= n; i++) ans = Modulo.mlt(ans, i);\n            out.printLine(ans);\n        }\n\n    }\n\n    static class Modulo {\n        public static long mod;\n        private long value;\n\n        public Modulo(long value) {\n            this.value = (value % mod + mod) % mod;\n        }\n\n        public static long add(long a, long b) {\n            return ((a + b) % mod + mod) % mod;\n        }\n\n        public static long mlt(long a, long b) {\n            return ((a % mod + mod) * (b % mod + mod)) % mod;\n        }\n\n        public static long rev(long a) {\n            //return pow(a, mod - 2);\n            return (Euclid.extgcd(a, mod, new long[3])[0] % mod + mod) % mod;\n        }\n\n        public String toString() {\n            return \"\" + value;\n        }\n\n    }\n\n    static class Euclid {\n        public static long[] extgcd(long a, long b, long[] is) {\n            if (a == 0) {\n                is[0] = 0;\n                is[1] = 1;\n                is[2] = b;\n            } else {\n                extgcd(b % a, a, is);\n                long x = is[1] - b / a * is[0];\n                is[1] = is[0];\n                is[0] = x;\n            }\n            return is;\n        }\n\n    }\n\n    static class MiscUtils {\n        public static final int MOD7 = (int) (1e9 + 7);\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public long[] readLongArray(int size) {\n            long[] array = new long[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readLong();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long readLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "code2": "m=10**9+7;f=->a,b{b>0?a**b[0]*f[a*a%m,b/2]%m:1}\ns=t=i=0;\nb=(1..gets.to_i).map{|j|t+=f[j,m-2]};r=1;\ngets.split.map{|a|s+=a.to_i*(b[i]+b[-i+=1]-1)%m;r=r*i%m}\np s*r%m", "label": 1, "name1": "s003754625.java", "name2": "s505414932.rb"}, {"id": 290, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint N = scan.nextInt();\n\t\tint M = scan.nextInt();\n\n\t\tint[] X = new int[M];\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tX[i] = scan.nextInt();\n\t\t}\n\n\t\tscan.close();\n\t\t\n\t\tif(M <= N) {\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tArrays.sort(X);\n\t\t\n\t\tint distance[] = new int[M-1];\n\t\tfor(int i=0; i<M-1; i++) {\n\t\t\tdistance[i] = X[i+1] - X[i];\n\t\t}\n\t\t\n\t\tArrays.sort(distance);\n\t\t\n\t\tint sum = 0;\n\t\tfor(int i=0; i<(M-N); i++) {\n\t\t\tsum+=distance[i];\n\t\t}\n\t\tSystem.out.println(sum);\n\n\n\t}\n\n}", "code2": "n, m = gets.chomp.split(\" \").map(&:to_i)\nxs = gets.chomp.split(\" \").map(&:to_i).sort\ndiffs = []\ni = 0\nwhile i < (xs.size - 1) do\n  diffs.push xs[i+1] - xs[i]\n  i += 1\nend\n\nputs diffs.sort.reverse.drop(n-1).reduce(&:+) || 0\n", "label": 1, "name1": "s564605710.java", "name2": "s974088402.rb"}, {"id": 118, "code1": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\t\n\tpublic static void main(String[] args) {\n\t\tFastScanner scanner=new FastScanner();\n\t\tint n=scanner.nextInt(),k=scanner.nextInt();\n\t\tint a[]=scanner.readArray(n);\n\t\t\n\t\tboolean dp[]=new boolean[k+1];\n//\t\tArrays.fill(dp, true);\n//\t\tdp[0]=false;\n\t\t\n\t\tfor(int stones=0;stones<=k;stones++) {\n\t\t\tfor(int j:a)\n\t\t\t\tif(j<=stones&&!dp[stones-j]) dp[stones]=true;\n\t\t}\n\t\tif(dp[k]) System.out.println(\"First\");\n\t\telse System.out.println(\"Second\");\n\t\n\t\t\n\t\t\n\n\t}\n\tstatic class FastScanner{\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\t\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tdouble nextDoubel() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tint [] readArray(int n) {\n\t\t\tint a[]=new int[n];\n\t\t\tfor(int i=0;i<n;i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\t\n\t}\n\n}\n\n", "code2": "n, k = gets.split.map(&:to_i)\na = gets.split.map(&:to_i)\n\ndp = Array.new(k+1) {[nil, nil]}\n\n(k+1).times do |i|\n    2.times do |player|\n        a.each do |e|\n            if i < e\n                dp[i][player] = player ^ 1\n                break\n            end\n\n            if dp[i-e][player ^ 1] == player\n                dp[i][player] = player\n                break\n            end\n        end or next\n        dp[i][player] = player ^ 1\n    end\nend\n\nputs dp[k][0] == 0 ? \"First\" : \"Second\"", "label": 1, "name1": "s041813111.java", "name2": "s522658822.rb"}, {"id": 5, "code1": "\nimport java.util.Scanner;\n\n/**\n * Created by enpingkuang on 2020/9/10 10:58 \u4e0b\u5348\n */\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String s = scanner.next();\n        long sum = 0;\n        int length = s.length();\n        for(int i = 0;i<length;i++){\n            sum += (s.charAt(i)-'0');\n        }\n        System.out.println(sum % 9==0?\"Yes\":\"No\");\n    }\n}\n", "code2": "puts gets.chomp.chars.map(&:to_i).sum % 9 == 0 ? 'Yes' : 'No'\n", "label": 1, "name1": "s939687060.java", "name2": "s010063752.rb"}, {"id": 946, "code1": "import java.util.Scanner;\nimport java.util.ArrayList;\n\npublic class Main{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n\n    //input\n    int d = sc.nextInt();\n    /*\n    int[] c = new int[26]; //array of decrease\n    for(int i = 0; i < c.length; i++){\n      c[i] = sc.nextInt();\n    }\n    */\n\n    int[] c = new int[26];\n    for(int i = 0; i < 26; i++){\n      c[i] = sc.nextInt();\n    }\n\n    int[][] s = new int[d][26]; //two dimensional array of increase\n    for(int row = 0; row < s.length; row++){ //day\n      for(int col = 0; col < s[row].length; col++){ //contest number\n        s[row][col] = sc.nextInt();\n      }\n    }\n    int[] t = new int[d]; //array of contest numbers of the day\n    for(int i = 0; i < t.length; i++){\n      t[i] = 13;\n    }\n\n    //output\n    //based on increase\n    /*\n    int largestNum = s[0][0];\n    int largestNumRow = 0;\n    int largestNumCol = 0;\n    for(int row = 0; row < s.length; row++){\n      for(int col = 0; col < s[row].length; col++){\n        if( s[row][col] > largestNum ){\n          largestNum = s[row][col];\n          largestNumRow = row;\n          largestNumCol = col;\n        }\n      }\n    }\n\n    int largestNuM = c.get(0);\n    int largestNumPos = 0;\n    for(int j = 0; j < c.size(); j++){\n      if( c.get(j) > largestNuM ){\n        largestNuM = c.get(j);\n        largestNumPos = j;\n      }\n    }\n\n    for(int i = 0; i < d; i++){\n      if( largestNum > largestNuM ){\n        System.out.println(largestNumCol+1);\n      }else{\n        System.out.println(largestNumPos+1);\n      }\n    }\n    */\n\n\n    /*\n\n    for(int m = 0; m < d; m++){\n      if( m%2 == 0 ){\n        System.out.println(largestNumCol+1);\n      }else{\n        int largestNuM = c.get(0);\n        int largestNumPos = 0;\n        for(int j = 0; j < c.size(); j++){\n          if( c.get(j) > largestNuM ){\n            largestNuM = c.get(j);\n            largestNumPos = j;\n          }\n        }\n        c.remove(largestNumPos);\n        System.out.println(largestNumPos+1);\n      }\n    }\n    */\n\n\n\n    for(int i = 0; i < d; i++){\n      System.out.println((int)(Math.random()*26+1));\n      //System.out.println(largestNumCol+1);\n    }\n\n    /*\n    int value = 0;\n    for(int i = 0; i < t.length; i++){\n      int contestNum = t[i]-1;\n      int day = i+1;\n      value += s[day-1][contestNum]; //increase\n      for(int j = 0; j < c.length; j++){\n        if( !(j == contestNum) ){\n          int daySinceLast = day;\n          for(int m = 0; m < i; m++){\n            if( j == t[m]-1 ){\n              daySinceLast = day-m-1;\n            }\n          }\n          value -= c[j]*(daySinceLast); //decrease (amount of decrease * days since last one)\n        }\n      }\n      System.out.println(value);\n    }\n    */\n\n\n  }\n}\n", "code2": "p`dd`.count ?2", "label": 0, "name1": "s036059827.java", "name2": "s071879224.rb"}, {"id": 531, "code1": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic long LINF = 1L << 55;\n\tstatic int MOD = 1000000007;\n\tstatic int[] mh4 = { 0, -1, 1, 0 };\n\tstatic int[] mw4 = { -1, 0, 0, 1 };\n\tstatic int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\tstatic int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n\tstatic class TaskX {\n\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tint n = in.nextInt();\n\t\t\tint[] a = in.nextIntArray(n);\n\n\t\t\tint count = 0;\n\n\t\t\tfor (int l = 0, r = 0; l < n; l = r) {\n\t\t\t\twhile (r < n && a[l] == a[r]) {\n\t\t\t\t\tr++;\n\t\t\t\t}\n\t\t\t\tint len = r-l;\n\t\t\t\tcount += len/2;\n\t\t\t}\n\n\t\t\tout.println(count);\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\t}\n\n}\n", "code2": "a=gets.to_i\nb=gets.to_i\nc=gets.to_i\nd=gets.to_i\na=a+b\na=a+c\na=a+d\nsec=a%60\na=a-sec\nmin=a/60\nprint(\"#{min}\\n#{sec}\\n\")", "label": 0, "name1": "s729269653.java", "name2": "s727924665.rb"}, {"id": 360, "code1": "import java.util.Scanner;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tprivate static final int INF = (int)1e9;\n\n\tstatic class Pair {\n\t\tint first;\n\t\tint second;\n\n\t\tpublic Pair(int first, int second) {\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn first + second;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\tif (other instanceof Pair) {\n\t\t\t\tPair p = (Pair)other;\n\n\t\t\t\treturn p.first == first && p.second == second;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner in = new Scanner(System.in)) {\n\t\t\tint n = in.nextInt();\n\t\t\tList<Integer>[] g = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tg[i] = new ArrayList<>();\n\n\t\t\tint m = in.nextInt();\n\t\t\tint r = in.nextInt();\n\t\t\tMap<Pair, Integer> dist = new HashMap<>();\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint f = in.nextInt();\n\t\t\t\tint t = in.nextInt();\n\t\t\t\tint w = in.nextInt();\n\n\t\t\t\tg[f].add(t);\n\t\t\t\tdist.put(new Pair(f, t), w);\n\t\t\t}\n\n\t\t\tdijkstra(g, n, dist, r);\n\t\t} catch (Exception ex) {\n\t\t\tthrow new RuntimeException(ex);\n\t\t}\n\t}\n\n\tpublic static void dijkstra(List<Integer> g[], int n, Map<Pair, Integer> dist, int s) {\n\t\tint[] d = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\td[i] = INF;\n\n\t\td[s] = 0;\n\t\tPriorityQueue<Pair> pq = new PriorityQueue<>((x, y) -> x.second-y.second);\n\t\tpq.add(new Pair(s, 0));\n\n\t\twhile (!pq.isEmpty()) {\n\t\t\tPair p = pq.remove();\n\n\t\t\tfor (int v : g[p.first]) {\n\t\t\t\tint dd = d[p.first] + dist.get(new Pair(p.first, v));\n\t\t\t\tif (dd < d[v]) {\n\t\t\t\t\td[v] = dd;\n\t\t\t\t\tpq.add(new Pair(v, d[v]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (d[i] == INF)\n\t\t\t\tSystem.out.println(\"INF\");\n\t\t\telse\n\t\t\t\tSystem.out.println(d[i]);\n\t\t}\n\t}\n}", "code2": "class PriorityQueue\n  def initialize(&comp)\n    @heap = []\n    @node_num = 0\n    if block_given?\n      @comp = comp\n    else\n      @comp = Proc.new { |x, y| x <= y }\n    end\n  end\n  attr_reader :heap\n \n  def push(x)\n    i = @node_num # self node number\n    @node_num += 1\n    while i > 0\n      par = (i - 1) / 2 # parent's node number\n      break if @comp.call(@heap[par], x) # \u9006\u8ee2\u3057\u3066\u306a\u3044\u306a\u3089\u629c\u3051\u308b\n      # \u89aa\u30ce\u30fc\u30c9\u3092\u4e0b\u308d\u3057\u3066\u81ea\u5206\u3092\u4e0a\u306b\n      @heap[i] = @heap[par]\n      i = par\n    end\n    @heap[i] = x\n  end\n \n  alias_method(:<<, :push)\n \n  def pop\n    # \u6700(\u5c0f|\u5927)\u5024\n    ret = @heap[0]\n    # \u6839\u306b\u3082\u3063\u3066\u304f\u308b\u5024\n    @node_num -= 1\n    x = @heap[@node_num]\n    # \u6839\u304b\u3089\u4e0b\u308d\u3057\u3066\u3044\u304f\n    i = 0\n    while i * 2 + 1 < @node_num\n      # \u5b50\u3069\u3046\u3057\u3092\u6bd4\u8f03\n      a, b = i * 2 + 1, i * 2 + 2\n      a = b if b < @node_num && @comp.call(@heap[b], @heap[a])\n      break unless @comp.call(@heap[a], x)\n      @heap[i] = @heap[a]\n      i = a\n    end\n    @heap[i] = x\n    ret\n  end\n \n  def get\n    @node_num == 0 ? nil : @heap[0]\n  end\n \n  def empty?\n    get.nil?\n  end\nend\n\n\n\n#\n# dijkstra\n#   O(|E|log|V|)\n#   \u96a3\u63a5\u8868\u73fe\u30b0\u30e9\u30d5graph, \u59cb\u70b9start, inf\n#\ndef dijkstra(graph, start, inf = Float::INFINITY)\n  vertex_num = graph.size\n  que = PriorityQueue.new { |x, y| x[0] <= y[0] }\n  dist = Array.new(vertex_num, inf)\n  dist[start] = 0\n  que.push([0, start])\n  while !que.empty?\n    d, v = que.pop\n    next if dist[v] < d\n    graph[v].size.times do |i|\n      # e is an instance of Edge\n      #   Edge = Struct.new(:to, :cost)\n      e = graph[v][i]\n      if dist[e.to] > dist[v] + e.cost\n        dist[e.to] = dist[v] + e.cost\n        que.push([dist[e.to], e.to])\n      end\n    end\n  end\n  return dist\nend\n\n\n\nEdge = Struct.new(:to, :cost)\nv, e, r = gets.split.map(&:to_i)\ng = Array.new(v) { [] }\ne.times do |i|\n  s, t, d = gets.split.map(&:to_i)\n  g[s] << Edge.new(t, d)\nend\nputs dijkstra(g, r).map { |x| x == Float::INFINITY ? \"INF\" : x }\n", "label": 1, "name1": "s004699498.java", "name2": "s468156306.rb"}, {"id": 927, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyScan in = new MyScan(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, MyScan in, PrintWriter out) {\n            int i = in.nextInt();\n\n            long[] md = new long[i];\n\n            int rm = i - 2;\n            int lx = i - 2;\n            while (rm >= 0) {\n                md[lx + 1] = Util.c(rm, lx);\n                rm -= 2;\n                lx--;\n            }\n            long res = 0;\n            long prev = 0;\n            for (int m = 1; m < i; m++) {\n                long cur = Util.fact(m) * Util.fact(i - m - 1) % Util._m;\n                cur = cur * (md[m]) % Util._m;\n\n\n                res += (cur - prev + Util._m) * m % Util._m;\n                prev = cur;\n\n            }\n\n\n            out.println(res % Util._m);\n\n        }\n\n    }\n\n    static class MyScan {\n        private final InputStream in;\n        private byte[] inbuf = new byte[1024];\n        public int lenbuf = 0;\n        public int ptrbuf = 0;\n\n        public MyScan(InputStream in) {\n            this.in = in;\n        }\n\n        private int readByte() {\n            if (lenbuf == -1) throw new InputMismatchException();\n            if (ptrbuf >= lenbuf) {\n                ptrbuf = 0;\n                try {\n                    lenbuf = in.read(inbuf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (lenbuf <= 0) return -1;\n            }\n            return inbuf[ptrbuf++];\n        }\n\n        public int nextInt() {\n            int num = 0, b;\n            boolean minus = false;\n            while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n\n            while (true) {\n                if (b >= '0' && b <= '9') {\n                    num = num * 10 + (b - '0');\n                } else {\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n    }\n\n    static class Util {\n        public static final long M07 = 1000_000_007;\n        public static long _m = M07;\n        private static long[] fact;\n        private static long[] inv;\n        private static long[] ifact;\n\n        public static void l() {\n            fact = new long[1000001];\n            inv = new long[1000001];\n            ifact = new long[1000001];\n            for (int s = 0; s < 2; s++) {\n                fact[s] = 1;\n                ifact[s] = 1;\n                inv[s] = 1;\n            }\n            inv[0] = 0;\n            for (int i = 2; i < inv.length; i++) {\n                inv[i] = (_m - (_m / i) * inv[(int) (_m % i)] % _m) % _m;\n            }\n            for (int i = 2; i < fact.length; i++) {\n                fact[i] = i * fact[i - 1] % _m;\n                ifact[i] = inv[i] * ifact[i - 1] % _m;\n            }\n        }\n\n        public static long c(int a, int b) {\n            if (fact == null) l();\n            return ifact[a] * ifact[b - a] % _m * fact[b] % _m;\n        }\n\n        public static long fact(int a) {\n            if (fact == null) l();\n            return fact[a];\n        }\n\n    }\n}\n\n", "code2": "h,w = gets.split.map(&:to_i)\nused = Array.new(h).map{Array.new(w,false)}\ns = h.times.map{gets.chomp}\nans = 0\nh.times do |i|\n    w.times do |j|\n        next if used[i][j]\n        q = [[i,j]]\n        used[i][j] = true\n        a = b = 0\n        if s[i][j] == \".\"\n            a += 1\n        else\n            b += 1\n        end\n        while q.any?\n            x,y = q.shift\n            if x != 0 && s[x][y] != s[x-1][y] && !used[x-1][y]\n                q.push([x-1,y])\n                used[x-1][y] = true\n                if s[x-1][y] == \".\"\n                    a += 1\n                else\n                    b += 1\n                end\n            end\n            if x != h-1 && s[x][y] != s[x+1][y] && !used[x+1][y]\n                q.push([x+1,y])\n                used[x+1][y] = true\n                if s[x+1][y] == \".\"\n                    a += 1\n                else\n                    b += 1\n                end\n            end\n            if y != 0 && s[x][y] != s[x][y-1] && !used[x][y-1]\n                q.push([x,y-1])\n                used[x][y-1] = true\n                if s[x][y-1] == \".\"\n                    a += 1\n                else\n                    b += 1\n                end\n            end\n            if y != w-1 && s[x][y] != s[x][y+1] && !used[x][y+1]\n                q.push([x,y+1])\n                used[x][y+1] = true\n                if s[x][y+1] == \".\"\n                    a += 1\n                else\n                    b += 1\n                end\n            end\n        end\n        ans += a*b\n    end\nend\nputs ans", "label": 0, "name1": "s881591663.java", "name2": "s085625093.rb"}, {"id": 120, "code1": "import java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\n\n \nclass Main implements Runnable {\n  // static Scanner in;\n  static FastReader in;\n  static PrintWriter out;\n  static int[][] dirs8 = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1, 1}, {-1, -1}, {-1, 1}, {1, -1}};\n  static int[][] dirs = {{0, -1}, {1, 0}, {0, +1}, {-1, 0}};\n \n  static int[][] E;\n  // static List<int[]>[] adj;\n  static List<Integer>[] adj;\n  static int[] vis;\n \n  static long INFL = (long) 1e15 + 7;\n  static int INF = (int) 1e9 + 7;\n  static int mod = 998244353;\n  \n  static int T, n, m, k, count, cur, w;\n  static boolean flag;\n  static int[] a, b;\n  static int[][] map;\n\n  static int[] par;\n  static boolean[] dp;\n\n  static void solve() throws Exception {\n    n = in.nextInt();\n    k = in.nextInt();\n    a = new int[n]; \n    for (int i = 0; i < n; i++) {a[i] = in.nextInt();}\n    dp = new boolean[k + 1];\n    // dp[i]: win(true) or loss(false) if \"I\" have i stones left and I am to play this round\n    dp[0] = false;\n    for (int i = 1; i <= k; i++) {\n      for (int x : a) {\n        if (x > i) {break;}\n        if (!dp[i - x]) {dp[i] = true; break;}\n      }\n    }\n    out.println(dp[k] ? \"First\" : \"Second\");\n  }\n\n\n  public static void main(String[] args) throws Exception {\n \n    // in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n    in = new FastReader();\n    out = new PrintWriter(System.out);\n \n    // int numOfTests = in.nextInt();\n    // for (int caseNum = 1; caseNum <= numOfTests; caseNum++) {\n    //   // Thread t = new Thread(null, new Main(), \"Main\", 1 << 28);\n    //   // t.start();\n    //   // t.join();\n    //   solve();\n    // }\n \n    // // Thread t = new Thread(null, new Main(), \"Main\", 1 << 28);\n    // // t.start();\n    // // t.join();\n    solve();\n \n    out.flush();\n    out.close();\n  }\n \n  @Override\n  public void run() {\n    try {\n      solve();\n    } catch (Exception e) {\n      e.printStackTrace(); \n    }\n  }\n \n  static class FastReader {\n    public BufferedReader br; \n    StringTokenizer st; \n    public FastReader() {br = new BufferedReader(new InputStreamReader(System.in));} \n    String next() { \n      while (st == null || !st.hasMoreElements()) { \n          try {st = new StringTokenizer(br.readLine());} \n          catch (IOException e) {e.printStackTrace();} \n      } \n      return st.nextToken(); \n    } \n    int nextInt() {return Integer.parseInt(next());} \n    long nextLong() {return Long.parseLong(next());} \n    double nextDouble() {return Double.parseDouble(next());} \n    String nextLine() {\n      String str = \"\"; \n        try {str = br.readLine();} \n        catch (IOException e) {e.printStackTrace();} \n        return str; \n    }\n  }\n\n  static void as(boolean result) throws Exception {\n    if (!result) {\n      throw new Exception();\n    }\n  }\n\n  static int modInverse(int a, int m) { \n    int m0 = m; \n    int y = 0, x = 1; \n    if (m == 1) {return 0;} \n    while (a > 1) { \n      // q is quotient \n      int q = a / m; \n      int t = m; \n      // m is remainder now, process \n      // same as Euclid's algo \n      m = a % m; \n      a = t; \n      t = y; \n      // Update x and y \n      y = x - q * y; \n      x = t; \n    } \n    // Make x positive \n    if (x < 0) \n      x += m0; \n    return x; \n  } \n} \n", "code2": "n, k = gets.split.map(&:to_i)\na = gets.split.map(&:to_i)\n\ndp = Array.new(k+1) {[nil, nil]}\n\n(k+1).times do |i|\n    2.times do |player|\n        a.each do |e|\n            if i < e\n                dp[i][player] = player ^ 1\n                break\n            end\n\n            if dp[i-e][player ^ 1] == player\n                dp[i][player] = player\n                break\n            end\n        end or next\n        dp[i][player] = player ^ 1\n    end\nend\n\nputs dp[k][0] == 0 ? \"First\" : \"Second\"", "label": 1, "name1": "s772358717.java", "name2": "s522658822.rb"}, {"id": 483, "code1": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int a[][] = new int[n][n];\n\n        for (int i = 0; i < m; i++) {\n            int t1 = in.nextInt() - 1;\n            int t2 = in.nextInt() - 1;\n            a[t1][t2] = 1;\n            a[t2][t1] = 1;\n        }\n        List<Integer> order = new ArrayList<>();\n        order.add(0);\n        List<Integer> remain = new ArrayList<>();\n        for (int i = 1; i < n; i++) {\n            remain.add(i);\n        }\n        System.out.println(f(order, remain, a));\n    }\n\n    static int f(List<Integer> order, List<Integer> remain, int edges[][]) {\n        if (remain.size() == 0) {\n            int cur = order.get(0);\n            int next;\n            for (int p = 1; p < order.size(); p++) {\n                next = order.get(p);\n                if (edges[cur][next] == 1 || edges[next][cur] == 1) {\n                    cur = next; \n                } else {\n                    return 0;\n                }\n            }\n            return 1;\n        }\n\n        int total = 0;\n        for (int p = 0; p < remain.size(); p++) {\n            order.add(remain.get(p));\n            remain.remove(p);\n            total += f(order, remain, edges);\n            remain.add(p, order.get(order.size() - 1));\n            order.remove(order.size() - 1);\n        }\n        return total;\n    }\n}", "code2": "require \"set\"\n\nn, m = gets.split(\" \").map(&:to_i)\nedges = {}\nnodes = Set.new\nm.times do |i|\n  a, b = gets.split(\" \").map(&:to_i)\n  edges[a] ||= []\n  edges[a] << b\n  edges[b] ||= []\n  edges[b] << a\n  nodes << a\n  nodes << b\nend\n\ndef one_line s, n, nodes, edges\n  # p \"[debug] set: #{s}, node: #{n}\"\n  new_s = s.clone\n  new_s << n\n  if new_s == nodes then\n    return 1\n  end\n\n  res = 0\n  ((edges[n] || []) - new_s.to_a).each do |b|\n    res += one_line new_s, b, nodes, edges\n  end\n  return res\nend\n\nputs one_line(Set.new, 1, nodes, edges)", "label": 1, "name1": "s216336518.java", "name2": "s002122536.rb"}, {"id": 827, "code1": "\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int A = scanner.nextInt();\n        int B = scanner.nextInt();\n        int C = scanner.nextInt();\n\n        if ((A == B && A != C) || (A == C && A != B) || (B == C &&  A != B)) {\n            System.out.println(\"Yes\");\n        } else {\n            System.out.println(\"No\");\n        }\n    }\n}\n", "code2": "def selection(n, arr)\n    c = 0\n    0.upto(n-1) do |i|\n        minj = i\n        i.upto(n-1) do |j|\n            if arr[j] < arr[minj] then\n                minj = j\n            end\n        end\n        if i != minj then\n            arr[i], arr[minj] = arr[minj], arr[i]\n            c += 1\n        end\n    end\n    puts arr.join(\" \")\n    p c\nend\nselection(gets.to_i, gets.split.map(&:to_i))", "label": 0, "name1": "s748781959.java", "name2": "s594460948.rb"}, {"id": 193, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n  public static void main(String[] args) {\n\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    long[] a = new long[n];\n\n    for (int i = 0; i < n; i++) {\n      a[i] = sc.nextInt();\n    }\n\n    Arrays.sort(a); // \u6607\u9806\n    long sum = a[n - 1];\n\n    if (n == 2) {\n      System.out.println(sum);\n    } else {\n      if (n % 2 == 1) {\n        int num = n / 2;\n        sum += a[n - num - 1];\n        for (int i = n - num; i < n - 1; i++) {\n          sum += 2 * a[i];\n        }\n        System.out.println(sum);\n      } else {\n        int num = n / 2;\n        for (int i = n - num; i < n - 1; i++) {\n          sum += 2 * a[i];\n        }\n        System.out.println(sum);\n      }\n    }\n\n  }\n}", "code2": "n=gets.to_i\na = gets.split.map(&:to_i).sort\na.unshift(0)\nsum = 0\n(1..n-1).each do |k|\n  sum += a[n-k/2]\nend\np sum\n", "label": 1, "name1": "s266436818.java", "name2": "s326126157.rb"}, {"id": 157, "code1": "/**\n * Created at 16:38 on 2019-08-27\n */\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n  static FastScanner sc = new FastScanner();\n  static Output out = new Output(System.out);\n\n  static final int[] dx = {0, 1, 0, -1};\n  static final int[] dy = {-1, 0, 1, 0};\n\n  static final long MOD = (long) (1e9 + 7);\n  static final long INF = Long.MAX_VALUE / 2;\n\n  public static class Solver {\n    public Solver() {\n\n      int Q = sc.nextInt();\n\n      for (int q=0; q<Q; q++) {\n        long A = sc.nextLong();\n        long B = sc.nextLong();\n        long P = A * B;\n\n        long sqrt = sqrt(P-1);\n\n        long ans = 2*sqrt;\n\n        if (Math.min(A, B) <= sqrt) ans--; //\u9ad8\u6a4b\u541b\u3068\u540c\u3058\u9806\u4f4d\u306b\u306a\u3063\u3066\u3044\u308b\u3082\u306e\u3092\u9664\u304f\n        if (sqrt * (sqrt+1) > P-1) ans--; //\u30c0\u30d6\u30eb\u30ab\u30a6\u30f3\u30c8\u3057\u3066\u3044\u308b\u3082\u306e\u3092\u9664\u304f(x == y \u306e\u3068\u304d)\n\n        out.println(ans);\n      }\n\n\n    }\n\n    long sqrt(long n) {\n      long res = (long)Math.floor(Math.sqrt(n));\n      while (res * res > n) res--;\n      while ((res+1) * (res+1) <= n) res++;\n      return res;\n    }\n\n  }\n\n  public static void main(String[] args) {\n    new Solver();\n    out.flush();\n  }\n\n  static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int N, boolean oneBased) {\n      if (oneBased) {\n        int[] array = new int[N + 1];\n        for (int i = 1; i <= N; i++) {\n          array[i] = sc.nextInt();\n        }\n        return array;\n      } else {\n        int[] array = new int[N];\n        for (int i = 0; i < N; i++) {\n          array[i] = sc.nextInt();\n        }\n        return array;\n      }\n    }\n\n    public long[] nextLongArray(int N, boolean oneBased) {\n      if (oneBased) {\n        long[] array = new long[N + 1];\n        for (int i = 1; i <= N; i++) {\n          array[i] = sc.nextLong();\n        }\n        return array;\n      } else {\n        long[] array = new long[N];\n        for (int i = 0; i < N; i++) {\n          array[i] = sc.nextLong();\n        }\n        return array;\n      }\n    }\n  }\n\n  static class Output extends PrintWriter {\n\n    public Output(PrintStream ps) {\n      super(ps);\n    }\n\n    public void print(int[] a, String separator) {\n      for (int i = 0; i < a.length; i++) {\n        if (i == 0) print(a[i]);\n        else print(separator + a[i]);\n      }\n      println();\n    }\n\n    public void print(long[] a, String separator) {\n      for (int i = 0; i < a.length; i++) {\n        if (i == 0) print(a[i]);\n        else print(separator + a[i]);\n      }\n      println();\n    }\n\n    public void print(String[] a, String separator) {\n      for (int i = 0; i < a.length; i++) {\n        if (i == 0) print(a[i]);\n        else print(separator + a[i]);\n      }\n      println();\n    }\n\n    public void print(ArrayList a, String separator) {\n      for (int i = 0; i < a.size(); i++) {\n        if (i == 0) print(a.get(i));\n        else print(separator + a.get(i));\n      }\n      println();\n    }\n  }\n\n}\n", "code2": "gets.to_i.times{\n\ta,b=gets.split.map &:to_i\n\tt=a*b\n\ts=Math.sqrt(t).to_i\n\tr=2*s-2\n\tr-=1 if s*s==t\n\tr+=1 if s*(s+1)<t\n\tr+=1 if a==b\n\tp r\n}", "label": 1, "name1": "s001351994.java", "name2": "s605229317.rb"}, {"id": 682, "code1": "import java.util.*;\n\nclass Main {\n\tpublic static void main(String args[]) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint m, f, count = 0, sum;\n\t\tm = scanner.nextInt();\n\t\tf = scanner.nextInt();\n\t\twhile(!(m == 0 && f == 0)) {\n\t\t\tfor(int i = 1;i < m+1;i++) {\n\t\t\t\tfor(int j = 1;j < m+1;j++) {\n\t\t\t\t\tfor(int k = 1;k < m+1;k++) {\n\t\t\t\t\t\t\tsum =  i+j+k;\n\t\t\t\t\t\t\tif(sum == f && (i!=j)&&(j!=k)&&(k!=i)) \n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count/(1*2*3));\n\t\t\tcount = 0;\n\t\t\tm = scanner.nextInt();\n\t\t\tf = scanner.nextInt();\n\t\t}\n\t\tscanner.close();\n\t}\n}", "code2": "a = Array.new(3)\nb = Array.new(3)\n\ncounts = Hash.new(0)\n3.times do|i|\n  a, b = gets.split.map(&:to_i)\n  counts[a.to_s] += 1\n  counts[b.to_s] += 1\nend\n\nputs counts.sort { |(k1, v1), (k2, v2)| v1<=>v2 }.map { |k, v| v } == [1, 1, 2, 2] ? 'YES' : 'NO'\n", "label": 0, "name1": "s275047149.java", "name2": "s056579310.rb"}, {"id": 943, "code1": "import java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.*;\nimport java.text.DecimalFormat;\nimport java.util.*;\n\n\n\n\npublic class Main {\n    private static int n,N;\n    private static int [] A;\n    private static int [] B;\n\n    private static int getLeft(){\n        int s = N/2 + 1;\n        while (s > 1 && B[s] != B[s-1]) s--;\n        return s;\n    }\n    private static int getRight(){\n        int e = N/2+1;\n        while (e < N && B[e] != B[e+1]) e++;\n        return e;\n    }\n\n    private static boolean valid(int x) {\n        for (int i = 1;i <= N;i++)\n            B[i] = (A[i] >= x) ? 1 : 0;\n        int s = getLeft(),e = getRight(),mid = N/2 + 1;\n        if (s == mid || e == mid) return B[mid] == 1;\n\n//        System.err.println(s + \" \" + e);\n        int prv = 0;\n        int l = B[s],r = B[e];\n\n        while (s <= e) {\n            int h = Math.max(s,e);\n            h = Math.min(h,N+1-h) - 1;\n            int rem = h - prv;\n            prv = h;\n            if (rem == 0) break;\n            int len = e-s-1;\n            if (2*rem <= len) {\n                s += rem;\n                e -= rem;\n            }\n            else {\n                if (l == r) return l == 1;\n                if (mid-s < e-mid) return l == 1;\n                else return r==1;\n            }\n        }\n//        System.err.println(\": \" + s + \" \" + e);\n        if (l == r) return l == 1;\n        int pos = mid - s;\n        if (l == 0) return pos%2 == 0;\n        return pos%2 == 1;\n    }\n    public static void main(String[] args) throws Exception {\n        IO io = new IO(null,null);\n        n = io.getNextInt();\n        N = 2*n-1;\n        A = new int[N+1];\n        B = new int[N+1];\n        for (int i = 1;i <= N;i++)\n            A[i] = io.getNextInt();\n\n        int s = 1,e = N;\n        while (s < e) {\n            int m = s + (e-s+1)/2;\n            if (valid(m)) s = m;\n            else e = m - 1;\n        }\n        io.println(s);\n\n        io.close();\n    }\n    private static void bf(int n) {\n        ArrayList<Integer> A = new ArrayList<>();\n        for (int i = 0;i < n;i++)\n            A.add(i&1);\n        TreeSet<ArrayList<Integer>> vis = new TreeSet<>(new Comparator<ArrayList<Integer>>() {\n            @Override\n            public int compare(ArrayList<Integer> o1, ArrayList<Integer> o2) {\n                for (int i = 0;i < n;i++)\n                    if (!o1.get(i).equals(o2.get(i)))\n                        return o1.get(i) - o2.get(i);\n                return 0;\n            }\n        });\n\n        while (!vis.contains(A)) {\n            System.err.println(A);\n            vis.add((ArrayList<Integer>)A.clone());\n            int prv = A.get(0);\n            for (int i = 1;i+1 < n;i++){\n                int cur = A.get(i);\n                if (prv != cur) A.set(i,A.get(i+1));\n                prv = cur;\n            }\n        }\n    }\n\n    private static void bftri(int n) {\n        ArrayList<Integer> A = new ArrayList<>();\n        for (int i = 0;i < n;i++)\n            A.add(i&1);\n        while (!A.isEmpty()) {\n            System.err.println(A);\n\n            ArrayList<Integer> B = new ArrayList<>();\n            int prv = A.get(0);\n            for (int i = 1;i+1 < A.size();i++){\n                int cur = A.get(i);\n                if (prv != cur) B.add(A.get(i+1));\n                else B.add(cur);\n                prv = cur;\n            }\n            A = B;\n        }\n    }\n}\n\nclass pair{\n    int s,e,v;\n    public pair(int s,int e,int v) {\n        this.s = s;\n        this.e = e;\n        this.v = v;\n    }\n    public int getLen(){\n        return e-s+1;\n    }\n    @Override\n    public String toString(){\n        return \"(\" + s + \":\" + e + \", \" + v + \")\";\n    }\n}\n\n\nclass IO{\n    private BufferedReader br;\n    private StringTokenizer st;\n    private PrintWriter writer;\n    private String inputFile,outputFile;\n\n    public boolean hasMore() throws IOException{\n        if(st != null && st.hasMoreTokens()) return true;\n        if(br != null && br.ready()) return true;\n        return false;\n    }\n    public String getNext() throws FileNotFoundException, IOException{\n        while(st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());\n        return st.nextToken();\n    }\n\n    public String getNextLine() throws FileNotFoundException, IOException{\n        return br.readLine().trim();\n    }\n\n    public int getNextInt() throws FileNotFoundException, IOException{\n        return Integer.parseInt(getNext());\n    }\n    public long getNextLong() throws FileNotFoundException, IOException{\n        return Long.parseLong(getNext());\n    }\n\n    public void print(double x,int num_digits) throws  IOException{\n        writer.printf(\"%.\" + num_digits + \"f\" ,x);\n    }\n    public void println(double x,int num_digits) throws  IOException{\n        writer.printf(\"%.\" + num_digits + \"f\\n\" ,x);\n    }\n    public void print(Object o) throws  IOException{\n        writer.print(o.toString());\n    }\n\n    public void println(Object o) throws  IOException{\n        writer.println(o.toString());\n    }\n    public IO(String x,String y) throws FileNotFoundException, IOException{\n        inputFile = x;\n        outputFile = y;\n        if(x != null) br = new BufferedReader(new FileReader(inputFile));\n        else br = new BufferedReader(new InputStreamReader(System.in));\n        if(y != null) writer = new PrintWriter(new BufferedWriter(new FileWriter(outputFile)));\n        else writer = new PrintWriter(new OutputStreamWriter(System.out));\n    }\n\n    protected void close() throws IOException{\n        br.close();\n        writer.close();\n    }\n    public void outputArr(Object [] A) throws IOException{\n        int L = A.length;\n        for (int i = 0;i < L;i++) {\n            if(i > 0) writer.print(\" \");\n            writer.print(A[i]);\n        }\n        writer.print(\"\\n\");\n    }\n}\n", "code2": "p`dd`.count ?2", "label": 0, "name1": "s134955630.java", "name2": "s071879224.rb"}, {"id": 926, "code1": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tint mod = 1000000007;\n\t\tlong[][] res =  guessLeaned(1000000007, \n\t\t\t\t1, 4, 16, 84, 516, 3696, 30096, 275040, 2786400, 31000320, 375736320, 928152292\n\t\t\t\t);\n\t\t\n\t\tlong[] u = {1, 4, 16};\n\t\tfor(int i = 3;i <= n;i++){\n\t\t\tlong v = f(res, u, i, mod);\n\t\t\tfor(int j = 0;j < 2;j++){\n\t\t\t\tu[j] = u[j+1];\n\t\t\t}\n\t\t\tu[2] = v;\n\t\t}\n\t\tout.println(u[0]);\n\t}\n\t\n\tpublic static long f(long[][] ged, long[] prevs, long x, int mod)\n\t{\n\t\tint n = ged.length;\n\t\tassert prevs.length == n-1;\n\t\tx -= n-1;\n\t\t\n\t\tlong s = 0;\n\t\tlong tar = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tlong co = 0;\n\t\t\tfor(int j = ged[i].length-1;j >= 0;j--){\n\t\t\t\tco = (co * x + ged[i][j]) % mod;\n\t\t\t}\n\t\t\tif(i < n-1){\n\t\t\t\ts += co * prevs[i];\n\t\t\t\ts %= mod;\n\t\t\t}else{\n\t\t\t\ttar = co;\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong ret = -invl(tar, mod) * s % mod;\n\t\tif(ret < 0)ret += mod;\n\t\treturn ret;\n\t}\n\t\n\tpublic static long[][] guessLeaned(int mod, long... a)\n\t{\n\t\tint n = a.length;\n\t\t\n\t\t// #formula >= #variable\n\t\t// n-r+2 >= r(r+1)/2\n\t\tfor(int r = n;r >= 1;r--){\n\t\t\tif(n-r+2 < r*(r+1)/2)continue;\n\t\t\tint[][] M = new int[n-r+2][r*(r+1)/2];\n\t\t\tfor(int i = 0;i < n-r+1;i++){\n\t\t\t\tint p = 0;\n\t\t\t\tfor(int j = 0;j < r;j++){\n\t\t\t\t\tlong prod = 1;\n\t\t\t\t\tfor(int k = 0;k <= r-j-1;k++){\n\t\t\t\t\t\tM[i][p++] = (int)(prod*a[i+j]%mod);\n\t\t\t\t\t\tprod = prod * i % mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tM[n-r+1][0] = 1;\n\t\t\t\n\t\t\tint[] v = new int[n-r+2];\n\t\t\tv[n-r+1] = 1;\n\t\t\t\n\t\t\tResult res = gaussElimination(M, v, mod);\n\t\t\tif(res.exists){\n\t\t\t\tlong[][] ret = new long[r][];\n\t\t\t\tint p = 0;\n\t\t\t\tfor(int i = 0;i < r;i++){\n\t\t\t\t\tret[i] = new long[r-i];\n\t\t\t\t\tfor(int j = 0;j < r-i;j++){\n\t\t\t\t\t\tret[i][j] = res.sol[p++];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic static Result gaussElimination(int[][] M, int[] v, int mod)\n\t{\n\t\tint n = M.length, m = M[0].length;\n\t\tint[] head = new int[n];\n\t\t\n\t\t// if not needed, comment out.\n\t\tfor(int[] row : M){\n\t\t\tfor(int i = 0;i < row.length;i++){\n\t\t\t\trow[i] %= mod;\n\t\t\t\tif(row[i] < 0)row[i] += mod;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Forward Elimination\n\t\tint row = 0;\n\t\tfor(int col = 0;col < m;col++){\n\t\t\t// select pivot\n\t\t\tboolean pivotFound = false;\n\t\t\tout:\n\t\t\tfor(int prow = row;prow < n;prow++){\n\t\t\t\tif(M[prow][col] != 0){\n\t\t\t\t\t// pivot found\n\t\t\t\t\tif(prow != row){\n\t\t\t\t\t\t// swap rows\n\t\t\t\t\t\tfor(int k = 0;k < m;k++){\n\t\t\t\t\t\t\tint u = M[prow][k]; M[prow][k] = M[row][k]; M[row][k] = u;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint dum = v[prow]; v[prow] = v[row]; v[row] = dum;\n\t\t\t\t\t}\n\t\t\t\t\tpivotFound = true;\n\t\t\t\t\tbreak out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!pivotFound)continue;\n\t\t\thead[row] = col;\n\t\t\t\n\t\t\t// diag to 1\n\t\t\tlong imul = invl(M[row][col], mod);\n\t\t\tfor(int k = 0;k < m;k++){\n\t\t\t\tM[row][k] = (int)(M[row][k] * imul % mod);\n\t\t\t}\n\t\t\tv[row] = (int)(v[row] * imul % mod);\n\t\t\t\n\t\t\tfor(int j = row+1;j < n;j++){\n\t\t\t\tif(M[j][col] != 0){\n\t\t\t\t\tlong mul = mod-M[j][col];\n\t\t\t\t\tfor(int k = col;k < m;k++){\n\t\t\t\t\t\tM[j][k] = (int)((M[j][k] + M[row][k] * mul) % mod);\n\t\t\t\t\t}\n\t\t\t\t\tv[j] = (int)((v[j] + v[row] * mul) % mod);\n\t\t\t\t}\n\t\t\t}\n\t\t\trow++;\n\t\t}\n\t\t\n\t\tResult ret = new Result();\n\t\tret.mat = M;\n\t\tfor(int i = row;i < n;i++){\n\t\t\tif(v[i] != 0){\n\t\t\t\tret.rank = row;\n\t\t\t\tret.exists = false;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = row-1;i >= 0;i--){\n\t\t\tfor(int j = i-1;j >= 0;j--){\n\t\t\t\tif(M[j][head[i]] != 0){\n\t\t\t\t\tlong mul = mod-M[j][head[i]];\n\t\t\t\t\tfor(int k = head[i];k < m;k++){\n\t\t\t\t\t\tM[j][k] = (int)((M[j][k] + M[i][k] * mul) % mod);\n\t\t\t\t\t}\n\t\t\t\t\tv[j] = (int)((v[j] + v[i] * mul) % mod);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] retv = new int[m];\n\t\tfor(int i = 0;i < row;i++){\n\t\t\tretv[head[i]] = v[i];\n\t\t}\n\t\t\n\t\tret.sol = retv;\n\t\tret.rank = row;\n\t\tret.exists = true;\n\t\treturn ret;\n\t}\n\t\n\tpublic static class Result\n\t{\n\t\tpublic int[][] mat;\n\t\tpublic int[] sol;\n\t\tpublic int rank;\n\t\tpublic boolean exists;\n\t}\n\t\n\tpublic static long invl(long a, long mod) {\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\treturn p < 0 ? p + mod : p;\n\t}\n\n\n\t\n\tpublic static long C(int n, int r, int mod, int[][] fif) {\n\t\tif (n < 0 || r < 0 || r > n)\n\t\t\treturn 0;\n\t\treturn (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n\t}\n\n\t\n\tpublic static int[][] enumFIF(int n, int mod) {\n\t\tint[] f = new int[n + 1];\n\t\tint[] invf = new int[n + 1];\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i] = (int) ((long) f[i - 1] * i % mod);\n\t\t}\n\t\tlong a = f[n];\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\tinvf[n] = (int) (p < 0 ? p + mod : p);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tinvf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n\t\t}\n\t\treturn new int[][] { f, invf };\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n", "code2": "h,w = gets.split.map(&:to_i)\na = Array.new(h){ gets.chomp }\n\nseen = Array.new(h){ Array.new(w){ false } }\nDX = [ 0, 1, 0,-1, 1,-1, 1,-1]\nDY = [ 1, 0,-1, 0, 1,-1,-1, 1]\ninside = -> y, x { 0 <= y && y < h && 0 <= x && x < w }\n\nbfs = -> sy,sx do\n  que = [[sy,sx]]\n  black = 0\n  white = 0\n  while que.size > 0\n    y,x = que.pop\n    next if seen[y][x]\n    seen[y][x] = true\n    a[y][x] == \"#\" ? black += 1 : white += 1\n    4.times do |i|\n      ny = y + DY[i]\n      nx = x + DX[i]\n      next unless inside[ny,nx]\n      next if a[y][x] == a[ny][nx] # \u540c\u3058\u8272\u306a\u3089\u5bfe\u8c61\u5916\n      que << [ny,nx]\n    end\n  end\n  return black * white\nend\n\nans = 0\nh.times do |y|\n  w.times do |x|\n    ans += bfs[y,x]\n  end\nend\nputs ans", "label": 0, "name1": "s195205493.java", "name2": "s014943683.rb"}, {"id": 272, "code1": "import java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);  \n\t\twhile(true){\n\t\t\t    int n=sc.nextInt();\n\t\t\t    int x=sc.nextInt();\n\t\t\t    if(n==0&&x==0)break;\n\t\t\t    int cnt=0;\n\t\t\t    for(int i=1;i<=n;i++){\n\t\t\t        for(int j=i+1;j<=n;j++){\n\t\t\t            for(int k=j+1;k<=n;k++){\n\t\t\t                if(i+j+k==x)cnt++;\n\t\t\t            }\n\t\t\t        }\n\t\t\t    }\n\t\t\t    System.out.println(cnt);\n\t\t}\n\t}\n}", "code2": "#!ruby -an\nn,m=$F.map &:to_i\nbreak if n<3\np [*1..n].combination(3).map{|i|i.inject(:+)}.count m", "label": 1, "name1": "s954202209.java", "name2": "s772764129.rb"}, {"id": 375, "code1": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tstatic void solve() {\n\t\tlong i = ni(), o = ni(), t = ni(), j = ni(), l = ni(), s = ni(), z = ni();\n\t\tlong ans = 0;\n\t\tans += o;\n\t\t\n\t\t\n\t\tlong rem = i%2+j%2+l%2;\n\t\tif(i==0||j==0||l==0) {\n\t\t\tans += 2*(i/2 + j/2 + l/2);\n\t\t\tout.println(ans);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(rem<=1) {\n\t\t\tans += 2*(i/2 + j/2 + l/2);\n\t\t}\n\t\telse {\n\t\t\tans += 3;\n\t\t\ti--; j--;l--;\n\t\t\tans += 2*(i/2 + j/2 + l/2);\n\t\t}\n\t\tout.println(ans);\n\t\t\n\t}\n\n\t//constant\n\tstatic final long mod = (long) 1e9 + 7;\n\tstatic final int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };\n\tstatic final int[] dx8 = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\tstatic final int inf = Integer.MAX_VALUE / 2;\n\tstatic final long linf = Long.MAX_VALUE / 3;\n\tstatic final double dinf = Double.MAX_VALUE / 3;\n\tstatic final double eps = 1e-10;\n\tstatic final double pi = Math.PI;\n\tstatic StringBuilder sb = new StringBuilder();\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\t//libraries\n\tstatic void reverse(int ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tint t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(long ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tlong t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(double ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tdouble t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(char ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tchar t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic String getReverse(String s) {\n\t\tchar c[] = s.toCharArray();\n\t\treverse(c);\n\t\ts = String.valueOf(c);\n\t\treturn s;\n\t}\n\n\tstatic <T> void reverse(List<T> ls) {\n\t\tint sz = ls.size();\n\t\tfor (int i = 0; i < sz / 2; i++) {\n\t\t\tT t = ls.get(i);\n\t\t\tls.set(i, ls.get(sz - 1 - i));\n\t\t\tls.set(sz - 1 - i, t);\n\t\t}\n\t}\n\n\tstatic <T> void reverse(T[] ar) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tT t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void sbnl() {//StringBuilder\u306b\u6539\u884c\u6587\u5b57\u3092append\u3059\u308b\n\t\tsb.append(\"\\n\");\n\t}\n\n\tstatic int lowerBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int lowerBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int lowerBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int lowerBound(char[] a, char x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(char[] a, char x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(char[] a, char x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(char[] a, char x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic <T> int lowerBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) >= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) >= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) >= 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int upperBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) > 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) > 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) > 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int rupperBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) < 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) < 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) < 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int rlowerBound(List<T> ls, T x) {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) <= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) <= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) <= 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic int[] concat(int x, int arr[]) {\n\t\tint ret[] = new int[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 1, ret.length - 1);\n\t\tret[0] = x;\n\t\treturn ret;\n\t}\n\n\tstatic int[] concat(int arr[], int x) {\n\t\tint ret[] = new int[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 0, ret.length - 1);\n\t\tret[ret.length - 1] = x;\n\t\treturn ret;\n\t}\n\n\tstatic long[] concat(long x, long arr[]) {\n\t\tlong ret[] = new long[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 1, ret.length - 1);\n\t\tret[0] = x;\n\t\treturn ret;\n\t}\n\n\tstatic long[] concat(long arr[], long x) {\n\t\tlong ret[] = new long[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 0, ret.length - 1);\n\t\tret[ret.length - 1] = x;\n\t\treturn ret;\n\t}\n\n\tstatic int max(int x, int y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic int min(int x, int y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic int max(int x, int y, int z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic int min(int x, int y, int z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic long max(long x, long y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic long min(long x, long y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic long max(long x, long y, long z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic long min(long x, long y, long z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic double max(double x, double y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic double min(double x, double y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic double max(double x, double y, double z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic double min(double x, double y, double z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic void sort(int[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void sort(long[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void sort(double[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void sort(char[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void rsort(int[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tint tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void rsort(long[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tlong tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void rsort(double[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tdouble tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void rsort(char[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tchar tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void fill(int arr[], int x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(long arr[], long x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(boolean arr[], boolean x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(double arr[], double x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(int arr[][], int x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(long arr[][], long x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(double arr[][], double x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(boolean arr[][], boolean x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\t//MOD culc\n\tstatic long plus(long x, long y) {\n\t\tlong res = (x + y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long sub(long x, long y) {\n\t\tlong res = (x - y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long mul(long x, long y) {\n\t\tlong res = (x * y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long div(long x, long y) {\n\t\tlong res = x * pow(y, mod - 2) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long pow(long x, long y) {\n\t\tif (y < 0)\n\t\t\treturn 0;\n\t\tif (y == 0)\n\t\t\treturn 1;\n\t\tif (y % 2 == 1)\n\t\t\treturn (x * pow(x, y - 1)) % mod;\n\t\tlong root = pow(x, y / 2);\n\t\treturn root * root % mod;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\t//input\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static long[] nla(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n}\n", "code2": "a = gets.split.map(&:to_i)\nans = a[1]\nif (a[0]%2)+(a[3]%2)+(a[4]%2) >= 2 && [a[0], a[3], a[4]].min > 0\n  ans += 3\n  a[0] -= 1\n  a[3] -= 1\n  a[4] -= 1\nend\n\nans += (a[0] / 2) * 2\nans += (a[3] / 2) * 2\nans += (a[4] / 2) * 2\n\nputs ans", "label": 1, "name1": "s751122857.java", "name2": "s995460361.rb"}, {"id": 756, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\n\n/*\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n            pass System Test!\n*/\n\npublic class Main {\n  private static class Task {\n    void solve(FastScanner in, PrintWriter out) {\n      int H = in.nextInt();\n      int W = in.nextInt();\n      char[][] map = new char[H][];\n      for (int i = 0; i < H; i++) {\n        map[i] = in.next().toCharArray();\n      }\n\n      boolean[][] red = new boolean[H][W];\n      boolean[][] blue = new boolean[H][W];\n      for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n          if (j == 0) red[i][j] = true;\n          else if (j == W - 1) blue[i][j] = true;\n          else if (i % 2 == 0) red[i][j] = true;\n          else blue[i][j] = true;\n        }\n      }\n\n      for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n          if (map[i][j] == '.') continue;\n          blue[i][j] = true;\n          red[i][j] = true;\n        }\n      }\n\n      for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n          out.print(red[i][j] ? \"#\" : \".\");\n        }\n        out.println();\n      }\n      out.println();\n      for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n          out.print(blue[i][j] ? \"#\" : \".\");\n        }\n        out.println();\n      }\n    }\n  }\n\n  /**\n   * \u3053\u3053\u304b\u3089\u4e0b\u306f\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u3067\u3059\u3002\n   */\n  public static void main(String[] args) {\n    OutputStream outputStream = System.out;\n    FastScanner in = new FastScanner();\n    PrintWriter out = new PrintWriter(outputStream);\n    Task solver = new Task();\n    solver.solve(in, out);\n    out.close();\n  }\n  private static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n      int[] array = new int[n];\n      for (int i = 0; i < n; i++) array[i] = nextInt();\n      return array;\n    }\n\n    public long[] nextLongArray(int n) {\n      long[] array = new long[n];\n      for (int i = 0; i < n; i++) array[i] = nextLong();\n      return array;\n    }\n\n    public String[] nextStringArray(int n) {\n      String[] array = new String[n];\n      for (int i = 0; i < n; i++) array[i] = next();\n      return array;\n    }\n\n    public char[][] nextCharMap(int n) {\n      char[][] array = new char[n][];\n      for (int i = 0; i < n; i++) array[i] = next().toCharArray();\n      return array;\n    }\n  }\n}\n", "code2": "class Array\n  def merge_sort\n    return self if length <= 1\n    a, b = half.map(&:merge_sort)\n    merge(a, b)\n  end\n\n  def half\n    n = (length/2.0).floor\n    return self[0...n], self[n..(length-1)]\n  end\n\n  private\n\n  def merge(a, b)\n    result = []\n    while a.size > 0 || b.size > 0\n      result << if a.empty?\n                  b.shift\n                elsif b.empty?\n                  a.shift\n                elsif a.first < b.first\n                  a.shift\n                else\n                  b.shift\n                end\n    end\n    result\n  end\nend\n\nwhile n = gets.to_i\n  break if n == 0\n  puts gets.split(' ').map(&:to_i).merge_sort.join(' ')\nend", "label": 0, "name1": "s871155444.java", "name2": "s469802588.rb"}, {"id": 300, "code1": "import java.util.*;\n\npublic class Main {\n    \n    public static boolean[] alr;\n    \n    public static List<List<Integer>> list = new ArrayList<>();\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        alr = new boolean[N];\n        for (int i = 0; i < N; i++) {\n            list.add(new ArrayList<>());\n        }\n        for (int i = 0; i < M; i++) {\n            int A = sc.nextInt()-1;\n            int B = sc.nextInt()-1;\n            list.get(A).add(B);\n            list.get(B).add(A);\n        }\n        long count = 0;\n        for (int i = 0; i < list.size(); i++) {\n            if (alr[i]) {\n                continue;\n            } else {\n                alr[i] = true;\n                count++;\n            }\n            List<Integer> lst = list.get(i);\n            count(lst);\n        }\n        System.out.println(count-1);\n    }\n    \n    private static void count(List<Integer> lst) {\n        int friends = 0;\n        for (Integer i : lst) {\n            if (alr[i]) {\n                continue;\n            } else {\n                alr[i] = true;\n            }           \n            count(list.get(i));\n        }\n    }\n}\n", "code2": "module AtCoder\n  class DSU\n    def initialize(n = 0)\n      @n = n\n      @parent_or_size = Array.new(n, -1)\n    end\n\n    def merge(a, b)\n      x, y = leader(a), leader(b)\n      return x if x == y\n\n      x, y = y, x if -@parent_or_size[x] < -@parent_or_size[y]\n      @parent_or_size[x] += @parent_or_size[y]\n      @parent_or_size[y] = x\n    end\n\n    def same(a, b)\n      leader(a) == leader(b)\n    end\n\n    def leader(a)\n      return a if @parent_or_size[a] < 0\n\n      @parent_or_size[a] = leader(@parent_or_size[a])\n    end\n\n    def size(a)\n      -@parent_or_size[leader(a)]\n    end\n\n    def groups\n      @n.times.group_by { |i| leader(i) }.values\n    end\n  end\nend\n\nn, m = gets.split.map!(&:to_i)\n\ndsu = AtCoder::DSU.new(n + 1)\nm.times do\n  a, b = gets.split.map!(&:to_i)\n  dsu.merge(a, b)\nend\n\nputs dsu.groups.size - 2\n", "label": 1, "name1": "s602301737.java", "name2": "s989552174.rb"}, {"id": 337, "code1": "import java.util.*;\nclass Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String S[] = sc.next().split(\"\");\n    \n    int n = (int)Math.pow(2, S.length - 1);\n    \n    long total = 0;\n    for (int i = 0; i < n; i++) {\n      String s = S[0];\n      \n      for (int j = 0; j < S.length - 1; j++) {\n        if ((1&i>>j) == 1) {\n          total += Long.parseLong(s);\n          s = S[j + 1];\n        } else {\n          s += S[j + 1];\n        }\n      }\n      total += Long.parseLong(s);\n    }\n    System.out.println(total);\n  }\n}", "code2": "s = gets.chomp.chars\nsum = 0\n['', '+'].repeated_permutation(s.size-1).each do |array|\n  sum += eval(s.zip(array).join)\nend\n\nputs sum", "label": 1, "name1": "s109985040.java", "name2": "s545852610.rb"}, {"id": 647, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[] fact = new int[9];\n\n\n\tpublic static void main(String[] args) {\n\t\tfact[1] = 1;\n\t\tfor(int i = 2; i <= 8; i++)\n\t\t\tfact[i] = fact[i-1] * i;\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] p = new int[n];\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tp[i] = sc.nextInt();\n\n\t\tint[] q = new int[n];\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tq[i] = sc.nextInt();\n\n\t\tint ans = Math.abs(getPosi(p) - getPosi(q));\n\t\tSystem.out.println(ans);\n        return;\n    }\n\n\tstatic private int getPosi(int[] x) {\n\n\t\t\tint l = x.length;\n\t\t\tint p = 1;\n\n\t\t\tfor(int i = 0; i < l; i++) {\n\t\t\t\tp += fact[l-i-1] * (x[i]-1);\n\t\t\t\tfor(int j = i+1; j < l; j++) {\n\t\t\t\t\tif(x[j] > x[i])\n\t\t\t\t\t\tx[j]--;\n\t\t\t\t}\n\t\t\t}\n\t\treturn p;\n\n\t}\n\n}\n\n", "code2": "n, k = gets.split( \" \" ).map { |val| val.to_i }\nw = []\nmaxW = sumW = 0\nn.times {\n\tnum = gets.to_i\n\tsumW += num\n\tw.push( num )\n}\nmaxW = w.max\n\nminP = 0\nif 1 == k\n\tminP = sumW\nelsif n == k\n\tminP = maxW\nelse\n\tleft = maxW\n\tright = 100000*10000\n\twhile left <= right\n\t\tmiddle = ( left+right ).div( 2 )\n\t\ttruckCnt = i = loadings = 0\n\n\t\twhile i < n\n\t\t\tloadings += w[i]\n\t\t\tif middle < loadings\n\t\t\t\ttruckCnt += 1\n\t\t\t\tbreak if k < truckCnt+1\n\t\t\t\tloadings = w[i]\n\t\t\tend\n\t\t\ti += 1\n\t\tend\n\t\t( minP = middle ) if truckCnt+1 <= k\n\t\t\n\t\tif k < truckCnt+1\n\t\t\tleft = middle + 1\t\t\n\t\telse\n\t\t\tright = middle - 1\n\t\tend\n\tend\nend\n\nputs( minP )", "label": 0, "name1": "s530732207.java", "name2": "s250378227.rb"}, {"id": 980, "code1": "import java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint[] v = new int[500000];\n        for(int i = 0;i < 500000;i++){\n            v[i] = 1;\n        }\n        int p = 3;\n        while(true){\n            if(p*p > 1000000){\n                break;\n            }else{\n                if(v[(p-1)/2] == 0){\n                    p += 2;\n                }else{\n                    int t = p*p;\n                    while(t < 1000000){\n                        v[(t-1)/2] = 0;\n                        t += 2*p;\n                    }\n                    p += 2;\n                }\n            }\n        }\n        v[0] = 0;\n\t\twhile(scan.hasNext()){\n\t\t\tint n = scan.nextInt();\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tfor(int i = 1;i < n/2;i++){\n\t\t\t\tif(v[i] != 1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(v[(n-2*i-2)/2] == 1){\n\t\t\t\t\tcount += ((n-2*i-2)/2 == i)?2:1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count/2);\n        }\n\t}\n}", "code2": "N = gets.to_i\nds = gets.split.map(&:to_i)\nhash = Hash.new(0)\nds.each{|d| hash[d] += 1}\nif hash[0] > 0 || hash.values.max >= 3\n    puts 0\n    exit\nend\n\ntz = [0, 24]\nrev = false\nhash.keys.sort.each do |i|\n    if hash[i] == 1\n        tz.push(rev ? 24-i : i)\n        rev = !rev\n    else\n        tz.push(i, 24-i)\n    end\nend\ntz.sort!\nputs (tz.length-1).times.map{|i| tz[i+1] - tz[i]}.min", "label": 0, "name1": "s280746172.java", "name2": "s521164035.rb"}, {"id": 790, "code1": "import java.io.*;\nimport java.util.*;\n\n/**\n *\n * @author baito\n */\nclass UnionFindTree\n{\n    int[] par;\n    int[] rank;\n    int[] sizes;\n\n    UnionFindTree(int n)\n    {\n        par = new int[n];\n        rank = new int[n];\n        sizes = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            par[i] = i;\n            rank[i] = 0;\n            sizes[i] = 1;\n        }\n    }\n\n    int find(int x)\n    {\n        if (par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n\n    void unite(int x, int y)\n    {\n        x = find(x);\n        y = find(y);\n\n        if (x == y) return;\n        if (rank[x] < rank[y])\n        {\n            par[x] = y;\n            sizes[y] += sizes[x];\n        }\n        else\n        {\n            par[y] = x;\n            sizes[x] += sizes[y];\n            if (rank[x] == rank[y]) rank[x]++;\n        }\n    }\n\n    boolean same(int x, int y)\n    {\n        return find(x) == find(y);\n    }\n\n    int size(int x)\n    {\n        return sizes[par[x]];\n    }\n}\npublic class Main\n{\n    static StringBuilder sb = new StringBuilder();\n    static FastScanner sc = new FastScanner(System.in);\n    static int INF = 10000;\n    static long MOD =1000000007;\n    static long[] f;//factorial\n    static int[] y4 = {0,1,0,-1};\n    static int[] x4 = {1,0,-1,0};\n    static int[] y8 = {0,1,0,-1,-1,1,1,-1};\n    static int[] x8 = {1,0,-1,0,1,-1,1,-1};\n\n    static int N,K,L;\n\n    public static void main(String[] args)\n    {\n\n        N = sc.nextInt();\n        K = sc.nextInt();\n        L = sc.nextInt();\n        UnionFindTree u1 = new UnionFindTree(N);\n        UnionFindTree u2 = new UnionFindTree(N);\n        //long\u3092\u5fd8\u308c\u308b\u306a\u30aa\u30fc\u30d0\u30fc\u30d5\u30ed\u30fc\u3059\u308b\u305e\n        for (int i = 0; i < K; i++)\n        {\n            int p = sc.nextInt()-1;\n            int q = sc.nextInt()-1;\n            u1.unite(p,q);\n        }\n        for (int i = 0; i < L; i++)\n        {\n            int p = sc.nextInt()-1;\n            int q = sc.nextInt()-1;\n            u2.unite(p,q);\n        }\n        Map<Long,Integer> sizes = new HashMap<>();\n        for (int i = 0; i < N; i++)\n        {\n            long root1 = u1.find(i);\n            long root2 = u2.find(i);\n            long hash = root1 * 1000000L + root2;\n            int value = sizes.containsKey(hash) ? sizes.get(hash):0;\n            sizes.put(hash,value+1);\n\n\n        }\n        for (int i = 0; i < N; i++)\n        {\n            long root1 = u1.find(i);\n            long root2 = u2.find(i);\n            long hash = root1 * 1000000L + root2;\n            System.out.println(sizes.get(hash));\n        }\n\n\n\n    }\n    //\u2193nCr\u3092mod\u8a08\u7b97\u3059\u308b\u305f\u3081\u306b\u5fc5\u8981\u3002\u3000***factorial(N)\u3092\u547c\u3076\u5fc5\u8981\u304c\u3042\u308b***\n    static long comb(int n, int r)\n    {\n        long result = f[n];\n        result = result * modInv(f[n - r]) % MOD;\n        result = result * modInv(f[r]) % MOD;\n        return result;\n    }\n\n    static long modInv(long n)\n    {\n        return modPow(n, MOD - 2);\n    }\n\n    static void factorial(int n)\n    {\n        f = new long[n + 1];\n        f[0] = f[1] = 1;\n        for (int i = 2; i <= n; i++)\n        {\n            f[i] = (f[i - 1] * i) % MOD;\n        }\n    }\n\n    static long modPow(long x, long n)\n    {\n        long res = 1L;\n        while (n > 0)\n        {\n            if ((n & 1) == 1)\n            {\n                res = res * x % MOD;\n            }\n            x = x * x % MOD;\n            n >>= 1;\n        }\n        return res;\n    }\n\n    //\u2191nCr\u3092mod\u8a08\u7b97\u3059\u308b\u305f\u3081\u306b\u5fc5\u8981\n\n    static int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n    static long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\n    static <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n    static void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n    public static void reverse(int[] x)\n    {\n        int l = 0;\n        int r = x.length - 1;\n        while (l < r)\n        {\n            int temp = x[l];\n            x[l] = x[r];\n            x[r] = temp;\n            l++;\n            r--;\n        }\n    }\n    public static void reverse(int[] x,int s, int e)\n    {\n        int l = s;\n        int r = e;\n        while (l < r)\n        {\n            int temp = x[l];\n            x[l] = x[r];\n            x[r] = temp;\n            l++;\n            r--;\n        }\n    }\n    static int length(int a) {int cou = 0; while(a != 0){ a /= 10; cou++; } return cou;}\n    static int length(long a) {int cou = 0; while(a != 0){ a /= 10; cou++; } return cou;}\n    static int countC2(char[][] a, char c){\n        int co = 0;\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[0].length; j++)\n                if(a[i][j] == c)\n                    co++;\n        return co;\n    }\n    static void fill(int[][] a, int v){\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[0].length; j++)\n                a[i][j] = v;\n    }\n    static class FastScanner {\n\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        public String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        /*public String nextChar(){\n            return (char)next()[0];\n        }*/\n        public String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n        public int [][] nextIntArray2(int h, int w){\n            int[][] a = new int[h][w];\n            for(int hi = 0 ; hi < h ; hi++){\n                for(int wi = 0 ; wi < w ; wi++){\n                    a[hi][wi] = nextInt();\n                }\n            }\n            return a;\n        }\n        public Integer[] nextIntegerArray(int n) {\n            Integer[] a = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n        public char[] nextCharArray(int n){\n            char[] a = next().toCharArray();\n\n            return a;\n        }\n        public char[][] nextCharArray2(int h , int w){\n            char[][] a = new char[h][w];\n            for (int i = 0; i < h; i++) {\n                a[i] = next().toCharArray();\n            }\n            return a;\n        }\n        //\u30b9\u30da\u30fc\u30b9\u304c\u5165\u3063\u3066\u3044\u308b\u5834\u5408\n        public char[][] nextCharArray2s(int h , int w){\n            char[][] a = new char[h][w];\n            for (int i = 0; i < h; i++) {\n                a[i] = nextLine().replace(\" \",\"\").toCharArray();\n            }\n            return a;\n        }\n        public char[][] nextWrapCharArray2(int h , int w, char c){\n            char[][] a = new char[h + 2][w + 2];\n            //char c = '*';\n            int i;\n            for (i = 0; i < w + 2; i++)\n                a[0][i] = c;\n            for (i = 1; i < h + 1; i++) {\n                a[i] = (c + next() + c).toCharArray();\n            }\n            for (i = 0; i < w + 2; i++)\n                a[h + 1][i] = c;\n            return a;\n        }\n        //\u30b9\u30da\u30fc\u30b9\u304c\u5165\u3063\u3066\u308b\u6642\u7528\n        public char[][] nextWrapCharArray2s(int h , int w ,char c){\n            char[][] a = new char[h + 2][w + 2];\n            //char c = '*';\n            int i;\n            for (i = 0; i < w + 2; i++)\n                a[0][i] = c;\n            for (i = 1; i < h + 1; i++) {\n                a[i] = (c + nextLine().replace(\" \",\"\") + c).toCharArray();\n            }\n            for (i = 0; i < w + 2; i++)\n                a[h + 1][i] = c;\n            return a;\n        }\n        public long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextLong();\n            }\n            return a;\n        }\n        public long [][] nextLongArray2(int h, int w){\n            long[][] a = new long[h][w];\n            for(int hi = 0 ; hi < h ; hi++){\n                for(int wi = 0 ; wi < h ; wi++){\n                    a[h][w] = nextLong();\n                }\n            }\n            return a;\n        }\n    }\n}\n", "code2": "eval'*A=#'+`tr ' ' ,`\ni=f=1\ns=m=10**9+7\np A.sum{f=f*i%m\ns+=i.pow m-2,m\n_1*~-s+A[1-i+=1]*s}*f%m", "label": 0, "name1": "s138073781.java", "name2": "s721063213.rb"}, {"id": 278, "code1": "import java.util.*;\n\nclass Main {\n\tpublic static void main(String args[]) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint m, f, count = 0, sum;\n\t\tm = scanner.nextInt();\n\t\tf = scanner.nextInt();\n\t\twhile(!(m == 0 && f == 0)) {\n\t\t\tfor(int i = 1;i < m+1;i++) {\n\t\t\t\tfor(int j = 1;j < m+1;j++) {\n\t\t\t\t\tfor(int k = 1;k < m+1;k++) {\n\t\t\t\t\t\t\tsum =  i+j+k;\n\t\t\t\t\t\t\tif(sum == f && (i!=j)&&(j!=k)&&(k!=i)) \n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count/(1*2*3));\n\t\t\tcount = 0;\n\t\t\tm = scanner.nextInt();\n\t\t\tf = scanner.nextInt();\n\t\t}\n\t\tscanner.close();\n\t}\n}", "code2": "require 'scanf'\nrequire 'pp'\n\n#p input\nwhile true\n\tdata = Array.new()\n\tcnt = 0\n\tinput = scanf(\"%d %d\")\n\tif input[0]==0 && input[1]==0\n\t\tbreak\n\tend\n\tfor i in 1..input[0]\n\t\tdata.push(i)\n\tend \n\tdata.combination(3) {|a, b, c| \n\t\tif a+b+c == input[1] \n\t\t\tcnt = cnt+1\n\t\tend\n\t}\n\tputs cnt\n\nend", "label": 1, "name1": "s275047149.java", "name2": "s770360608.rb"}, {"id": 345, "code1": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\nclass Solver extends Main{\n\tSolver(){\n\t\t\n\t}\n}//Solver_end\n\n@SuppressWarnings(\"unchecked\")\nclass Main{\n\tstatic int imax=Integer.MAX_VALUE;\n\tstatic long lmax=Long.MAX_VALUE;\n\t\n\tpublic static void main(String[] args) throws FileNotFoundException{\n\t\t\n\t\t\n\t\tScanner sc=new Scanner(System.in);\n\t\t//Scanner sc=new Scanner(fp);\n\t\t\n\t\tint[] data=readlnI(sc,\" \");\n\t\tint n=data[0];\n\t\tint m=data[1];\n\t\tint[] path=new int[200000];\n\t\t\n\t\tfor(int i=0;i<m; i++){\n\t\t\tint[] line=readlnI(sc,\" \");\n\t\t\tif(line[0]==1){\n\t\t\t\tpath[line[1]-1]+=1;\n\t\t\t}else if(line[1]==n){\n\t\t\t\tpath[line[0]-1]+=1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean fnd=false;\n\t\t\n\t\tfor(int x:path){\n\t\t\tif(x==2)fnd=true;\n\t\t}\n\t\t\n\t\tputs(fnd==true ? \"POSSIBLE\" : \"IMPOSSIBLE\");\n\t\t\n\t}//main_end\n\t\n//---------------------------------------------------------------------------\n\tstatic int readI(Scanner sc){\n\t\treturn Integer.parseInt(sc.nextLine().trim());\n\t}\n\tstatic long readL(Scanner sc){\n\t\treturn Long.parseLong(sc.nextLine().trim());\n\t}\n\tstatic String readS(Scanner sc){\n\t\treturn sc.nextLine().trim();\n\t}\n\tstatic int[] readlnI(Scanner sc, String dl){\n\t\treturn Arrays.stream(sc.nextLine().trim().split(dl)).mapToInt(Integer::parseInt).toArray();\n\t}\n\tstatic long[] readlnL(Scanner sc, String dl){\n\t\treturn Arrays.stream(sc.nextLine().trim().split(dl)).mapToLong(Long::parseLong).toArray();\n\t}\n\tstatic String[] readlnS(Scanner sc, String dl){\n\t\treturn sc.nextLine().trim().split(dl);\n\t}\n\t@SuppressWarnings(\"unchecked\")\n\tstatic <T> void puts(T... args){\n\t\tfor(int i=0; i<args.length-1; i++){\n\t\t\tSystem.out.printf(\"%s \",args[i]);\n\t\t}\n\t\tSystem.out.println(args[args.length-1]);\n\t}\n\tstatic void puts(int[] ary){\n\t\tfor(int i=0; i<ary.length-1; i++){\n\t\t\tSystem.out.printf(\"%d \",ary[i]);\n\t\t}\n\t\tSystem.out.println(ary[ary.length-1]);\n\t}\n\tstatic void puts(long[] ary){\n\t\tfor(int i=0; i<ary.length-1; i++){\n\t\t\tSystem.out.printf(\"%d \",ary[i]);\n\t\t}\n\t\tSystem.out.println(ary[ary.length-1]);\n\t}\n\tstatic void bs(){\n\t\tSystem.out.println(\"\");\n\t}\n\tstatic int sum(int[] ary){\n\t\tint sum=0;\n\t\tfor(int i=0; i<ary.length; i++) sum+=ary[i];\n\t\treturn sum;\n\t}\n\tstatic long sum(long[] ary){\n\t\tlong sum=0;\n\t\tfor(int i=0; i<ary.length; i++) sum+=ary[i];\n\t\treturn sum;\n\t}\n\tstatic void tblSort(int[][] tbl){\n\t\tArrays.sort(tbl, new Comparator<int[]>(){\n\t\t\t@Override\n\t\t\tpublic int compare(int[] a, int[] b){\n\t\t\t\tif(a[0]==b[0]){\n\t\t\t\t\treturn b[1]-a[1];\n\t\t\t\t}else{\n\t\t\t\t\treturn b[0]-a[0];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n", "code2": "n,*z=$<.map &:split;y=z.to_h;puts\"#{z.all?{|a,b|a>?1||y[b]!=n[0]}?:IM:\"\"}POSSIBLE\"", "label": 1, "name1": "s766623172.java", "name2": "s984752060.rb"}, {"id": 426, "code1": "\nimport java.util.HashMap;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main \n{\n\tstatic HashMap<String, String> groupdef;\n\tstatic String firstgroup;\n\tstatic TreeSet<String> members;\n\tstatic TreeSet<String> checked;\n\t\n\tstatic void get(String g)\n\t{\n\t\tString con = groupdef.get(g);\n//\t\tSystem.out.println(\"Getting \" + g + \"...\");\n\t\tif(checked.contains(g))return;\n\t\t\n\t\tint start = 0;\n\t\tint mem = 0;\n\t\tfor(int i = 0; i < con.length(); i++)\n\t\t{\n\t\t\tif(con.charAt(i) == ',' || con.charAt(i) == '.')\n\t\t\t{\n\t\t\t\tString word = con.substring(start, i);\n\t\t\t\tstart = i+1;\n\t\t\t\t\n\t\t\t\tif(groupdef.containsKey(word))\n\t\t\t\t{\n\t\t\t\t\tget(word);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmembers.add(word);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tchecked.add(g);\n//\t\tcache.put(g, mem);\n\t}\n\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0)break;\n\t\t\tgroupdef = new HashMap<String, String>();\n//\t\t\tcache = new HashMap<String, Integer>();\n\t\t\tmembers = new TreeSet<String>();\n\t\t\tchecked = new TreeSet<String>();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tString s = sc.next();\n\t\t\t\tint lim = s.indexOf(':');\n\t\t\t\tString groupname = s.substring(0, lim);\n\t\t\t\tString groupcon = s.substring(lim+1);\n\t\t\t\tif(i == 0)firstgroup = groupname;\n\t\t\t\tgroupdef.put(groupname, groupcon);\n\t\t\t}\n\t\t\t\n\t\t\tget(firstgroup);\n\t\t\tSystem.out.println(members.size());\n//\t\t\tSystem.out.println(members);\n\t\t}\n\t\t\n\n\t}\n\n}\n\n", "code2": "def find(x, root)\n  return unless @group[x]\n  return true if @group[x].include?(root)\n  @group[x].each do |m|\n    return true if find(m, root)\n  end\n  false\nend\n\nwhile n = gets.to_i\n  break if n == 0\n  root = ''\n  @group = {}\n  n.times do |i|\n    g, m = gets.split(':')\n    root = g if i == 0\n    ms = m[0..-3].split(',')\n    ms.each{ |m| @group[m] ||= []; @group[m] << g }\n  end\n  cnt = 0\n  @group.keys.each do |name|\n    if find(name, root) && !@group.values.flatten.include?(name)\n      cnt += 1\n    end\n  end\n  p cnt\nend", "label": 1, "name1": "s001547590.java", "name2": "s172002341.rb"}, {"id": 971, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n        }\n        int[] b = new int[n];\n        for (int i = 0; i < n; i++) {\n            b[i] = sc.nextInt();\n        }\n        int[] c = new int[n];\n        for (int i = 0; i < n; i++) {\n            c[i] = sc.nextInt();\n        }\n        Arrays.sort(a);\n        Arrays.sort(b);\n        Arrays.sort(c);\n        System.out.println(solve(a, b, c));\n    }\n\n    private static long solve(int[] a, int[] b, int[] c) {\n        int n = a.length;\n        long[] bmemo = new long[n];\n        int cidx = 0;\n        for (int j = 0; j < n; j++) {\n            for (int k = cidx; k < n; k++) {\n                if (b[j] >= c[k]) {\n                    cidx++;\n                } else {\n                    bmemo[j] = n - k;\n                    break;\n                }\n            }\n        }\n        for (int i = n - 2; i >= 0; i--) {\n            bmemo[i] += bmemo[i + 1];\n        }\n        long sum = 0;\n        int bidx = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = bidx; j < n; j++) {\n                if (a[i] >= b[j]) {\n                    bidx++;\n                } else {\n                    sum += bmemo[j];\n                    break;\n                }\n            }\n        }\n        return sum;\n    }\n}\n", "code2": "### constant\n\nMAX_P = 1000000\n\n### subroutines\n\ndef gen_primes(max_p)\n  primes = Array.new(max_p + 1){true}\n  primes[0] = primes[1] = false\n\n  for p in (2..max_p)\n    if primes[p]\n      for q in (p * p).step(max_p, p)\n        primes[q] = false\n      end\n    end\n  end\n\n  return primes\nend\n\n### main\n\nprimes = gen_primes(MAX_P)\n\nwhile true\n  n = gets.strip.to_i\n  break if n == 0\n\n  hn = n / 2\n  count = 0\n\n  for i in (3..hn)\n    if primes[i] && primes[n - i]\n      count += 1\n    end\n  end\n\n  puts count\nend", "label": 0, "name1": "s244653324.java", "name2": "s145027976.rb"}, {"id": 99, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in);) {\n\t\t\tdouble a = sc.nextDouble();\n\t\t\tdouble b = sc.nextDouble();\n\t\t\tdouble c = sc.nextDouble();\n\t\t\t//\uff12\u70b9\u9593\u306e\u8ddd\u96e2\n\t\t\tdouble s = (a * b / 2 * Math.sin(Math.toRadians(c)));\n\t\t\t\tSystem.out.println(s);\n\t\t\tdouble l = (a + b +Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) - 2 * a * b\n\t\t\t\t\t* Math.cos(Math.toRadians(c))));\n\t\t\t\tSystem.out.println(l);\n\t\t\tdouble h = (b * Math.sin(Math.toRadians(c)));\n\t\t\t\tSystem.out.println(h);\n\t\t}\n\t}\n}\n", "code2": "a,b,c = gets.split.map(&:to_f)\nr = c * Math::PI / 180\nh = b * Math.sin(r)\ns = a * h / 2\nw = b * Math.cos(r)\nd = Math.hypot(a-w,h)\nl = a + b + d\nputs [s,l,h] * \"\\n\"", "label": 1, "name1": "s947759194.java", "name2": "s377972091.rb"}, {"id": 669, "code1": "import java.io.File;\nimport java.io.IOException;\nimport java.util.*;\n \npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\t//File file = new File(\"input.txt\");\n\t\t//Scanner in = new Scanner(file);\n\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\t\n\t\tString SS = in.next();\n\t\tString T = in.next();\n\t\t\n\t\tint index = SS.length() - T.length();\n\t\t\n\t\twhile(index >= 0){\n\t\t\tString s = SS.substring(index, index + T.length());\n\t\t\t\n\t\t\tboolean tf = true;\n\t\t\tfor(int i = 0; i < T.length(); i++){\n\t\t\t\tif(s.charAt(i) != '?' && s.charAt(i) != T.charAt(i)){\n\t\t\t\t\ttf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(tf){\n\t\t\t\tSS = new StringBuilder(SS).replace(index, index + s.length(), T).toString();\n\t\t\t\tSS = SS.replace('?', 'a');\n\t\t\t\tSystem.out.println(SS);\n\t\t\t\treturn;\n\t\t\t}else{\n\t\t\t\tindex--;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"UNRESTORABLE\");\n\t}\n}", "code2": "a, b, c, k = gets.split.map &:to_i\nans = 0\n[a, b, c].zip([1, 0, -1]).each do |n, cost|\n\tm = [n, k].min\n\tk -= m\n\tans += cost * m\nend\nputs ans\n", "label": 0, "name1": "s419255365.java", "name2": "s146217788.rb"}, {"id": 551, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main{\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint unko=sc.nextInt();\n\t\tboolean ike=false;\n\t\tint N=0;\n\t\tfor(int i=0; i<=500; i++) {\n\t\t\tif(unko==i*(i+1)/2) {\n\t\t\t\tike=true;\n\t\t\t\tN=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(unko<i*(i+1)/2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ike) {\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\tSystem.out.println(N+1);\n\t\t\tint[][] ary=new int[N+1][N];\n\t\t\tint[] kaz=new int[N+2];\n\t\t\tfor(int i=0; i<=N; i++) {\n\t\t\t\tfor(int j=0; j<N; j++) {\n\t\t\t\t\tary[i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<=N+1; i++) {\n\t\t\t\tkaz[i]=0;\n\t\t\t}\n\t\t\tint counter=1;\n\t\t\tfor(int i=1; i<=N+1; i++) {\n\t\t\t\tfor(int j=1; j<i; j++) {\n\t\t\t\t\tary[i-1][kaz[i-1]]=counter;\n\t\t\t\t\tkaz[i-1]++;\n\t\t\t\t\tary[j-1][kaz[j-1]]=counter;\n\t\t\t\t\tkaz[j-1]++;\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tString buri=\"\";\n\t\t\tfor(int i=0; i<N+1; i++) {\n\t\t\t\tburi=Arrays.toString(ary[i]);\n\t\t\t\tburi=buri.replaceAll(\",\",\"\");\n\t\t\t\tburi=buri.replace(\"[\",\" \");\n\t\t\t\tburi=buri.replace(\"]\",\"\");\n\t\t\t\tSystem.out.println(N+buri);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t}\n}", "code2": "n,k=gets.split.map &:to_i\nr=n%k\nputs [r,k-r].min", "label": 0, "name1": "s468399402.java", "name2": "s492428229.rb"}, {"id": 925, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n    void solve(){\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int[] s = new int[n];\n        int sum = 0;\n        for(int i = 0; i < n; i++){\n            s[i] = in.nextInt();\n            sum += s[i];\n        }\n        \n        if(sum % 10 != 0){\n            System.out.println(sum);\n            return;\n        }else{\n            Arrays.sort(s);\n            int i = 0;\n            while(sum%10==0 && i < n){\n                if(s[i]%10 != 0){\n                    sum -= s[i];\n                }\n                i++;\n            }\n            if(i == n){\n                sum = 0;\n            }\n        }\n        System.out.println(sum);\n    }\n    \n    public static void main(String[] args){\n        new Main().solve();\n    }\n}", "code2": "h,w = gets.split.map(&:to_i)\na = Array.new(h){ gets.chomp }\n\nseen = Array.new(h){ Array.new(w){ false } }\nDX = [ 0, 1, 0,-1, 1,-1, 1,-1]\nDY = [ 1, 0,-1, 0, 1,-1,-1, 1]\ninside = -> y, x { 0 <= y && y < h && 0 <= x && x < w }\n\nbfs = -> sy,sx do\n  return 0 if seen[sy][sx]\n  que = [[sy,sx]]\n  seen[sy][sx] = true\n  black = 0\n  white = 0\n  while que.size > 0\n    y,x = que.pop\n    a[y][x] == \"#\" ? black += 1 : white += 1\n    4.times do |i|\n      ny = y + DY[i]\n      nx = x + DX[i]\n      next unless inside[ny,nx]\n      next if seen[ny][nx]\n      next if a[y][x] == a[ny][nx] # \u540c\u3058\u8272\u306a\u3089\u5bfe\u8c61\u5916\n      que << [ny,nx]\n      seen[ny][nx] = true\n    end\n  end\n  return black * white\nend\n\nans = 0\nh.times do |y|\n  w.times do |x|\n    ans += bfs[y,x]\n  end\nend\nputs ans", "label": 0, "name1": "s390984007.java", "name2": "s257634144.rb"}, {"id": 896, "code1": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n\t\n\tvoid solve() {\n\t\tint n = in.nextInt(), m = in.nextInt();\n\t\tout.println((1L << m) * (1900 * m + 100 * (n - m))); \n\t}\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tvoid run() {\n\t\tin = new FastScanner();\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(s));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic String nextToken() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n", "code2": "require 'prime'\n\nbase = gets.to_i\nans = Prime.find {|p| p >= base }\nputs ans", "label": 0, "name1": "s585016642.java", "name2": "s724728663.rb"}, {"id": 708, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint a=scan.nextInt();\n\t\tint b=scan.nextInt();\n\t\tint c=scan.nextInt();\n\t\tint d=a-b;\n\t\tif(c-d>0) System.out.println(c-d);\n\t\telse System.out.println(\"0\");\n\n\t}\n\n}\n", "code2": "puts gets.split.map(&:to_i).combination(2).map {|x,y| x+y}.min", "label": 0, "name1": "s407931652.java", "name2": "s609833635.rb"}, {"id": 102, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tdouble a = sc.nextDouble();\n\t\tdouble b = sc.nextDouble();\n\t\tdouble C = sc.nextDouble();\n\t\t\n\t\tdouble S = 0.5*a*b*Math.sin(Math.toRadians(C));\n\t\tdouble c = Math.sqrt(Math.pow(a, 2)+Math.pow(b, 2)-(2*a*b*Math.cos(Math.toRadians(C))));\n\t\tdouble L = a + b + c;\n\t\tdouble h = 2*S / a;\n\t\t\n\t\tSystem.out.println(S);\n\t\tSystem.out.println(L);\n\t\tSystem.out.println(h);\n\n\t}\n}", "code2": "a,b,c = gets.chomp.split.map(&:to_f)\n\ns = (a * b * Math.sin(c * Math::PI / 180)) * 0.5\nl = (a + b) + (a*a + b*b - 2*a*b*Math.cos(c * Math::PI / 180)) ** 0.5\nh = b * Math.sin(c * Math::PI / 180)\n\nputs s\nputs l\nputs h", "label": 1, "name1": "s501686962.java", "name2": "s128364594.rb"}, {"id": 955, "code1": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args ) throws Exception {\n    Scanner sc = new Scanner(System.in);\n    String A = sc.next();\n    int count=0;\n    char[] B = A.toCharArray();\n    for(int i=0;i<A.length();i++){\n      if(B[i]=='2'){\n      \tcount++;\n      }\n    }\n    System.out.println(count);\n  }\n}\n\n", "code2": "N, C = gets.split.map(&:to_i)\nD = Array.new(C) { Array.new(C) }\nC.times do |i|\n  D[i] = gets.split.map(&:to_i)\nend\nGRID = Array.new(N) { Array.new(N) }\nN.times do |i|\n  GRID[i] = gets.split.map(&:to_i)\nend\n\ncost = Array.new(3) { Array.new(C) {0} }\n(1..C).each do |c|\n  (1..N).each do |x|\n    (1..N).each do |y|\n      cost[(x-1+y-1)%3][c-1] += D[GRID[x-1][y-1]-1][c-1]\n    end\n  end\nend\n\nans = 1 << 30\n(1..C).each do |c1|\n  (1..C).each do |c2|\n    next if c1 == c2\n    (1..C).each do |c3|\n      next if c2 == c3 || c1 == c3\n      ans = [ans, cost[0][c1-1] + cost[1][c2-1] + cost[2][c3-1]].min\n    end\n  end\nend\n\nputs ans\n", "label": 0, "name1": "s261661305.java", "name2": "s928332636.rb"}, {"id": 698, "code1": "import java.util.*;\npublic class Main {\n\tstatic int yono;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tArrayList<Integer> al = new ArrayList<Integer>();\n\t\tint N = Integer.parseInt(sc.next());\n\t\tyono = N - 1;\n\t\tint M = sc.nextInt();\n\t\ttree = new int[N];\n\t\tArrays.fill(tree, -1);\n\t\tfor (int i = 0; i < M; i++)union(Integer.parseInt(sc.next()) - 1, Integer.parseInt(sc.next()) - 1);\n\t\tSystem.out.println(yono);\n\t}\n\t\n\tstatic int[] tree;\n\tstatic void union(int x, int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif(x != y) {\n\t\t\tyono--;\n\t\t\tif(tree[x] < tree[y]) {\n\t\t\t\tx ^= y; y ^= x; x^= y;\n\t\t\t}\n\t\t\ttree[x] += tree[y];\n\t\t\ttree[y] = x;\n\t\t}\n\t}\n\tstatic boolean find(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tstatic int root(int x) {\n\t\treturn tree[x] < 0 ? x : (tree[x] = root(tree[x]));\n\t}\n}", "code2": "A, B, C = gets.split.map(&:to_i)\n\nif B+C < A\n  puts 0\nelse\n  puts (B+C) - A\nend", "label": 0, "name1": "s179713562.java", "name2": "s890378071.rb"}, {"id": 594, "code1": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        List<Integer> abc = new ArrayList<>();\n        abc.add(sc.nextInt());\n        abc.add(sc.nextInt());\n        abc.add(sc.nextInt());\n        Collections.sort(abc);\n\n        int count = 0;\n        int diff21 = abc.get(2) - abc.get(1);\n        abc.set(0, abc.get(0) + diff21);\n        abc.set(1, abc.get(1) + diff21);\n        count += diff21;\n\n        int diff10 = abc.get(1) - abc.get(0);\n        if (diff10 % 2 == 0) {\n            count += diff10 / 2;\n        } else {\n            count += (diff10 + 1) / 2 + 1;\n        }\n        System.out.println(count);\n    }\n\n}\n", "code2": "Q = $stdin.gets.chomp.to_i\n\nsums = []\n\nQ.times do |i|\n    # a <= b\n    a, b = $stdin.gets.chomp.split(' ').map(&:to_i).sort\n    prod = a * b\n    sum = 0\n    sum += a - 1\n    sqrt = Math.sqrt(prod)\n    sqrt_f = sqrt == sqrt.floor ? sqrt.floor - 1 : sqrt.floor\n    l = [sqrt_f, a].max\n    sum += l - a\n    r = (prod - 1) / (l + 1)\n    sum += r\n    sums.push(sum)\nend\n\nprint sums.join(\"\\n\")", "label": 0, "name1": "s664157474.java", "name2": "s305871249.rb"}, {"id": 620, "code1": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tString str = scanner.nextLine();\n\t\tString[] ab = str.split(\" \");\n\t\tint a = Integer.parseInt(ab[0]);\n\t\tint b = Integer.parseInt(ab[1]);\n\t\tif (a > b) {\n\t\t\tSystem.out.println(a - 1);\n\t\t}else {\n\t\t\tSystem.out.println(a);\n\t\t}\n\t\t\n\t\tscanner.close();\n\n\t}\n\n}\n", "code2": "# \u89e3\u8aac\u898b\u305f\n\nn = gets.to_i\nfriendly = gets.strip.split.map(&:to_i).sort\nans = 0\n(1..(n - 1)).each do |i|\n  ans += friendly[n - (i / 2) - 1]\nend\nputs(ans)\n", "label": 0, "name1": "s957138694.java", "name2": "s991737388.rb"}, {"id": 491, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    private static class FastScanner {\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        public String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        int array[] = new int[3], num = 0;\n        int count = 0;\n\n        while (count < 3) {\n            num = sc.nextInt();\n            if (0 < num && num < 10) {\n                array[count] = num;\n                count++;\n            }\n        }\n\n\n        for (int i = 0; i < 3; i++) {\n            for (int j = i + 1; j < 3; j++) {\n                if (array[i] == array[j]) {\n                    count = count - 1;\n                }\n            }\n        }\n        if (count == 2) {\n            System.out.print(\"Yes\");\n        } else {\n            System.out.print(\"No\");\n        }\n    }\n}\n", "code2": "arr = gets.chomp.split(\" \").map(&:to_i)\nif arr.uniq.length == 2 then\n  puts \"Yes\"\nelse\n  puts \"No\"\nend\n", "label": 1, "name1": "s136290389.java", "name2": "s944100071.rb"}, {"id": 894, "code1": "class Main {\n\tpublic static void main(String args[]){\n\t\tfor(int i=0;i<1000;i++){\n\t\t\tSystem.out.println(\"Hello World\");\n\t\t}\n\t}\n}", "code2": "require 'prime'\nn = gets.to_i\n\nuntil n.prime? do\n  n += 1\nend\n\nputs n\n", "label": 0, "name1": "s780087873.java", "name2": "s001969879.rb"}, {"id": 0, "code1": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String str = sc.next();\n        int n = str.length();\n        int digitSum = 0;\n        for (int i = 0; i < n; i++)\n            digitSum += (str.charAt(i) - '0');\n        if(digitSum % 9 == 0) {\n            System.out.println(\"Yes\");\n        }\n        else {\n            System.out.println(\"No\");\n        }\n    }\n}\n\n", "code2": "s = 0\ngets.chomp.each_char{|c| s += c.to_i}\nputs s % 9 == 0 ? \"Yes\" : \"No\"", "label": 1, "name1": "s204970720.java", "name2": "s059876675.rb"}, {"id": 283, "code1": "import java.io.BufferedReader;\n\nimport static java.util.Comparator.*;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.lang.reflect.Array;\nimport java.math.BigDecimal;\nimport java.util.AbstractMap;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class Main {\n\t\n//\tpublic static Set<String> mem = new HashSet<String>();\n//\tpublic static boolean[] mem_1 = new boolean[100];\n//\tpublic static boolean[] mem_2 = new boolean[100];\n//\tpublic static Set<Integer> mem = new TreeSet<Integer>();\n//\tpublic static Map<String, Integer> mem_1= new HashMap<String, Integer>();\n//\tpublic static Map<String, Integer> mem_2 = new HashMap<String, Integer>();\n\t\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        \n        Solver solver = new Solver();\n        solver.solve(1, in, out);\n        \n        out.close();\n    }\n    \n    // ======================================================================\n    static class Solver {\n    \t\n\t\tList<Pair<Integer, Integer>> lP = new ArrayList<Pair<Integer, Integer>>();\n\t\tList<Pair<Integer, Integer>> lAns = new ArrayList<Pair<Integer, Integer>>();\n\n    \tpublic void solve(int testNumber, MyInput in, PrintWriter out) {\n    \t\tlong ans = 0L;\n    \t\tint[] cnt = new int[4];\n    \t\tfor(int i=0; i < 6; i++) {\n        \t\tint a = in.nextInt();\n        \t\tcnt[a-1] += 1;\n        // \t\tout.println(\"[\" + a + \"]\");\n    \t\t}\n    \t\tboolean f = true;\n    \t\tfor(int i=0; i < 4; i++) {\n        // \t\tout.println(\"[\" + cnt[i] + \"]\");\n    \t\t\tif(cnt[i] >= 3)\t\tf = false;\n    \t\t}\n    \t\tif(f)   \t\tout.println(\"YES\");\n    \t\telse            out.println(\"NO\");\n        }\n    }\n    // ======================================================================\n    static class Pair<K, V> extends AbstractMap.SimpleEntry<K, V> {\n        /** serialVersionUID. */\n        private static final long serialVersionUID = 6411527075103472113L;\n\n        public Pair(final K key, final V value) {\n            super(key, value);\n        }\n        public String getString() {\n            return \"[\" + getKey() + \"] [\" + getValue() + \"]\";\n        }\n     }    \n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n \n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n \n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n \n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n \n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n \n        public String nextString() {\n        \tString ret = new String(nextDChar()).trim();\n            return ret;\n        }\n \n        public char[] nextDChar() {\n            int len = 0;\n            len = reads(len, isSpace);\n            char[] ret = new char[len + 1];\n            for (int i=0; i < len; i++)\t\tret[i] = str[i];\n            ret[len] = 0x00;\n            return ret;\n        }\n \n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n \n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n \n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n    }\n}\n", "code2": "path_list = 3.times.map { gets.split(' ').map(&:to_i) }\nedge_to_count = Hash.new(0)\npath_list.each do |(a, b)|\n  edge_to_count[a] += 1\n  edge_to_count[b] += 1\nend\n\nans = edge_to_count.keys.size == 4 && edge_to_count.values.max < 3\nputs(ans ? 'YES': 'NO')\n", "label": 1, "name1": "s961270278.java", "name2": "s267170093.rb"}, {"id": 655, "code1": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-9;\n\n\tint n;\n\tint start, goal, ttl;\n\tLinkedList<Integer>[] graph;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tn = sc.nextInt();\n\t\tgraph = new LinkedList[n];\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint u = sc.nextInt() - 1;// \u0083\u008b\u0081[\u0083^\u0094\u00d4\u008d\u0086\n\t\t\tint m = sc.nextInt();\n\t\t\tgraph[u] = new LinkedList<Integer>();\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint v = sc.nextInt() - 1;\n\t\t\t\tgraph[u].add(v);\n\t\t\t}\n\t\t}\n\t\tint p = sc.nextInt();\n\t\tfor (int i = 0; i < p; i++) {\n\t\t\tstart = sc.nextInt() - 1;\n\t\t\tgoal = sc.nextInt() - 1;\n\t\t\tttl = sc.nextInt();\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve() {\n\t\tLinkedList<Integer> que = new LinkedList<Integer>();\n\t\tboolean[] visited = new boolean[n];\n\t\tint[] d = new int[n];\n\t\tArrays.fill(d, INF);\n\t\tque.offer(start);\n\t\td[start] = 1;\n\t\tvisited[start] = true;\n\t\tfor (; !que.isEmpty();) {\n\t\t\tint u = que.poll();\n\t\t\tfor (int v : graph[u]) {\n\t\t\t\tif (!visited[v]) {\n\t\t\t\t\tque.offer(v);\n\t\t\t\t\td[v] = d[u] + 1;\n\t\t\t\t\tvisited[v] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[goal] <= ttl) {\n\t\t\tprintln(\"\" + d[goal]);\n\t\t} else {\n\t\t\tprintln(\"NA\");\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s) {\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s) {\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}", "code2": "n = gets.to_i\na = gets.chomp.split(\" \").map(&:to_i)\n\n#b = Array.new(n+1).map{Array.new}\nh = Hash.new{|k,v| k[v]=0}\n\na.each_with_index do |n, i|\n  t = [n, i+1].sort!\n  h[t] += 1\n  #b[n] << i+1\n  #b[i+1] << n\nend\np h.to_a.select{|t| t[1]==2}.size\n\n\n#b.select{|t| }\n", "label": 0, "name1": "s019260377.java", "name2": "s972469766.rb"}, {"id": 137, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint[] abc = new int[3];\n\t\tArrays.setAll(abc, i -> sc.nextInt());\n\t\tArrays.sort(abc);\n\t\t\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tint dif = abc[2] - abc[i];\n\t\t\tint quo = dif / 2;\n\t\t\tcnt += quo;\n\t\t\tabc[i] += 2 * quo;\n\t\t}\n\t\t\n\t\tArrays.sort(abc);\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tabc[2 - i] -= abc[0];\n\t\t}\n\t\t\n\t\tfor (int i : abc) {\n\t\t\tcnt += i;\n\t\t}\n\t\t\n\t\tSystem.out.println(cnt);\n\t}\t\n}\n", "code2": "array = gets.split(\" \").map { |e| e.to_i }\n\nguki = [0,0,0] #\u4e09\u3064\u306e\u5076\u5947\u3092\u8abf\u3079\u308b\nki = 0\nfor i in 0..2 do\n  if array[i]%2 == 1\n    guki[i] = 1\n    ki += 1\n  end\nend\n\ncount = 0\n\nif ki == 1 #\u5076\u5947\u3092\u63c3\u3048\u308b\n  for i in 0..2 do\n    if guki[i] == 0\n      array[i] += 1\n    end\n  end\n  count += 1\nelsif ki == 2\n  for i in 0..2 do\n    if guki[i] == 1\n      array[i] += 1\n    end\n  end\n  count += 1\nend\n\nmax = array.max #\u3044\u3061\u3070\u3093\u5927\u304d\u3044\u306e\u306b\u5408\u308f\u305b\u308b\nfor i in 0..2 do\n  if array[i] < max\n    count += (max - array[i]) / 2\n  end\nend\n\nputs count\n", "label": 1, "name1": "s839188761.java", "name2": "s981224172.rb"}, {"id": 274, "code1": "import java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc= new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint count=0;\n\t\t\tint n=sc.nextInt();\n\t\t\tint x=sc.nextInt();\n\t\t\tif(n==0 && x==0) break;\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=i+1;j<=n;j++){\n\t\t\t\t\tfor(int k=j+1;k<=n;k++){\n\t\t\t\t\t\tif(i+j+k == x) count++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}", "code2": "#!ruby -an\nn,m=$F.map &:to_i\nbreak if n<3\np [*1..n].combination(3).map{|i|i.inject(:+)}.count m", "label": 1, "name1": "s030330226.java", "name2": "s772764129.rb"}, {"id": 760, "code1": "\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scn = new Scanner(System.in);\n\n        long a = scn.nextLong(), b = scn.nextLong(), x = scn.nextLong();\n        long ans = 0;\n\n        ans = (b / x) - (a / x);\n\n        if(a % x == 0){\n            ans++;\n        }\n\n        System.out.println(ans);\n\n    }\n\n}", "code2": "#!/usr/bin/ruby\n\ni=STDIN.gets\n\nnum = STDIN.gets.split()\nnum.map!{|i| i.to_i}\n\nnum.sort!\n\nputs num.join(\" \")", "label": 0, "name1": "s378055358.java", "name2": "s080700840.rb"}, {"id": 519, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tMyInput in = new MyInput(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic long LINF = 1L << 55;\n\tstatic int MOD = 1000000007;\n\tstatic int[] mh4 = { 0, -1, 1, 0 };\n\tstatic int[] mw4 = { -1, 0, 0, 1 };\n\tstatic int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\tstatic int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n\tstatic class TaskX {\n\n\t\tpublic void solve(int testNumber, MyInput in, PrintWriter out) {\n\n\t\t\tint n = in.nextInt();\n\t\t\tlong a = in.nextLong(), b = in.nextLong();\n\t\t\tlong[] x = in.nextLongArray(n);\n\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\t\tans += Math.min(a * (x[i+1] - x[i]), b);\n\t\t\t}\n\t\t\tout.println(ans);\n\n\t\t}\n\t}\n\n\tstatic class MyInput {\n\t\tprivate final BufferedReader in;\n\t\tprivate static int pos;\n\t\tprivate static int readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500 * 8 * 2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic {\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tisDigit['0' + i] = true;\n\t\t\t}\n\t\t\tisDigit['-'] = true;\n\t\t\tisSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n\t\t\tisLineSep['\\r'] = isLineSep['\\n'] = true;\n\t\t}\n\n\t\tpublic MyInput(InputStream is) {\n\t\t\tin = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (pos >= readLen) {\n\t\t\t\tpos = 0;\n\t\t\t\ttry {\n\t\t\t\t\treadLen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException();\n\t\t\t\t}\n\t\t\t\tif (readLen <= 0) {\n\t\t\t\t\tthrow new MyInput.EndOfFileRuntimeException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buffer[pos++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\tint i = 0;\n\t\t\tint ret = 0;\n\t\t\tif (str[0] == '-') {\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t\tfor (; i < len; i++)\n\t\t\t\tret = ret * 10 + str[i] - '0';\n\t\t\tif (str[0] == '-') {\n\t\t\t\tret = -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\tint i = 0;\n\t\t\tlong ret = 0;\n\t\t\tif (str[0] == '-') {\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t\tfor (; i < len; i++)\n\t\t\t\tret = ret * 10 + str[i] - '0';\n\t\t\tif (str[0] == '-') {\n\t\t\t\tret = -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic char nextChar() {\n\t\t\twhile (true) {\n\t\t\t\tfinal int c = read();\n\t\t\t\tif (!isSpace[c]) {\n\t\t\t\t\treturn (char) c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic String nextString() {\n\t\t\treturn new String(nextChars());\n\t\t}\n\n\t\tpublic char[] nextChars() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\treturn Arrays.copyOf(str, len);\n\t\t}\n\n\t\tpublic char[][] next2DChars(int h, int w) {\n\t\t\tchar[][] s = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\ts[i] = nextChars();\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\n\t\tint reads(int len, boolean[] accept) {\n\t\t\ttry {\n\t\t\t\twhile (true) {\n\t\t\t\t\tfinal int c = read();\n\t\t\t\t\tif (accept[c]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (str.length == len) {\n\t\t\t\t\t\tchar[] rep = new char[str.length * 3 / 2];\n\t\t\t\t\t\tSystem.arraycopy(str, 0, rep, 0, str.length);\n\t\t\t\t\t\tstr = rep;\n\t\t\t\t\t}\n\t\t\t\t\tstr[len++] = (char) c;\n\t\t\t\t}\n\t\t\t} catch (MyInput.EndOfFileRuntimeException e) {\n\t\t\t}\n\t\t\treturn len;\n\t\t}\n\n\t\tpublic int[] nextIntArray(final int n) {\n\t\t\tfinal int[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArray1Index(final int n) {\n\t\t\tfinal int[] res = new int[n + 1];\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArrayDec(final int n) {\n\t\t\tfinal int[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(final int n) {\n\t\t\tfinal long[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray1Index(final int n) {\n\t\t\tfinal long[] res = new long[n + 1];\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArrayDec(final int n) {\n\t\t\tfinal long[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic double[] nextDoubleArray(int n) {\n\t\t\tdouble[] res = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextDouble();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\t}\n\n\t}\n\n}\n", "code2": "until (n = gets.strip.to_i) == 0\n\tpoints = gets.strip.split(\" \").map {|i| i.to_f}\n\tavg = (points.reduce(0.0){|sum, p| sum += p}) / n.to_f\n\tvar = points.reduce(0.0){|sum, p| sum += (p - avg) ** 2} / n.to_f\n\tstd = var ** 0.5\n\tputs std.floor(4)\nend\n", "label": 0, "name1": "s004356600.java", "name2": "s105211939.rb"}, {"id": 287, "code1": "import java.util.*;\n\nclass Main{\n  public static void main(String[] args)\n  {\n    Scanner scanner = new Scanner(System.in);\n    int[] a = new int[3];\n    int[] b = new int[3];\n\n    int iti = 0,ni=0,san=0,si =0;\n\n    int odd=0, even=0;\n\n    for(int i=0; i<3; i++){\n      a[i] = scanner.nextInt();\n      b[i] = scanner.nextInt();\n    }\n\n    for(int i=0; i<3; i++){\n      if(a[i] == 1){\n        iti++;\n      }\n      else if(a[i]==2)\n      {\n        ni++;\n      }else if(a[i] == 3)\n      {\n        san++;\n      }else if(a[i] == 4){\n        si++;\n      }\n\n      if(b[i] == 1){\n        iti++;\n      }\n      else if(b[i]==2)\n      {\n        ni++;\n      }else if(b[i] == 3)\n      {\n        san++;\n      }else if(b[i] == 4){\n        si++;\n      }\n    }\n\n    if(checkEven(iti)){\n      even++;\n    }else{\n      odd++;\n    }\n    if(checkEven(ni)){\n      even++;\n    }else{\n      odd++;\n    }\n    if(checkEven(san)){\n      even++;\n    }else{\n      odd++;\n    }\n\n    if(checkEven(si)){\n      even++;\n    }else{\n      odd++;\n    }\n\n      if(odd == 2 && even == 2)\n      {\n        System.out.println(\"YES\");\n      }else{\n        System.out.println(\"NO\");\n      }\n\n  }\n\n  public static boolean checkEven(int num){\n    if(num %2 == 0){\n      return true;\n    }\n    return false;\n  }\n\n}", "code2": "list=[0,0,0,0]\n3.times{\n    a,b=gets.split.map &:to_i\n    list[a-1]+=1\n    list[b-1]+=1\n}\nputs list.sort==[1,1,2,2]? \"YES\" : \"NO\"", "label": 1, "name1": "s151827431.java", "name2": "s065760287.rb"}, {"id": 217, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[] fact = new int[9];\n\n\n\tpublic static void main(String[] args) {\n\t\tfact[1] = 1;\n\t\tfor(int i = 2; i <= 8; i++)\n\t\t\tfact[i] = fact[i-1] * i;\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] p = new int[n];\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tp[i] = sc.nextInt();\n\n\t\tint[] q = new int[n];\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tq[i] = sc.nextInt();\n\n\t\tint ans = Math.abs(getPosi(p) - getPosi(q));\n\t\tSystem.out.println(ans);\n        return;\n    }\n\n\tstatic private int getPosi(int[] x) {\n\n\t\t\tint l = x.length;\n\t\t\tint p = 1;\n\n\t\t\tfor(int i = 0; i < l; i++) {\n\t\t\t\tp += fact[l-i-1] * (x[i]-1);\n\t\t\t\tfor(int j = i+1; j < l; j++) {\n\t\t\t\t\tif(x[j] > x[i])\n\t\t\t\t\t\tx[j]--;\n\t\t\t\t}\n\t\t\t}\n\t\treturn p;\n\n\t}\n\n}\n\n", "code2": "def solve(n, p, q)\n  perms = [ *1..n ].permutation(n)\n  a = perms.find_index { |perm| perm == p }\n  b = perms.find_index { |perm| perm == q }\n  (a - b).abs\nend\n\nn = gets.chomp.to_i\np = gets.chomp.split.map(&:to_i)\nq = gets.chomp.split.map(&:to_i)\n\nputs solve(n, p, q)\n", "label": 1, "name1": "s530732207.java", "name2": "s527873790.rb"}, {"id": 612, "code1": "import java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tchar[] s = sc.next().toCharArray();\n\t\tStack<Character> st = new Stack<>();\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < s.length; i++) {\n\t\t\tif (s[i] == 'T') {\n\t\t\t\tif (st.isEmpty()) cnt++;\n\t\t\t\telse st.pop();\n\t\t\t} else {\n\t\t\t\tst.push('S');\n\t\t\t}\n\t\t}\n\t\tcnt += st.size();\n\t\tSystem.out.println(cnt);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}", "code2": "a,b=gets.split.map(&:to_i)\np a>b ?a-1:a", "label": 0, "name1": "s350666247.java", "name2": "s660994056.rb"}, {"id": 11, "code1": "import java.util.*;\n\npublic class Main{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n\n    String[] s = sc.next().split(\"\");\n    int l =  s.length;\n    int count =0;\n    for(int i=0; i<l; i++){\n      if(s[i].equals(\"U\")||s[i].equals(\"D\")){\n        count +=1;\n        continue;\n      }\n\n\n      if(i%2==0){\n        if(s[i].equals(\"R\")){\n          count += 1;\n        }\n      }else{\n        if(s[i].equals(\"L\")){\n          count += 1;\n        }\n      }\n    }\n    if(count == l){\n      System.out.println(\"Yes\");\n    }else{\n      System.out.println(\"No\");\n    }\n\n\n\n\n  }\n}", "code2": "ary = gets.chomp.chars \nx = ary.each_slice(2).map { |a, b| [a, b] }.transpose\nputs x[0].include?(\"L\") || x[1].include?(\"R\") ? \"No\" : \"Yes\"", "label": 1, "name1": "s855266906.java", "name2": "s268735595.rb"}, {"id": 502, "code1": "import java.util.*;\n\nclass Main{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    String N = sc.next();\n    int sum = 0;\n    for(int i = 0;i<N.length();i++){\n      sum+=Integer.parseInt(N.substring(i,i+1));\n      sum=sum%9;\n    }\n    if(sum == 0){\n      System.out.println(\"Yes\");\n    }else{\n      System.out.println(\"No\");\n    }\n  }\n}", "code2": "s = gets.chomp.split(\"\")\ndir = [[\"R\", \"U\", \"D\"], [\"L\", \"U\", \"D\"]]\nflag = 1\nid = 0\ns.each do |c|\n  tmpflag = 0\n  dir[id%2].each do |d|\n    if c == d\n      tmpflag = 1\n      break\n    end\n  end\n  if tmpflag == 0\n    flag = 0\n    break\n  end\n  id += 1\nend\nif flag == 1\n  puts \"Yes\"\nelse\n  puts \"No\"\nend", "label": 0, "name1": "s788833633.java", "name2": "s423509236.rb"}, {"id": 640, "code1": "import java.util.*;\npublic class Main{\n    public static void main(String args[]) {\n        Scanner cin = new Scanner(System.in);\n        while(cin.hasNext()){\n        \tint n = cin.nextInt();\n        \tint[][] vote = readMatrix(cin,n,2);\n        \tSystem.out.println(getNum(vote,n));\n        }\n    }\n    public static long getNum(int[][] vote, int n){\n    \tlong[] result={vote[0][0],vote[0][1]};\n    \tlong result1;\n    \tfor(int i=1;i<n;i++){\n    \t\tresult1 = result[1];\n    \t\tif(result[0]>vote[i][0]){\n    \t\t\tif(result[0]%vote[i][0]!=0) result[0] += vote[i][0]-result[0]%vote[i][0];\n    \t\t}else{result[0]=vote[i][0];}\n    \t\tresult[1] = result[0]/vote[i][0]*vote[i][1];\n    \t\tif(result1>result[1]){\n    \t\t\tresult[1] = result1;\n    \t\t\tif(result[1]%vote[i][1]!=0) result[1] += vote[i][1]-result[1]%vote[i][1];\n    \t\t\t result[0] = result[1]/vote[i][1]*vote[i][0];\n    \t\t}\n    \t}\n    \treturn result[0]+result[1];\n    }\n    public static int[][] readMatrix(Scanner in,int n,int m){\n    \tint[][] mtx = new int[n][m];\n    \tfor(int i=0;i<n;i++){\n    \t\tfor(int j=0;j<m;j++){\n    \t\t\tmtx[i][j] = in.nextInt();\n    \t\t}\n    \t}\n    \treturn mtx;\n    }\n    \n}", "code2": "def solve(n, p, q)\n  perms = [ *1..n ].permutation(n)\n  a = perms.find_index { |perm| perm == p }\n  b = perms.find_index { |perm| perm == q }\n  (a - b).abs\nend\n\nn = gets.chomp.to_i\np = gets.chomp.split.map(&:to_i)\nq = gets.chomp.split.map(&:to_i)\n\nputs solve(n, p, q)\n", "label": 0, "name1": "s502019413.java", "name2": "s527873790.rb"}, {"id": 865, "code1": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n     \npublic class Main{\n\tpublic static void main(String[] args) throws Exception {\n\tIO io = new IO();\n\tPrintWriter out = new PrintWriter(System.out);\n\tSolver sr = new Solver();\n\tsr.solve(io,out);\n\tout.flush();\n\tout.close();\n    \t}\n\n\tstatic class Solver\n\t{\n      class Pair{\n        int x, y;\n        Pair(int a, int b)\n        {\n          x=a;\n          y=b;\n        }\n      }\n\t    void solve(IO io, PrintWriter out)\n\t    {\n           int i, j;\n          int n = io.nextInt();\n          int m = io.nextInt();\n          \n          ArrayList<Pair> ar = new ArrayList<>();\n          for(i=0 ; i<=n ; i++)\n            \tar.add(new Pair(0,0));\n          for(i=0 ; i<m ; i++)\n          {\n            int tmp=io.nextInt();\n            String str = io.next();\n            if(ar.get(tmp).x==0)\n            {\n              if(str.equals(\"WA\"))\n                ar.get(tmp).y++;\n              else\n                ar.get(tmp).x++;\n            }\n          }\n          int pen=0, correct=0;\n          for(Pair p : ar)\n          {\n            if(p.x!=0)\n            {\n              correct++;\n              pen+=p.y;\n            }\n          }\n            out.print(correct+\" \"+pen);\n\t    }\n    \t\n\t}\n\t//Special thanks to Petr (on codeforces) who inspired me to implement IO class!\n\tstatic class IO\n\t{\n    \tBufferedReader reader;\n        StringTokenizer tokenizer;\n    \tpublic IO() {\n                reader = new BufferedReader(new InputStreamReader(System.in));\n                tokenizer = null;\n            }\n     \n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        public String nextLine() {\n            String s=\"\";\n            try {\n                    s=reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            return s;\n        }\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n    \n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    \tdouble nextDouble()\n    \t{\n    \t\treturn Double.parseDouble(next());\n    \t}\n\t}\n}", "code2": "A,B,C,X,Y = gets.chomp.split.map(&:to_i)\na = 0\nb = 0\ncost = 0\nif A+B >= C*2\n\ta = [X,Y].min\n\tb = a\n\tcost += a*C*2\nend\nif A >= C*2\n\tcost += (X-a)*C*2\n\tb += (X-a)\nelse\n\tcost += (X-a)*A\nend\nif B >= C*2\n\tcost += (Y-b)*C*2\nelse\n\tcost += (Y-b)*B\nend\np cost", "label": 0, "name1": "s215380733.java", "name2": "s390656619.rb"}, {"id": 206, "code1": "\nimport static java.lang.Math.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic int modP = 1000000007;\n\n\tstatic class TaskX {\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tint n = in.nextInt();\n\t\t\tlong[] t = in.nextLongArray(n), a = in.nextLongArray(n);\n\n\t\t\tlong[] tCalc = new long[n];\n\t\t\tArrays.fill(tCalc, -1);\n\n\t\t\tlong[] aCalc = new long[n];\n\t\t\tArrays.fill(aCalc, -1);\n\n\t\t\tlong[] tDef = new long[n];\n\t\t\tlong[] aDef = new long[n];\n\n\t\t\tlong tMax = -1, aMax = -1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (tMax < t[i]) {\n\t\t\t\t\ttMax = t[i];\n\t\t\t\t\ttDef[i] = t[i];\n\t\t\t\t} else {\n\t\t\t\t\ttCalc[i] = tMax;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = n-1; i >= 0; i--) {\n\t\t\t\tif (aMax < a[i]) {\n\t\t\t\t\taMax = a[i];\n\t\t\t\t\taDef[i] = a[i];\n\t\t\t\t} else {\n\t\t\t\t\taCalc[i] = aMax;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (aCalc[i] == -1 && tCalc[i] == -1) {\n\t\t\t\t\tif (aDef[i] != tDef[i]) {\n\t\t\t\t\t\tout.println(0);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else if (aCalc[i] == -1) {\n\t\t\t\t\tif (aDef[i] > tCalc[i]) {\n\t\t\t\t\t\tout.println(0);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else if (tCalc[i] == -1) {\n\t\t\t\t\tif (tDef[i] > aCalc[i]) {\n\t\t\t\t\t\tout.println(0);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong ans = 1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (tCalc[i] == -1 || aCalc[i] == -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tans = ans * min(aCalc[i],tCalc[i]) % modP;\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\n\t}\n\n}\n", "code2": "n = gets.chomp.to_i\ntt = gets.chomp.split(\" \").map(&:to_i)\naa = gets.chomp.split(\" \").map(&:to_i)\nhtt = Array.new(n, nil)\ntt.each_with_index do |e, i|\n  if i == 0 || tt[i-1] < e then  \n    htt[i] = e\n  end\nend\nhaa = Array.new(n, nil)\naa.each_with_index do |e, i|\n  if i == (n - 1) || aa[i + 1] < e then\n    haa[i] = e\n  end\nend\nret = 1\ntt.zip(aa).each_with_index do |e, i|\n  if haa[i] && e[0] < haa[i] then\n    puts 0; exit\n  elsif htt[i] && e[1] < htt[i] then\n    puts 0; exit\n  elsif htt[i] || haa[i] then\n    next\n  end\n  ret *= e.min\n  ret %= (10**9 + 7)\nend\nputs ret", "label": 1, "name1": "s083135979.java", "name2": "s797003004.rb"}, {"id": 570, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tdouble a = sc.nextDouble();\n\t\tdouble b = sc.nextDouble();\n\t\tdouble C = sc.nextDouble();\n\t\t\n\t\tdouble S = 0.5*a*b*Math.sin(Math.toRadians(C));\n\t\tdouble c = Math.sqrt(Math.pow(a, 2)+Math.pow(b, 2)-(2*a*b*Math.cos(Math.toRadians(C))));\n\t\tdouble L = a + b + c;\n\t\tdouble h = 2*S / a;\n\t\t\n\t\tSystem.out.println(S);\n\t\tSystem.out.println(L);\n\t\tSystem.out.println(h);\n\n\t}\n}", "code2": "eval\"(*D),K,*A=\"+`dd`.split*?,;puts D[K.times{D<<A.all?{|a|!D[-a]}}]?:Second: :First", "label": 0, "name1": "s501686962.java", "name2": "s678851692.rb"}, {"id": 461, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.stream.IntStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.PriorityQueue;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.AbstractCollection;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            Dijkstra d = new Dijkstra(n);\n            for (int i = 0; i < n - 1; i++) {\n                int from = in.readInt() - 1;\n                int to = in.readInt() - 1;\n                d.addUndirectedEdge(from, to, 1);\n            }\n            long[] dist1 = d.getDist(0);\n            long[] distN = d.getDist(n - 1);\n            long count1 = IntStream.range(0, n)\n                    .filter(i -> dist1[i] <= distN[i])\n                    .count();\n            out.printLine(count1 > n - count1 ? \"Fennec\" : \"Snuke\");\n        }\n\n    }\n\n    static class Dijkstra {\n        int n;\n        ArrayList<Pair>[] G;\n        private long INF = Long.MAX_VALUE / 3;\n\n        public Dijkstra(int n) {\n            this.n = n;\n            G = new ArrayList[n];\n            for (int i = 0; i < n; i++) {\n                G[i] = new ArrayList<>();\n            }\n        }\n\n        public void addUndirectedEdge(int from, int to, long cost) {\n            G[from].add(new Pair(to, cost));\n            G[to].add(new Pair(from, cost));\n        }\n\n        public long[] getDist(int s) {\n            PriorityQueue<Pair> Q = new PriorityQueue<>();\n            Q.add(new Pair(s, 0));\n            long[] dist = new long[n];\n            Arrays.fill(dist, INF);\n            boolean[] used = new boolean[n];\n            while (!Q.isEmpty()) {\n                Pair p = Q.poll();\n                if (used[p.x]) continue;\n                used[p.x] = true;\n                dist[p.x] = p.y;\n\n                for (Pair edge : G[p.x]) {\n                    Q.add(new Pair(edge.x, p.y + edge.y));\n                }\n            }\n            return dist;\n        }\n\n        class Pair implements Comparable<Pair> {\n            int x;\n            long y;\n\n            Pair(int x, long y) {\n                this.x = x;\n                this.y = y;\n            }\n\n            public int compareTo(Pair p) {\n                return Long.compare(y, p.y);\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n}\n\n", "code2": "n = gets.chomp.to_i\ntree = Array.new(n)\nn.times { |i| tree[i] = [] }\n(n - 1).times do\n  a, b = gets.chomp.split(' ').map { |x| x.to_i - 1 }\n  tree[a] << b\n  tree[b] << a\nend\n\nvisited = Hash.new(false)\ndistances = Array.new(n, 0)\ndistance = 0\nqueue = [0]\nuntil queue.empty?\n  size = queue.length\n  size.times do\n    q = queue.shift\n    next if visited[q]\n    distances[q] = distance\n    visited[q] = true\n    tree[q].each do |i|\n      next if visited[i]\n      queue << i\n    end\n  end\n  distance += 1\nend\n\nqueue = [n - 1]\nroute = []\nuntil queue.empty?\n  q = queue.shift\n  route.unshift(q)\n  tree[q].each do |i|\n    if distances[q] - distances[i] == 1\n      queue << i\n      break\n    end\n  end\nend\nvisited = Hash.new(false)\nstart_index = route.length % 2 == 0 ? route.length / 2 - 1 : route.length / 2\nqueue = [route[start_index]]\ncount = 0\nuntil queue.empty?\n  q = queue.pop\n  next if visited[q]\n  visited[q] = true\n  count += 1\n  tree[q].each do |i|\n    next if i == route[start_index + 1]\n    next if visited[i]\n    queue << i\n  end\nend\n\nputs count > n - count ? 'Fennec' : 'Snuke'", "label": 1, "name1": "s823656696.java", "name2": "s088298181.rb"}, {"id": 298, "code1": "import java.util.*;\npublic class Main {\n\tstatic int yono;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tArrayList<Integer> al = new ArrayList<Integer>();\n\t\tint N = Integer.parseInt(sc.next());\n\t\tyono = N - 1;\n\t\tint M = sc.nextInt();\n\t\ttree = new int[N];\n\t\tArrays.fill(tree, -1);\n\t\tfor (int i = 0; i < M; i++)union(Integer.parseInt(sc.next()) - 1, Integer.parseInt(sc.next()) - 1);\n\t\tSystem.out.println(yono);\n\t}\n\t\n\tstatic int[] tree;\n\tstatic void union(int x, int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif(x != y) {\n\t\t\tyono--;\n\t\t\tif(tree[x] < tree[y]) {\n\t\t\t\tx ^= y; y ^= x; x^= y;\n\t\t\t}\n\t\t\ttree[x] += tree[y];\n\t\t\ttree[y] = x;\n\t\t}\n\t}\n\tstatic boolean find(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tstatic int root(int x) {\n\t\treturn tree[x] < 0 ? x : (tree[x] = root(tree[x]));\n\t}\n}", "code2": "module AtCoder\n  class DSU\n    def initialize(n = 0)\n      @n = n\n      @parent_or_size = Array.new(n, -1)\n    end\n\n    def merge(a, b)\n      x, y = leader(a), leader(b)\n      return x if x == y\n\n      x, y = y, x if -@parent_or_size[x] < -@parent_or_size[y]\n      @parent_or_size[x] += @parent_or_size[y]\n      @parent_or_size[y] = x\n    end\n\n    def same(a, b)\n      leader(a) == leader(b)\n    end\n\n    def leader(a)\n      return a if @parent_or_size[a] < 0\n\n      @parent_or_size[a] = leader(@parent_or_size[a])\n    end\n\n    def size(a)\n      -@parent_or_size[leader(a)]\n    end\n\n    def groups\n      @n.times.group_by { |i| leader(i) }.values\n    end\n  end\nend\n\nn, m = gets.split.map!(&:to_i)\n\ndsu = AtCoder::DSU.new(n + 1)\nm.times do\n  a, b = gets.split.map!(&:to_i)\n  dsu.merge(a, b)\nend\n\nputs dsu.groups.size - 2\n", "label": 1, "name1": "s179713562.java", "name2": "s989552174.rb"}, {"id": 824, "code1": "\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int A = scanner.nextInt();\n        int B = scanner.nextInt();\n        int C = scanner.nextInt();\n\n        if ((A == B && A != C) || (A == C && A != B) || (B == C &&  A != B)) {\n            System.out.println(\"Yes\");\n        } else {\n            System.out.println(\"No\");\n        }\n    }\n}\n", "code2": "n = gets.chomp\nstr = gets.chomp\n\nlen = str.length\nans = len\n\nwcounts = []\necounts = []\n\nlen.times do |i|\n  wcounts[i] = i == 0 ? 0 : wcounts[i-1]\n  wcounts[i] += 1 if str[i] == 'W'\nend\n\nlen.times do |i|\n  j = len - i - 1\n  ecounts[j] = j == len - 1 ? 0 : ecounts[j+1]\n  ecounts[j] += 1 if str[j] == 'E'\nend\n\n# p wcounts\n# p ecounts\n\nans = len\n\nlen.times do |i|\n  if i == 0\n    count = ecounts[i+1]\n  elsif i == len - 1\n    count = wcounts[i]\n  else\n    count = wcounts[i] + ecounts[i+1]\n  end\n  ans = [ans, count].min\nend\n\nputs ans\n", "label": 0, "name1": "s748781959.java", "name2": "s582528009.rb"}, {"id": 832, "code1": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tchar[] s = ns(n);\n\t\tint[] pres = new int[n+1];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tpres[i+1] = pres[i] + (s[i] == 'W' ? 1 : 0);\n\t\t}\n\t\tint[] sufs = new int[n+1];\n\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\tsufs[i] = sufs[i+1] + (s[i] == 'E' ? 1 : 0);\n\t\t}\n\t\tint min = 999999999;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tmin = Math.min(min, pres[i] + sufs[i+1]);\n\t\t}\n\t\tout.println(min);\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n", "code2": "def selection_sort! size, target_array\n  count = 0\n  size.times {|i|\n    unsorted = target_array[i..(size - 1)]\n    min = unsorted.min\n    index_min = unsorted.index(min)\n    if min < target_array[i]\n      target_array[i], target_array[i + index_min] = target_array[i + index_min], target_array[i]\n      count += 1\n    end\n  }\n  count\nend\n\n\nsize = STDIN.gets.chomp.to_i\ntarget_array = STDIN.gets.chomp.split(' ').map{|n|n.to_i}\n\ncount = selection_sort!(size, target_array)\nputs target_array.join ' '\nputs count", "label": 0, "name1": "s365509328.java", "name2": "s018060842.rb"}, {"id": 358, "code1": "import java.util.*;\nimport java.io.*;\n\npublic class Main implements Runnable {\n    public static void main(String[] args) {\n        Thread.setDefaultUncaughtExceptionHandler((t,e)->System.exit(1));\n        // keep stack\n        new Thread(null, new Main(), \"\", 16 * 1024 * 1024).start();\n    }\n    public void run() {\n        FastScanner sc = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        long X = sc.nextLong();\n        long Y = sc.nextLong();\n\n        long count = 1;\n        while(true) {\n            long A = X * 2;\n            if (Y < A) {\n                break;\n            }\n            X = A;\n            count++;\n        }\n        out.printf(\"%d\\n\", count);\n        out.flush();\n    }\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        } else {\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int readByte() {\n        if (hasNextByte()) {\n            return buffer[ptr++];\n        }\n        else {\n            return -1;\n        }\n    }\n\n    private static boolean isPrintableChar(int c) {\n        return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n        while (hasNextByte() && !isPrintableChar(buffer[ptr])) {\n            ptr++;\n        }\n    }\n\n    public boolean hasNext() {\n        skipUnprintable();\n        return hasNextByte();\n    }\n\n    public String next() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public int nextInt() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        int n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b)) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n\n    public long nextLong() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b)) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}", "code2": "X,Y=$<.read.split.map(&:to_i)\n\ni = 0\nn = X\nwhile n <= Y\n    i += 1\n    n *= 2\nend\n\nputs i\n", "label": 1, "name1": "s869503854.java", "name2": "s888422546.rb"}, {"id": 720, "code1": "import java.util.Scanner;\n\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    // \u6574\u6570\u306e\u5165\u529b\n    int a = sc.nextInt();\n    // \u30b9\u30da\u30fc\u30b9\u533a\u5207\u308a\u306e\u6574\u6570\u306e\u5165\u529b\n    int b = sc.nextInt();\n    int c = sc.nextInt();\n\n//    int ab = a + b;\n//    int bc = b + c;\n//    int ac = a+c;\n//\n//    int result = Math.min(ab, Math.min(bc , ac));\n\n    int max = Math.max(a, Math.max(b, c));\n\n    System.out.println(a + b + c - max);\n  }\n}\n", "code2": "n, m = gets.split.map(&:to_i)\nfst, snd = [], []\nm.times{\n  a, b = gets.split.map(&:to_i)\n  fst << b if a==1\n  snd << a if b==n\n}\nputs (fst & snd).empty? ? \"IMPOSSIBLE\" : \"POSSIBLE\"", "label": 0, "name1": "s393158982.java", "name2": "s938238267.rb"}, {"id": 374, "code1": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)924844033;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint ai = io.nextInt();\n\t\t\tint ao = io.nextInt();\n\t\t\tint at = io.nextInt();\n\t\t\tint aj = io.nextInt();\n\t\t\tint al = io.nextInt();\n\t\t\tint as = io.nextInt();\n\t\t\tint az = io.nextInt();\n\t\t\t\n\t\t\tlong ans = 0;\n\t\t\t\n\t\t\tint cnt = aj % 2 + al % 2 + ai % 2;\n\t\t\tif (cnt >= 2) {\n\t\t\t\tif (aj > 0 && al > 0 && ai > 0) {\n\t\t\t\t\tai--;\n\t\t\t\t\taj--;\n\t\t\t\t\tal--;\n\t\t\t\t\tans += 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += ao;\n\t\t\tans += ai / 2 * 2;\n\t\t\tans += aj / 2 * 2;\n\t\t\tans += al / 2 * 2;\n\t\t\t\n\t\t\tio.out.println(ans);\n\t\t}\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n", "code2": "I,O,_,J,L,_,_ = gets.split.map(&:to_i)\np O + I + J + L + case\n                  when [I,J,L].map{ |x| x % 2 }.uniq.size == 1; 0\n                  when [I,J,L].min > 0; -1\n                  when [I,J,L].count{ |x| x % 2 == 0 } == 2; -1\n                  else -2\n                  end", "label": 1, "name1": "s961512992.java", "name2": "s422289570.rb"}, {"id": 24, "code1": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map.Entry;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nclass Main {\n    static final int MOD = 1000000007;\n    static final int INF = 1 << 30;\n\n    Main() {\n        Scanner sc = new Scanner(System.in);\n        long ans = 0;\n        long H = sc.nextLong();\n        long W = sc.nextLong();\n        if(H==1 || W==1){\n        System.out.println(1);\n        return;\n        }\n        long ht = H/2+H%2;\n        long hd = H/2;\n        long wt = W/2+W%2;\n        long wd = W/2;\n        ans += ht*wt;\n        ans += hd*wd;\n        System.out.println(ans);\n    }\n\n    public static void main(String[] args) {\n        new Main();\n    }\n}\n ", "code2": "H, W = gets.split.map(&:to_f)\nif H == 1 || W == 1 then\n  p 1\nelse\n  p (H*W / 2).ceil\nend\n\n", "label": 1, "name1": "s490391243.java", "name2": "s709033779.rb"}, {"id": 496, "code1": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tstatic final long mod = (long) 1e9 + 7;\n\tstatic final int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };\n\tstatic final int[] dx8 = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\tstatic final int inf = Integer.MAX_VALUE / 3;\n\tstatic final long linf = Long.MAX_VALUE / 3;\n\tstatic final double dinf = Double.MAX_VALUE / 3;\n\tstatic final double eps = 1e-10;\n\tstatic final double pi = Math.PI;\n\tstatic StringBuilder sb = new StringBuilder();\n\n\tstatic void solve() {\n\t\tint n = ni();\n\t\tchar s[] = ns(n);\n\t\t//\u5de6\u304b\u3089W\u3092\u5411\u3044\u3066\u308b\u4eba\u3001\u53f3\u304b\u3089E\u3092\u5411\u3044\u3066\u308b\u4eba\u3092\u6570\u3048\u308b\n\t\tint suml[] = new int[n+1];\n\t\tint sumr[] = new int[n+1];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tsuml[i+1] = suml[i] + (s[i]=='W'?1:0);\n\t\t\tsumr[n-i-1] = sumr[n-i] + (s[n-1-i]=='E'?1:0);\n\t\t}\n\t\t\n\t\tint ans = inf;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint t = suml[i]+sumr[i+1];\n\t\t\tans = min(ans, t);\n\t\t}\n\t\tout.println(ans);\n\t\t\n\t}\n\n\t//libraries\n\tstatic void reverse(int ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tint t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(long ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tlong t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(double ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tdouble t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(char ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tchar t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic String getReverse(String s) {\n\t\tchar c[] = s.toCharArray();\n\t\treverse(c);\n\t\ts = String.valueOf(c);\n\t\treturn s;\n\t}\n\n\tstatic <T> void reverse(List<T> ls) {\n\t\tint sz = ls.size();\n\t\tfor (int i = 0; i < sz / 2; i++) {\n\t\t\tT t = ls.get(i);\n\t\t\tls.set(i, ls.get(sz - 1 - i));\n\t\t\tls.set(sz - 1 - i, t);\n\t\t}\n\t}\n\n\tstatic void sbnl() {//StringBuilder\u306b\u6539\u884c\u6587\u5b57\u3092append\u3059\u308b\n\t\tsb.append(\"\\n\");\n\t}\n\n\tstatic int lowerBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int lowerBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int lowerBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic <T> int lowerBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) >= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) >= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) >= 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int upperBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) > 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) > 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) > 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int rupperBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) < 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) < 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) < 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int rlowerBound(List<T> ls, T x) {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) <= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) <= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) <= 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic int[] concat(int x, int arr[]) {\n\t\tint ret[] = new int[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 1, ret.length - 1);\n\t\tret[0] = x;\n\t\treturn ret;\n\t}\n\n\tstatic int[] concat(int arr[], int x) {\n\t\tint ret[] = new int[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 0, ret.length - 1);\n\t\tret[ret.length - 1] = x;\n\t\treturn ret;\n\t}\n\n\tstatic long[] concat(long x, long arr[]) {\n\t\tlong ret[] = new long[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 1, ret.length - 1);\n\t\tret[0] = x;\n\t\treturn ret;\n\t}\n\n\tstatic long[] concat(long arr[], long x) {\n\t\tlong ret[] = new long[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 0, ret.length - 1);\n\t\tret[ret.length - 1] = x;\n\t\treturn ret;\n\t}\n\n\tstatic int max(int x, int y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic int min(int x, int y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic int max(int x, int y, int z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic int min(int x, int y, int z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic long max(long x, long y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic long min(long x, long y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic long max(long x, long y, long z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic long min(long x, long y, long z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic double max(double x, double y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic double min(double x, double y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic double max(double x, double y, double z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic double min(double x, double y, double z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic void sort(int[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void sort(long[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void sort(double[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void rsort(int[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tint tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void rsort(long[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tlong tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void rsort(double[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tdouble tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void fill(int arr[], int x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(long arr[], long x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(boolean arr[], boolean x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(double arr[], double x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(int arr[][], int x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(long arr[][], long x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(double arr[][], double x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(boolean arr[][], boolean x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\t//MOD culc\n\tstatic long plus(long x, long y) {\n\t\tlong res = (x + y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long sub(long x, long y) {\n\t\tlong res = (x - y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long mul(long x, long y) {\n\t\tlong res = (x * y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long div(long x, long y) {\n\t\tlong res = x * pow(y, mod - 2) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long pow(long x, long y) {\n\t\tif (y < 0)\n\t\t\treturn 0;\n\t\tif (y == 0)\n\t\t\treturn 1;\n\t\tif (y % 2 == 1)\n\t\t\treturn (x * pow(x, y - 1)) % mod;\n\t\tlong root = pow(x, y / 2);\n\t\treturn root * root % mod;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\t//input\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static long[] nla(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n}\n", "code2": "N = gets.to_i\nS = gets.chomp\n\new = we = 0\nN.times do |i|\n  we += 1 if S[i] == 'E'\nend\n\nans = 1000000\nN.times do |i|\n  we -= 1 if S[i] == 'E'\n  ans = [ans, ew + we].min\n  ew += 1 if S[i] == 'W'\nend\n\nputs ans\n", "label": 1, "name1": "s594845311.java", "name2": "s770679196.rb"}, {"id": 230, "code1": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint cnt(int s,int g,int cnt,int xy[][],int n){\n\t\tint result = 0;\n\t\tint c[] = new int [n+1];\n\t\tint d[] = new int [n+1];\n\t\tc[s] = 1;\n\t\tif(s == g && cnt > 0)result = 1;\n\t\tfor(int i = 1;i < cnt;i++){\n\t\t\tfor(int j = 1;j < n+1;j++){\n\t\t\t\tfor(int k = 1;k < n+1;k++){\n\t\t\t\t\tif(xy[j][k] == 1 && c[j] == i){\n\t\t\t\t\t\td[k] = i + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 1;j < n+1;j++){\n\t\t\t\tc[j] = d[j];\n\t\t\t}\n\t\t\tif(c[g] > 0){\n\t\t\t\tresult = c[g];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(i == 101){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tvoid doIt() { \n\t\tint n = sc.nextInt();\n\t\tint xy[][] = new int [n+1][n+1];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint r1 = sc.nextInt();\n\t\t\tint k1 = sc.nextInt();\n\t\t\tfor(int j = 0;j < k1;j++){\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\txy[r1][t] = 1;\n\t\t\t}\n    \t }\n\t\tint p = sc.nextInt();\n\t\tfor(int i = 0;i < p;i++){\n\t\t\tint s = sc.nextInt();\n\t\t\tint d = sc.nextInt();\n\t\t\tint TTL = sc.nextInt();\n\t\t\tint ans = cnt(s,d,TTL,xy,n);\n\t\t\tif(ans == 0){\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t//\u4e2d\u8eab\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\tSystem.out.print(xy[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t*/\n     }\n    public static void main(String[] args) {\n    \t// TODO Auto-generated method stub\n    \tnew Main().doIt();\n    }\n}", "code2": "n = gets.to_i\ndp = Array.new(n) { Array.new n }\nn.times do |i|\n  r, _, *ts = gets.split.map(&:to_i)\n  ts.each {|j| dp[r-1][j-1] = 1 }\n  dp[i][i] = 0\nend\nn.times do |k|\n  n.times do |i|\n    n.times do |j|\n      dp[i][j] = dp[i][k] + dp[k][j] if dp[i][k] && dp[k][j] && (!dp[i][j] || dp[i][k] + dp[k][j] < dp[i][j])\n    end\n  end\nend\ngets.to_i.times do\n  s, d, v = gets.split.map(&:to_i)\n  puts dp[s-1][d-1] && dp[s-1][d-1] + 1 <= v ? dp[s-1][d-1] + 1 : 'NA'\nend", "label": 1, "name1": "s130494609.java", "name2": "s305207862.rb"}, {"id": 788, "code1": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Map;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class TaskX {\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tint n = in.nextInt();\n\t\t\tint k = in.nextInt();\n\t\t\tint l = in.nextInt();\n\t\t\tUnionFind u1 = new UnionFind(n);\n\t\t\tUnionFind u2 = new UnionFind(n);\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tint p = in.nextInt()-1;\n\t\t\t\tint q = in.nextInt()-1;\n\t\t\t\tu1.link(p, q);\n\t\t\t}\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tint r = in.nextInt()-1;\n\t\t\t\tint s = in.nextInt()-1;\n\t\t\t\tu2.link(r, s);\n\t\t\t}\n\t\t\tMap<Long, Integer> roots = new HashMap<Long, Integer>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tlong code = (long)u1.root(i)<< 32 | u2.root(i);\n\t\t\t\troots.merge(code, 1, Integer::sum);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i > 0)out.print(\" \");\n\t\t\t\tlong code = (long)u1.root(i) << 32 | u2.root(i);\n\t\t\t\tout.print(roots.get(code));\n\t\t\t}\n\n\t\t}\n\n\t\tpublic class UnionFind {\n\t\t\tint[] data;\n\n\t\t\tpublic UnionFind(int n) {\n\t\t\t\tdata = new int[n];\n\t\t\t\tArrays.fill(data, -1);\n\t\t\t}\n\n\t\t\tboolean link(int x, int y) {\n\t\t\t\tx = root(x);\n\t\t\t\ty = root(y);\n\t\t\t\tif (x != y) {\n\t\t\t\t\tif (data[y] < data[x]) {\n\t\t\t\t\t\tdata[y] += data[x];\n\t\t\t\t\t\tdata[x] = y;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdata[x] += data[y];\n\t\t\t\t\t\tdata[y] = x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn x != y;\n\t\t\t}\n\n\t\t\tint root(int x) {\n\t\t\t\treturn data[x] < 0 ? x : (data[x] = root(data[x]));\n\t\t\t}\n\t\t}\n\t}\n\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\n\t}\n\n}\n", "code2": "eval'*A=#'+`tr ' ' ,`\ns=m=10**9+7\nf=1\np A.sum{f=f*($.+=1)%m\ns+=$..pow m-2,m\n_1*~-s+A[-$.]*s}*f%m", "label": 0, "name1": "s544715299.java", "name2": "s525960042.rb"}, {"id": 143, "code1": "import java.io.IOException;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\nimport java.io.PrintWriter;\n\n@SuppressWarnings(\"unchecked\")\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        final String s;\n\n        try (\n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(System.in))) {\n            s = reader.readLine();\n        }\n\n        PrintWriter out = new PrintWriter(System.out);\n\n        final String[] sl = s.split(\" \");\n        int A = Integer.parseInt(sl[0]);\n        int B = Integer.parseInt(sl[1]);\n        int C = Integer.parseInt(sl[2]);\n\n        int max = Math.max(A, Math.max(B, C));\n\n        int sum = 3 * max - A - B - C;\n\n        int ans;\n\n        if (sum % 2 == 0) ans = sum / 2;\n        else ans = (int)Math.ceil((double)sum / 2) + 1;\n\n        out.println(ans);\n\n        out.flush();\n    }\n}\n", "code2": "# \u6700\u5927\u5024\u306b\u8fd1\u3065\u3051\u308b\u305f\u3081\u306b\u305d\u308c\u4ee5\u5916\u306e\u4e8c\u3064\u3092\u30a4\u30f3\u30af\u30ea\u30e1\u30f3\u30c8\u3057\u3066\u3044\u304f\uff08\u4e8c\u756a\u76ee\u306b\u5927\u304d\u3044\u3084\u3064\u3068\u6700\u5927\u5024\u3068\u306e\u5dee\u3076\u3093\u3060\u3051\u5897\u3048\u308b\uff09\n# \u4e8c\u6570\u304c\u540c\u3058\u6570\u306b\u306a\u3063\u305f\u3068\u304d\u6700\u5c0f\u5024\u306f\u2191\u3092\u52a0\u3048\u305f\u3082\u306e\u306b\u306a\u3063\u3066\u3044\u308b\n# \u305d\u308c\u3068\u6700\u5927\u5024\u3068\u306e\u5dee\u3076\u3093\u3060\u3051+2\u3059\u308b\u304c\u3001\u5dee\u304c\u5947\u6570\u3060\u3068\u8d8a\u3048\u308b\u306e\u3067\n# \u3044\u3063\u305f\u3093\u6700\u5927\u5024\u3092\u66f4\u65b0\u3057\u3066\u304b\u3089\u6700\u521d\u306b\u6700\u5927\u5024\u306b\u5230\u9054\u3057\u3066\u3044\u305f\u4e8c\u6570\u3092\u30a4\u30f3\u30af\u30ea\u30e1\u30f3\u30c8\na, b, c = gets.chomp.split.map(&:to_i)\nmaximum = [a, b, c].max\nminimum = [a, b, c].min\nmid = (a+b+c)-(maximum+minimum)\naa = maximum-mid\nif (maximum - (minimum+aa)).even?\n  puts aa+(maximum - (minimum+aa))/2\nelse\n  puts aa+(maximum - (minimum+aa))/2+2\nend", "label": 1, "name1": "s588342457.java", "name2": "s244849458.rb"}, {"id": 292, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.AbstractCollection;\nimport java.util.PriorityQueue;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CStreamline solver = new CStreamline();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CStreamline {\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            int[] x = in.nextIntArray(m);\n            Arrays.sort(x);\n            int ans = x[m - 1] - x[0];\n            PriorityQueue<Integer> q = new PriorityQueue<>();\n            for (int i = 0; i < m - 1; i++) {\n                q.add(-(x[i + 1] - x[i]));\n            }\n            for (int i = 0; i < n - 1 && !q.isEmpty(); i++) {\n                ans += q.poll();\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        public int[] nextIntArray(final int n) {\n            final int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt();\n            }\n            return res;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n", "code2": "n, m = gets.chomp.split(\" \").map(&:to_i)\nxs = gets.chomp.split(\" \").map(&:to_i).sort\ndiffs = []\ni = 0\nwhile i < (xs.size - 1) do\n  diffs.push xs[i+1] - xs[i]\n  i += 1\nend\n\nputs diffs.sort.reverse.drop(n-1).reduce(&:+) || 0\n", "label": 1, "name1": "s975956716.java", "name2": "s974088402.rb"}, {"id": 822, "code1": "\n\nimport java.util.*;\nimport java.io.*;\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t\n\tScanner sc=new Scanner(System.in);\n\t     int n=sc.nextInt();\n\t     int m=sc.nextInt();\n\t     ArrayList<ArrayList<Integer>> a=new ArrayList<>();\nfor(int i=0;i<n;i++) {\n\ta.add(new ArrayList<Integer>());\n}\nfor(int j=0;j<m;j++) {\n\tint x=sc.nextInt()-1;\n\tint y=sc.nextInt()-1;\n\ta.get(x).add(y);\n\ta.get(y).add(x);\n}\nboolean vis[]=new boolean[n];\nans=0;\n\tSystem.out.println(dfs(a,0,vis,1,n));\n\t}\nstatic int ans=0;\t\n\tstatic int dfs(ArrayList<ArrayList<Integer>> a,int src,boolean vis[],int count,int n) {\n\t\tvis[src]=true;\n\t\tfor(int i:a.get(src)) {\n\t\t\tif(vis[i]==false) {\n\t\t\t\t\n\t\t\t\tdfs(a,i,vis,count+1,n);\n\t\t\t}\n\t\t}\n\t\tif(count==n) {\n\t\tans++;\n\t\tvis[src]=false;\n\t\t\t}else {\n\t\t\t\tvis[src]=false;\n\t\t\t}\n\t\t\n\t\treturn ans;\n\t}\n\tstatic int[] arr(int n,Scanner sc) {\n\t\tint a[]=new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i]=sc.nextInt();\n\t\t}\n\t\treturn a;\n}\n\n}\n", "code2": "# frozen_string_literal: true\n\ndef read\n  [gets.to_i, gets.chomp]\nend\n\ndef solve(_, s)\n  min = Float::INFINITY\n  cnt = { e: 0, w: 0 }\n  table = [cnt.dup]\n  s.chars.each_with_index do |c, i|\n    k = if c == 'W' then :w\n        else :e\n        end\n    cnt[k] += 1\n    table[i + 1] = cnt.dup\n  end\n  table.each do |el|\n    c = el[:w] + table.last[:e] - el[:e]\n    min = c if c < min\n  end\n  min\nend\n\nputs solve(*read)\n# puts [\n#   solve(5, 'WEEWW') == 1,\n#   solve(12, 'WEWEWEEEWWWE') == 4,\n#   solve(8, 'WWWWWEEE') == 3\n# ].all?\n", "label": 0, "name1": "s658101216.java", "name2": "s025378271.rb"}, {"id": 228, "code1": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint cnt(int s,int g,int cnt,int xy[][],int n){\n\t\tint result = 0;\n\t\tint c[] = new int [n+1];\n\t\tint d[] = new int [n+1];\n\t\tc[s] = 1;\n\t\tif(s == g && cnt > 0)result = 1;\n\t\tfor(int i = 1;i < cnt;i++){\n\t\t\tfor(int j = 1;j < n+1;j++){\n\t\t\t\tfor(int k = 1;k < n+1;k++){\n\t\t\t\t\tif(xy[j][k] == 1 && c[j] == i){\n\t\t\t\t\t\td[k] = i + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 1;j < n+1;j++){\n\t\t\t\tc[j] = d[j];\n\t\t\t}\n\t\t\tif(c[g] > 0){\n\t\t\t\tresult = c[g];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(i == 101){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tvoid doIt() { \n\t\tint n = sc.nextInt();\n\t\tint xy[][] = new int [n+1][n+1];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint r1 = sc.nextInt();\n\t\t\tint k1 = sc.nextInt();\n\t\t\tfor(int j = 0;j < k1;j++){\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\txy[r1][t] = 1;\n\t\t\t}\n    \t }\n\t\tint p = sc.nextInt();\n\t\tfor(int i = 0;i < p;i++){\n\t\t\tint s = sc.nextInt();\n\t\t\tint d = sc.nextInt();\n\t\t\tint TTL = sc.nextInt();\n\t\t\tint ans = cnt(s,d,TTL,xy,n);\n\t\t\tif(ans == 0){\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t//\u4e2d\u8eab\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\tSystem.out.print(xy[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t*/\n     }\n    public static void main(String[] args) {\n    \t// TODO Auto-generated method stub\n    \tnew Main().doIt();\n    }\n}", "code2": "def g;gets.split.map &:to_i;end\nr=1..n=g[0]\nw=[0]+r.map{[0]+[1e9]*n}\nr.map{f,_,*t=g;t.map{|i|w[f][i]=1}}\nr.each{|k|r.each{|i|r.each{|j|(a=(b=w[i])[k]+w[k][j])<b[j]&&b[j]=a}}}\ng[0].times{s,d,v=g;puts v<(c=w[s][d]+1)?:NA:c}", "label": 1, "name1": "s130494609.java", "name2": "s754069394.rb"}, {"id": 439, "code1": "import java.io.*;\nimport java.util.*;\n\n/**\n *\n * @author baito\n */\nclass UnionFindTree\n{\n    int[] par;\n    int[] rank;\n    int[] sizes;\n\n    UnionFindTree(int n)\n    {\n        par = new int[n];\n        rank = new int[n];\n        sizes = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            par[i] = i;\n            rank[i] = 0;\n            sizes[i] = 1;\n        }\n    }\n\n    int find(int x)\n    {\n        if (par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n\n    void unite(int x, int y)\n    {\n        x = find(x);\n        y = find(y);\n\n        if (x == y) return;\n        if (rank[x] < rank[y])\n        {\n            par[x] = y;\n            sizes[y] += sizes[x];\n        }\n        else\n        {\n            par[y] = x;\n            sizes[x] += sizes[y];\n            if (rank[x] == rank[y]) rank[x]++;\n        }\n    }\n\n    boolean same(int x, int y)\n    {\n        return find(x) == find(y);\n    }\n\n    int size(int x)\n    {\n        return sizes[par[x]];\n    }\n}\npublic class Main\n{\n    static StringBuilder sb = new StringBuilder();\n    static FastScanner sc = new FastScanner(System.in);\n    static int INF = 10000;\n    static long MOD =1000000007;\n    static long[] f;//factorial\n    static int[] y4 = {0,1,0,-1};\n    static int[] x4 = {1,0,-1,0};\n    static int[] y8 = {0,1,0,-1,-1,1,1,-1};\n    static int[] x8 = {1,0,-1,0,1,-1,1,-1};\n\n    static int N,K,L;\n\n    public static void main(String[] args)\n    {\n\n        N = sc.nextInt();\n        K = sc.nextInt();\n        L = sc.nextInt();\n        UnionFindTree u1 = new UnionFindTree(N);\n        UnionFindTree u2 = new UnionFindTree(N);\n        //long\u3092\u5fd8\u308c\u308b\u306a\u30aa\u30fc\u30d0\u30fc\u30d5\u30ed\u30fc\u3059\u308b\u305e\n        for (int i = 0; i < K; i++)\n        {\n            int p = sc.nextInt()-1;\n            int q = sc.nextInt()-1;\n            u1.unite(p,q);\n        }\n        for (int i = 0; i < L; i++)\n        {\n            int p = sc.nextInt()-1;\n            int q = sc.nextInt()-1;\n            u2.unite(p,q);\n        }\n        Map<Long,Integer> sizes = new HashMap<>();\n        for (int i = 0; i < N; i++)\n        {\n            long root1 = u1.find(i);\n            long root2 = u2.find(i);\n            long hash = root1 * 1000000L + root2;\n            int value = sizes.containsKey(hash) ? sizes.get(hash):0;\n            sizes.put(hash,value+1);\n\n\n        }\n        for (int i = 0; i < N; i++)\n        {\n            long root1 = u1.find(i);\n            long root2 = u2.find(i);\n            long hash = root1 * 1000000L + root2;\n            System.out.println(sizes.get(hash));\n        }\n\n\n\n    }\n    //\u2193nCr\u3092mod\u8a08\u7b97\u3059\u308b\u305f\u3081\u306b\u5fc5\u8981\u3002\u3000***factorial(N)\u3092\u547c\u3076\u5fc5\u8981\u304c\u3042\u308b***\n    static long comb(int n, int r)\n    {\n        long result = f[n];\n        result = result * modInv(f[n - r]) % MOD;\n        result = result * modInv(f[r]) % MOD;\n        return result;\n    }\n\n    static long modInv(long n)\n    {\n        return modPow(n, MOD - 2);\n    }\n\n    static void factorial(int n)\n    {\n        f = new long[n + 1];\n        f[0] = f[1] = 1;\n        for (int i = 2; i <= n; i++)\n        {\n            f[i] = (f[i - 1] * i) % MOD;\n        }\n    }\n\n    static long modPow(long x, long n)\n    {\n        long res = 1L;\n        while (n > 0)\n        {\n            if ((n & 1) == 1)\n            {\n                res = res * x % MOD;\n            }\n            x = x * x % MOD;\n            n >>= 1;\n        }\n        return res;\n    }\n\n    //\u2191nCr\u3092mod\u8a08\u7b97\u3059\u308b\u305f\u3081\u306b\u5fc5\u8981\n\n    static int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n    static long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\n    static <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n    static void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n    public static void reverse(int[] x)\n    {\n        int l = 0;\n        int r = x.length - 1;\n        while (l < r)\n        {\n            int temp = x[l];\n            x[l] = x[r];\n            x[r] = temp;\n            l++;\n            r--;\n        }\n    }\n    public static void reverse(int[] x,int s, int e)\n    {\n        int l = s;\n        int r = e;\n        while (l < r)\n        {\n            int temp = x[l];\n            x[l] = x[r];\n            x[r] = temp;\n            l++;\n            r--;\n        }\n    }\n    static int length(int a) {int cou = 0; while(a != 0){ a /= 10; cou++; } return cou;}\n    static int length(long a) {int cou = 0; while(a != 0){ a /= 10; cou++; } return cou;}\n    static int countC2(char[][] a, char c){\n        int co = 0;\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[0].length; j++)\n                if(a[i][j] == c)\n                    co++;\n        return co;\n    }\n    static void fill(int[][] a, int v){\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[0].length; j++)\n                a[i][j] = v;\n    }\n    static class FastScanner {\n\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        public String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        /*public String nextChar(){\n            return (char)next()[0];\n        }*/\n        public String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n        public int [][] nextIntArray2(int h, int w){\n            int[][] a = new int[h][w];\n            for(int hi = 0 ; hi < h ; hi++){\n                for(int wi = 0 ; wi < w ; wi++){\n                    a[hi][wi] = nextInt();\n                }\n            }\n            return a;\n        }\n        public Integer[] nextIntegerArray(int n) {\n            Integer[] a = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n        public char[] nextCharArray(int n){\n            char[] a = next().toCharArray();\n\n            return a;\n        }\n        public char[][] nextCharArray2(int h , int w){\n            char[][] a = new char[h][w];\n            for (int i = 0; i < h; i++) {\n                a[i] = next().toCharArray();\n            }\n            return a;\n        }\n        //\u30b9\u30da\u30fc\u30b9\u304c\u5165\u3063\u3066\u3044\u308b\u5834\u5408\n        public char[][] nextCharArray2s(int h , int w){\n            char[][] a = new char[h][w];\n            for (int i = 0; i < h; i++) {\n                a[i] = nextLine().replace(\" \",\"\").toCharArray();\n            }\n            return a;\n        }\n        public char[][] nextWrapCharArray2(int h , int w, char c){\n            char[][] a = new char[h + 2][w + 2];\n            //char c = '*';\n            int i;\n            for (i = 0; i < w + 2; i++)\n                a[0][i] = c;\n            for (i = 1; i < h + 1; i++) {\n                a[i] = (c + next() + c).toCharArray();\n            }\n            for (i = 0; i < w + 2; i++)\n                a[h + 1][i] = c;\n            return a;\n        }\n        //\u30b9\u30da\u30fc\u30b9\u304c\u5165\u3063\u3066\u308b\u6642\u7528\n        public char[][] nextWrapCharArray2s(int h , int w ,char c){\n            char[][] a = new char[h + 2][w + 2];\n            //char c = '*';\n            int i;\n            for (i = 0; i < w + 2; i++)\n                a[0][i] = c;\n            for (i = 1; i < h + 1; i++) {\n                a[i] = (c + nextLine().replace(\" \",\"\") + c).toCharArray();\n            }\n            for (i = 0; i < w + 2; i++)\n                a[h + 1][i] = c;\n            return a;\n        }\n        public long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextLong();\n            }\n            return a;\n        }\n        public long [][] nextLongArray2(int h, int w){\n            long[][] a = new long[h][w];\n            for(int hi = 0 ; hi < h ; hi++){\n                for(int wi = 0 ; wi < h ; wi++){\n                    a[h][w] = nextLong();\n                }\n            }\n            return a;\n        }\n    }\n}\n", "code2": "def inp() a=gets.chomp.split(\" \").map(&:to_i)end \ndef inpf() a=gets.chomp.split(\" \").map(&:to_f)end\ndef inps() a=gets.chomp.split(\" \")end  \ndef copy(a) Marshal.load(Marshal.dump(a)) end\ndef kaizyo(n)(n < 2)? 1 : (2..n).inject(:*) end\ndef scount(a) b = na(a.max+1); a.each{|n|b[n]+=1};return b end\ndef na(n=0,d=0) Array.new(n,d)end\ndef na2(n,m,d=0) Array.new(n){Array.new(m,d)}end\ndef na3(n,m,l,d=0) Array.new(n){Array.new(m){Array.new(l,d)}}end\nclass Uf\ndef initialize(n)\n  @r = na(n+1)\n  @a = (0...n).to_a\nend\ndef uf(x)\n  return x if (@a[x] == x)\n  @a[x] = uf(@a[x])\nend\ndef add(x,p)\n  root  = uf(x)\n  connect  = uf(p)\n  return if root == connect\n  if @r[root] > @r[connect]\n    @a[connect] = root\n  elsif @r[root] == @r[connect]\n    @a[connect] = root\n    @r[root] += 1\n  else\n    @a[root] = connect\n  end\nend\ndef ufj(x,p)\n   return uf(x) == uf(p) \nend\nend\nh = {}\nn,k,l = inp\na = Uf.new(n+1)\nb = Uf.new(n+1)\n(k).times do |i|\n  d = inp\n  a.add(d[0],d[1])\nend\n(l).times do |i|\n  d = inp\n  b.add(d[0],d[1])\nend\n(1..n).each do |i|\n  aa = a.uf(i)\n  bb = b.uf(i)\n  h[aa+n*bb] = 0 if(h[aa+n*bb] == nil)\n  h[aa+n*bb] += 1 \nend\n(1..n-1).each do |i|\n  aa = a.uf(i)\n  bb = b.uf(i)\n  print \"#{h[aa+n*bb]} \" \nend\naa = a.uf(n)\nbb = b.uf(n)\nputs h[aa+n*bb]\n=begin\nmax = c if max < c \n=end", "label": 1, "name1": "s138073781.java", "name2": "s266029074.rb"}, {"id": 173, "code1": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t\n\tint cmp (String p1, String p2) {\n\t\tif( p1.length() != p2.length() ) return p2.length() - p1.length();\n\t\treturn p2.compareTo(p1);\n\t}\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif((w|h) == 0 ) break;\n\t\t\t\n\t\t\tString[][] dp = new String[h+1][w+1];\n\t\t\tString pass = \"\";\n\t\t\tchar[][] map = new char[h+1][w+1];\n\t\t\t\n\t\t\tfor(String[] a: dp) fill(a, \"\");\n\t\t\t\n\t\t\tfor(int i=1;i<=h;i++) {\n\t\t\t\tString str = sc.next();\n\t\t\t\tfor(int j=1;j<=w;j++) {\n\t\t\t\t\tmap[i][j] = str.charAt(j-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=1;i<=h;i++) for(int j=1;j<=w;j++) {\n\t\t\t\tif( '0' <= map[i][j] && map[i][j] <= '9' ) {\n\t\t\t\t\tif( map[i][j] == '0' && dp[i-1][j].equals(\"\") && dp[i][j-1].equals(\"\") ) continue;\n\t\t\t\t\tdp[i][j] = ( cmp(dp[i-1][j], dp[i][j-1])<0? dp[i-1][j]: dp[i][j-1] ) + (char)map[i][j];\n\t\t\t\t}\n\t\t\t\tpass = cmp(pass, dp[i][j])<0? pass: dp[i][j];\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(pass);\n\t\t\t\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}", "code2": "loop do\n    w, h = gets.split.map(&:to_i)\n    break if w == 0 && h == 0\n    c = h.times.map{gets.strip}\n    dp = Array.new(h).map{Array.new(w,0)}\n    max = 0\n    c.each_with_index do |r,i|\n        r.each_char.with_index do |ch, j|\n            next if ch.to_s.match(/[A-Z]/)\n            if i == 0\n                if j == 0\n                    dp[i][j] = ch.to_i\n                else\n                    dp[i][j] = (dp[i][j-1].to_s + ch).to_i\n                end\n            else\n                if j == 0\n                    dp[i][j] = (dp[i-1][j].to_s + ch).to_i\n                else\n                    dp[i][j] = ([dp[i-1][j], dp[i][j-1]].max.to_s + ch).to_i\n                end\n            end\n        end\n        max = [max, dp[i].max].max\n    end\n    puts max\nend", "label": 1, "name1": "s246113848.java", "name2": "s260108293.rb"}, {"id": 940, "code1": "import java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.*;\nimport java.text.DecimalFormat;\nimport java.util.*;\n\n\n\n\npublic class Main {\n    private static int n,N;\n    private static int [] A;\n    private static int [] B;\n\n    private static int getLeft(){\n        int s = N/2 + 1;\n        while (s > 1 && B[s] != B[s-1]) s--;\n        return s;\n    }\n    private static int getRight(){\n        int e = N/2+1;\n        while (e < N && B[e] != B[e+1]) e++;\n        return e;\n    }\n\n    private static boolean valid(int x) {\n        for (int i = 1;i <= N;i++)\n            B[i] = (A[i] >= x) ? 1 : 0;\n        int s = getLeft(),e = getRight(),mid = N/2 + 1;\n        if (s == mid || e == mid) return B[mid] == 1;\n\n//        System.err.println(s + \" \" + e);\n        int prv = 0;\n        int l = B[s],r = B[e];\n\n        while (s <= e) {\n            int h = Math.max(s,e);\n            h = Math.min(h,N+1-h) - 1;\n            int rem = h - prv;\n            prv = h;\n            if (rem == 0) break;\n            int len = e-s-1;\n            if (2*rem <= len) {\n                s += rem;\n                e -= rem;\n            }\n            else {\n                if (l == r) return l == 1;\n                if (mid-s < e-mid) return l == 1;\n                else return r==1;\n            }\n        }\n//        System.err.println(\": \" + s + \" \" + e);\n        if (l == r) return l == 1;\n        int pos = mid - s;\n        if (l == 0) return pos%2 == 0;\n        return pos%2 == 1;\n    }\n    public static void main(String[] args) throws Exception {\n        IO io = new IO(null,null);\n        n = io.getNextInt();\n        N = 2*n-1;\n        A = new int[N+1];\n        B = new int[N+1];\n        for (int i = 1;i <= N;i++)\n            A[i] = io.getNextInt();\n\n        int s = 1,e = N;\n        while (s < e) {\n            int m = s + (e-s+1)/2;\n            if (valid(m)) s = m;\n            else e = m - 1;\n        }\n        io.println(s);\n\n        io.close();\n    }\n    private static void bf(int n) {\n        ArrayList<Integer> A = new ArrayList<>();\n        for (int i = 0;i < n;i++)\n            A.add(i&1);\n        TreeSet<ArrayList<Integer>> vis = new TreeSet<>(new Comparator<ArrayList<Integer>>() {\n            @Override\n            public int compare(ArrayList<Integer> o1, ArrayList<Integer> o2) {\n                for (int i = 0;i < n;i++)\n                    if (!o1.get(i).equals(o2.get(i)))\n                        return o1.get(i) - o2.get(i);\n                return 0;\n            }\n        });\n\n        while (!vis.contains(A)) {\n            System.err.println(A);\n            vis.add((ArrayList<Integer>)A.clone());\n            int prv = A.get(0);\n            for (int i = 1;i+1 < n;i++){\n                int cur = A.get(i);\n                if (prv != cur) A.set(i,A.get(i+1));\n                prv = cur;\n            }\n        }\n    }\n\n    private static void bftri(int n) {\n        ArrayList<Integer> A = new ArrayList<>();\n        for (int i = 0;i < n;i++)\n            A.add(i&1);\n        while (!A.isEmpty()) {\n            System.err.println(A);\n\n            ArrayList<Integer> B = new ArrayList<>();\n            int prv = A.get(0);\n            for (int i = 1;i+1 < A.size();i++){\n                int cur = A.get(i);\n                if (prv != cur) B.add(A.get(i+1));\n                else B.add(cur);\n                prv = cur;\n            }\n            A = B;\n        }\n    }\n}\n\nclass pair{\n    int s,e,v;\n    public pair(int s,int e,int v) {\n        this.s = s;\n        this.e = e;\n        this.v = v;\n    }\n    public int getLen(){\n        return e-s+1;\n    }\n    @Override\n    public String toString(){\n        return \"(\" + s + \":\" + e + \", \" + v + \")\";\n    }\n}\n\n\nclass IO{\n    private BufferedReader br;\n    private StringTokenizer st;\n    private PrintWriter writer;\n    private String inputFile,outputFile;\n\n    public boolean hasMore() throws IOException{\n        if(st != null && st.hasMoreTokens()) return true;\n        if(br != null && br.ready()) return true;\n        return false;\n    }\n    public String getNext() throws FileNotFoundException, IOException{\n        while(st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());\n        return st.nextToken();\n    }\n\n    public String getNextLine() throws FileNotFoundException, IOException{\n        return br.readLine().trim();\n    }\n\n    public int getNextInt() throws FileNotFoundException, IOException{\n        return Integer.parseInt(getNext());\n    }\n    public long getNextLong() throws FileNotFoundException, IOException{\n        return Long.parseLong(getNext());\n    }\n\n    public void print(double x,int num_digits) throws  IOException{\n        writer.printf(\"%.\" + num_digits + \"f\" ,x);\n    }\n    public void println(double x,int num_digits) throws  IOException{\n        writer.printf(\"%.\" + num_digits + \"f\\n\" ,x);\n    }\n    public void print(Object o) throws  IOException{\n        writer.print(o.toString());\n    }\n\n    public void println(Object o) throws  IOException{\n        writer.println(o.toString());\n    }\n    public IO(String x,String y) throws FileNotFoundException, IOException{\n        inputFile = x;\n        outputFile = y;\n        if(x != null) br = new BufferedReader(new FileReader(inputFile));\n        else br = new BufferedReader(new InputStreamReader(System.in));\n        if(y != null) writer = new PrintWriter(new BufferedWriter(new FileWriter(outputFile)));\n        else writer = new PrintWriter(new OutputStreamWriter(System.out));\n    }\n\n    protected void close() throws IOException{\n        br.close();\n        writer.close();\n    }\n    public void outputArr(Object [] A) throws IOException{\n        int L = A.length;\n        for (int i = 0;i < L;i++) {\n            if(i > 0) writer.print(\" \");\n            writer.print(A[i]);\n        }\n        writer.print(\"\\n\");\n    }\n}\n", "code2": "D = gets.to_i\nC = gets.chomp.split.map(&:to_i)\ns = D.times.map{gets.split.map(&:to_i)}\nc = Array.new(26, 0)\n\n(0..D-1).each do |i|\nans = 0\nboder = s[i][0]+c[0]\n\n  (0..25).each do |l|\n    c[l] += C[l]\n  end\n  (1..25).each do |e|\n    if s[i][e]+c[e] > boder\n      ans = e\n      boder = s[i][e]+c[e]\n    end\n  end\nc[ans] = 0\nputs ans+1\nend", "label": 0, "name1": "s134955630.java", "name2": "s863240765.rb"}, {"id": 312, "code1": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        // \u6574\u6570\u306e\u5165\u529b\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        int c = sc.nextInt();\n        // \u51fa\u529b\n        int o = c-a+b;\n        System.out.println(o > 0 ? o : 0);\n    }\n}", "code2": "a,b,c=gets.split.map(&:to_i)\np [0, c-a+b].max", "label": 1, "name1": "s598978529.java", "name2": "s732080470.rb"}, {"id": 409, "code1": "import java.util.Scanner;\n\npublic class Main {\n  private static Scanner sc;\n\n  public static void main(String[] args) {\n    sc = new Scanner(System.in);\n    new Main().solve();\n  }\n\n  private void solve() {\n    int N = sc.nextInt();\n    int[] a = new int[N + 2];\n    for (int i = 0; i < N; i++) {\n      a[i + 1] = sc.nextInt();\n    }\n    int sum = 0;\n    for (int i = 0; i <= N; i++) {\n      sum += Math.abs(a[i] - a[i + 1]);\n    }\n\n    for (int i = 0; i < N; i++) {\n      System.out.println(sum - Math.abs(a[i] - a[i + 1]) - Math.abs(a[i + 2] - a[i + 1]) + Math.abs(a[i] - a[i + 2]));\n    }\n  }\n}\n", "code2": "N = gets.chomp.to_i\nA = gets.chomp.split.map(&:to_i)\nA.push(0)\nA.unshift(0)\nsum = 0\nbalance = Array.new(N,0)\n1.upto(A.length-1) do |n|\n\tsum += (A[n-1]-A[n]).abs\n\tif n<balance.length+1\n\t\tbalance[n-1] = (A[n-1]-A[n+1]).abs-((A[n-1]-A[n]).abs+(A[n]-A[n+1]).abs)\n\tend\nend\nbalance.each do |b|\n\tp b+sum\nend", "label": 1, "name1": "s142792447.java", "name2": "s447319638.rb"}, {"id": 895, "code1": "public class Main {\n\tpublic static void main(String[] args){\n\t\tfor(int i=0; i<1000; i++){\n\t\t\tSystem.out.println(\"Hello World\");\n\t\t}\n\t}\n\n}", "code2": "require 'prime'\nx = gets.chomp.to_i\ni = x\n\nwhile i > 0\n  if i.prime?\n\t\tputs i\n\t\tbreak\n  end\n\ti += 1\nend\n", "label": 0, "name1": "s362909688.java", "name2": "s105042152.rb"}, {"id": 976, "code1": "import java.io.*;\nimport java.util.*;\n\n/**\n * @author baito\n */\npublic class Main\n{\n    static StringBuilder sb = new StringBuilder();\n    static FastScanner sc = new FastScanner(System.in);\n    static int INF = 12345678;\n    static long LINF = 123456789123456789L;\n    static long MINF = -123456789123456789L;\n    static long MOD = 1000000007;\n    static int[] y4 = {0, 1, 0, -1};\n    static int[] x4 = {1, 0, -1, 0};\n    static int[] y8 = {0, 1, 0, -1, -1, 1, 1, -1};\n    static int[] x8 = {1, 0, -1, 0, 1, -1, 1, -1};\n    static long[] F;//factorial\n    static boolean[] isPrime;\n    static int[] primes;\n    static char[][] map;\n\n    static int N, A, B;\n    static int[] h;\n\n\n    public static void main(String[] args)\n    {\n        N = sc.nextInt();\n        A = sc.nextInt();\n        B = sc.nextInt();\n        h = sc.nextIntArray(N);\n        int ok = (int) Math.ceil(max(h) * 1.0 / B);\n        int ng = 0;\n        System.out.println(mgr(ok,ng));\n\n    }\n\n    static int mgr(int ok, int ng)\n    {\n        while (Math.abs(ok - ng) > 1)\n        {\n            int mid = (ok + ng) / 2;\n            if (solve(mid))\n            {\n                ok = mid;\n            }\n            else\n            {\n                ng = mid;\n            }\n        }\n        return ok;\n    }\n\n    static boolean solve(long K)\n    {\n        long k = 0;\n        for (int i = 0; i < N; i++)\n        {\n            long hp = h[i];\n            hp -= K * B;\n            if (hp <= 0) continue;\n            k += (long) Math.ceil(hp * 1.0 / (A - B));\n        }\n        if (K < k) return false;\n        else return true;\n    }\n\n    public static boolean isOutofIndex(int x, int y)\n    {\n        if (x < 0 || y < 0) return true;\n        if (map[0].length <= x || map.length <= y) return true;\n        return false;\n    }\n\n    public static void setPrimes()\n    {\n        int n = 100001;\n        isPrime = new boolean[n];\n        List<Integer> prs = new ArrayList<>();\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n        for (int i = 2; i * i <= n; i++)\n        {\n            if (!isPrime[i]) continue;\n            prs.add(i);\n            for (int j = i * 2; j < n; j += i)\n            {\n                isPrime[j] = false;\n            }\n        }\n        primes = new int[prs.size()];\n        for (int i = 0; i < prs.size(); i++)\n            primes[i] = prs.get(i);\n    }\n\n    public static void revSort(int[] a)\n    {\n        Arrays.sort(a);\n        reverse(a);\n    }\n\n    public static void revSort(long[] a)\n    {\n        Arrays.sort(a);\n        reverse(a);\n    }\n\n    public static int[][] copy(int[][] ar)\n    {\n        int[][] nr = new int[ar.length][ar[0].length];\n        for (int i = 0; i < ar.length; i++)\n            for (int j = 0; j < ar[0].length; j++)\n                nr[i][j] = ar[i][j];\n        return nr;\n    }\n\n    public static long sumMod(long... lar)\n    {\n        long sum = 0;\n        for (long l : lar)\n            sum = (sum + l % MOD) % MOD;\n        return sum;\n    }\n\n    /**\n     * <h1>\u6307\u5b9a\u3057\u305f\u5024\u4ee5\u4e0a\u306e\u5148\u982d\u306e\u30a4\u30f3\u30c7\u30af\u30b9\u3092\u8fd4\u3059</h1>\n     * <p>\u914d\u5217\u8981\u7d20\u304c\uff10\u306e\u3068\u304d\u306f\u3001\uff10\u304c\u8fd4\u308b\u3002</p>\n     *\n     * @return<b>int</b> \uff1a \u63a2\u7d22\u3057\u305f\u5024\u4ee5\u4e0a\u3067\u3001\u5148\u982d\u306b\u306a\u308b\u30a4\u30f3\u30c7\u30af\u30b9\n     */\n    public static int lowerBound(final int[] arr, final int value)\n    {\n        int low = 0;\n        int high = arr.length;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (\u30aa\u30fc\u30d0\u30fc\u30d5\u30ed\u30fc\u5bfe\u7b56)\n            if (arr[mid] < value)\n            {\n                low = mid + 1;\n            }\n            else\n            {\n                high = mid;\n            }\n        }\n        return low;\n    }\n\n    /**\n     * <h1>\u6307\u5b9a\u3057\u305f\u5024\u3088\u308a\u5927\u304d\u3044\u5148\u982d\u306e\u30a4\u30f3\u30c7\u30af\u30b9\u3092\u8fd4\u3059</h1>\n     * <p>\u914d\u5217\u8981\u7d20\u304c\uff10\u306e\u3068\u304d\u306f\u3001\uff10\u304c\u8fd4\u308b\u3002</p>\n     *\n     * @return<b>int</b> \uff1a \u63a2\u7d22\u3057\u305f\u5024\u3088\u308a\u4e0a\u3067\u3001\u5148\u982d\u306b\u306a\u308b\u30a4\u30f3\u30c7\u30af\u30b9\n     */\n    public static int upperBound(final int[] arr, final int value)\n    {\n        int low = 0;\n        int high = arr.length;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (\u30aa\u30fc\u30d0\u30fc\u30d5\u30ed\u30fc\u5bfe\u7b56)\n            if (arr[mid] <= value)\n            {\n                low = mid + 1;\n            }\n            else\n            {\n                high = mid;\n            }\n        }\n        return low;\n    }\n\n    //\u6b21\u306e\u9806\u5217\u306b\u66f8\u304d\u63db\u3048\u308b\u3001\u6700\u5927\u5024\u306a\u3089false\u3092\u8fd4\u3059\n    public static boolean nextPermutation(int A[])\n    {\n        int len = A.length;\n        int pos = len - 2;\n        for (; pos >= 0; pos--)\n        {\n            if (A[pos] < A[pos + 1]) break;\n        }\n        if (pos == -1) return false;\n\n        //pos\u3088\u308a\u5927\u304d\u3044\u6700\u5c0f\u306e\u6570\u3092\u4e8c\u5206\u63a2\u7d22\n        int ok = pos + 1;\n        int ng = len;\n        while (Math.abs(ng - ok) > 1)\n        {\n            int mid = (ok + ng) / 2;\n            if (A[mid] > A[pos]) ok = mid;\n            else ng = mid;\n\n        }\n\n        swap(A, pos, ok);\n        reverse(A, pos + 1, len - 1);\n\n\n        return true;\n    }\n\n    //\u6b21\u306e\u9806\u5217\u306b\u66f8\u304d\u63db\u3048\u308b\u3001\u6700\u5c0f\u5024\u306a\u3089false\u3092\u8fd4\u3059\n    public static boolean prevPermutation(int A[])\n    {\n        int len = A.length;\n        int pos = len - 2;\n        for (; pos >= 0; pos--)\n        {\n            if (A[pos] > A[pos + 1]) break;\n        }\n        if (pos == -1) return false;\n\n        //pos\u3088\u308a\u5c0f\u3055\u3044\u6700\u5927\u306e\u6570\u3092\u4e8c\u5206\u63a2\u7d22\n        int ok = pos + 1;\n        int ng = len;\n        while (Math.abs(ng - ok) > 1)\n        {\n            int mid = (ok + ng) / 2;\n            if (A[mid] < A[pos]) ok = mid;\n            else ng = mid;\n\n        }\n\n        swap(A, pos, ok);\n        reverse(A, pos + 1, len - 1);\n\n\n        return true;\n    }\n\n    //\u2193nCr\u3092mod\u8a08\u7b97\u3059\u308b\u305f\u3081\u306b\u5fc5\u8981\u3002\u3000***factorial(N)\u3092\u547c\u3076\u5fc5\u8981\u304c\u3042\u308b***\n    static long ncr(int n, int r)\n    {\n        if (n < r) return 0;\n        else if (r == 0) return 1;\n\n        factorial(n);\n        return F[n] / (F[n - r] * F[r]);\n    }\n\n    static long ncr2(int a, int b)\n    {\n        if (b == 0) return 1;\n        else if (a < b) return 0;\n        long res = 1;\n        for (int i = 0; i < b; i++)\n        {\n            res *= a - i;\n            res /= i + 1;\n        }\n        return res;\n    }\n\n    static long ncrdp(int n, int r)\n    {\n        if (n < r) return 0;\n        long[][] dp = new long[n + 1][r + 1];\n        for (int ni = 0; ni < n + 1; ni++)\n        {\n            dp[ni][0] = dp[ni][ni] = 1;\n            for (int ri = 1; ri < ni; ri++)\n            {\n                dp[ni][ri] = dp[ni - 1][ri - 1] + dp[ni - 1][ri];\n            }\n        }\n        return dp[n][r];\n    }\n\n    static long modNcr(int n, int r)\n    {\n        long result = F[n];\n        result = result * modInv(F[n - r]) % MOD;\n        result = result * modInv(F[r]) % MOD;\n        return result;\n    }\n\n    static long modInv(long n)\n    {\n        return modPow(n, MOD - 2);\n    }\n\n    static void factorial(int n)\n    {\n        F = new long[n + 1];\n        F[0] = F[1] = 1;\n        for (int i = 2; i <= n; i++)\n        {\n            F[i] = (F[i - 1] * i) % MOD;\n        }\n    }\n\n    static long modPow(long x, long n)\n    {\n        long res = 1L;\n        while (n > 0)\n        {\n            if ((n & 1) == 1)\n            {\n                res = res * x % MOD;\n            }\n            x = x * x % MOD;\n            n >>= 1;\n        }\n        return res;\n    }\n\n    //\u2191nCr\u3092mod\u8a08\u7b97\u3059\u308b\u305f\u3081\u306b\u5fc5\u8981\n\n    static int gcd(int n, int r)\n    {\n        return r == 0 ? n : gcd(r, n % r);\n    }\n\n    static long gcd(long n, long r)\n    {\n        return r == 0 ? n : gcd(r, n % r);\n    }\n\n    static <T> void swap(T[] x, int i, int j)\n    {\n        T t = x[i];\n        x[i] = x[j];\n        x[j] = t;\n    }\n\n    static void swap(int[] x, int i, int j)\n    {\n        int t = x[i];\n        x[i] = x[j];\n        x[j] = t;\n    }\n\n    public static void reverse(int[] x)\n    {\n        int l = 0;\n        int r = x.length - 1;\n        while (l < r)\n        {\n            int temp = x[l];\n            x[l] = x[r];\n            x[r] = temp;\n            l++;\n            r--;\n        }\n    }\n\n    public static void reverse(long[] x)\n    {\n        int l = 0;\n        int r = x.length - 1;\n        while (l < r)\n        {\n            long temp = x[l];\n            x[l] = x[r];\n            x[r] = temp;\n            l++;\n            r--;\n        }\n    }\n\n    public static void reverse(int[] x, int s, int e)\n    {\n        int l = s;\n        int r = e;\n        while (l < r)\n        {\n            int temp = x[l];\n            x[l] = x[r];\n            x[r] = temp;\n            l++;\n            r--;\n        }\n    }\n\n    static int length(int a)\n    {\n        int cou = 0;\n        while (a != 0)\n        {\n            a /= 10;\n            cou++;\n        }\n        return cou;\n    }\n\n    static int length(long a)\n    {\n        int cou = 0;\n        while (a != 0)\n        {\n            a /= 10;\n            cou++;\n        }\n        return cou;\n    }\n\n    static int countC2(char[][] a, char c)\n    {\n        int co = 0;\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[0].length; j++)\n                if (a[i][j] == c) co++;\n        return co;\n    }\n\n    static int countI(int[] a, int key)\n    {\n        int co = 0;\n        for (int i = 0; i < a.length; i++)\n            if (a[i] == key) co++;\n        return co;\n    }\n\n    static int countI(int[][] a, int key)\n    {\n        int co = 0;\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[0].length; j++)\n                if (a[i][j] == key) co++;\n        return co;\n    }\n\n    static void fill(int[][] a, int v)\n    {\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[0].length; j++)\n                a[i][j] = v;\n    }\n\n\n    static void fill(long[][] a, long v)\n    {\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[0].length; j++)\n                a[i][j] = v;\n    }\n\n    static void fill(int[][][] a, int v)\n    {\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[0].length; j++)\n                for (int k = 0; k < a[0][0].length; k++)\n                    a[i][j][k] = v;\n    }\n\n    static int max(int a, int b, int c)\n    {\n        return Math.max(a, Math.max(b, c));\n    }\n\n    static int max(int[] ar)\n    {\n        int res = Integer.MIN_VALUE;\n        for (int i : ar)\n            res = Math.max(res, i);\n        return res;\n    }\n\n    static int max(int[][] ar)\n    {\n        int res = Integer.MIN_VALUE;\n        for (int i[] : ar)\n            res = Math.max(res, max(i));\n        return res;\n    }\n\n    static int min(int a, int b, int c)\n    {\n        return Math.min(a, Math.min(b, c));\n    }\n\n    static int min(int[] ar)\n    {\n        int res = Integer.MAX_VALUE;\n        for (int i : ar)\n            res = Math.min(res, i);\n        return res;\n    }\n\n    static int min(int[][] ar)\n    {\n        int res = Integer.MAX_VALUE;\n        for (int i[] : ar)\n            res = Math.min(res, min(i));\n        return res;\n    }\n\n    static int sum(int[] a)\n    {\n        int cou = 0;\n        for (int i : a)\n            cou += i;\n        return cou;\n    }\n\n    static int abs(int a)\n    {\n        return Math.abs(a);\n    }\n\n    static class FastScanner\n    {\n\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public FastScanner(InputStream in)\n        {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        public String next()\n        {\n            if (tokenizer == null || !tokenizer.hasMoreTokens())\n            {\n                try\n                {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        /*public String nextChar(){\n            return (char)next()[0];\n        }*/\n        public String nextLine()\n        {\n            if (tokenizer == null || !tokenizer.hasMoreTokens())\n            {\n                try\n                {\n                    return reader.readLine();\n                } catch (IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        public int[] nextIntArray(int n)\n        {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n            {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        public int[] nextIntArrayDec(int n)\n        {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n            {\n                a[i] = nextInt() - 1;\n            }\n            return a;\n        }\n\n        public int[][] nextIntArray2(int h, int w)\n        {\n            int[][] a = new int[h][w];\n            for (int hi = 0; hi < h; hi++)\n            {\n                for (int wi = 0; wi < w; wi++)\n                {\n                    a[hi][wi] = nextInt();\n                }\n            }\n            return a;\n        }\n\n        public int[][] nextIntArray2Dec(int h, int w)\n        {\n            int[][] a = new int[h][w];\n            for (int hi = 0; hi < h; hi++)\n            {\n                for (int wi = 0; wi < w; wi++)\n                {\n                    a[hi][wi] = nextInt() - 1;\n                }\n            }\n            return a;\n        }\n\n        //\u8907\u6570\u306e\u914d\u5217\u3092\u53d7\u3051\u53d6\u308b\n        public void nextIntArrays2ar(int[] a, int[] b)\n        {\n            for (int i = 0; i < a.length; i++)\n            {\n                a[i] = sc.nextInt();\n                b[i] = sc.nextInt();\n            }\n        }\n\n        public void nextIntArrays2arDec(int[] a, int[] b)\n        {\n            for (int i = 0; i < a.length; i++)\n            {\n                a[i] = sc.nextInt() - 1;\n                b[i] = sc.nextInt() - 1;\n            }\n        }\n\n        //\u8907\u6570\u306e\u914d\u5217\u3092\u53d7\u3051\u53d6\u308b\n        public void nextIntArrays3ar(int[] a, int[] b, int[] c)\n        {\n            for (int i = 0; i < a.length; i++)\n            {\n                a[i] = sc.nextInt();\n                b[i] = sc.nextInt();\n                c[i] = sc.nextInt();\n            }\n        }\n\n        //\u8907\u6570\u306e\u914d\u5217\u3092\u53d7\u3051\u53d6\u308b\n        public void nextIntArrays3arDec(int[] a, int[] b, int[] c)\n        {\n            for (int i = 0; i < a.length; i++)\n            {\n                a[i] = sc.nextInt() - 1;\n                b[i] = sc.nextInt() - 1;\n                c[i] = sc.nextInt() - 1;\n            }\n        }\n\n        public Integer[] nextIntegerArray(int n)\n        {\n            Integer[] a = new Integer[n];\n            for (int i = 0; i < n; i++)\n            {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        public char[] nextCharArray(int n)\n        {\n            char[] a = next().toCharArray();\n\n            return a;\n        }\n\n        public char[][] nextCharArray2(int h, int w)\n        {\n            char[][] a = new char[h][w];\n            for (int i = 0; i < h; i++)\n            {\n                a[i] = next().toCharArray();\n            }\n            return a;\n        }\n\n        //\u30b9\u30da\u30fc\u30b9\u304c\u5165\u3063\u3066\u3044\u308b\u5834\u5408\n        public char[][] nextCharArray2s(int h, int w)\n        {\n            char[][] a = new char[h][w];\n            for (int i = 0; i < h; i++)\n            {\n                a[i] = nextLine().replace(\" \", \"\").toCharArray();\n            }\n            return a;\n        }\n\n        public char[][] nextWrapCharArray2(int h, int w, char c)\n        {\n            char[][] a = new char[h + 2][w + 2];\n            //char c = '*';\n            int i;\n            for (i = 0; i < w + 2; i++)\n                a[0][i] = c;\n            for (i = 1; i < h + 1; i++)\n            {\n                a[i] = (c + next() + c).toCharArray();\n            }\n            for (i = 0; i < w + 2; i++)\n                a[h + 1][i] = c;\n            return a;\n        }\n\n        //\u30b9\u30da\u30fc\u30b9\u304c\u5165\u3063\u3066\u308b\u6642\u7528\n        public char[][] nextWrapCharArray2s(int h, int w, char c)\n        {\n            char[][] a = new char[h + 2][w + 2];\n            //char c = '*';\n            int i;\n            for (i = 0; i < w + 2; i++)\n                a[0][i] = c;\n            for (i = 1; i < h + 1; i++)\n            {\n                a[i] = (c + nextLine().replace(\" \", \"\") + c).toCharArray();\n            }\n            for (i = 0; i < w + 2; i++)\n                a[h + 1][i] = c;\n            return a;\n        }\n\n        public long[] nextLongArray(int n)\n        {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n            {\n                a[i] = nextLong();\n            }\n            return a;\n        }\n\n        public long[][] nextLongArray2(int h, int w)\n        {\n            long[][] a = new long[h][w];\n            for (int hi = 0; hi < h; hi++)\n            {\n                for (int wi = 0; wi < h; wi++)\n                {\n                    a[h][w] = nextLong();\n                }\n            }\n            return a;\n        }\n    }\n}\n", "code2": "require 'prime'\n \nprimes = Prime.each(1_000_000).to_a\n \nwhile (n = gets.to_i) > 0\n    i = 0\n    j = (primes.find_index{|x| x > n} || primes.size) - 1\n \n    count = 0\n    while\n        s = primes[i] + primes[j]\n        count += 1 if s == n\n        break if i == j\n        if s < n\n            i += 1\n        else\n            j -= 1\n        end\n    end\n    p count\nend", "label": 0, "name1": "s118659723.java", "name2": "s198211396.rb"}, {"id": 660, "code1": "import java.util.*;\nimport java.io.*;\n\nclass Main {\n    static int searchP(long p,int[] ws){\n        int count = 1;\n        int sum = 0; \n        for(int i = 0; i < ws.length; i++){\n            if(sum + ws[i] <= p) {\n            sum += ws[i];\n            } else {\n                count++;\n                if(ws[i] <= p){\n                sum = ws[i];\n                } else{\n                    count += 99999;\n                }\n            }\n        }\n        return count;\n    }\n    static long solve(long p, int[] ws, long k){\n        long right = p;\n        long left = 0;\n        long mid;\n        while(right - left > 1) {\n            mid = (left + right) / 2;\n            int v = searchP(mid,ws);\n            if(k >= v) {\n                right = mid;\n            } else {\n               left = mid;\n                \n            }\n        }\n    return right;\n    }\n    public static void main(String...args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        \n        String[] info = br.readLine().split(\" \");\n        int n = Integer.parseInt(info[0]);\n        int k = Integer.parseInt(info[1]);\n        int[] ws = new int[n];\n        for(int i = 0; i < n; i++) {\n            ws[i] = Integer.parseInt(br.readLine());\n        }\n        long p = 100000 * 10000;\n        System.out.println(solve(p,ws,k));\n        \n    }\n}\n\n\n\n", "code2": "S = gets.chomp\nT = gets.chomp\n\noffset = (0 .. S.size - T.size).reverse_each.find do |offset|\n  found = T.size.times.all? do |i| \n    S[offset + i] == '?' || S[offset + i] == T[i]\n  end\nend\nif offset\n  z = S.tr('?','a')\n  z[offset,T.size] = T\n  puts z\nelse\n  puts \"UNRESTORABLE\"\nend", "label": 0, "name1": "s705576178.java", "name2": "s917754252.rb"}, {"id": 320, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author cunbidun\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        EProductOfArithmeticProgression solver = new EProductOfArithmeticProgression();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EProductOfArithmeticProgression {\n        private static final int MOD = (int) 1e6 + 3;\n        private InputReader in;\n        private PrintWriter out;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            this.in = in;\n            this.out = out;\n            int q = in.nextInt();\n\n            int[] fac = new int[MOD + 1];\n            int[] inv = new int[MOD + 1];\n            fac[0] = 1;\n            inv[0] = Op.inv(1, MOD);\n            for (int i = 1; i <= MOD; i++) {\n                fac[i] = Op.mulMod(fac[i - 1], i, MOD);\n                inv[i] = Op.inv(fac[i], MOD);\n            }\n\n            while (q-- > 0) {\n                int x = in.nextInt();\n                int d = in.nextInt();\n                int n = in.nextInt();\n                if (d == 0) {\n                    out.println(Op.powMod(x, n, MOD));\n                    continue;\n                }\n                x = Op.mulMod(x, Op.inv(d, MOD), MOD);\n                int ans;\n                if (x + n - 1 >= MOD || x == 0) ans = 0;\n                else\n                    ans = Op.mulMod(fac[x + n - 1], inv[x - 1], MOD);\n                out.println(Op.mulMod(ans, Op.powMod(d, n, MOD), MOD));\n            }\n        }\n\n    }\n\n    static class Op {\n        public static int mulMod(int x, int y, int MOD) {\n            return (int) (((long) x * y) % MOD);\n        }\n\n        public static int powMod(int x, long p, int MOD) {\n            if (p == 0) return 1;\n            int t = powMod(x, p / 2, MOD);\n            if ((p & 1) == 1)\n                return mulMod(mulMod(t, t, MOD), x, MOD);\n            return mulMod(t, t, MOD);\n        }\n\n        public static int inv(int x, int MOD) {\n            return powMod(x, MOD - 2, MOD);\n        }\n\n    }\n\n    static class InputReader extends InputStream {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private static boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n", "code2": "M=1000003\no=->a,n{n<1?1:(n%2>0?a:1)*o[a,n/2]**2%M}\nf=f=1,*(1..M).map{|i|f=f*i%M}\ngets\n$<.map{|s|x,d,n=s.split.map &:to_i\np d<1?o[x,n]:M-n<=(t=x*o[d,M-2]%M-1)?0:f[t+n]*o[f[t],M-2]*o[d,n]%M}", "label": 1, "name1": "s606724970.java", "name2": "s763901366.rb"}, {"id": 521, "code1": "import java.util.*;\nimport java.io.*;\n\nimport static java.lang.System.in;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long A = sc.nextLong();\n        long B = sc.nextLong();\n        long[] x = new long[n];\n        for(int i=0;i<n;i++) x[i]=sc.nextLong();\n        long ans= 0;\n        for(int i=0;i<n-1;i++){\n            ans += Math.min(A*(x[i+1]-x[i]),B);\n        }\n        PrintWriter out = new PrintWriter(System.out);\n        out.println(ans);\n        out.flush();\n    }\n}\n", "code2": "n = gets.to_i\na = gets.split.map(&:to_i)\nans = 0\nfor i in 1..n-1\n    if a[i] == a[i-1]\n        ans += 1\n        a[i] = 0\n    end\nend\nputs ans", "label": 0, "name1": "s316016733.java", "name2": "s614056368.rb"}, {"id": 653, "code1": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\t\n\tint n;\n\tint[][] es;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\tes = new int[n][n];\n\t\tfor (int[] a: es) fill(a, INF);\n\t\tfor (int i=0;i<n;i++) es[i][i] = 0;\n\t\tfor (int i=0;i<n;i++) {\n\t\t\tint r = sc.nextInt()-1, k = sc.nextInt();\n\t\t\tfor (int j=0;j<k;j++) {\n\t\t\t\tint t = sc.nextInt()-1;\n\t\t\t\tes[r][t] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int k=0;k<n;k++) for (int i=0;i<n;i++) for (int j=0;j<n;j++) {\n\t\t\tes[i][j] = min(es[i][j], es[i][k] + es[k][j]);\n\t\t}\n\t\tint p = sc.nextInt();\n\t\tfor (int i=0;i<p;i++) {\n\t\t\tint s = sc.nextInt()-1, d = sc.nextInt()-1, v = sc.nextInt();\n\t\t\tSystem.out.println((es[s][d] + 1 <= v ? es[s][d] + 1 : \"NA\"));\n\t\t}\n\t}\n\t\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}", "code2": "n=gets.to_i\na=gets.chomp.split.map(&:to_i)\ns=0\na.each_with_index{|x, i|\n    if a[x-1] == i+1\n        s+=1\n    end\n}\nputs s/2\n", "label": 0, "name1": "s834155894.java", "name2": "s156669970.rb"}, {"id": 223, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\n\npublic class Main {\n\n    static <T extends Comparable<? super T>> boolean nextPermutation(T[] sequence) {\n        int first = getFirst(sequence);\n        if (first == -1) return false;\n        int toSwap = sequence.length - 1;\n        while (sequence[first].compareTo(sequence[toSwap]) >= 0) --toSwap;\n        swap(sequence, first++, toSwap);\n        toSwap = sequence.length - 1;\n        while (first < toSwap) swap(sequence, first++, toSwap--);\n        return true;\n    }\n\n    static <T extends Comparable<? super T>> int getFirst(T[] sequence) {\n        for (int i = sequence.length - 2; i >= 0; --i)\n            if (sequence[i].compareTo(sequence[i + 1]) < 0) return i;\n        return -1;\n    }\n\n    static <T extends Comparable<? super T>> void swap(T[] sequence, int i, int j) {\n        T tmp = sequence[i];\n        sequence[i] = sequence[j];\n        sequence[j] = tmp;\n    }\n\n    public static void main(String[] args) {\n        FastScanner fs = new FastScanner();\n        int N = fs.nextInt();\n        Integer[] P = new Integer[N];\n        Integer[] Q = new Integer[N];\n        for (int i = 0; i < N; ++i) P[i] = fs.nextInt();\n        for (int i = 0; i < N; ++i) Q[i] = fs.nextInt();\n\n        Integer[] arr = new Integer[N];\n        for (int i = 0; i < N; ++i) arr[i] = i+1;\n\n        int cnt = 1, pNum = 0, qNum = 0;\n        do {\n            if (Arrays.toString(arr).equals(Arrays.toString(P))) pNum = cnt;\n            if (Arrays.toString(arr).equals(Arrays.toString(Q))) qNum = cnt;\n            ++cnt;\n        } while (nextPermutation(arr));\n\n        System.out.println(Math.abs(pNum - qNum));\n\n    }\n\n\n    static class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            }else{\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while(true){\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                }else if(b == -1 || !isPrintableChar(b)){\n                    return minus ? -n : n;\n                }else{\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        public int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        public double nextDouble() { return Double.parseDouble(next());}\n    }\n\n}", "code2": "N = gets.to_i\nP = gets.split.map &:to_i\nQ = gets.split.map &:to_i\nps = [*1..N].permutation(N).to_a\n\na = ps.index P\nb = ps.index Q\n\np (a - b).abs", "label": 1, "name1": "s792830085.java", "name2": "s709261522.rb"}, {"id": 134, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tMyInput in = new MyInput(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic long LINF = 1L << 55;\n\tstatic int MOD = 1000000007;\n\tstatic int[] mh4 = { 0, -1, 1, 0 };\n\tstatic int[] mw4 = { -1, 0, 0, 1 };\n\tstatic int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\tstatic int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n\tstatic class TaskX {\n\n\t\tpublic void solve(int testNumber, MyInput in, PrintWriter out) {\n\n\t\t\tint n = in.nextInt();\n\t\t\tchar[] s = in.nextChars();\n\n\t\t\tlong[][] dp = new long[n+1][n+1];\n\t\t\tArrays.fill(dp[0], 1);\n\n\t\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\t\tif (s[i] == '<') {\n\t\t\t\t\tfor (int j = 0; j < n-i; j++) {\n\t\t\t\t\t\tdp[i+1][j] += dp[i][j];\n\t\t\t\t\t\tdp[i+1][j] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (int j = 0; j < n-i; j++) {\n\t\t\t\t\t\tdp[i+1][0] += dp[i][j];\n\t\t\t\t\t\tdp[i+1][j] -= dp[i][j] - MOD;\n\t\t\t\t\t\tdp[i+1][0] %= MOD;\n\t\t\t\t\t\tdp[i+1][j] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 1; j < n-1-i; j++) {\n\t\t\t\t\tdp[i+1][j] += dp[i+1][j-1];\n\t\t\t\t\tdp[i+1][j] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout.println(dp[n-1][0]);\n\n\t\t}\n\t}\n\n\tstatic class MyInput {\n\t\tprivate final BufferedReader in;\n\t\tprivate static int pos;\n\t\tprivate static int readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500 * 8 * 2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic {\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tisDigit['0' + i] = true;\n\t\t\t}\n\t\t\tisDigit['-'] = true;\n\t\t\tisSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n\t\t\tisLineSep['\\r'] = isLineSep['\\n'] = true;\n\t\t}\n\n\t\tpublic MyInput(InputStream is) {\n\t\t\tin = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (pos >= readLen) {\n\t\t\t\tpos = 0;\n\t\t\t\ttry {\n\t\t\t\t\treadLen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException();\n\t\t\t\t}\n\t\t\t\tif (readLen <= 0) {\n\t\t\t\t\tthrow new MyInput.EndOfFileRuntimeException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buffer[pos++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\tint i = 0;\n\t\t\tint ret = 0;\n\t\t\tif (str[0] == '-') {\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t\tfor (; i < len; i++)\n\t\t\t\tret = ret * 10 + str[i] - '0';\n\t\t\tif (str[0] == '-') {\n\t\t\t\tret = -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\tint i = 0;\n\t\t\tlong ret = 0;\n\t\t\tif (str[0] == '-') {\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t\tfor (; i < len; i++)\n\t\t\t\tret = ret * 10 + str[i] - '0';\n\t\t\tif (str[0] == '-') {\n\t\t\t\tret = -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic char nextChar() {\n\t\t\twhile (true) {\n\t\t\t\tfinal int c = read();\n\t\t\t\tif (!isSpace[c]) {\n\t\t\t\t\treturn (char) c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic String nextString() {\n\t\t\treturn new String(nextChars());\n\t\t}\n\n\t\tpublic char[] nextChars() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\treturn Arrays.copyOf(str, len);\n\t\t}\n\n\t\tint reads(int len, boolean[] accept) {\n\t\t\ttry {\n\t\t\t\twhile (true) {\n\t\t\t\t\tfinal int c = read();\n\t\t\t\t\tif (accept[c]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (str.length == len) {\n\t\t\t\t\t\tchar[] rep = new char[str.length * 3 / 2];\n\t\t\t\t\t\tSystem.arraycopy(str, 0, rep, 0, str.length);\n\t\t\t\t\t\tstr = rep;\n\t\t\t\t\t}\n\t\t\t\t\tstr[len++] = (char) c;\n\t\t\t\t}\n\t\t\t} catch (MyInput.EndOfFileRuntimeException e) {\n\t\t\t}\n\t\t\treturn len;\n\t\t}\n\n\t\tpublic int[] nextIntArray(final int n) {\n\t\t\tfinal int[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArray1Index(final int n) {\n\t\t\tfinal int[] res = new int[n + 1];\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArrayDec(final int n) {\n\t\t\tfinal int[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(final int n) {\n\t\t\tfinal long[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray1Index(final int n) {\n\t\t\tfinal long[] res = new long[n + 1];\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArrayDec(final int n) {\n\t\t\tfinal long[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic double[] nextDoubleArray(int n) {\n\t\t\tdouble[] res = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextDouble();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\t}\n\n\t}\n\n}\n", "code2": "d=*1..n=gets.to_i;gets.bytes{|c|x=0;n=d.pop;d.map!{|a|x+=-c%3*n+a*=1-c%3;x%=10**9+7}};p n", "label": 1, "name1": "s819730919.java", "name2": "s760491761.rb"}, {"id": 917, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tString Sa = scanner.next();\n\t\tString Sb = scanner.next();\n\t\tString Sc = scanner.next();\n\n\t\tchar[][] C = new char[3][100];\n\t\tC[0] = Sa.toCharArray();\n\t\tC[1] = Sb.toCharArray();\n\t\tC[2] = Sc.toCharArray();\n\n\t\tint[] t = new int[3];\n\t\tint now = 0;\n\t\tString ans = \"\";\n\t\twhile(true) {\n\t\t\tswitch(C[now][t[now]]) {\n\t\t\tcase 'a':\n\t\t\t\tt[now]++;\n\t\t\t\tnow = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tt[now]++;\n\t\t\t\tnow = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tt[now]++;\n\t\t\t\tnow = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(t[0]==Sa.length()&&now==0) {\n\t\t\t\tans = \"A\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(t[1]==Sb.length()&&now==1) {\n\t\t\t\tans = \"B\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(t[2]==Sc.length()&&now==2) {\n\t\t\t\tans = \"C\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t\tscanner.close();\n\t}\n\n}\n", "code2": "N=gets.to_i\nM=10**9+7\n*F=I=[r=1,t=1]\nR=1,1,*(2..N).map{|i|I<<z=M/i*-I[M%i]%M;F<<r=r*i%M;t=t*z%M}\n(-~N/2...N).each{|i|r-=F[i-1]*R[2*i-N]*F[i]%M}\np r%M\n###############################################\n###############################################\n###############################################\n###############################################\n###############################################", "label": 0, "name1": "s757722337.java", "name2": "s817895786.rb"}, {"id": 397, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String args[]){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tInteger[] num = new Integer[n];\n\t\tStringBuilder s = new StringBuilder(\"\");\n\t\tfor(int i=0;i<n;i++){\n\t\t\tnum[i] = scan.nextInt();\n\t\t}\n\t\tArrays.sort(num);\n\t\t\n\t\ts.append(num[0]);\n\t\tfor(int i=1;i<num.length;i++){\n\t\t\ts.append(\" \"+num[i]);\n\t\t}\n\t\t\n\t\tSystem.out.println(s);\n\t}\n}", "code2": "#!/usr/bin/ruby\n\ni=STDIN.gets\n\nnum = STDIN.gets.split()\nnum.map!{|i| i.to_i}\n\nnum.sort!\n\nputs num.join(\" \")", "label": 1, "name1": "s177932526.java", "name2": "s080700840.rb"}, {"id": 619, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[][] field;\n\tstatic String[][] dp;\n\tstatic int h,w;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = cin.nextInt();\n\t\t\th = cin.nextInt();\n\t\t\tif(w+h==0)break;\n\t\t\tfield=new int[h][w];\n\t\t\tdp=new String[h][w];\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tString s = cin.next();\n\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\tdp[i][j]=\"\";\n\t\t\t\t\tif(Character.isDigit(s.charAt(j))){\n\t\t\t\t\t\tfield[i][j]=s.charAt(j)-'0';\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tfield[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i<w;i++){\n\t\t\t\tif(i==0){\n\t\t\t\t\tif(field[0][i]<=0){\n\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdp[0][i]=\"\"+field[0][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(field[0][i]==-1){\n\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(!dp[0][i-1].equals(\"0\")&&!dp[0][i-1].equals(\"\")){\n\t\t\t\t\t\t\tdp[0][i]=dp[0][i-1]+field[0][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[0][i]=\"\"+field[0][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tif(i==0){\n\t\t\t\t\tif(field[i][0]<=0){\n\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdp[i][0]=\"\"+field[i][0];\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(field[i][0]==-1){\n\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(!dp[i-1][0].equals(\"0\")&&!dp[i-1][0].equals(\"\")){\n\t\t\t\t\t\t\tdp[i][0]=dp[i-1][0]+field[i][0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i][0]=\"\"+field[i][0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tString ans=\"0\";\n\t\t\tfor(int i = 1;i<h;i++){\n\t\t\t\tfor(int j = 1;j<w;j++){\n\t\t\t\t\tif(field[i][j]==-1)continue;\n\t\t\t\t\tString s1=dp[i-1][j]+field[i][j];\n\t\t\t\t\tString s2=dp[i][j-1]+field[i][j];\n\t\t\t\t\tString s3=field[i][j]+\"\";\n\t\t\t\t\tif(big(s1,s2)>=0){\n\t\t\t\t\t\tif(big(s1,s3)>=0){\n\t\t\t\t\t\t\tdp[i][j]=s1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i][j]=s3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(big(s2,s3)>=0){\n\t\t\t\t\t\t\tdp[i][j]=s2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i][j]=s3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\twhile(dp[i][j].charAt(0)=='0'&&dp[i][j].length()>1){\n\t\t\t\t\t\tdp[i][j]=dp[i][j].substring(1,dp[i][j].length());\n\t\t\t\t\t}\n\t\t\t\t\tif(big(dp[i][j],ans)>0){\n\t\t\t\t\t\tans=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\tif(big(dp[i][j],ans)>0){\n\t\t\t\t\t\tans=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//output();\n\t\t\tSystem.out.println(ans);\n\t\t}\n\n\t}\n\tstatic int big(String s1,String s2){\n\t\tif(s1.length()==s2.length()){\n\t\t\treturn s1.compareTo(s2);\n\t\t}\n\t\treturn s1.length()-s2.length();\n\t}\n\tstatic void output(){\n\t\tfor(int i = 0;i<h;i++){\n\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\tSystem.out.print(dp[i][j]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n}", "code2": "N = gets.to_i\nA = gets.split.map(&:to_i).sort\n\nans = A.pop\n(N-2).times do |i|\n  ans += i.odd? ? A.pop : A[-1]\nend\nputs ans", "label": 0, "name1": "s061375468.java", "name2": "s029357848.rb"}, {"id": 299, "code1": "import java.util.*;\npublic class Main {\n\tstatic int yono;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tArrayList<Integer> al = new ArrayList<Integer>();\n\t\tint N = Integer.parseInt(sc.next());\n\t\tyono = N - 1;\n\t\tint M = sc.nextInt();\n\t\ttree = new int[N];\n\t\tArrays.fill(tree, -1);\n\t\tfor (int i = 0; i < M; i++)union(Integer.parseInt(sc.next()) - 1, Integer.parseInt(sc.next()) - 1);\n\t\tSystem.out.println(yono);\n\t}\n\t\n\tstatic int[] tree;\n\tstatic void union(int x, int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif(x != y) {\n\t\t\tyono--;\n\t\t\tif(tree[x] < tree[y]) {\n\t\t\t\tx ^= y; y ^= x; x^= y;\n\t\t\t}\n\t\t\ttree[x] += tree[y];\n\t\t\ttree[y] = x;\n\t\t}\n\t}\n\tstatic boolean find(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tstatic int root(int x) {\n\t\treturn tree[x] < 0 ? x : (tree[x] = root(tree[x]));\n\t}\n}", "code2": "class UnionFind\n\tNode = Struct.new(:p, :h)\n\tdef initialize(size); @p, @r = size.times.to_a, [0]*size; end\n\tdef unite(i, j); k, l = parent(i), parent(j); if @r[k] < @r[l]; @p[k] = l; @r[l] += 1 if @r[k] == @r[l]; else; @p[l] = k; end; end\n\tdef united?(i, j); parent(i) == parent(j); end\n\tdef parent(i); j = i; until i == @p[i]; j, i = i, @p[j] = @p[i]; end; i; end\nend\n\nn, m = gets.split.map &:to_i\nuf = UnionFind.new n\nm.times do\n  a, b = gets.split.map &:to_i\n  uf.unite(a-1, b-1)\nend\n\nrequire \"set\"\ns = Set.new\nn.times do |i|\n  s << uf.parent(i)\nend\n\np s.size-1", "label": 1, "name1": "s179713562.java", "name2": "s827373738.rb"}, {"id": 785, "code1": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tString s;\n\t\t\tString[][] a = new String[n][];\n\t\t\tint p;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\ts = sc.next().replaceAll(\":\", \" \").replaceAll(\",\", \" \");\n\t\t\t\ta[i] = s.split(\" \");\n\t\t\t\tp = a[i].length-1;\n\t\t\t\ta[i][p] = a[i][p].substring(0,a[i][p].length()-1);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<String> list = new ArrayList<String>();\n\t\t\tfor(int i=1;i<a[0].length;i++) list.add(a[0][i]);\n\t\t\t\n\t\t\tboolean flag;\n\t\t\twhile(true){\n\t\t\t\tflag = false;\n\t\t\t\tfor(int i=1;i<n;i++){\n\t\t\t\t\tif(list.contains(a[i][0])==true){\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tlist.remove(list.indexOf(a[i][0]));\n\t\t\t\t\t\tfor(int j=1;j<a[i].length;j++){\n\t\t\t\t\t\t\tif(list.contains(a[i][j])==false) list.add(a[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag==false) break;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(list.size());\n\t\t}\t\n\t}\t\n}", "code2": "eval'*A=#'+`tr ' ' ,`\ns=m=10**9+7\nf=1\np A.sum{f=f*($.+=1)%m\ns+=$..pow m-2,m\n_1*~-s+A[-$.]*s}*f%m", "label": 0, "name1": "s663814901.java", "name2": "s525960042.rb"}, {"id": 993, "code1": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line = br.readLine();\n        char[] alpha = line.toCharArray();\n        int n = alpha.length - 2;\n        int m = n / 2;\n        boolean b = true;\n        while(n != 0) {\n            b = true;\n            for(int i = 0; i < m; i++) {\n                if(alpha[i] != alpha[m + i]) {\n                    b = false;\n                    break;\n                }\n            }\n            if(b) {\n                break;\n            }\n            n = n -2;\n            m = n / 2;\n        }\n        System.out.println(n);\n    }\n}", "code2": "loop do\n  t = gets.to_i\n  break if t==0\n  total=0\n  gets.to_i.times do\n    s,f = gets.split.map(&:to_i)\n    total += s>f ? (24-s)+f : f-s\n  end\n  puts total>=t ? \"OK\" : t-total\nend", "label": 0, "name1": "s226153548.java", "name2": "s703099751.rb"}, {"id": 887, "code1": "/*\n    Arnab Chanda \n*/\n\n// All imports here\n\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n// Template code starts here //\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Debugger debug = new Debugger(out);\n        Objectify objectify = new Objectify(debug);\n        Task solver = new Task();\n        int test = 1;\n        while(test-->0){\n            solver.solve(1, in, out, debug, objectify);\n        }\n\t\tout.close();\n\t}\n}\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n \n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n        tokenizer = null;\n    }\n \n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n \n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    public Double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    public float nextFloat() {\n        return Float.parseFloat(next());\n    }\n \n}\n\nclass Debugger{\n    PrintWriter out;\n\n    Debugger(PrintWriter out){    \n        this.out = out;\n    }\n\n    public <T> void printList(List<T> arrayList){\n        for( Object ob: arrayList){\n            out.print(ob+\" \");\n        }\n        out.println();\n    }\n\n    public <T> void printSet(Set<T> set){\n        for(Object ob: set){\n            out.print(ob+\" \");\n        }\n        out.println();\n    }\n\n    public <T> void printMap(Map<?,?> map){\n        for(Object ob: map.keySet()){\n            System.out.println(ob+\" : \"+map.get(ob));\n        }\n    }\n}\n\nclass Objectify{\n    \n    Debugger debug;\n\n    Objectify(Debugger ob){ debug = ob; }\n\n    public void printArr(int[] arr){ debug.printList(Arrays.stream(arr).boxed().collect(Collectors.toList())); }\n    public void printArr(double[] arr){ debug.printList(Arrays.stream(arr).boxed().collect(Collectors.toList())); }\n    public void printArr(long[] arr){ debug.printList(Arrays.stream(arr).boxed().collect(Collectors.toList())); }\n    public void printArr(char[] arr){ debug.printList( String.valueOf(arr).chars().mapToObj(c -> (char) c).collect(Collectors.toList())); }\n    public void printArr(String[] arr){ debug.printList(Arrays.asList(arr)); }\n\n    public void printMatrix(int[][] arr){ for(int a[]:arr) printArr(a); }\n    public void printMatrix(double[][] arr){ for(double a[]:arr) printArr(a); }\n    public void printMatrix(long[][] arr){ for(long a[]:arr) printArr(a); }\n    public void printMatrix(char[][] arr){ for(char a[]:arr) printArr(a); }\n    public void printMatrix(String[][] arr){ for(String a[]:arr) printArr(a); }\n\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n// Template code ends here\n\n\nclass Task {\n\n    final long MOD = (int)Math.pow(10,9)+7;\n\n    public void solve(int testNumber, InputReader sc, PrintWriter out, Debugger debug, Objectify objectify) {\n        \n        // write your code here\n        int k = sc.nextInt();\n\n        int A = sc.nextInt();\n        int B = sc.nextInt();\n\n        for(int i = A; i <= B; ++i){\n            if (i%k == 0){\n                out.println(\"OK\");\n                return;\n                // break;\n            }\n        }\n\n        out.println(\"NG\");\n    }\n}", "code2": "N,M=gets.split.map(&:to_i)\np (18*M+N)*100*2**M", "label": 0, "name1": "s434750672.java", "name2": "s933045021.rb"}, {"id": 309, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint a=scan.nextInt();\n\t\tint b=scan.nextInt();\n\t\tint c=scan.nextInt();\n\t\tint d=a-b;\n\t\tif(c-d>0) System.out.println(c-d);\n\t\telse System.out.println(\"0\");\n\n\t}\n\n}\n", "code2": "a,b,c=gets.chomp.split.map(&:to_i)\nif c-(a-b)<0\n  puts \"0\"\nelse\n  puts c-(a-b)\nend\n\n", "label": 1, "name1": "s407931652.java", "name2": "s801690691.rb"}, {"id": 17, "code1": "import java.util.*;\n \nclass Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    \n    String s = sc.next();\n    boolean a = true, b = true;\n \n    for(int i=0;i<s.length();i+=2){\n        if(s.charAt(i) == 'L'){\n            a = false;\n            break;\n        }\n    }\n    \n    for(int i=1;i<s.length();i+=2){\n        if (!a){break;}\n        if(s.charAt(i) == 'R'){\n            b = false;\n            break;\n        }\n    }\n    \n    if(a&&b){System.out.println(\"Yes\");}\n    else{System.out.println(\"No\");}\n  }\n}", "code2": "s = gets.chomp.chars\nans = true\ns.size.times do |i|\n  if s[i] == \"R\" && i % 2 != 0\n    ans = false\n    break\n  elsif s[i] == \"L\" && i % 2 == 0\n    ans = false\n    break\n  end\nend\nputs ans ? \"Yes\" : \"No\"\n", "label": 1, "name1": "s301964893.java", "name2": "s697628492.rb"}, {"id": 661, "code1": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\n\tstatic class TaskX {\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tint n = in.nextInt();\n\t\t\tint k = in.nextInt();\n\t\t\tint[] wn = in.nextIntArray(n);\n\n\t\t\tint left = 0;\n\t\t\tint right = INF;\n\t\t\tint mid = 0;\n\t\t\twhile (right > left + 1) {\n\t\t\t\tmid = (left + right) / 2;\n\t\t\t\tint count = 1;\n\t\t\t\tint ca = mid;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (ca - wn[i] >= 0) {\n\t\t\t\t\t\tca -= wn[i];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tca = mid;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tif (ca - wn[i] >= 0) {\n\t\t\t\t\t\t\tca -= wn[i];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcount = INF;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// k\u53f0\u4ee5\u4e0b\u3067\u7a4d\u3081\u308b\u5834\u5408\n\t\t\t\tif (count <= k){\n\t\t\t\t\tright = mid;\n\n\t\t\t\t// \uff4b\u53f0\u4ee5\u4e0a\u5fc5\u8981\u306a\u5834\u5408\n\t\t\t\t} else if (count > k) {\n\t\t\t\t\tleft = mid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout.println(right);\n\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\n\t}\n\n}\n\n", "code2": "s = gets.chomp\nt = gets.chomp\nk = s.length - t.length + 1\ni = 0\nflag = false\nwhile i < k && !flag\n\tcp = s.clone\n\tcp[cp.length-t.length-i,t.length] = t\n\tcheck = true\n\t(cp.length).times do |j|\n\t\tcheck = false if s[j] != cp[j] && s[j] != \"?\"\n\tend\n\tflag = true if check\n\ti += 1\nend\nif flag\n\t(cp.length).times do |j|\n\t\tcp[j] = \"a\" if cp[j] == \"?\"\n\tend\n\tputs cp\nelse\n\tputs \"UNRESTORABLE\"\nend\n", "label": 0, "name1": "s166648431.java", "name2": "s763613339.rb"}, {"id": 30, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tMyInput in = new MyInput(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic long LINF = 1L << 55;\n\tstatic int MOD = 1000000007;\n\tstatic int[] mh4 = { 0, -1, 1, 0 };\n\tstatic int[] mw4 = { -1, 0, 0, 1 };\n\tstatic int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\tstatic int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n\tstatic class TaskX {\n\n\t\tpublic void solve(int testNumber, MyInput in, PrintWriter out) {\n\n\t\t\tint n = in.nextInt();\n\t\t\tlong a = in.nextLong(), b = in.nextLong();\n\t\t\tlong[] x = in.nextLongArray(n);\n\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\t\tans += Math.min(a * (x[i+1] - x[i]), b);\n\t\t\t}\n\t\t\tout.println(ans);\n\n\t\t}\n\t}\n\n\tstatic class MyInput {\n\t\tprivate final BufferedReader in;\n\t\tprivate static int pos;\n\t\tprivate static int readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500 * 8 * 2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic {\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tisDigit['0' + i] = true;\n\t\t\t}\n\t\t\tisDigit['-'] = true;\n\t\t\tisSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n\t\t\tisLineSep['\\r'] = isLineSep['\\n'] = true;\n\t\t}\n\n\t\tpublic MyInput(InputStream is) {\n\t\t\tin = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (pos >= readLen) {\n\t\t\t\tpos = 0;\n\t\t\t\ttry {\n\t\t\t\t\treadLen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException();\n\t\t\t\t}\n\t\t\t\tif (readLen <= 0) {\n\t\t\t\t\tthrow new MyInput.EndOfFileRuntimeException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buffer[pos++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\tint i = 0;\n\t\t\tint ret = 0;\n\t\t\tif (str[0] == '-') {\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t\tfor (; i < len; i++)\n\t\t\t\tret = ret * 10 + str[i] - '0';\n\t\t\tif (str[0] == '-') {\n\t\t\t\tret = -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\tint i = 0;\n\t\t\tlong ret = 0;\n\t\t\tif (str[0] == '-') {\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t\tfor (; i < len; i++)\n\t\t\t\tret = ret * 10 + str[i] - '0';\n\t\t\tif (str[0] == '-') {\n\t\t\t\tret = -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic char nextChar() {\n\t\t\twhile (true) {\n\t\t\t\tfinal int c = read();\n\t\t\t\tif (!isSpace[c]) {\n\t\t\t\t\treturn (char) c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic String nextString() {\n\t\t\treturn new String(nextChars());\n\t\t}\n\n\t\tpublic char[] nextChars() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\treturn Arrays.copyOf(str, len);\n\t\t}\n\n\t\tpublic char[][] next2DChars(int h, int w) {\n\t\t\tchar[][] s = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\ts[i] = nextChars();\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\n\t\tint reads(int len, boolean[] accept) {\n\t\t\ttry {\n\t\t\t\twhile (true) {\n\t\t\t\t\tfinal int c = read();\n\t\t\t\t\tif (accept[c]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (str.length == len) {\n\t\t\t\t\t\tchar[] rep = new char[str.length * 3 / 2];\n\t\t\t\t\t\tSystem.arraycopy(str, 0, rep, 0, str.length);\n\t\t\t\t\t\tstr = rep;\n\t\t\t\t\t}\n\t\t\t\t\tstr[len++] = (char) c;\n\t\t\t\t}\n\t\t\t} catch (MyInput.EndOfFileRuntimeException e) {\n\t\t\t}\n\t\t\treturn len;\n\t\t}\n\n\t\tpublic int[] nextIntArray(final int n) {\n\t\t\tfinal int[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArray1Index(final int n) {\n\t\t\tfinal int[] res = new int[n + 1];\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArrayDec(final int n) {\n\t\t\tfinal int[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(final int n) {\n\t\t\tfinal long[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray1Index(final int n) {\n\t\t\tfinal long[] res = new long[n + 1];\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArrayDec(final int n) {\n\t\t\tfinal long[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic double[] nextDoubleArray(int n) {\n\t\t\tdouble[] res = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextDouble();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\t}\n\n\t}\n\n}\n", "code2": "\nn,a,b = gets.split.map(&:to_i)\nx = gets.split.map(&:to_i)\n\ncost = 0\nlast = x[0]\n\n(1...n).each{|i|\n    if (x[i]-last)*a < b\n        cost += (x[i]-last)*a\n    else\n        cost += b\n    end\n    last = x[i]\n}\n\np cost\n", "label": 1, "name1": "s004356600.java", "name2": "s273635362.rb"}, {"id": 670, "code1": "import java.util.*;\n \nclass Main{\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n \n        String S = sc.next();\n        String T = sc.next();\n        int ls = S.length();\n        int lt = T.length();\n        String a = \"?\";\n\n        if(ls<lt){\n            System.out.println(\"UNRESTORABLE\");\n            return;\n        }\n        int x = -1;\n        for(int i=0; i<=ls-lt; i++){\n            if(S.charAt(i)==T.charAt(0) || S.charAt(i)==a.charAt(0)){\n                for(int j=0; j<lt; j++){\n                    if(S.charAt(i+j)!=T.charAt(j) && S.charAt(i+j)!=a.charAt(0)){\n                        break;\n                    }\n                    if(j==lt-1){\n                        x = i;\n                    }\n                }\n            }\n        }\n        if(x==-1){\n            System.out.println(\"UNRESTORABLE\");\n            return;\n        }\n        else if(ls==lt){\n            S = T;\n            System.out.println(S);\n            return;\n        }\n        else if(x==0){\n            S = T + S.substring(lt);\n        }\n        else if(x!=0){\n            if(x+lt-1==ls){\n                S = S.substring(0, x) + T;\n            }\n            else{\n                S = S.substring(0, x) + T + S.substring(x + lt);\n            }\n        }\n        String st = \"\";\n        for(int i=0; i<ls; i++){\n            if(S.charAt(i)==a.charAt(0)){\n                st += \"a\";\n            }\n            else{\n                st += String.valueOf((char)S.charAt(i));\n            }\n        }\n        System.out.println(st);\n    }\n}", "code2": "imput = gets.chomp.split(\" \")\n#puts imput\na = imput[0].to_i\nb = imput[1].to_i\nc = imput[2].to_i\nk = imput[3].to_i\n#puts a,b,c,k\nif (a >= k) then\n    puts k\nelse\n    if (a + b >= k) then\n        puts a\n    else\n        puts (a - (k-a-b))\n        #puts k\n    end\nend\n  ", "label": 0, "name1": "s748827885.java", "name2": "s251719998.rb"}, {"id": 464, "code1": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t// \u5165\u529b\n\t\tint n = sc.nextInt();\n\t\tGraph g = new Graph(n, false);\n\t\tfor(int i = 0; i < n-1; i++){\n\t\t    int a = sc.nextInt() - 1;\n\t\t    int b = sc.nextInt() - 1;\n\t\t    g.add(a, b);\n\t\t}\n\t\t\n\t\t// \u8a08\u7b97\n\t\tString result = \"Snuke\";\n\t\tlong[] distFromB = g.dijkstra(0);\n\t\tlong[] distFromW = g.dijkstra(n-1);\n\t\tint cnt = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t    if(distFromB[i] <= distFromW[i]) cnt++;\n\t\t}\n\t\tif(cnt > (n-cnt)) result = \"Fennec\";\n\t\t\n\t\t// \u51fa\u529b\n\t\tSystem.out.println(result);\n\t}\n\n}\n\nclass Graph {\n\tint n;\n\tboolean directed;\n\tArrayList<Edge>[] adjList;\n\tint m;\n\tlong[] dist;\n\tlong[][] distWF;\n\tint start;\n\tint[] prev;\n\tArrayList<Integer> path;\n\tlong INF = 1001001001001001001L;\n\n\tpublic Graph (int n, boolean directed) {\n\t\tthis.n = n;\n\t\tthis.m = 0;\n\t\tthis.directed = directed;\n\t\tthis.adjList = new ArrayList[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tadjList[i] = new ArrayList<Edge>();\n\t\t}\n\t}\n\t\n\tpublic void add(int from, int to) {\n\t\tadd(from, to, 1);\n\t}\n\tpublic void add(int from, int to, int w) {\n\t\tadjList[from].add(new Edge(from, to, w));\n\t\tthis.m++;\n\t\tif(!directed){\n\t\t\tadjList[to].add(new Edge(to, from, w));\n\t\t\tthis.m++;\n\t\t}\n\t}\n\t\n\tpublic long[] bfs(int start) { // O(M)\n\t\tthis.start = start;\n\t\tthis.prev = new int[n];\n\t\tArrays.fill(prev, -1);\n\t\tprev[start] = start;\n\t\tthis.dist = new long[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[start] = 0;\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tq.add(start);\n\t\twhile(!q.isEmpty()){\n\t\t\tint now = q.poll();\n\t\t\tfor(Edge e : adjList[now]){\n\t\t\t\tif(dist[e.to] != INF) continue;\n\t\t\t\tdist[e.to] = dist[now] + e.w;\n\t\t\t\tprev[e.to] = now;\n\t\t\t\tq.add(e.to);\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\t\n\tpublic long[] dijkstra(int start) { // O(MlogM)\n\t\tthis.start = start;\n\t\tthis.prev = new int[n];\n\t\tArrays.fill(prev, -1);\n\t\tprev[start] = start;\n\t\tthis.dist = new long[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[start] = 0;\n\t\tPriorityQueue<Vertex> q = new PriorityQueue<Vertex>((x, y) -> Long.compare(x.distance, y.distance));\n\t\tq.add(new Vertex(start, 0));\n\t\twhile(!q.isEmpty()){\n\t\t\tVertex now = q.poll();\n\t\t\tif(now.distance > dist[now.id]) continue; \n\t\t\tfor(Edge e : adjList[now.id]){\n\t\t\t\tlong newDist = now.distance + e.w;\n\t\t\t\tif(dist[e.to] <= newDist) continue;\n\t\t\t\tdist[e.to] = newDist;\n\t\t\t\tprev[e.to] = now.id;\n\t\t\t\tq.add(new Vertex(e.to, newDist));\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\t\n\tpublic long[][] wf() { // O(N^3)\n\t\tthis.distWF = new long[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tArrays.fill(distWF[i], INF);\n\t\t\tdistWF[i][i] = 0;\n\t\t}\n\t\tfor(ArrayList<Edge> list : adjList){\n\t\t\tfor(Edge e : list){\n\t\t\t\tdistWF[e.from][e.to] = e.w;\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < n; k++){\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tdistWF[i][j] = min(distWF[i][j], distWF[i][k] + distWF[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn distWF;\n\t}\n\t\n\tpublic boolean bf(int start) { // O(NM)\n\t\tthis.start = start;\n\t\tthis.prev = new int[n];\n\t\tArrays.fill(prev, -1);\n\t\tprev[start] = start;\n\t\tthis.dist = new long[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[start] = 0;\n\t\tboolean hasNegativeLoop = false;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tfor(Edge e : adjList[j]){\n\t\t\t\t\tif(dist[e.to] <= dist[e.from] + e.w) continue;\n\t\t\t\t\tdist[e.to] = dist[e.from] + e.w;\n\t\t\t\t\tprev[e.to] = e.from;\n\t\t\t\t\tif(i == n-1) hasNegativeLoop = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn hasNegativeLoop;\n\t}\n\t\n\tpublic ArrayList<Integer> pathTo(int to){\n\t\tthis.path = new ArrayList<Integer>();\n\t\treturn pathToRec(to);\n\t}\n\t\n\tprivate ArrayList<Integer> pathToRec(int to){\n\t\tif(to != start) pathToRec(prev[to]);\n\t\tpath.add(to);\n\t\treturn path;\n\t}\n\t\n\tpublic String toString(){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(ArrayList<Edge> list : adjList){\n\t\t\tfor(Edge e : list){\n\t\t\t\tsb.append(e.toString());\n\t\t\t\tsb.append(\"\\n\");\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tpublic String distToString(){\n\t\tif(dist != null) return Arrays.toString(dist);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(distWF[i][j] == INF){\n\t\t\t\t\tsb.append(\"from:\" + i + \" to:\" + j + \" dist:INF\" + \"\\n\");\n\t\t\t\t}else{\n\t\t\t\t\tsb.append(\"from:\" + i + \" to:\" + j + \" dist:\" + distWF[i][j] + \"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tclass Edge {\n\t\tint from;\n\t\tint to;\n\t\tint w;\n\t\t\n\t\tEdge(int from, int to, int w){\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.w = w;\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"from:\" + from + \" to:\" + to + \" w:\" + w;\n\t\t}\n\t}\n\t\n\tclass Vertex {\n\t\tint id;\n\t\tlong distance;\n\t\t\n\t\tVertex(int id, long distance){\n\t\t\tthis.id = id;\n\t\t\tthis.distance = distance;\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"id:\" + id + \" distance:\" + distance;\n\t\t}\n\t}\n}\n", "code2": "n = gets.chomp.to_i\ntree = Array.new(n)\nn.times { |i| tree[i] = [] }\n(n - 1).times do\n  a, b = gets.chomp.split(' ').map { |i| i.to_i - 1 }\n  tree[a] << b\n  tree[b] << a\nend\n\ndistances = Array.new(n, 100001)\nqueue = [0]\nvisited = Hash.new(false)\ndistance = 0\nuntil queue.empty?\n  length = queue.length\n  length.times do\n    q = queue.shift\n    next if visited[q]\n    visited[q] = true\n    distances[q] = distance\n    tree[q].each do |t|\n      next if visited[t]\n      queue << t\n    end\n  end\n  distance += 1\nend\n\nroute = [n - 1]\ncurrent = n - 1\nwhile route.first != 0 do\n  tree[current].each do |i|\n    if distances[current] - distances[i] == 1\n      current = i\n      route.unshift(i)\n      break\n    end\n  end\nend\n\nstart_index = route.length % 2 == 0 ? (route.length / 2) - 1 : route.length / 2\nstart = route[start_index]\nclose = route[start_index + 1]\ntree[start].delete(close)\nqueue = [start]\nvisited = Hash.new(false)\nfennec_count = 0\nuntil queue.empty?\n  q = queue.pop\n  next if visited[q]\n  visited[q] = true\n  fennec_count += 1\n  tree[q].each do |t|\n    next if visited[t]\n    queue << t\n  end\nend\n\nputs fennec_count > n - fennec_count ? 'Fennec' : 'Snuke'", "label": 1, "name1": "s816087530.java", "name2": "s449655546.rb"}, {"id": 119, "code1": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\t\n\tpublic static void main(String[] args) {\n\t\tFastScanner scanner=new FastScanner();\n\t\tint n=scanner.nextInt(),k=scanner.nextInt();\n\t\tint a[]=scanner.readArray(n);\n\t\t\n\t\tboolean dp[]=new boolean[k+1];\n//\t\tArrays.fill(dp, true);\n//\t\tdp[0]=false;\n\t\t\n\t\tfor(int stones=0;stones<=k;stones++) {\n\t\t\tfor(int j:a)\n\t\t\t\tif(j<=stones&&!dp[stones-j]) dp[stones]=true;\n\t\t}\n\t\tif(dp[k]) System.out.println(\"First\");\n\t\telse System.out.println(\"Second\");\n\t\n\t\t\n\t\t\n\n\t}\n\tstatic class FastScanner{\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\t\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tdouble nextDoubel() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tint [] readArray(int n) {\n\t\t\tint a[]=new int[n];\n\t\t\tfor(int i=0;i<n;i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\t\n\t}\n\n}\n\n", "code2": "eval\"(*D),K,*A=\"+`dd`.split*?,;puts D[K.times{D<<A.none?{D[-_1]}}]?:Second: :First", "label": 1, "name1": "s041813111.java", "name2": "s954498434.rb"}, {"id": 624, "code1": "import java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint a = scan.nextInt();\n\t\tint b = scan.nextInt();\n\t\tscan.close();\n\t\tint ans = 12;\n\t\tif(b >= a) {\n\t\t\tans = a;\n\t\t}else {\n\t\t\tans = a - 1;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n", "code2": "n=gets.to_i\nT=gets.split.map &:to_i\nA=gets.split.map &:to_i\nX=[0]*n\nc=0\na=1\nn.times{|i|\n  if T[i]!=c\n    X[i] = 1\n    a=0 if T[i]>A[i]\n  end\n  c=T[i]\n}\nY=[0]*n\nc=0\n(n-1).downto(0){|i|\n  if A[i]!=c\n    Y[i] = 1\n    a=0 if T[i]<A[i]\n  end\n  c=A[i]\n}\nn.times{|i|\n  if X[i]+Y[i]<1\n    a *= [T[i],A[i]].min\n    a %= 10**9+7\n  end\n}\np a", "label": 0, "name1": "s648355489.java", "name2": "s894245225.rb"}, {"id": 226, "code1": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\t\n\tint n;\n\tint[][] es;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\tes = new int[n][n];\n\t\tfor (int[] a: es) fill(a, INF);\n\t\tfor (int i=0;i<n;i++) es[i][i] = 0;\n\t\tfor (int i=0;i<n;i++) {\n\t\t\tint r = sc.nextInt()-1, k = sc.nextInt();\n\t\t\tfor (int j=0;j<k;j++) {\n\t\t\t\tint t = sc.nextInt()-1;\n\t\t\t\tes[r][t] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int k=0;k<n;k++) for (int i=0;i<n;i++) for (int j=0;j<n;j++) {\n\t\t\tes[i][j] = min(es[i][j], es[i][k] + es[k][j]);\n\t\t}\n\t\tint p = sc.nextInt();\n\t\tfor (int i=0;i<p;i++) {\n\t\t\tint s = sc.nextInt()-1, d = sc.nextInt()-1, v = sc.nextInt();\n\t\t\tSystem.out.println((es[s][d] + 1 <= v ? es[s][d] + 1 : \"NA\"));\n\t\t}\n\t}\n\t\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}", "code2": "def g;gets.split.map &:to_i;end\nr=1..n=g[0]\nw=[0]+r.map{[0]+[1e9]*n}\nr.map{f,_,*t=g;t.map{|i|w[f][i]=1}}\nr.each{|k|r.each{|i|r.each{|j|(a=(b=w[i])[k]+w[k][j])<b[j]&&b[j]=a}}}\ng[0].times{s,d,v=g;puts v<(c=w[s][d]+1)?:NA:c}", "label": 1, "name1": "s834155894.java", "name2": "s754069394.rb"}, {"id": 48, "code1": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic long LINF = 1L << 55;\n\tstatic int MOD = 1000000007;\n\tstatic int[] mh4 = { 0, -1, 1, 0 };\n\tstatic int[] mw4 = { -1, 0, 0, 1 };\n\tstatic int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\tstatic int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n\tstatic class TaskX {\n\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tint n = in.nextInt();\n\t\t\tint[] a = in.nextIntArray(n);\n\n\t\t\tint count = 0;\n\n\t\t\tfor (int l = 0, r = 0; l < n; l = r) {\n\t\t\t\twhile (r < n && a[l] == a[r]) {\n\t\t\t\t\tr++;\n\t\t\t\t}\n\t\t\t\tint len = r-l;\n\t\t\t\tcount += len/2;\n\t\t\t}\n\n\t\t\tout.println(count);\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\t}\n\n}\n", "code2": "def main(argv)\n  n = gets.chomp.to_i\n  a = gets.chomp.split(' ').map(&:to_i)\n\n  as = [[]]\n  prev = a[0]\n  n.times do |i|\n    if prev != a[i] then\n      as.push([a[i]])\n      prev = a[i]\n    else\n      as[as.size - 1].push(a[i])\n    end\n  end\n  \n  puts as.map{|a| a.size / 2}.reduce(:+).to_s\nend\n\nif self.to_s == 'main' then\n  main(ARGV)\nend", "label": 1, "name1": "s729269653.java", "name2": "s355654198.rb"}, {"id": 172, "code1": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t\n\tint cmp (String p1, String p2) {\n\t\tif( p1.length() != p2.length() ) return p2.length() - p1.length();\n\t\treturn p2.compareTo(p1);\n\t}\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif((w|h) == 0 ) break;\n\t\t\t\n\t\t\tString[][] dp = new String[h+1][w+1];\n\t\t\tString pass = \"\";\n\t\t\tchar[][] map = new char[h+1][w+1];\n\t\t\t\n\t\t\tfor(String[] a: dp) fill(a, \"\");\n\t\t\t\n\t\t\tfor(int i=1;i<=h;i++) {\n\t\t\t\tString str = sc.next();\n\t\t\t\tfor(int j=1;j<=w;j++) {\n\t\t\t\t\tmap[i][j] = str.charAt(j-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=1;i<=h;i++) for(int j=1;j<=w;j++) {\n\t\t\t\tif( '0' <= map[i][j] && map[i][j] <= '9' ) {\n\t\t\t\t\tif( map[i][j] == '0' && dp[i-1][j].equals(\"\") && dp[i][j-1].equals(\"\") ) continue;\n\t\t\t\t\tdp[i][j] = ( cmp(dp[i-1][j], dp[i][j-1])<0? dp[i-1][j]: dp[i][j-1] ) + (char)map[i][j];\n\t\t\t\t}\n\t\t\t\tpass = cmp(pass, dp[i][j])<0? pass: dp[i][j];\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(pass);\n\t\t\t\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}", "code2": "$x=0\n$y=0\n$bord = []\n$cnt = 0\n\n\ndef calc()\n\n\tmax = 0\n\tfor i in 0..$x-1\n\t\tfor j in 0..$y-1\n\t\t\tif $bord[j][i] != -1 then\n\t\t\t\tif j > 0 then\n\t\t\t\t\tup = $bord[j-1][i]\n\t\t\t\telse\n\t\t\t\t\tup = -1\n\t\t\t\tend\n\t\t\t\n\t\t\t\tif i > 0 then\n\t\t\t\t\tleft = $bord[j][i-1]\n\t\t\t\telse\n\t\t\t\t\tleft = -1\n\t\t\t\tend\n\n\t\t\t\n\t\t\t\tif up > left and up != -1 then\n\t\t\t\t\t$bord[j][i] += up * 10\n\t\t\t\t\t\n\t\t\t\telsif left != -1 then\n\t\t\t\t\t$bord[j][i] += left * 10\n\t\t\t\tend\n\t\t\t\tif $bord[j][i] > max then\n\t\t\t\t\tmax = $bord[j][i]\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn max\nend\n\t\nloop{\n\tline = gets\n\tif line==nil then\n\t\tbreak\n\tend\n\tsp = line.split(nil)\n\t\n\tif sp.count() != 2 then\n\t\tbreak\n\telse\n\t\t$x = sp[0].to_i()\n\t\t$y = sp[1].to_i()\n\t\tif $x == 0 and $y == 0 then\n\t\t\tbreak\n\t\tend\n\t\t\n\t\tsx = 0\n\t\tsy = 0\n\t\t$cnt = 1 \n\t\t$bord = Array.new($y).map{Array.new($x,0)}\n\t\tfor i in 0..$y-1\n\t\t\tline = gets\n\t\t\tfor j in 0..$x-1\n\t\t\t\ttmp = -1\n\t\t\t\tif line[j] =~ /\\d/ then\n\t\t\t\t\ttmp = line[j].to_i() \n\t\t\t\tend\n\t\t\t\t$bord[i][j] = tmp\n\t\t\tend\n\t\tend\n\t\tprint calc()\n\t\tprint(\"\\n\")\n\tend\n}", "label": 1, "name1": "s246113848.java", "name2": "s033677438.rb"}, {"id": 676, "code1": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Random;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        try (BufferedInputStream in = new BufferedInputStream(System.in);\n             PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out))) {\n\n            _Scanner sc = new _Scanner(in);\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            int c = sc.nextInt();\n            int k = sc.nextInt();\n\n            if (a + b >= k) {\n                out.println(Math.min(k, a));\n            } else {\n                out.println(a - (k - a - b));\n            }\n        }\n    }\n\n    private static void reverse(int[] vs) {\n        for (int i = 0; i < vs.length / 2; i++) {\n            swap(vs, i, vs.length - 1 - i);\n        }\n    }\n\n    static class _Scanner {\n        InputStream is;\n        _Scanner(InputStream is) {\n            this.is = is;\n        }\n        byte[] bb = new byte[1 << 15];\n        int k, l;\n        byte getc() {\n            try {\n                if (k >= l) {\n                    k = 0;\n                    l = is.read(bb);\n                    if (l < 0) return -1;\n                }\n                return bb[k++];\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        byte skip() {\n            byte b;\n            while ((b = getc()) <= 32)\n                ;\n            return b;\n        }\n\n        int nextInt() {\n            int n = 0;\n            int sig = 1;\n            for (byte b = skip(); b > 32; b = getc()) {\n                if (b == '-') {\n                    sig = -1;\n                } else {\n                    n = n * 10 + b - '0';\n                }\n            }\n            return sig * n;\n        }\n\n        long nextLong() {\n            long n = 0;\n            long sig = 1;\n            for (byte b = skip(); b > 32; b = getc()) {\n                if (b == '-') {\n                    sig = -1;\n                } else {\n                    n = n * 10 + b - '0';\n                }\n            }\n            return sig * n;\n        }\n\n        public String next() {\n            StringBuilder sb = new StringBuilder();\n            for (int b = skip(); b > 32; b = getc()) {\n                sb.append(((char) b));\n            }\n            return sb.toString();\n        }\n    }\n\n    private static void shuffle(int[] ar) {\n        Random rnd = new Random();\n        for (int i = 0; i < ar.length; i++) {\n            int j = i + rnd.nextInt(ar.length - i);\n            swap(ar, i, j);\n        }\n    }\n\n    private static void shuffle(Object[] ar) {\n        Random rnd = new Random();\n        for (int i = 0; i < ar.length; i++) {\n            int j = i + rnd.nextInt(ar.length - i);\n            swap(ar, i, j);\n        }\n    }\n\n    private static void swap(int[] ar, int i, int j) {\n        int t = ar[i];\n        ar[i] = ar[j];\n        ar[j] = t;\n    }\n\n    private static void swap(Object[] ar, int i, int j) {\n        Object t = ar[i];\n        ar[i] = ar[j];\n        ar[j] = t;\n    }\n\n\n}\n", "code2": "require 'scanf'\nwhile true\ninput = scanf(\"%d %d\")\nn = input[0];\nx = input[1];\nif n == 0 && x == 0\nbreak\nend\ncnt = 0\nfor r in 1...n+1\nfor c in r + 1...n+1\nfor f in c + 1...n+1\nif r + c + f == x\ncnt += 1\nend\nend\nend\nend\nputs cnt\nend", "label": 0, "name1": "s673107340.java", "name2": "s364906499.rb"}, {"id": 242, "code1": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\n\tstatic class TaskX {\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tint n = in.nextInt();\n\t\t\tint k = in.nextInt();\n\t\t\tint[] wn = in.nextIntArray(n);\n\n\t\t\tint left = 0;\n\t\t\tint right = INF;\n\t\t\tint mid = 0;\n\t\t\twhile (right > left + 1) {\n\t\t\t\tmid = (left + right) / 2;\n\t\t\t\tint count = 1;\n\t\t\t\tint ca = mid;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (ca - wn[i] >= 0) {\n\t\t\t\t\t\tca -= wn[i];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tca = mid;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tif (ca - wn[i] >= 0) {\n\t\t\t\t\t\t\tca -= wn[i];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcount = INF;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// k\u53f0\u4ee5\u4e0b\u3067\u7a4d\u3081\u308b\u5834\u5408\n\t\t\t\tif (count <= k){\n\t\t\t\t\tright = mid;\n\n\t\t\t\t// \uff4b\u53f0\u4ee5\u4e0a\u5fc5\u8981\u306a\u5834\u5408\n\t\t\t\t} else if (count > k) {\n\t\t\t\t\tleft = mid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout.println(right);\n\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\n\t}\n\n}\n\n", "code2": "k=gets.split[1].to_i\nw=$<.map &:to_i\np (w.max..10**9).bsearch{|i|s=0;w.count{|j|(s+=j)>i&&s=j}<k}", "label": 1, "name1": "s166648431.java", "name2": "s169809774.rb"}, {"id": 103, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tdouble a = sc.nextDouble();\n\t\tdouble b = sc.nextDouble();\n\t\tdouble C = sc.nextDouble();\n\t\t\n\t\tdouble S = 0.5*a*b*Math.sin(Math.toRadians(C));\n\t\tdouble c = Math.sqrt(Math.pow(a, 2)+Math.pow(b, 2)-(2*a*b*Math.cos(Math.toRadians(C))));\n\t\tdouble L = a + b + c;\n\t\tdouble h = 2*S / a;\n\t\t\n\t\tSystem.out.println(S);\n\t\tSystem.out.println(L);\n\t\tSystem.out.println(h);\n\n\t}\n}", "code2": "inputs = gets.strip.split(\" \").map{|i| i.to_f}\na, b, c = inputs[0], inputs[1], inputs[2]\nrad_c = (Math::PI / 180.0) * c \nd = Math.sqrt(a**2 + b**2 - 2*a*b*Math.cos(rad_c))\ns = 0.5 * a * b * Math.sin(rad_c)\nl = a + b + d\nh = 2*s / a\nputs s.floor(4)\nputs l.floor(4)\nputs h.floor(4)\n", "label": 1, "name1": "s501686962.java", "name2": "s843747761.rb"}, {"id": 151, "code1": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String args[]) {\n\tScanner sc = new Scanner(System.in);\n\n\twhile (true) {\n\t    int n = sc.nextInt();\n\t    int ans = 0;\n\t    if (n == 0) {\n\t\tbreak;\n\t    }\n\t    \n\t    ans = solve(n);\n\t    System.out.println(ans);\n\t}\n    }\n\n    public static int solve(int n) {\n\t//int max = 123456 * 2;\n\t//int prime[] = new prime[123456 * 2 + 1];\n\tboolean is_prime[] = new boolean[123456 * 2 + 1];\n\tint count = 0;\n\n\t//int p = 0;\n\tfor (int i = 0; i <= 2 * n; i++) {\n\t    is_prime[i] = true;\n\t}\n\n\tis_prime[0] = is_prime[1] = false;\n\tfor (int i = 2; i <= 2 * n; i++) {\n\t    if (is_prime[i]) {\n\t\t// prime[p++] = i;\n\t\tfor (int j = 2 * i; j <= 2 * n; j += i) {\n\t\t    is_prime[j] = false;\n\t\t}\n\t    }\n\t}\n\tfor (int i = n + 1; i <= 2 * n; i++) {\n\t    if (is_prime[i]) {\n\t\tcount++;\n\t    }\n\t}\n\t\n\treturn count;\n    }\n}", "code2": "require \"prime\"\n\nuntil (n = gets.to_i).zero?\n  puts Prime.each(2 * n).to_a.count{ |i| n < i }\nend", "label": 1, "name1": "s027703193.java", "name2": "s242670642.rb"}, {"id": 314, "code1": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        // \u6574\u6570\u306e\u5165\u529b\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        int c = sc.nextInt();\n        // \u51fa\u529b\n        int o = c-a+b;\n        System.out.println(o > 0 ? o : 0);\n    }\n}", "code2": "A, B, C = gets.split.map(&:to_i)\n\nputs [0, C - (A - B)].max\n", "label": 1, "name1": "s598978529.java", "name2": "s037386852.rb"}, {"id": 716, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[] total = new int[3];\n\n\t\ttotal[0] = sc.nextInt();\n\t\ttotal[1] = sc.nextInt();\n\t\ttotal[2] = sc.nextInt();\n\n\t\tsc.close();\n\n\t\tArrays.sort(total);\n\n\t\tSystem.out.println(total[0] + total[1]);\n\t}\n}", "code2": "s = gets.chomp\n\ndef merge(s, t)\n  r = \"\"\n  t.size.times{|i| r += s[i].to_s + t[i].to_s }\n  r += s[(t.size)..-1]\n  r\nend\n\np (0...(2 ** (s.size - 1))).to_a.map {|i|\n  ss = s.clone\n  f = i.to_s(2).rjust(s.size - 1, '0').gsub(/1/, '+').gsub(/0/, ' ')\n  eval(merge(ss, f).gsub(/\\s/, ''))\n}.inject(&:+)", "label": 0, "name1": "s443302375.java", "name2": "s812495641.rb"}, {"id": 644, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[] fact = new int[9];\n\n\n\tpublic static void main(String[] args) {\n\t\tfact[1] = 1;\n\t\tfor(int i = 2; i <= 8; i++)\n\t\t\tfact[i] = fact[i-1] * i;\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] p = new int[n];\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tp[i] = sc.nextInt();\n\n\t\tint[] q = new int[n];\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tq[i] = sc.nextInt();\n\n\t\tint ans = Math.abs(getPosi(p) - getPosi(q));\n\t\tSystem.out.println(ans);\n        return;\n    }\n\n\tstatic private int getPosi(int[] x) {\n\n\t\t\tint l = x.length;\n\t\t\tint p = 1;\n\n\t\t\tfor(int i = 0; i < l; i++) {\n\t\t\t\tp += fact[l-i-1] * (x[i]-1);\n\t\t\t\tfor(int j = i+1; j < l; j++) {\n\t\t\t\t\tif(x[j] > x[i])\n\t\t\t\t\t\tx[j]--;\n\t\t\t\t}\n\t\t\t}\n\t\treturn p;\n\n\t}\n\n}\n\n", "code2": "Infinity = 1000000\n\ndef floydwarshall graph\n  n = graph.size\n  dist = Array.new(n).map{Array.new(n, Infinity)}\n  n.times do |i|\n    dist[i][i] = 0\n  end\n  n.times do |i|\n    graph[i].each do |edge|\n      dist[i][edge] = 1\n    end\n  end\n\n  n.times do |k|\n    n.times do |u|\n      n.times do |v|\n        newPop = dist[u][k] + dist[k][v]\n        if newPop < dist[u][v]\n          dist[u][v] = newPop\n        end\n      end\n    end\n  end\n  dist\nend\n\n#\u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u53d6\u5f97\nn = $stdin.gets.to_i\ngraph = Array.new(n).map{Array.new}\nn.times do\n  input = $stdin.gets.split(\" \").map(&:to_i)\n  input[1].times do |t|\n    graph[input[0] - 1] << input[t + 2] - 1\n  end\nend\n\ndist = floydwarshall graph\n\n#\u30d1\u30b1\u30c3\u30c8\u51e6\u7406\n$stdin.gets.to_i.times do\n  s, d, v = $stdin.gets.split(\" \").map(&:to_i)\n  if dist[s - 1][d - 1] + 1 <= v\n    puts dist[s - 1][d - 1] + 1\n  else\n    puts \"NA\"\n  end\nend", "label": 0, "name1": "s530732207.java", "name2": "s930752392.rb"}, {"id": 44, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Optional;\nimport java.util.OptionalDouble;\nimport java.util.stream.DoubleStream;\nimport java.util.stream.Stream;\n\npublic class Main {\n\n  public static void main(String[] args) throws IOException {\n    \n    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {\n\n      String line;\n      String[] lines;\n      double[] s;\n      while( !(line = br.readLine()).equals(\"0\") ){\n\n        int n = Integer.parseInt(line);\n        lines = br.readLine().split(\" \");\n\n        s =\n          Stream.of(lines)\n            .mapToDouble(Double::parseDouble)\n            .toArray();\n        \n        double dm =\n          Arrays.stream(s)\n            .average()\n          .getAsDouble();\n\n        double result =\n        Arrays.stream(s)\n          .map(d -> Math.pow((d-dm),2) / n)\n          .sum();\n\n        System.out.printf(\"%.8f\\n\" , Math.sqrt(result));\n      }\n    }\n  }\n}\n", "code2": "loop do\n  n = gets.to_i\n  break if n == 0\n\n  scores = readline.split.map(&:to_i)\n  average = scores.inject(:+).to_f / n\n  variance = scores.inject(0.0) {|sum, s| sum += (s - average) ** 2 } / n\n  standard_deviation = Math.sqrt(variance)\n  p standard_deviation\nend", "label": 1, "name1": "s757478171.java", "name2": "s767854055.rb"}, {"id": 307, "code1": "import java.io.*;\nimport java.util.StringTokenizer;\n\npublic final class Main{\n    public static void main(String[] args){\n        FastScanner stdIn = new FastScanner(System.in);\n        long a = stdIn.nextLong();\n        long b = stdIn.nextLong();\n        long c = stdIn.nextLong();\n\n        if(c-(a-b)<0){\n            System.out.println(0);\n        }else{\n            System.out.println(c-(a-b));\n        }\n    }\n}\n\nclass FastScanner {\n    private BufferedReader reader = null;\n    private StringTokenizer tokenizer = null;\n\n    public FastScanner(InputStream in) {\n        reader = new BufferedReader(new InputStreamReader(in));\n        tokenizer = null;\n    }\n\n    public String next() {\n        if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public String nextLine() {\n        if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        return tokenizer.nextToken(\"\\n\");\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n    \n    public long nextInt() {\n        return Integer.parseInt(next());\n    }\n\n}\n", "code2": "a,b,c=gets.chomp.split.map(&:to_i)\nif c-(a-b)<0\n  puts \"0\"\nelse\n  puts c-(a-b)\nend\n\n", "label": 1, "name1": "s641134227.java", "name2": "s801690691.rb"}, {"id": 88, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tblood_groups();\n\t}\n\n\tprivate static void blood_groups() {\n\t\tint[] bg = new int[4];\n\n\t\twhile (sc.hasNext()) {\n\t\t\tString[] datas = sc.nextLine().split(\",\");\n\n\t\t\tswitch( datas[1] ) {\n\t\t\tcase \"A\":\n\t\t\t\tbg[0]++;\n\t\t\t\tbreak;\n\t\t\tcase \"B\":\n\t\t\t\tbg[1]++;\n\t\t\t\tbreak;\n\t\t\tcase \"AB\":\n\t\t\t\tbg[2]++;\n\t\t\t\tbreak;\n\t\t\tcase \"O\":\n\t\t\t\tbg[3]++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(bg[0]);\n\t\tSystem.out.println(bg[1]);\n\t\tSystem.out.println(bg[2]);\n\t\tSystem.out.println(bg[3]);\n\n\t}\n\n}\n\n", "code2": "h=Hash.new(0)\n$<.map{|l|h[l.strip.split(?,)[1]]+=1}\np h[?A],h[?B],h[\"AB\"],h[?O]", "label": 1, "name1": "s776356865.java", "name2": "s836086969.rb"}, {"id": 269, "code1": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Random;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        try (BufferedInputStream in = new BufferedInputStream(System.in);\n             PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out))) {\n\n            _Scanner sc = new _Scanner(in);\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            int c = sc.nextInt();\n            int k = sc.nextInt();\n\n            if (a + b >= k) {\n                out.println(Math.min(k, a));\n            } else {\n                out.println(a - (k - a - b));\n            }\n        }\n    }\n\n    private static void reverse(int[] vs) {\n        for (int i = 0; i < vs.length / 2; i++) {\n            swap(vs, i, vs.length - 1 - i);\n        }\n    }\n\n    static class _Scanner {\n        InputStream is;\n        _Scanner(InputStream is) {\n            this.is = is;\n        }\n        byte[] bb = new byte[1 << 15];\n        int k, l;\n        byte getc() {\n            try {\n                if (k >= l) {\n                    k = 0;\n                    l = is.read(bb);\n                    if (l < 0) return -1;\n                }\n                return bb[k++];\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        byte skip() {\n            byte b;\n            while ((b = getc()) <= 32)\n                ;\n            return b;\n        }\n\n        int nextInt() {\n            int n = 0;\n            int sig = 1;\n            for (byte b = skip(); b > 32; b = getc()) {\n                if (b == '-') {\n                    sig = -1;\n                } else {\n                    n = n * 10 + b - '0';\n                }\n            }\n            return sig * n;\n        }\n\n        long nextLong() {\n            long n = 0;\n            long sig = 1;\n            for (byte b = skip(); b > 32; b = getc()) {\n                if (b == '-') {\n                    sig = -1;\n                } else {\n                    n = n * 10 + b - '0';\n                }\n            }\n            return sig * n;\n        }\n\n        public String next() {\n            StringBuilder sb = new StringBuilder();\n            for (int b = skip(); b > 32; b = getc()) {\n                sb.append(((char) b));\n            }\n            return sb.toString();\n        }\n    }\n\n    private static void shuffle(int[] ar) {\n        Random rnd = new Random();\n        for (int i = 0; i < ar.length; i++) {\n            int j = i + rnd.nextInt(ar.length - i);\n            swap(ar, i, j);\n        }\n    }\n\n    private static void shuffle(Object[] ar) {\n        Random rnd = new Random();\n        for (int i = 0; i < ar.length; i++) {\n            int j = i + rnd.nextInt(ar.length - i);\n            swap(ar, i, j);\n        }\n    }\n\n    private static void swap(int[] ar, int i, int j) {\n        int t = ar[i];\n        ar[i] = ar[j];\n        ar[j] = t;\n    }\n\n    private static void swap(Object[] ar, int i, int j) {\n        Object t = ar[i];\n        ar[i] = ar[j];\n        ar[j] = t;\n    }\n\n\n}\n", "code2": "a, b, c, k = gets.split(\" \").map(&:to_i)\nans = [a, k].min\nk -= a if k > a\nk -= b if k > 0\nans -= [k, c].min if k > 0\nputs ans\n", "label": 1, "name1": "s673107340.java", "name2": "s814519680.rb"}, {"id": 777, "code1": "import java.math.BigInteger;\nimport java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = Integer.parseInt(sc.next());\n\t\tlong m = Long.parseLong(sc.next());\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tm = lcm(m, Long.parseLong(sc.next()));\n\t\tSystem.out.println(m);\n\t}\n\tpublic static long lcm(long m, long n) {\n\t\tBigInteger M = new BigInteger(String.valueOf(m));\n\t\tBigInteger N = new BigInteger(String.valueOf(n));\n\t\tBigInteger G = new BigInteger(String.valueOf(gcd(m, n)));\n\t\treturn M.multiply(N).divide(G).longValue();\n\t}\n\tpublic static long gcd(long m, long n) {\n\t\tif (m < n) {\n\t\t\tlong tem = m;\n\t\t\tm = n;\n\t\t\tn = tem;\n\t\t}\n\t\tlong r = -1;\n\t\twhile (r != 0) {\n\t\t\tr = m % n;\n\t\t\tm = n;\n\t\t\tn = r;\n\t\t}\n\t\treturn m;\n\t}\n}", "code2": "def fold arr\n    arr2 = []\n    arr.each{|name|\n        if @h.key? name\n            @h[name] = fold(@h[name])\n            @h[name].each{|name2| arr2 << name2}\n        else\n            arr2 << name\n        end\n    }\n    arr2.uniq!\n    arr2\nend\n\nwhile true\n    n = gets.to_i\n    break if n == 0\n    @h = Hash.new{|h, k| h[k] = []}\n    firstgroup = nil\n    n.times{|i|\n        group, members = (gets.chomp)[0..-2].split(\":\")\n        members = members.split(\",\")\n        @h[group] = members\n        firstgroup = group if i == 0\n    }\n    puts fold(@h[firstgroup]).length\nend\n", "label": 0, "name1": "s725061223.java", "name2": "s533876771.rb"}, {"id": 787, "code1": "import java.util.*;\n\npublic class Main {\n\tpublic static HashMap<String,HashSet<String>> map;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tmap = new HashMap<String, HashSet<String>>();\n\t\t\tString first = null;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tString[] s = sc.next().split(\":\");\n\t\t\t\tif(i == 0) first = s[0];\n\t\t\t\ts[1] = s[1].replaceAll(\"\\\\.\", \"\");\n\t\t\t\tString[] ss = s[1].split(\",\");\n\t\t\t\tmap.put(s[0], new HashSet<String>());\n\t\t\t\tfor(String tmp : ss){\n\t\t\t\t\tmap.get(s[0]).add(tmp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(String si : map.keySet()){\n\t\t\t\tfor(String sj : map.keySet()){\n\t\t\t\t\tif(map.get(si).contains(sj)){\n\t\t\t\t\t\tmap.get(si).remove(sj);\n\t\t\t\t\t\tmap.get(si).addAll(map.get(sj));\n\t\t\t\t\t}\n\t\t\t\t\tif(map.get(sj).contains(si)){\n\t\t\t\t\t\tmap.get(sj).remove(si);\n\t\t\t\t\t\tmap.get(sj).addAll(map.get(si));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(map.get(first).size());\n\t\t}\n\t}\n/*\n\tpublic static HashSet<String> solve(String group){\n\t\tfor(String s : map.get(group)){\n\n\t\t}\n\n\t}\n\t*/\n}", "code2": "eval'*A=#'+`tr ' ' ,`\ni=f=1\ns=m=10**9+7\np A.sum{f=f*i%m\ns+=i.pow m-2,m\n_1*~-s+A[1-i+=1]*s}*f%m", "label": 0, "name1": "s038642140.java", "name2": "s721063213.rb"}, {"id": 709, "code1": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        // \u6574\u6570\u306e\u5165\u529b\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        int c = sc.nextInt();\n        // \u51fa\u529b\n        int o = c-a+b;\n        System.out.println(o > 0 ? o : 0);\n    }\n}", "code2": "# coding: utf-8\nlines = $stdin.read\narray = lines.split(\"\\n\")\n\na = array[0].split(\" \")[0].to_i\nb = array[0].split(\" \")[1].to_i\nc = array[0].split(\" \")[2].to_i\n\nab = a+b\nbc = b+c\nca = c+a\n\narr = [ab, bc, ca].sort\n\nputs arr[0]\n", "label": 0, "name1": "s598978529.java", "name2": "s342762132.rb"}, {"id": 629, "code1": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\n\nimport static java.util.Comparator.reverseOrder;\n\npublic class Main {\n\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n\n        List<Long> inputList = new ArrayList<Long>();\n        for(int i = 0; i < n ;i++) {\n            inputList.add(sc.nextLong());\n        }\n\n        /*\n        List<Integer> sortedList = inputList.stream().sorted(reverseOrder()).collect(Collectors.toList());\n        for(int a: sortedList) {\n            System.out.println(a);\n        }\n        */\n        List<Long> sortedList = inputList.stream().sorted(reverseOrder()).collect(Collectors.toList());\n        long result = sortedList.get(0);\n        int index = 1;\n        int count = 0;\n        for (int i = 0; i < n - 2 ; i++) {\n            result += sortedList.get(index);\n            count = count + 1;\n            if (count == 2) {\n                count = 0;\n                index = index + 1;\n            }\n        }\n        System.out.println(result);\n    }\n}", "code2": "t = a = 1\ngets.to_i.times{\n\tu, b = gets.split.map(&:to_i)\n\tm = (u<t || b<a) ? [(t+u-1)/u, (a+b-1)/b].max : 1\n\tt, a = u*m, b*m\n}\np t+a\n", "label": 0, "name1": "s542407178.java", "name2": "s565416710.rb"}, {"id": 931, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tint n;\n\tlong mo = 1_000_000_000 + 7;\n\tlong[] fac = new long[3000000];\n\tlong[] ifac = new long[3000000];\n\tlong[] inv = new long[3000000];\n\t{\n\t\tfac[0] = 1;\n\t\tfor (int i = 1; i < fac.length; ++i) {\n\t\t\tfac[i] = i * fac[i - 1] % mo;\n\t\t}\n\t\tinv[1] = 1;\n\t\tfor (int i = 2; i < inv.length; ++i) {\n\t\t\tinv[i] = mo - inv[(int) (mo % i)] * (mo / i) % mo;\n\t\t}\n\t\tifac[0] = 1;\n\t\tfor (int i = 1; i < ifac.length; ++i) {\n\t\t\tifac[i] = ifac[i - 1] * inv[i] % mo;\n\t\t}\n\t}\n\n\tlong comb(int n, int k) {\n\t\treturn fac[n] * ifac[n - k] % mo * ifac[k] % mo;\n\t}\n\n\tlong g(int k) {\n\t\tif (2 * k < n)\n\t\t\treturn 0;\n\t\tint a = 2 * k - n;\n\t\tint b = n - k;\n\t\treturn comb(a - 1 + b, b - 1) * fac[k] % mo * fac[n - 1 - k] % mo;\n\t}\n\n\tlong f(int k) {\n\t\treturn (g(k) - g(k - 1) + mo) % mo;\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner();\n\t\tn = (int) sc.nextLong();\n\t\tlong ans = 0;\n\t\tfor (int i = (n + 1) / 2; i <= n - 1; ++i) {\n\t\t\tans = (ans + f(i) * i % mo) % mo;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tlong pow(long a, long n) {\n\t\tlong ret = 1;\n\t\tfor (; n > 0; n >>= 1, a = a * a % mo) {\n\t\t\tif (n % 2 == 1) {\n\t\t\t\tret = ret * a % mo;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tlong inv(long a) {\n\t\treturn pow(a, mo - 2);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tclass Scanner {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[ptr++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isPrintableChar(int c) {\n\t\t\treturn 33 <= c && c <= 126;\n\t\t}\n\n\t\tprivate void skipUnprintable() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\t\tptr++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskipUnprintable();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n}\n", "code2": "eval\"N,*A=\"+`dd`.split*?,;p (0..2*N).bsearch{|x,*y|N.times{|i|[-1,1].map{|s|A[j=N-1+i*s]>x==A[j+s]&.>(x)&&y<<=A[j]<=x}};y[0]}", "label": 0, "name1": "s980347613.java", "name2": "s661607401.rb"}, {"id": 52, "code1": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt(), result = 0, combo = 0, color = 0;\n        for (int i = 0; i < n; i++) {\n            int j = scanner.nextInt();\n            combo++;\n\n            if (j != color) {\n                result += combo / 2;\n                combo = 0;\n                color = j;\n            }\n        }\n        System.out.println(result + ++combo / 2);\n    }\n}", "code2": "a, b = $stdin.read.split(\"\\n\")\nb = b.split(\" \").map{|c| c.to_i}\na = a.to_i\nresult = 0\ni = 1\nloop do\n  break if i-1 >= a - 1\n  a1 = b[i-1]\n  a2 = b[i]\n  a3 = b[i+1]\n  if a1 == a2 || a3 == a2\n    if a1 == a2 && a1 == a2\n      b[i] = b[i] + 1\n      result += 1\n    elsif a1 == a2\n      b[i] = b[i+1] +  1\n      result += 1\n    elsif a2 == a3\n      b[i+1] = a2+b[i+2]\n      result += 1\n    end\n  end\n  i+=2\nend\nputs result", "label": 1, "name1": "s379654146.java", "name2": "s480254051.rb"}, {"id": 961, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[]args) {\n\t\ttry(Scanner scan = new Scanner(System.in)){\n\n\t\t\tint N = scan.nextInt();\n\t\t\tint M = scan.nextInt();\n\t\t\tint K = scan.nextInt();\n\n\n\n\t\t\tint goukei = 0;\n\t\t\tint ok = 0;\n\t\t\tfor(int i = 0;i<=N;i++) {\n\t\t\t\tfor(int j = 0;j<=M;j++) {\n\t\t\t\t\tgoukei =  i*M+j*N-2*i*j;\n\t\t\t\t\tif(goukei==K) {\n\t\t\t\t\t\tok=1;break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(ok==1)System.out.println(\"Yes\");\n\t\t\telse System.out.println(\"No\");\n\n\t\t}\n\n\n\t}\n\n\n}\n", "code2": "n = gets.to_i\nas = gets.split(\" \").map(&:to_i)\nbs = gets.split(\" \").map(&:to_i)\ncs = gets.split(\" \").map(&:to_i)\n\nas.sort!\ncs.sort!\n\ncount = 0\nbs.each do |b|\n  a_i = as.bsearch_index{|a| b <= a}\n  c_i = cs.bsearch_index{|c| b < c}\n  if !a_i\n    a_i = n\n  end\n  if c_i\n    count += a_i * (n - c_i)\n  end\nend\n\nputs count", "label": 0, "name1": "s703141884.java", "name2": "s635818491.rb"}, {"id": 964, "code1": "\npublic class Main {\n\n\n  private static void solve() {\n    int N = ni();\n    int C = ni();\n    int[][] D = ntable(C, C);\n    int[][] c = ntable(N, N);\n\n    int[][] dp = new int[C][3];\n    for (int i = 0; i < C; i++) {\n      for (int x = 0; x < N; x++) {\n        for (int y = 0; y < N; y++) {\n          dp[i][(x + y) % 3] += D[c[x][y] - 1][i];\n        }\n      }\n    }\n\n    int min = Integer.MAX_VALUE;\n    for (int i = 0; i < C; i++) {\n      for (int j = 0; j < C; j++) {\n        if (i == j)\n          continue;\n        for (int k = 0; k < C; k++) {\n          if (i == k || j == k)\n            continue;\n\n          int now = dp[i][0] + dp[j][1] + dp[k][2];\n          min = Math.min(now, min);\n        }\n      }\n    }\n    System.out.println(min);\n  }\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n", "code2": "n = gets.to_i\nas = gets.split(\" \").map(&:to_i)\nbs = gets.split(\" \").map(&:to_i)\ncs = gets.split(\" \").map(&:to_i)\n\nas.sort!\ncs.sort!\n\ncount = 0\nbs.each do |b|\n  a_i = as.bsearch_index{|a| b <= a}\n  c_i = cs.bsearch_index{|c| b < c}\n  if !a_i\n    a_i = n\n  end\n  if c_i\n    count += a_i * (n - c_i)\n  end\nend\n\nputs count", "label": 0, "name1": "s175876855.java", "name2": "s635818491.rb"}, {"id": 851, "code1": "import java.util.*;\npublic class Main {\n\tpublic static void doIt(){\n\t\tScanner in = new Scanner(System.in);\n\t\tdata pp[][] = new data[3][8];\n\t\tfor(int i=0;i<3;i++){\n\t\t\tfor(int s=0;s<8;s++){\n\t\t\t\tint ban=in.nextInt();\n\t\t\t\tdouble time=in.nextDouble();\n\t\t\t\tpp[i][s]=new data(ban,time);\n\t\t\t}\n\t\t\tArrays.sort(pp[i]);\n\t\t}\n\t\tfor(int i=0;i<3;i++){\n\t\t\tSystem.out.printf(\"%d %.2f\\n\",pp[i][0].code,pp[i][0].time);\n\t\t\tSystem.out.printf(\"%d %.2f\\n\",pp[i][1].code,pp[i][1].time);\n\t\t}\n\t\tdata ans[]=new data[18];\n\t\tint cnt=0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tfor(int s=2;s<8;s++){\n\t\t\t\tans[cnt]=pp[i][s];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tArrays.sort(ans);\n\t\tSystem.out.printf(\"%d %.2f\\n\",ans[0].code,ans[0].time);\n\t\tSystem.out.printf(\"%d %.2f\\n\",ans[1].code,ans[1].time);\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain.doIt();\n\t}\n\tstatic class data implements Comparable<data>{\n\t\tint code;\n\t\tdouble time;\n\t\tdata(int code,double time){\n\t\t\tthis.code=code;\n\t\t\tthis.time=time;\n\t\t}\n\t\tpublic int compareTo(data o) {\n\t\t\treturn Double.compare(this.time,o.time);//\u3053\u308c\u3067\u6bd4\u3079\u3089\u308c\u308b\u3002\n\t\t}\n\t}\n}", "code2": "n,m=gets.chomp.split(' ').map(&:to_i)\narr = []\nm.times do\n    arr << gets.chomp.split(' ')\nend\nhash = {}\narr.each do |a|\n    if hash[a[0].to_i].nil?\n        hash[a[0].to_i] = [a]\n    else\n        hash[a[0].to_i] << a\n    end \nend\nans = [0,0]\nhash.keys.each do |h|\n    wa_num = 0\n    hash[h].each do |t|\n        if t[1]==\"AC\"\n            ans[1] += wa_num \n            ans[0]+=1\n            break\n        else\n            wa_num += 1\n        end\n    end\nend\nputs ans.join(' ')", "label": 0, "name1": "s614656631.java", "name2": "s336890329.rb"}, {"id": 893, "code1": "import java.io.*;\nimport java.lang.*;\nimport java.util.Scanner;\nimport java.util.Arrays;\nimport java.util.ArrayList;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint i;\n\t\tfor(i = 0; i < 1000; i++){\n\t\t\tSystem.out.println(\"Hello World\");\n\t\t}\n\t}\n}", "code2": "require 'prime'\n\nbase = gets.to_i\nans = Prime.find {|p| p >= base }\nputs ans", "label": 0, "name1": "s933848138.java", "name2": "s724728663.rb"}, {"id": 494, "code1": "import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        int A = scan.nextInt();\n        int B = scan.nextInt();\n        int C = scan.nextInt();\n        if(A == B && A== C){\n            System.out.println(\"No\");\n        }\n        else if(A == B || A == C || B == C){\n            System.out.println(\"Yes\");\n        }\n        else{\n            System.out.println(\"No\");\n        }\n    }\n}", "code2": "A, B, C = gets.split(' ').map(&:to_i)\nif A == B and B == C\n  puts 'No' \nelsif A == B or B == C or A == C\n  puts 'Yes'\nelse\n  puts 'No'\nend", "label": 1, "name1": "s236930555.java", "name2": "s700176714.rb"}, {"id": 987, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] d = in.nextIntArray(n);\n            int ans = 0;\n            LOOP:\n            for (int i = 24; i >= 0; i--) {\n                boolean[] vis = new boolean[n];\n                int[] time = new int[n + 1];\n                for (int j = 0; j < n; j++) {\n                    int idx = -1, t = 1 << 29;\n                    for (int k = 0; k < n; k++) {\n                        for (int r = 0; r < 2; r++) {\n                            int cur = r == 0 ? d[k] : 24 - d[k];\n                            if (!vis[k] && cur >= time[j] + i && (idx == -1 || cur < t)) {\n                                idx = k;\n                                t = cur;\n                                break;\n                            }\n                        }\n                    }\n                    if (idx == -1) continue LOOP;\n                    vis[idx] = true;\n                    time[j + 1] = t;\n                }\n                if ((24 - time[n]) % 24 >= i) {\n                    ans = i;\n                    break;\n                }\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        public int[] nextIntArray(final int n) {\n            final int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt();\n            }\n            return res;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n", "code2": "S = gets.chomp\nputs (S.size / 2 - 1).downto(1).find{|len| S[0,len] == S[len,len] } * 2\n", "label": 0, "name1": "s643732585.java", "name2": "s181959324.rb"}, {"id": 793, "code1": "import java.io.*;\nimport java.util.*;\n\n/**\n *\n * @author baito\n */\nclass UnionFindTree\n{\n    int[] par;\n    int[] rank;\n    int[] sizes;\n\n    UnionFindTree(int n)\n    {\n        par = new int[n];\n        rank = new int[n];\n        sizes = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            par[i] = i;\n            rank[i] = 0;\n            sizes[i] = 1;\n        }\n    }\n\n    int find(int x)\n    {\n        if (par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n\n    void unite(int x, int y)\n    {\n        x = find(x);\n        y = find(y);\n\n        if (x == y) return;\n        if (rank[x] < rank[y])\n        {\n            par[x] = y;\n            sizes[y] += sizes[x];\n        }\n        else\n        {\n            par[y] = x;\n            sizes[x] += sizes[y];\n            if (rank[x] == rank[y]) rank[x]++;\n        }\n    }\n\n    boolean same(int x, int y)\n    {\n        return find(x) == find(y);\n    }\n\n    int size(int x)\n    {\n        return sizes[par[x]];\n    }\n}\npublic class Main\n{\n    static StringBuilder sb = new StringBuilder();\n    static FastScanner sc = new FastScanner(System.in);\n    static int INF = 10000;\n    static long MOD =1000000007;\n    static long[] f;//factorial\n    static int[] y4 = {0,1,0,-1};\n    static int[] x4 = {1,0,-1,0};\n    static int[] y8 = {0,1,0,-1,-1,1,1,-1};\n    static int[] x8 = {1,0,-1,0,1,-1,1,-1};\n\n    static int N,K,L;\n\n    public static void main(String[] args)\n    {\n\n        N = sc.nextInt();\n        K = sc.nextInt();\n        L = sc.nextInt();\n        UnionFindTree u1 = new UnionFindTree(N);\n        UnionFindTree u2 = new UnionFindTree(N);\n        //long\u3092\u5fd8\u308c\u308b\u306a\u30aa\u30fc\u30d0\u30fc\u30d5\u30ed\u30fc\u3059\u308b\u305e\n        for (int i = 0; i < K; i++)\n        {\n            int p = sc.nextInt()-1;\n            int q = sc.nextInt()-1;\n            u1.unite(p,q);\n        }\n        for (int i = 0; i < L; i++)\n        {\n            int p = sc.nextInt()-1;\n            int q = sc.nextInt()-1;\n            u2.unite(p,q);\n        }\n        Map<Long,Integer> sizes = new HashMap<>();\n        for (int i = 0; i < N; i++)\n        {\n            long root1 = u1.find(i);\n            long root2 = u2.find(i);\n            long hash = root1 * 1000000L + root2;\n            int value = sizes.containsKey(hash) ? sizes.get(hash):0;\n            sizes.put(hash,value+1);\n\n\n        }\n        for (int i = 0; i < N; i++)\n        {\n            long root1 = u1.find(i);\n            long root2 = u2.find(i);\n            long hash = root1 * 1000000L + root2;\n            System.out.println(sizes.get(hash));\n        }\n\n\n\n    }\n    //\u2193nCr\u3092mod\u8a08\u7b97\u3059\u308b\u305f\u3081\u306b\u5fc5\u8981\u3002\u3000***factorial(N)\u3092\u547c\u3076\u5fc5\u8981\u304c\u3042\u308b***\n    static long comb(int n, int r)\n    {\n        long result = f[n];\n        result = result * modInv(f[n - r]) % MOD;\n        result = result * modInv(f[r]) % MOD;\n        return result;\n    }\n\n    static long modInv(long n)\n    {\n        return modPow(n, MOD - 2);\n    }\n\n    static void factorial(int n)\n    {\n        f = new long[n + 1];\n        f[0] = f[1] = 1;\n        for (int i = 2; i <= n; i++)\n        {\n            f[i] = (f[i - 1] * i) % MOD;\n        }\n    }\n\n    static long modPow(long x, long n)\n    {\n        long res = 1L;\n        while (n > 0)\n        {\n            if ((n & 1) == 1)\n            {\n                res = res * x % MOD;\n            }\n            x = x * x % MOD;\n            n >>= 1;\n        }\n        return res;\n    }\n\n    //\u2191nCr\u3092mod\u8a08\u7b97\u3059\u308b\u305f\u3081\u306b\u5fc5\u8981\n\n    static int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n    static long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\n    static <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n    static void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n    public static void reverse(int[] x)\n    {\n        int l = 0;\n        int r = x.length - 1;\n        while (l < r)\n        {\n            int temp = x[l];\n            x[l] = x[r];\n            x[r] = temp;\n            l++;\n            r--;\n        }\n    }\n    public static void reverse(int[] x,int s, int e)\n    {\n        int l = s;\n        int r = e;\n        while (l < r)\n        {\n            int temp = x[l];\n            x[l] = x[r];\n            x[r] = temp;\n            l++;\n            r--;\n        }\n    }\n    static int length(int a) {int cou = 0; while(a != 0){ a /= 10; cou++; } return cou;}\n    static int length(long a) {int cou = 0; while(a != 0){ a /= 10; cou++; } return cou;}\n    static int countC2(char[][] a, char c){\n        int co = 0;\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[0].length; j++)\n                if(a[i][j] == c)\n                    co++;\n        return co;\n    }\n    static void fill(int[][] a, int v){\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[0].length; j++)\n                a[i][j] = v;\n    }\n    static class FastScanner {\n\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        public String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        /*public String nextChar(){\n            return (char)next()[0];\n        }*/\n        public String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n        public int [][] nextIntArray2(int h, int w){\n            int[][] a = new int[h][w];\n            for(int hi = 0 ; hi < h ; hi++){\n                for(int wi = 0 ; wi < w ; wi++){\n                    a[hi][wi] = nextInt();\n                }\n            }\n            return a;\n        }\n        public Integer[] nextIntegerArray(int n) {\n            Integer[] a = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n        public char[] nextCharArray(int n){\n            char[] a = next().toCharArray();\n\n            return a;\n        }\n        public char[][] nextCharArray2(int h , int w){\n            char[][] a = new char[h][w];\n            for (int i = 0; i < h; i++) {\n                a[i] = next().toCharArray();\n            }\n            return a;\n        }\n        //\u30b9\u30da\u30fc\u30b9\u304c\u5165\u3063\u3066\u3044\u308b\u5834\u5408\n        public char[][] nextCharArray2s(int h , int w){\n            char[][] a = new char[h][w];\n            for (int i = 0; i < h; i++) {\n                a[i] = nextLine().replace(\" \",\"\").toCharArray();\n            }\n            return a;\n        }\n        public char[][] nextWrapCharArray2(int h , int w, char c){\n            char[][] a = new char[h + 2][w + 2];\n            //char c = '*';\n            int i;\n            for (i = 0; i < w + 2; i++)\n                a[0][i] = c;\n            for (i = 1; i < h + 1; i++) {\n                a[i] = (c + next() + c).toCharArray();\n            }\n            for (i = 0; i < w + 2; i++)\n                a[h + 1][i] = c;\n            return a;\n        }\n        //\u30b9\u30da\u30fc\u30b9\u304c\u5165\u3063\u3066\u308b\u6642\u7528\n        public char[][] nextWrapCharArray2s(int h , int w ,char c){\n            char[][] a = new char[h + 2][w + 2];\n            //char c = '*';\n            int i;\n            for (i = 0; i < w + 2; i++)\n                a[0][i] = c;\n            for (i = 1; i < h + 1; i++) {\n                a[i] = (c + nextLine().replace(\" \",\"\") + c).toCharArray();\n            }\n            for (i = 0; i < w + 2; i++)\n                a[h + 1][i] = c;\n            return a;\n        }\n        public long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextLong();\n            }\n            return a;\n        }\n        public long [][] nextLongArray2(int h, int w){\n            long[][] a = new long[h][w];\n            for(int hi = 0 ; hi < h ; hi++){\n                for(int wi = 0 ; wi < h ; wi++){\n                    a[h][w] = nextLong();\n                }\n            }\n            return a;\n        }\n    }\n}\n", "code2": "require \"date\"\narr = Array.new\nuntil (line = gets) == \"0 0\\n\"\n  arr << line\nend\narr.each do |i|\n  a = i.split(\" \")\n  a.map!{|j| j.to_i}\n  m = a[0]\n  d = a[1]\n  wday = [\"Sunday\",\n          \"Monday\",\n          \"Tuesday\",\n          \"Wednesday\",\n          \"Thursday\",\n          \"Friday\",\n          \"Saturday\"]\n  day = Date::new(2004, m, d)\n  puts wday[day.wday]\nend", "label": 0, "name1": "s138073781.java", "name2": "s152498090.rb"}, {"id": 60, "code1": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        try(Scanner scn = new Scanner(System.in)) {\n            int sum = scn.nextInt() + scn.nextInt() + scn.nextInt() + scn.nextInt();\n            System.out.println(sum / 60);\n            System.out.println(sum % 60);\n        }\n    }\n}", "code2": "n=0\n4.times do\n  n+=gets.chomp.to_i\nend\n\np n/60\np n%60", "label": 1, "name1": "s061388848.java", "name2": "s834558089.rb"}, {"id": 508, "code1": "import java.util.*;\n \nclass Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    \n    String s = sc.next();\n    boolean a = true, b = true;\n \n    for(int i=0;i<s.length();i+=2){\n        if(s.charAt(i) == 'L'){\n            a = false;\n            break;\n        }\n    }\n    \n    for(int i=1;i<s.length();i+=2){\n        if (!a){break;}\n        if(s.charAt(i) == 'R'){\n            b = false;\n            break;\n        }\n    }\n    \n    if(a&&b){System.out.println(\"Yes\");}\n    else{System.out.println(\"No\");}\n  }\n}", "code2": "h, w = gets.chomp.split.map(&:to_i)\nif (h == 1 || w == 1 )\n  puts \"1\"\nelse\n  puts \"#{(h * w / 2.0).round}\"\nend\n", "label": 0, "name1": "s301964893.java", "name2": "s520164559.rb"}, {"id": 923, "code1": "import java.util.*;\n\npublic class Main {    \n    \n  public static void main(String[] args) {              \n     Scanner sc = new Scanner(System.in);\n     \n     int N = sc.nextInt();\n     \n     int sum = 0;\n     int min = Integer.MAX_VALUE;\n     \n     int count = 0;\n     for(int i = 0;i < N;i++){\n         int a = sc.nextInt();\n         if(a%10 == 0){\n               count++;\n         }\n         sum += a;\n         if(a%10 != 0){\n           min = Math.min(min,a);\n         }\n     }\n     \n     if(count == N){\n         System.out.println(0);\n         return;\n     }     \n                           \n     if(sum%10 != 0){\n         System.out.println(sum);\n         return;\n     }else{\n         System.out.println(sum - min);\n         return;\n     }\n      \n  }          \n}", "code2": "h,w = gets.split.map(&:to_i)\na = Array.new(h){ gets.chomp }\n\nseen = Array.new(h){ Array.new(w){ false } }\nDX = [ 0, 1, 0,-1, 1,-1, 1,-1]\nDY = [ 1, 0,-1, 0, 1,-1,-1, 1]\ninside = -> y, x { 0 <= y && y < h && 0 <= x && x < w }\n\nbfs = -> sy,sx do\n  que = [[sy,sx]]\n  black = 0\n  white = 0\n  while que.size > 0\n    y,x = que.pop\n    next if seen[y][x]\n    seen[y][x] = true\n    a[y][x] == \"#\" ? black += 1 : white += 1\n    4.times do |i|\n      ny = y + DY[i]\n      nx = x + DX[i]\n      next unless inside[ny,nx]\n      next if a[y][x] == a[ny][nx] # \u540c\u3058\u8272\u306a\u3089\u5bfe\u8c61\u5916\n      que << [ny,nx]\n    end\n  end\n  return black * white\nend\n\nans = 0\nh.times do |y|\n  w.times do |x|\n    ans += bfs[y,x]\n  end\nend\nputs ans", "label": 0, "name1": "s839075233.java", "name2": "s014943683.rb"}, {"id": 650, "code1": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\t\n\tint n;\n\tint[][] es;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\tes = new int[n][n];\n\t\tfor (int[] a: es) fill(a, INF);\n\t\tfor (int i=0;i<n;i++) es[i][i] = 0;\n\t\tfor (int i=0;i<n;i++) {\n\t\t\tint r = sc.nextInt()-1, k = sc.nextInt();\n\t\t\tfor (int j=0;j<k;j++) {\n\t\t\t\tint t = sc.nextInt()-1;\n\t\t\t\tes[r][t] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int k=0;k<n;k++) for (int i=0;i<n;i++) for (int j=0;j<n;j++) {\n\t\t\tes[i][j] = min(es[i][j], es[i][k] + es[k][j]);\n\t\t}\n\t\tint p = sc.nextInt();\n\t\tfor (int i=0;i<p;i++) {\n\t\t\tint s = sc.nextInt()-1, d = sc.nextInt()-1, v = sc.nextInt();\n\t\t\tSystem.out.println((es[s][d] + 1 <= v ? es[s][d] + 1 : \"NA\"));\n\t\t}\n\t}\n\t\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}", "code2": "n, k = gets.split( \" \" ).map { |val| val.to_i }\nw = []\nmaxW = sumW = 0\nn.times {\n\tnum = gets.to_i\n\tsumW += num\n\tw.push( num )\n}\nmaxW = w.max\n\nminP = 0\nif 1 == k\n\tminP = sumW\nelsif n == k\n\tminP = maxW\nelse\n\tleft = maxW\n\tright = 100000*10000\n\twhile left <= right\n\t\tmiddle = ( left+right ).div( 2 )\n\t\ttruckCnt = i = loadings = 0\n\n\t\twhile i < n\n\t\t\tloadings += w[i]\n\t\t\tif middle < loadings\n\t\t\t\ttruckCnt += 1\n\t\t\t\tbreak if k < truckCnt+1\n\t\t\t\tloadings = w[i]\n\t\t\tend\n\t\t\ti += 1\n\t\tend\n\t\t( minP = middle ) if truckCnt+1 <= k\n\t\t\n\t\tif k < truckCnt+1\n\t\t\tleft = middle + 1\t\t\n\t\telse\n\t\t\tright = middle - 1\n\t\tend\n\tend\nend\n\nputs( minP )", "label": 0, "name1": "s834155894.java", "name2": "s250378227.rb"}, {"id": 854, "code1": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String... args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        ArrayList<Integer> list = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            list.add(scanner.nextInt());\n        }\n        list.sort((val1, val2) -> val1 - val2);\n        int b = list.get(0);\n        for (int i = 1; i < list.size(); i++) {\n            int a = list.get(i);\n            int r = a % b;\n            while (r != 0) {\n                a = b;\n                b = r;\n                r = a % b;\n            }\n        }\n        System.out.println(b);\n    }\n}", "code2": "n,m=gets.chomp.split(' ').map(&:to_i)\narr = []\nm.times do\n    arr << gets.chomp.split(' ')\nend\nhash = {}\narr.each do |a|\n    if hash[a[0].to_i].nil?\n        hash[a[0].to_i] = [a]\n    else\n        hash[a[0].to_i] << a\n    end \nend\nans = [0,0]\nhash.keys.each do |h|\n    wa_num = 0\n    hash[h].each do |t|\n        if t[1]==\"AC\"\n            ans[1] += wa_num \n            ans[0]+=1\n            break\n        else\n            wa_num += 1\n        end\n    end\nend\nputs ans.join(' ')", "label": 0, "name1": "s333010125.java", "name2": "s336890329.rb"}, {"id": 311, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint a=scan.nextInt();\n\t\tint b=scan.nextInt();\n\t\tint c=scan.nextInt();\n\t\tint d=a-b;\n\t\tif(c-d>0) System.out.println(c-d);\n\t\telse System.out.println(\"0\");\n\n\t}\n\n}\n", "code2": "A, B, C = gets.split.map(&:to_i)\nrest = A - B\nif rest >= C\n  puts '0'\nelse\n  puts(C - rest)\nend\n", "label": 1, "name1": "s407931652.java", "name2": "s187353051.rb"}, {"id": 188, "code1": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\n\tprivate static Scanner sc;\n\tprivate static Printer pr;\n\n\tprivate static void solve() {\n\t\tint a = sc.nextInt();\n\t\tint b = sc.nextInt();\n\n\t\tif (b < a) {\n\t\t\ta--;\n\t\t}\n\n\t\tpr.println(a);\n\t}\n\n\t// ---------------------------------------------------\n\tpublic static void main(String[] args) {\n\t\tsc = new Scanner(INPUT == null ? System.in : new ByteArrayInputStream(INPUT.getBytes()));\n\t\tpr = new Printer(System.out);\n\n\t\tsolve();\n\n//\t\tpr.close();\n\t\tpr.flush();\n//\t\tsc.close();\n\t}\n\n\tstatic String INPUT = null;\n\n\tprivate static class Printer extends PrintWriter {\n\t\tPrinter(OutputStream out) {\n\t\t\tsuper(out);\n\t\t}\n\t}\n}\n", "code2": "#!/usr/bin/env ruby\n\nrequire 'set'\n\nclass Hash\n  def push(key, value)\n    self[key] = [] if self[key] == nil\n    self[key].push(value)\n  end\nend\n\nclass Array\n  def lower_bound(value)\n    left = -1;\n    right = self.length;\n    while left + 1 < right\n      mid = left + (right - left) / 2;\n      if self[mid] >= value\n        right = mid\n      else\n        left = mid\n      end\n    end\n    right\n  end\n\n  def unique\n    res = [self.first]\n    each_cons(2) do |a, b|\n      if a != b\n        res.push(b)\n      end\n    end\n    res\n  end\nend\n\ndef get_ints\n  gets.chomp.split.map(&:to_i)\nend\n\ndef get_ints_minus_one\n  get_ints.map { |x| x - 1 }\nend\n\ndef get_int\n  gets.chomp.to_i\nend\n\nA, B = get_ints\n\ncount = A-1\nif B >= A\n  count += 1\nend\n\nputs count\n", "label": 1, "name1": "s998480605.java", "name2": "s050204724.rb"}, {"id": 142, "code1": "import java.io.IOException;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\nimport java.io.PrintWriter;\n\n@SuppressWarnings(\"unchecked\")\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        final String s;\n\n        try (\n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(System.in))) {\n            s = reader.readLine();\n        }\n\n        PrintWriter out = new PrintWriter(System.out);\n\n        final String[] sl = s.split(\" \");\n        int A = Integer.parseInt(sl[0]);\n        int B = Integer.parseInt(sl[1]);\n        int C = Integer.parseInt(sl[2]);\n\n        int max = Math.max(A, Math.max(B, C));\n\n        int sum = 3 * max - A - B - C;\n\n        int ans;\n\n        if (sum % 2 == 0) ans = sum / 2;\n        else ans = (int)Math.ceil((double)sum / 2) + 1;\n\n        out.println(ans);\n\n        out.flush();\n    }\n}\n", "code2": "a,b,c = gets.chomp.split(' ').map(&:to_i)\nnum_of_odd = 0\narr = [[a,0],[b,0],[c,0]]\narr.each do |x|\n  if x[0] % 2 != 0\n    x[1] = 1\n    num_of_odd += 1\n  end\nend\ncount = 0\nif num_of_odd == 1#\u5076\u6570\u306b1\u3092\u8db3\u3059\u3002\n  count += 1\n  arr.each do |x|\n    if x[1] != 1\n      x[0] += 1\n    end\n  end\nelsif num_of_odd == 2#\u5947\u6570\u306b1\u3092\u8db3\u3059\u3002\n  count += 1\n  arr.each do |x|\n    if x[1] == 1\n      x[0] += 1\n    end\n  end\nend\nnums = [arr[0][0],arr[1][0],arr[2][0]] \nmax = nums.max\nnums.each do |num|\n  while max - num > 0\n    count += 1\n    num += 2\n  end\nend \nputs count", "label": 1, "name1": "s588342457.java", "name2": "s020203730.rb"}, {"id": 453, "code1": "import java.util.*;\nimport java.text.*;\nimport java.math.*;\n\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tScanner in = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint m = in.nextInt();\n\t\t\tint d = in.nextInt();\n\t\t\tif((m|d) == 0) break;\n\t\t\tint day = d;\n\t\t\tswitch(m){\n\t\t\tcase 12:\n\t\t\t\tday += 335;\n\t\t\t\tbreak;\n\t\t\tcase 11:\n\t\t\t\tday += 305;\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tday += 274;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tday += 244;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tday += 213;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tday += 182;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tday += 152;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tday += 121;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tday += 91;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tday += 60;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tday += 31;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t}\n\t\t\tswitch(day%7){\n\t\t\tcase 1:\n\t\t\t\tSystem.out.println(\"Thursday\");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tSystem.out.println(\"Friday\");\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tSystem.out.println(\"Saturday\");\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tSystem.out.println(\"Sunday\");\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tSystem.out.println(\"Monday\");\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tSystem.out.println(\"Tuesday\");\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tSystem.out.println(\"Wednesday\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}", "code2": "require \"date\"\narr = Array.new\nuntil (line = gets) == \"0 0\\n\"\n  arr << line\nend\narr.each do |i|\n  a = i.split(\" \")\n  a.map!{|j| j.to_i}\n  m = a[0]\n  d = a[1]\n  wday = [\"Sunday\",\n          \"Monday\",\n          \"Tuesday\",\n          \"Wednesday\",\n          \"Thursday\",\n          \"Friday\",\n          \"Saturday\"]\n  day = Date::new(2004, m, d)\n  puts wday[day.wday]\nend", "label": 1, "name1": "s648991274.java", "name2": "s152498090.rb"}, {"id": 583, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.stream.IntStream;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMain main = new Main();\n\t\tmain.solve();\n\t}\n\n\tprivate void solve() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tint[] a = new int[N];\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\ta[j] = sc.nextInt();\n\t\t}\n\t\tboolean[] dp = new boolean[K + 1];\n\t\tfor (int i = 0; i <= K; i++) {\n\t\t\tboolean isWin = false;\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (a[j] <= i && !dp[i - a[j]]) {\n\t\t\t\t\tisWin = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i] = isWin;\n\t\t}\n\t\tSystem.out.println(dp[K] ? \"First\" : \"Second\");\n\t}\n\n\tclass Scanner {\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int index;\n\t\tprivate int length;\n\n\t\tpublic Scanner(InputStream in) {\n\t\t\tthis.in = in;\n\t\t}\n\n\t\tprivate boolean isPrintableChar(int c) {\n\t\t\treturn '!' <= c && c <= '~';\n\t\t}\n\n\t\tprivate boolean isDigit(int c) {\n\t\t\treturn '0' <= c && c <= '9';\n\t\t}\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (index < length) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tlength = in.read(buffer);\n\t\t\t\t\tindex = 0;\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\treturn length > 0;\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[index])) {\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\treturn hasNextByte() ? buffer[index++] : -1;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) {\n\t\t\t\tthrow new RuntimeException(\"no input\");\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) {\n\t\t\t\tthrow new RuntimeException(\"no input\");\n\t\t\t}\n\t\t\tlong value = 0L;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tif (isDigit(b)) {\n\t\t\t\t\tvalue = value * 10 + (b - '0');\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn minus ? -value : value;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n\n\tinterface CombCalculator {\n\t\tlong comb(int n, int m);\n\t}\n\n\tinterface MobiusFunction {\n\t\tint get(int n);\n\t}\n\n\t/**\n\t * \u30e1\u30d3\u30a6\u30b9\u95a2\u6570\u3092\u30a8\u30e9\u30c8\u30b9\u30c6\u30cd\u30b9\u306e\u7be9\u3063\u307d\u304f\u524d\u8a08\u7b97\u3059\u308b\u30af\u30e9\u30b9\u3067\u3059\u3002\n\t * \u8a08\u7b97\u91cf\u306fO(1)\u3067\u3001\u524d\u8a08\u7b97\u3067O(N logN)\u3067\u3059\u3002\n\t */\n\tclass SieveMobiusFunction implements MobiusFunction {\n\t\tint size;\n\t\tint[] mobiusFunctionValues;\n\n\t\tpublic SieveMobiusFunction(int size) {\n\t\t\tthis.size = size;\n\t\t\tmobiusFunctionValues = new int[size];\n\n\t\t\tmobiusFunctionValues[0] = 0;\n\t\t\tmobiusFunctionValues[1] = 1;\n\t\t\tfor (int i = 2; i < size; i++) {\n\t\t\t\tmobiusFunctionValues[i] = 1;\n\t\t\t}\n\t\t\tfor (int i = 2; i * i < size; i++) {\n\t\t\t\tfor (int k = 1; i * i * k < size; k++) {\n\t\t\t\t\tmobiusFunctionValues[i * i * k] *= 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 2; i < size; i++) {\n\t\t\t\tif (mobiusFunctionValues[i] == 1) {\n\t\t\t\t\tfor (int k = 1; i * k < size; k++) {\n\t\t\t\t\t\tmobiusFunctionValues[i * k] *= -2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mobiusFunctionValues[i] > 1) {\n\t\t\t\t\tmobiusFunctionValues[i] = 1;\n\t\t\t\t}\n\t\t\t\tif (mobiusFunctionValues[i] < -1) {\n\t\t\t\t\tmobiusFunctionValues[i] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int get(int n) {\n\t\t\tif (n > size) {\n\t\t\t\tthrow new RuntimeException(\"n is greater than size.\");\n\t\t\t}\n\t\t\tif (n < 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn mobiusFunctionValues[n];\n\t\t}\n\t}\n\n\t/**\n\t * \u30e1\u30d3\u30a6\u30b9\u95a2\u6570\u3092\u5b9a\u7fa9\u901a\u308a\u8a08\u7b97\u3059\u308b\u30af\u30e9\u30b9\u3067\u3059\u3002\n\t * \u8a08\u7b97\u91cf\u306fO(logN)\u3067\u3059\u3002\n\t */\n\tclass PrimeFactorizationMobiusFunction implements MobiusFunction {\n\t\t@Override\n\t\tpublic int get(int n) {\n\t\t\tif (n <= 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (n == 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tint num = 0;\n\t\t\tfor (int i = 2; i < n; i++) {\n\t\t\t\tif (n % i == 0) {\n\t\t\t\t\tn /= i;\n\t\t\t\t\tnum++;\n\t\t\t\t\tif (n % i == 0) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn num % 2 == 0 ? -1 : 1;\n\t\t}\n\t}\n\n\t/**\n\t * \u7d44\u307f\u5408\u308f\u305b\u8a08\u7b97\u3092\u968e\u4e57\u306e\u5024\u3067\u884c\u3046\u30af\u30e9\u30b9\u3067\u3059(MOD\u5bfe\u5fdc)\n\t * \u968e\u4e57\u3068\u305d\u306e\u9006\u5143\u306f\u524d\u8a08\u7b97\u3057\u3066\u30c6\u30fc\u30d6\u30eb\u306b\u683c\u7d0d\u3057\u307e\u3059\u3002\n\t * C(N, N) % M \u306e\u8a08\u7b97\u91cf\u306f O(1)\u3001 \u524d\u8a08\u7b97\u3067O(max(N, logM))\u3067\u3059\u3002\n\t * size\u30921e8\u3088\u308a\u5927\u304d\u3044\u5024\u3067\u5b9f\u884c\u3059\u308b\u3068MLE\u306e\u5371\u967a\u6027\u304c\u3042\u308a\u307e\u3059\u3002\n\t * \u307e\u305f\u7d20\u6570\u4ee5\u5916\u306eMOD\u306b\u306f\u5bfe\u5fdc\u3057\u3066\u3044\u307e\u305b\u3093(\u9006\u5143\u306e\u8a08\u7b97\u306b\u7d20\u6570\u306e\u5270\u4f59\u74b0\u306e\u6027\u8cea\u3092\u5229\u7528\u3057\u3066\u3044\u308b\u305f\u3081)\u3002\n\t */\n\tclass FactorialTableCombCalculator implements CombCalculator {\n\t\tint size;\n\t\tlong[] factorialTable;\n\t\tlong[] inverseFactorialTable;\n\t\tlong mod;\n\n\t\tpublic FactorialTableCombCalculator(int size, long mod) {\n\t\t\tthis.size = size;\n\t\t\tfactorialTable = new long[size + 1];\n\t\t\tinverseFactorialTable = new long[size + 1];\n\t\t\tthis.mod = mod;\n\n\t\t\tfactorialTable[0] = 1L;\n\t\t\tfor (int i = 1; i <= size; i++) {\n\t\t\t\tfactorialTable[i] = (factorialTable[i - 1] * i) % mod;\n\t\t\t}\n\t\t\tinverseFactorialTable[size] = inverse(factorialTable[size], mod);\n\t\t\tfor (int i = size - 1; i >= 0; i--) {\n\t\t\t\tinverseFactorialTable[i] = (inverseFactorialTable[i + 1] * (i + 1)) % mod;\n\t\t\t}\n\t\t}\n\n\t\tprivate long inverse(long n, long mod) {\n\t\t\treturn pow(n, mod - 2, mod);\n\t\t}\n\n\t\tprivate long pow(long n, long p, long mod) {\n\t\t\tif (p == 0) {\n\t\t\t\treturn 1L;\n\t\t\t}\n\t\t\tlong half = pow(n, p / 2, mod);\n\t\t\tlong ret = (half * half) % mod;\n\t\t\tif (p % 2 == 1) {\n\t\t\t\tret = (ret * n) % mod;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic long comb(int n, int m) {\n\t\t\tif (n > size) {\n\t\t\t\tthrow new RuntimeException(\"n is greater than size.\");\n\t\t\t}\n\t\t\tif (n < 0 || m < 0 || n < m) {\n\t\t\t\treturn 0L;\n\t\t\t}\n\t\t\treturn (((factorialTable[n] * inverseFactorialTable[m]) % mod) * inverseFactorialTable[n - m]) % mod;\n\t\t}\n\t}\n\n\t/**\n\t * \u7d44\u307f\u5408\u308f\u305b\u8a08\u7b97\u3092\u30c6\u30fc\u30d6\u30eb\u3067\u5b9f\u88c5\u3057\u305f\u30af\u30e9\u30b9\u3067\u3059(MOD\u5bfe\u5fdc)\n\t * \u524d\u8a08\u7b97\u3067O(N^2), comb\u306fO(1)\u3067\u5b9f\u884c\u3067\u304d\u307e\u3059\n\t * size\u30922 * 1e4\u3088\u308a\u5927\u304d\u3044\u5024\u3067\u5b9f\u884c\u3059\u308b\u3068MLE\u306e\u5371\u967a\u6027\u304c\u3042\u308a\u307e\u3059\n\t */\n\tclass TableCombCalculator implements CombCalculator {\n\t\tlong[][] table;\n\t\tint size;\n\n\t\tpublic TableCombCalculator(int size, long mod) {\n\t\t\tthis.size = size;\n\t\t\ttable = new long[size + 1][];\n\n\t\t\ttable[0] = new long[1];\n\t\t\ttable[0][0] = 1L;\n\t\t\tfor (int n = 1; n <= size; n++) {\n\t\t\t\ttable[n] = new long[n + 1];\n\t\t\t\ttable[n][0] = 1L;\n\t\t\t\tfor (int m = 1; m < n; m++) {\n\t\t\t\t\ttable[n][m] = (table[n - 1][m - 1] + table[n - 1][m]) % mod;\n\t\t\t\t}\n\t\t\t\ttable[n][n] = 1L;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic long comb(int n, int m) {\n\t\t\tif (n > size) {\n\t\t\t\tthrow new RuntimeException(\"n is greater than size.\");\n\t\t\t}\n\t\t\tif (n < 0 || m < 0 || n < m) {\n\t\t\t\treturn 0L;\n\t\t\t}\n\t\t\treturn table[n][m];\n\t\t}\n\t}\n\n\tinterface Graph {\n\t\tvoid link(int from, int to, long cost);\n\t\tOptional<Long> getCost(int from, int to);\n\t\tint getVertexNum();\n\t}\n\n\tinterface FlowResolver {\n\t\tlong maxFlow(int from, int to);\n\t}\n\n\t/**\n\t * \u30b0\u30e9\u30d5\u306e\u884c\u5217\u306b\u3088\u308b\u5b9f\u88c5\n\t * \u63a5\u70b9\u6570\u306e\u5927\u304d\u3044\u30b0\u30e9\u30d5\u3067\u4f7f\u3046\u3068MLE\u3067\u6b7b\u306b\u305d\u3046\n\t */\n\tclass ArrayGraph implements Graph {\n\t\tprivate Long[][] costArray;\n\t\tprivate int vertexNum;\n\n\t\tpublic ArrayGraph(int n) {\n\t\t\tcostArray = new Long[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tcostArray[i] = new Long[n];\n\t\t\t}\n\t\t\tvertexNum = n;\n\t\t}\n\n\t\t@Override\n\t\tpublic void link(int from, int to, long cost) {\n\t\t\tcostArray[from][to] = new Long(cost);\n\t\t}\n\n\t\t@Override\n\t\tpublic Optional<Long> getCost(int from, int to) {\n\t\t\treturn Optional.ofNullable(costArray[from][to]);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getVertexNum() {\n\t\t\treturn vertexNum;\n\t\t}\n\t}\n\n\t/**\n\t * DFS(\u6df1\u3055\u512a\u5148\u63a2\u7d22)\u306b\u3088\u308b\u5b9f\u88c5\n\t * \u8a08\u7b97\u91cf\u306fO(E*MaxFlow)\u306e\u306f\u305a (E:\u8fba\u306e\u6570, MaxFlow:\u6700\u5927\u30d5\u30ed\u30fc)\n\t */\n\tclass DfsFlowResolver implements FlowResolver {\n\t\tprivate Graph graph;\n\t\tpublic DfsFlowResolver(Graph graph) {\n\t\t\tthis.graph = graph;\n\t\t}\n\n\t\t/**\n\t\t * \u6700\u5927\u30d5\u30ed\u30fc(\u6700\u5c0f\u30ab\u30c3\u30c8)\u3092\u6c42\u3081\u308b\n\t\t * @param from \u59cb\u70b9(source)\u306eID\n\t\t * @param to \u7d42\u70b9(target)\u306eID\n\t\t * @return \u6700\u5927\u30d5\u30ed\u30fc(\u6700\u5c0f\u30ab\u30c3\u30c8)\n\t\t */\n\t\tpublic long maxFlow(int from, int to) {\n\t\t\tlong sum = 0L;\n\t\t\tlong currentFlow;\n\t\t\tdo {\n\t\t\t\tcurrentFlow = flow(from, to, Long.MAX_VALUE / 3, new boolean[graph.getVertexNum()]);\n\t\t\t\tsum += currentFlow;\n\t\t\t} while (currentFlow > 0);\n\t\t\treturn sum;\n\t\t}\n\n\t\t/**\n\t\t * \u30d5\u30ed\u30fc\u306e\u5b9f\u884c \u30b0\u30e9\u30d5\u306e\u66f4\u65b0\u3082\u884c\u3046\n\t\t * @param from \u73fe\u5728\u3044\u308b\u7bc0\u70b9\u306eID\n\t\t * @param to \u7d42\u70b9(target)\u306eID\n\t\t * @param current_flow \u3053\u3053\u307e\u3067\u306e\u6d41\u91cf\n\t\t * @param passed \u65e2\u306b\u901a\u3063\u305f\u7bc0\u70b9\u304b\u5426\u304b\u3092\u683c\u7d0d\u3057\u305f\u914d\u5217\n\t\t * @return \u7d42\u70b9(target)\u306b\u6d41\u3057\u305f\u6d41\u91cf/\u623b\u308a\u306e\u30b0\u30e9\u30d5\u306e\u6d41\u91cf\n\t\t */\n\t\tprivate long flow(int from, int to, long current_flow, boolean[] passed) {\n\t\t\tpassed[from] = true;\n\t\t\tif (from == to) {\n\t\t\t\treturn current_flow;\n\t\t\t}\n\t\t\tfor (int id = 0; id < graph.getVertexNum(); id++) {\n\t\t\t\tif (passed[id]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tOptional<Long> cost = graph.getCost(from, id);\n\t\t\t\tif (cost.orElse(0L) > 0) {\n\t\t\t\t\tlong nextFlow = current_flow < cost.get() ? current_flow : cost.get();\n\t\t\t\t\tlong returnFlow = flow(id, to, nextFlow, passed);\n\t\t\t\t\tif (returnFlow > 0) {\n\t\t\t\t\t\tgraph.link(from, id, cost.get() - returnFlow);\n\t\t\t\t\t\tgraph.link(id, from, graph.getCost(id, from).orElse(0L) + returnFlow);\n\t\t\t\t\t\treturn returnFlow;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0L;\n\t\t}\n\t}\n\n\t/**\n\t * 1-indexed\u306eBIT\u914d\u5217\n\t */\n\tclass BinaryIndexedTree {\n\t\tprivate long[] array;\n\n\t\tpublic BinaryIndexedTree(int size) {\n\t\t\tthis.array = new long[size + 1];\n\t\t}\n\n\t\t/**\n\t\t * \u6307\u5b9a\u3057\u305f\u8981\u7d20\u306b\u5024\u3092\u52a0\u7b97\u3059\u308b\n\t\t * \u8a08\u7b97\u91cf\u306fO(logN)\n\t\t * @param index \u52a0\u7b97\u3059\u308b\u8981\u7d20\u306e\u6dfb\u5b57\n\t\t * @param value \u52a0\u7b97\u3059\u308b\u91cf\n\t\t */\n\t\tpublic void add(int index, long value) {\n\t\t\tfor (int i = index; i < array.length; i += (i & -i)) {\n\t\t\t\tarray[i] += value;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * 1\u301c\u6307\u5b9a\u3057\u305f\u8981\u7d20\u307e\u3067\u306e\u548c\u3092\u53d6\u5f97\u3059\u308b\n\t\t * \u8a08\u7b97\u91cf\u306fO(logN)\n\t\t * @param index \u548c\u306e\u7d42\u7aef\u3068\u306a\u308b\u8981\u7d20\u306e\u6dfb\u5b57\n\t\t * @return 1\u301cindex\u307e\u3067\u306e\u548c\n\t\t */\n\t\tpublic long getSum(int index) {\n\t\t\tlong sum = 0L;\n\t\t\tfor (int i = index; i > 0; i -= (i & -i)) {\n\t\t\t\tsum += array[i];\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\n\t/**\n\t * 1-indexed\u306e2\u6b21\u5143BIT\u914d\u5217\n\t */\n\tclass BinaryIndexedTree2D {\n\t\tprivate long[][] array;\n\n\t\tpublic BinaryIndexedTree2D(int size1, int size2) {\n\t\t\tthis.array = new long[size1 + 1][];\n\t\t\tfor (int i = 1; i <= size1; i++) {\n\t\t\t\tthis.array[i] = new long[size2 + 1];\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * \u6307\u5b9a\u3057\u305f\u8981\u7d20\u306b\u5024\u3092\u52a0\u7b97\u3059\u308b\n\t\t * \u8a08\u7b97\u91cf\u306fO(logN * logN)\n\t\t * @param index1 \u52a0\u7b97\u3059\u308b\u8981\u7d20\u306e1\u6b21\u5143\u76ee\u306e\u6dfb\u5b57\n\t\t * @param index2 \u52a0\u7b97\u3059\u308b\u8981\u7d20\u306e2\u6b21\u5143\u76ee\u306e\u6dfb\u5b57\n\t\t * @param value \u52a0\u7b97\u3059\u308b\u91cf\n\t\t */\n\t\tpublic void add(int index1, int index2, long value) {\n\t\t\tfor (int i1 = index1; i1 < array.length; i1 += (i1 & -i1)) {\n\t\t\t\tfor (int i2 = index2; i2 < array.length; i2 += (i2 & -i2)) {\n\t\t\t\t\tarray[i1][i2] += value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * (1,1)\u301c\u6307\u5b9a\u3057\u305f\u8981\u7d20\u307e\u3067\u306e\u77e9\u5f62\u548c\u3092\u53d6\u5f97\u3059\u308b\n\t\t * \u8a08\u7b97\u91cf\u306fO(logN * logN)\n\t\t * @param index1 \u548c\u306e\u7d42\u7aef\u3068\u306a\u308b\u8981\u7d20\u306e1\u6b21\u5143\u76ee\u306e\u6dfb\u5b57\n\t\t * @param index2 \u548c\u306e\u7d42\u7aef\u3068\u306a\u308b\u8981\u7d20\u306e2\u6b21\u5143\u76ee\u306e\u6dfb\u5b57\n\t\t * @return (1,1)\u301c(index1,index2)\u307e\u3067\u306e\u77e9\u5f62\u548c\n\t\t */\n\t\tpublic long getSum(int index1, int index2) {\n\t\t\tlong sum = 0L;\n\t\t\tfor (int i1 = index1; i1 > 0; i1 -= (i1 & -i1)) {\n\t\t\t\tfor (int i2 = index2; i2 > 0; i2 -= (i2 & -i2)) {\n\t\t\t\t\tsum += array[i1][i2];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\n\tinterface UnionFind {\n\t\tvoid union(int A, int B);\n\t\tboolean judge(int A, int B);\n\t\tSet<Integer> getSet(int id);\n\t}\n\n\t/**\n\t * ArrayUnionFind\u306e\u62e1\u5f35\n\t * MapSet\u3067\u6839\u306e\u6dfb\u5b57\u304b\u3089\u6839\u306b\u3076\u3089\u4e0b\u304c\u308b\u9802\u70b9\u306e\u96c6\u5408\u304c\u53d6\u5f97\u3067\u304d\u308b\u3088\u3046\u306b\u3057\u305f\n\t * getSet\u30e1\u30bd\u30c3\u30c9\u3092O(logN * logN)\u306b\u843d\u3068\u305b\u3066\u3044\u308b\u306f\u305a\n\t * \u305f\u3060\u3057union\u30e1\u30bd\u30c3\u30c9\u306f2\u500d\u306e\u8a08\u7b97\u91cf\u306b\u306a\u3063\u3066\u3044\u308b\u306e\u3067\u6ce8\u610f(\u30aa\u30fc\u30c0\u30fc\u306f\u5909\u308f\u3089\u306a\u3044\u306f\u305a)\n\t */\n\tclass SetUnionFind extends ArrayUnionFind {\n\t\tMap<Integer, Set<Integer>> map;\n\t\tpublic SetUnionFind(int size) {\n\t\t\tsuper(size);\n\t\t\tmap = new HashMap<>();\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tmap.put(i, new HashSet<>());\n\t\t\t\tmap.get(i).add(i);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tprotected void unionTo(int source, int dest) {\n\t\t\tsuper.unionTo(source, dest);\n\t\t\tmap.get(dest).addAll(map.get(source));\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<Integer> getSet(int id) {\n\t\t\treturn map.get(root(id));\n\t\t}\n\t}\n\n\t/**\n\t * \u914d\u5217\u306b\u3088\u308bUnionFind\u306e\u5b9f\u88c5\n\t * getSet\u30e1\u30bd\u30c3\u30c9\u306fO(NlogN)\u306a\u306e\u3067TLE\u306b\u6ce8\u610f\n\t */\n\tclass ArrayUnionFind implements UnionFind {\n\t\tint[] parent;\n\t\tint[] rank;\n\t\tint size;\n\t\tpublic ArrayUnionFind(int size) {\n\t\t\tparent = new int[size];\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tparent[i] = i;\n\t\t\t}\n\t\t\trank = new int[size];\n\t\t\tthis.size = size;\n\t\t}\n\n\t\t@Override\n\t\tpublic void union(int A, int B) {\n\t\t\tint rootA = root(A);\n\t\t\tint rootB = root(B);\n\t\t\tif (rootA != rootB) {\n\t\t\t\tif (rank[rootA] < rank[rootB]) {\n\t\t\t\t\tunionTo(rootA, rootB);\n\t\t\t\t} else {\n\t\t\t\t\tunionTo(rootB, rootA);\n\t\t\t\t\tif (rank[rootA] == rank[rootB]) {\n\t\t\t\t\t\trank[rootA]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprotected void unionTo(int source, int dest) {\n\t\t\tparent[source] = dest;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean judge(int A, int B) {\n\t\t\treturn root(A) == root(B);\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<Integer> getSet(int id) {\n\t\t\tSet<Integer> set = new HashSet<>();\n\t\t\tIntStream.range(0, size).filter(i -> judge(i, id)).forEach(set::add);\n\t\t\treturn set;\n\t\t}\n\n\t\tprotected int root(int id) {\n\t\t\tif (parent[id] == id) {\n\t\t\t\treturn id;\n\t\t\t}\n\t\t\tparent[id] = root(parent[id]);\n\t\t\treturn parent[id];\n\t\t}\n\t}\n\n\t/**\n\t * \u7d20\u6570\u306e\u30e6\u30fc\u30c6\u30a3\u30ea\u30c6\u30a3\n\t */\n\tclass PrimeNumberUtils {\n\t\tboolean[] isPrimeArray;\n\t\tList<Integer> primes;\n\n\t\t/**\n\t\t * \u7d20\u6570\u5224\u5b9a\u306e\u4e0a\u9650\u3068\u306a\u308b\u5024\u3092\u6307\u5b9a\u3057\u3066\u30e6\u30fc\u30c6\u30a3\u30ea\u30c6\u30a3\u3092\u521d\u671f\u5316\n\t\t * @param limit \u7d20\u6570\u5224\u5b9a\u306e\u4e0a\u9650(\u3053\u306e\u5024\u4ee5\u4e0a\u304c\u7d20\u6570\u3067\u3042\u308b\u304b\u5224\u5b9a\u3057\u306a\u3044)\n\t\t */\n\t\tpublic PrimeNumberUtils(int limit) {\n\t\t\tif (limit > 10000000) {\n\t\t\t\tSystem.err.println(\"\u4e0a\u9650\u306e\u5024\u304c\u9ad8\u3059\u304e\u308b\u305f\u3081\u7d20\u6570\u30e6\u30fc\u30c6\u30a3\u30ea\u30c6\u30a3\u306e\u521d\u671f\u5316\u3067TLE\u3059\u308b\u53ef\u80fd\u6027\u304c\u5927\u5909\u9ad8\u3044\u3067\u3059\");\n\t\t\t}\n\t\t\tprimes = new ArrayList<>();\n\t\t\tisPrimeArray = new boolean[limit];\n\t\t\tif (limit > 2) {\n\t\t\t\tprimes.add(2);\n\t\t\t\tisPrimeArray[2] = true;\n\t\t\t}\n\n\t\t\tfor (int i = 3; i < limit; i += 2) {\n\t\t\t\tif (isPrime(i, primes)) {\n\t\t\t\t\tprimes.add(i);\n\t\t\t\t\tisPrimeArray[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic List<Integer> getPrimeNumberList() {\n\t\t\treturn primes;\n\t\t}\n\n\t\tpublic boolean isPrime(int n) {\n\t\t\treturn isPrimeArray[n];\n\t\t}\n\n\t\tprivate boolean isPrime(int n, List<Integer> primes) {\n\t\t\tfor (int prime : primes) {\n\t\t\t\tif (n % prime == 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (prime > Math.sqrt(n)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tinterface BitSet {\n\t\tvoid set(int index, boolean bit);\n\t\tboolean get(int index);\n\t\tvoid shiftRight(int num);\n\t\tvoid shiftLeft(int num);\n\t\tvoid or(BitSet bitset);\n\t\tvoid and(BitSet bitset);\n\t}\n\n\t/**\n\t * Long\u306e\u914d\u5217\u306b\u3088\u308bBitSet\u306e\u5b9f\u88c5\n\t * get/set\u306fO(1)\n\t * shift/or/and\u306fO(size / 64)\n\t */\n\tclass LongBit implements BitSet {\n\t\tlong[] bitArray;\n\n\t\tpublic LongBit(int size) {\n\t\t\tbitArray = new long[((size + 63) / 64)];\n\t\t}\n\n\t\t@Override\n\t\tpublic void set(int index, boolean bit) {\n\t\t\tint segment = index / 64;\n\t\t\tint inIndex = index % 64;\n\t\t\tif (bit) {\n\t\t\t\tbitArray[segment] |= 1L << inIndex;\n\t\t\t} else {\n\t\t\t\tbitArray[segment] &= ~(1L << inIndex);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean get(int index) {\n\t\t\tint segment = index / 64;\n\t\t\tint inIndex = index % 64;\n\t\t\treturn (bitArray[segment] & (1L << inIndex)) != 0L;\n\t\t}\n\n\t\t@Override\n\t\tpublic void shiftRight(int num) {\n\t\t\tint shiftSeg = num / 64;\n\t\t\tint shiftInI = num % 64;\n\t\t\tfor (int segment = 0; segment < bitArray.length; segment++) {\n\t\t\t\tint sourceSeg = segment + shiftSeg;\n\t\t\t\tif (sourceSeg < bitArray.length) {\n\t\t\t\t\tbitArray[segment] = bitArray[sourceSeg] >>> shiftInI;\n\t\t\t\t\tif (shiftInI > 0 && sourceSeg + 1 < bitArray.length) {\n\t\t\t\t\t\tbitArray[segment] |= bitArray[sourceSeg + 1] << (64 - shiftInI);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbitArray[segment] = 0L;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void shiftLeft(int num) {\n\t\t\tint shiftSeg = num / 64;\n\t\t\tint shiftInI = num % 64;\n\t\t\tfor (int segment = bitArray.length - 1; segment >= 0; segment--) {\n\t\t\t\tint sourceSeg = segment - shiftSeg;\n\t\t\t\tif (sourceSeg >= 0) {\n\t\t\t\t\tbitArray[segment] = bitArray[sourceSeg] << shiftInI;\n\t\t\t\t\tif (shiftInI > 0 && sourceSeg > 0) {\n\t\t\t\t\t\tbitArray[segment] |= bitArray[sourceSeg - 1] >>> (64 - shiftInI);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbitArray[segment] = 0L;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic long getLong(int segment) {\n\t\t\treturn bitArray[segment];\n\t\t}\n\n\t\t@Override\n\t\tpublic void or(BitSet bitset) {\n\t\t\tif (!(bitset instanceof LongBit)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int segment = 0; segment < bitArray.length; segment++) {\n\t\t\t\tbitArray[segment] |= ((LongBit)bitset).getLong(segment);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void and(BitSet bitset) {\n\t\t\tif (!(bitset instanceof LongBit)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int segment = 0; segment < bitArray.length; segment++) {\n\t\t\t\tbitArray[segment] &= ((LongBit)bitset).getLong(segment);\n\t\t\t}\n\t\t}\n\t}\n\n}", "code2": "#!/usr/bin/env ruby\n\nrequire 'set'\n\nclass Hash\n  def push(key, value)\n    self[key] = [] if self[key] == nil\n    self[key].push(value)\n  end\nend\n\nclass Array\n  def lower_bound(value)\n    left = -1;\n    right = self.length;\n    while left + 1 < right\n      mid = left + (right - left) / 2;\n      if self[mid] >= value\n        right = mid\n      else\n        left = mid\n      end\n    end\n    right\n  end\n\n  def unique\n    res = [self.first]\n    each_cons(2) do |a, b|\n      if a != b\n        res.push(b)\n      end\n    end\n    res\n  end\nend\n\ndef get_ints\n  gets.chomp.split.map(&:to_i)\nend\n\ndef get_ints_minus_one\n  get_ints.map { |x| x - 1 }\nend\n\ndef get_int\n  gets.chomp.to_i\nend\n\nA, B, C = get_ints\n\nsum = A + B + C\nstock = [A, B, C].max * 3\n\nwaru = (stock - sum)/2\namari = (stock - sum) % 2\n\nputs waru + (amari == 1 ? 2 : 0)\n", "label": 0, "name1": "s208804589.java", "name2": "s046246097.rb"}, {"id": 750, "code1": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)924844033;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint ai = io.nextInt();\n\t\t\tint ao = io.nextInt();\n\t\t\tint at = io.nextInt();\n\t\t\tint aj = io.nextInt();\n\t\t\tint al = io.nextInt();\n\t\t\tint as = io.nextInt();\n\t\t\tint az = io.nextInt();\n\t\t\t\n\t\t\tlong ans = 0;\n\t\t\t\n\t\t\tint cnt = aj % 2 + al % 2 + ai % 2;\n\t\t\tif (cnt >= 2) {\n\t\t\t\tif (aj > 0 && al > 0 && ai > 0) {\n\t\t\t\t\tai--;\n\t\t\t\t\taj--;\n\t\t\t\t\tal--;\n\t\t\t\t\tans += 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += ao;\n\t\t\tans += ai / 2 * 2;\n\t\t\tans += aj / 2 * 2;\n\t\t\tans += al / 2 * 2;\n\t\t\t\n\t\t\tio.out.println(ans);\n\t\t}\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n", "code2": "a, b, x = gets.split.map(&:to_i)\nputs b / x - (a - 1) / x\n", "label": 0, "name1": "s961512992.java", "name2": "s654797155.rb"}, {"id": 732, "code1": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\nclass Solver extends Main{\n\tSolver(){\n\t\t\n\t}\n}//Solver_end\n\n@SuppressWarnings(\"unchecked\")\nclass Main{\n\tstatic int imax=Integer.MAX_VALUE;\n\tstatic long lmax=Long.MAX_VALUE;\n\t\n\tpublic static void main(String[] args) throws FileNotFoundException{\n\t\t\n\t\t\n\t\tScanner sc=new Scanner(System.in);\n\t\t//Scanner sc=new Scanner(fp);\n\t\t\n\t\tint[] data=readlnI(sc,\" \");\n\t\tint n=data[0];\n\t\tint m=data[1];\n\t\tint[] path=new int[200000];\n\t\t\n\t\tfor(int i=0;i<m; i++){\n\t\t\tint[] line=readlnI(sc,\" \");\n\t\t\tif(line[0]==1){\n\t\t\t\tpath[line[1]-1]+=1;\n\t\t\t}else if(line[1]==n){\n\t\t\t\tpath[line[0]-1]+=1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean fnd=false;\n\t\t\n\t\tfor(int x:path){\n\t\t\tif(x==2)fnd=true;\n\t\t}\n\t\t\n\t\tputs(fnd==true ? \"POSSIBLE\" : \"IMPOSSIBLE\");\n\t\t\n\t}//main_end\n\t\n//---------------------------------------------------------------------------\n\tstatic int readI(Scanner sc){\n\t\treturn Integer.parseInt(sc.nextLine().trim());\n\t}\n\tstatic long readL(Scanner sc){\n\t\treturn Long.parseLong(sc.nextLine().trim());\n\t}\n\tstatic String readS(Scanner sc){\n\t\treturn sc.nextLine().trim();\n\t}\n\tstatic int[] readlnI(Scanner sc, String dl){\n\t\treturn Arrays.stream(sc.nextLine().trim().split(dl)).mapToInt(Integer::parseInt).toArray();\n\t}\n\tstatic long[] readlnL(Scanner sc, String dl){\n\t\treturn Arrays.stream(sc.nextLine().trim().split(dl)).mapToLong(Long::parseLong).toArray();\n\t}\n\tstatic String[] readlnS(Scanner sc, String dl){\n\t\treturn sc.nextLine().trim().split(dl);\n\t}\n\t@SuppressWarnings(\"unchecked\")\n\tstatic <T> void puts(T... args){\n\t\tfor(int i=0; i<args.length-1; i++){\n\t\t\tSystem.out.printf(\"%s \",args[i]);\n\t\t}\n\t\tSystem.out.println(args[args.length-1]);\n\t}\n\tstatic void puts(int[] ary){\n\t\tfor(int i=0; i<ary.length-1; i++){\n\t\t\tSystem.out.printf(\"%d \",ary[i]);\n\t\t}\n\t\tSystem.out.println(ary[ary.length-1]);\n\t}\n\tstatic void puts(long[] ary){\n\t\tfor(int i=0; i<ary.length-1; i++){\n\t\t\tSystem.out.printf(\"%d \",ary[i]);\n\t\t}\n\t\tSystem.out.println(ary[ary.length-1]);\n\t}\n\tstatic void bs(){\n\t\tSystem.out.println(\"\");\n\t}\n\tstatic int sum(int[] ary){\n\t\tint sum=0;\n\t\tfor(int i=0; i<ary.length; i++) sum+=ary[i];\n\t\treturn sum;\n\t}\n\tstatic long sum(long[] ary){\n\t\tlong sum=0;\n\t\tfor(int i=0; i<ary.length; i++) sum+=ary[i];\n\t\treturn sum;\n\t}\n\tstatic void tblSort(int[][] tbl){\n\t\tArrays.sort(tbl, new Comparator<int[]>(){\n\t\t\t@Override\n\t\t\tpublic int compare(int[] a, int[] b){\n\t\t\t\tif(a[0]==b[0]){\n\t\t\t\t\treturn b[1]-a[1];\n\t\t\t\t}else{\n\t\t\t\t\treturn b[0]-a[0];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n", "code2": "class PriorityQueue\n  def initialize(&comp)\n    @heap = []\n    @node_num = 0\n    if block_given?\n      @comp = comp\n    else\n      @comp = Proc.new { |x, y| x <= y }\n    end\n  end\n  attr_reader :heap\n \n  def push(x)\n    i = @node_num # self node number\n    @node_num += 1\n    while i > 0\n      par = (i - 1) / 2 # parent's node number\n      break if @comp.call(@heap[par], x) # \u9006\u8ee2\u3057\u3066\u306a\u3044\u306a\u3089\u629c\u3051\u308b\n      # \u89aa\u30ce\u30fc\u30c9\u3092\u4e0b\u308d\u3057\u3066\u81ea\u5206\u3092\u4e0a\u306b\n      @heap[i] = @heap[par]\n      i = par\n    end\n    @heap[i] = x\n  end\n \n  alias_method(:<<, :push)\n \n  def pop\n    # \u6700(\u5c0f|\u5927)\u5024\n    ret = @heap[0]\n    # \u6839\u306b\u3082\u3063\u3066\u304f\u308b\u5024\n    @node_num -= 1\n    x = @heap[@node_num]\n    # \u6839\u304b\u3089\u4e0b\u308d\u3057\u3066\u3044\u304f\n    i = 0\n    while i * 2 + 1 < @node_num\n      # \u5b50\u3069\u3046\u3057\u3092\u6bd4\u8f03\n      a, b = i * 2 + 1, i * 2 + 2\n      a = b if b < @node_num && @comp.call(@heap[b], @heap[a])\n      break unless @comp.call(@heap[a], x)\n      @heap[i] = @heap[a]\n      i = a\n    end\n    @heap[i] = x\n    ret\n  end\n \n  def get\n    @node_num == 0 ? nil : @heap[0]\n  end\n \n  def empty?\n    get.nil?\n  end\nend\n\n\n\n#\n# dijkstra\n#   O(|E|log|V|)\n#   \u96a3\u63a5\u8868\u73fe\u30b0\u30e9\u30d5graph, \u59cb\u70b9start, inf\n#\ndef dijkstra(graph, start, inf = Float::INFINITY)\n  vertex_num = graph.size\n  que = PriorityQueue.new { |x, y| x[0] <= y[0] }\n  dist = Array.new(vertex_num, inf)\n  dist[start] = 0\n  que.push([0, start])\n  while !que.empty?\n    d, v = que.pop\n    next if dist[v] < d\n    graph[v].size.times do |i|\n      # e is an instance of Edge\n      #   Edge = Struct.new(:to, :cost)\n      e = graph[v][i]\n      if dist[e.to] > dist[v] + e.cost\n        dist[e.to] = dist[v] + e.cost\n        que.push([dist[e.to], e.to])\n      end\n    end\n  end\n  return dist\nend\n\n\n\nEdge = Struct.new(:to, :cost)\nv, e, r = gets.split.map(&:to_i)\ng = Array.new(v) { [] }\ne.times do |i|\n  s, t, d = gets.split.map(&:to_i)\n  g[s] << Edge.new(t, d)\nend\nputs dijkstra(g, r).map { |x| x == Float::INFINITY ? \"INF\" : x }\n", "label": 0, "name1": "s766623172.java", "name2": "s468156306.rb"}, {"id": 699, "code1": "import java.util.*;\n\npublic class Main {\n    \n    public static boolean[] alr;\n    \n    public static List<List<Integer>> list = new ArrayList<>();\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        alr = new boolean[N];\n        for (int i = 0; i < N; i++) {\n            list.add(new ArrayList<>());\n        }\n        for (int i = 0; i < M; i++) {\n            int A = sc.nextInt()-1;\n            int B = sc.nextInt()-1;\n            list.get(A).add(B);\n            list.get(B).add(A);\n        }\n        long count = 0;\n        for (int i = 0; i < list.size(); i++) {\n            if (alr[i]) {\n                continue;\n            } else {\n                alr[i] = true;\n                count++;\n            }\n            List<Integer> lst = list.get(i);\n            count(lst);\n        }\n        System.out.println(count-1);\n    }\n    \n    private static void count(List<Integer> lst) {\n        int friends = 0;\n        for (Integer i : lst) {\n            if (alr[i]) {\n                continue;\n            } else {\n                alr[i] = true;\n            }           \n            count(list.get(i));\n        }\n    }\n}\n", "code2": "a, b, c = gets.strip.split(' ').map(&:to_i)\n\nans = 0\nif a - b < c then\n    ans = c - a + b\nend\n\nputs(ans)", "label": 0, "name1": "s602301737.java", "name2": "s914404322.rb"}, {"id": 635, "code1": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\npublic class Main {\n\tstatic final long C =  1000000007;\n\tstatic final int CY = 1000000000;\n\tstatic final int INF = Integer.MAX_VALUE/2;\n\tStringBuilder sb;\n\t//\u30bb\u30c3\u30c8\n\tclass Set<F,S> {\n\t\tF f;\n\t\tS s;\n\t\tSet(F f, S s) {this.f = f;this.s = s;}\n\t}\n\tpublic void calc() {\n\t\tsb = new StringBuilder();\n\n\n\t\tIO sc = new IO();\n\n\t\tint n = sc.nextInt();\n\t\tint[] t = sc.nextIntArray(n);\n\t\tint[] a = sc.nextIntArray(n);\n\n\n\t\tlong ans = 1;\n\t\t//BigInteger bi = new BigInteger(\"1\");\n\t\tint[] min = new int[n];\n\t\tint[] max = new int[n];\n\t\tArrays.fill(min, 1);\n\t\tArrays.fill(max, INF);\n\t\tint b = -1, nb = -1;\n\t\tfor (int i=0; i < n; i++) {\n\t\t\t//System.out.println(\"t\" + i);\n\t\t\tint ni = n-1-i;\n\t\t\tif (b != t[i]) {\n\t\t\t\tmax[i] = Math.min(max[i],t[i]);\n\t\t\t\tmin[i] = Math.max(min[i],t[i]);\n\t\t\t\tb = t[i];\n\t\t\t}else {\n\t\t\t\tmax[i] = Math.min(max[i],t[i]);\n\t\t\t}\n\t\t\tif (nb != a[ni]) {\n\t\t\t\tmax[ni] = Math.min(max[ni],a[ni]);\n\t\t\t\tmin[ni] = Math.max(min[ni],a[ni]);\n\t\t\t\tnb = a[ni];\n\t\t\t}else {\n\t\t\t\tmax[ni] = Math.min(max[ni],a[ni]);\n\t\t\t}\n\n\t\t}\n\n\t\tfor (int i=0; i < n; i++) {\n\t\t\t//System.out.println(min[i] + \":\" + max[i]);\n\t\t\tif (max[i] - min[i] < 0) {\n\t\t\t\tSystem.out.println(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tans *= max[i] - min[i] +1;\n\t\t\tans %= C;\n\t\t\t//bi = bi.multiply(new BigInteger((max[i] - min[i] +1)+\"\" ));\n\n\t\t}\n\n\n\t\tSystem.out.println(ans);\n\t}\n\n\n\tpublic static void main(String[] args) {\n\t\tMain main = new Main();\n\t\tmain.calc();\n\n\t}\n}\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}\n\n", "code2": "def factorial(x)\n  product = 1\n  for i in 1..x do\n    product *= i\n  end\n  return product\nend\n\nn = gets.to_i\np = gets.split.map(&:to_i)\nq = gets.split.map(&:to_i)\npp = (1..n).to_a\nqq = (1..n).to_a\na = 0\nb = 0\nfor i in 0...n do\n  a += pp.index(p[i]) * factorial(n-i-1)\n  b += qq.index(q[i]) * factorial(n-i-1)\n  pp.delete(p[i])\n  qq.delete(q[i])\nend\nputs (a-b).abs\n", "label": 0, "name1": "s145899300.java", "name2": "s622115708.rb"}, {"id": 842, "code1": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint l = sc.nextInt();\n\t\tint t = sc.nextInt();\n\t\tint[] x = new int[n];\n\t\tint[] w = new int[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tx[i] = sc.nextInt();\n\t\t\tw[i] = sc.nextInt();\n\t\t}\n\n\t\tint cnt = 0;\n\t\tfor(int i=1; i<n; i++){\n\t\t\tif(w[0]==1 && w[i]==2){\n\t\t\t\tif(t*2>=x[i]-x[0]){\n\t\t\t\t\tcnt += (1+(t*2-x[i]+x[0])/l);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(w[0]==2 && w[i]==1){\n\t\t\t\tif(t*2>=l-x[i]+x[0]){\n\t\t\t\t\tcnt -= (1+(t*2-l+x[i]-x[0])/l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(w[0]==1){\n\t\t\tcnt %= n;\n\t\t}\n\t\telse{\n\t\t\tcnt = ((cnt%n)+n)%n;\n\t\t}\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif(w[i]==1){\n\t\t\t\tx[i] = (x[i]+t)%l;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tx[i] = ((x[i]-t)%l+l)%l;\n\t\t\t}\n\t\t}\n\t\tint dist0 = x[0];\n\t\tArrays.sort(x);\n\t\tint index0 = 0;\n\t\tif(w[0]==1){\n\t\t\tfor(int i=n-1; i>=0; i--){\n\t\t\t\tif(x[i]==dist0){\n\t\t\t\t\tindex0 = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(x[i]==dist0){\n\t\t\t\t\tindex0 = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<n; i++){\n\t\t\tSystem.out.println(x[(index0-cnt+n+i)%n]);\n\t\t}\n\t}\n}", "code2": "rs = []\nbs = []\n24.times.map { p, t = gets.split; [t.to_f, p.to_i] }.each_slice(8).map(&:sort).each {|as| rs += as[0...2]; bs += as[2..-1] }\nbs.sort!\nrs += bs[0...2]\nrs.each {|t, p| puts '%d %.2f' % [p, t] }", "label": 0, "name1": "s799989824.java", "name2": "s863098923.rb"}, {"id": 646, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\n\npublic class Main {\n\n    static <T extends Comparable<? super T>> boolean nextPermutation(T[] sequence) {\n        int first = getFirst(sequence);\n        if (first == -1) return false;\n        int toSwap = sequence.length - 1;\n        while (sequence[first].compareTo(sequence[toSwap]) >= 0) --toSwap;\n        swap(sequence, first++, toSwap);\n        toSwap = sequence.length - 1;\n        while (first < toSwap) swap(sequence, first++, toSwap--);\n        return true;\n    }\n\n    static <T extends Comparable<? super T>> int getFirst(T[] sequence) {\n        for (int i = sequence.length - 2; i >= 0; --i)\n            if (sequence[i].compareTo(sequence[i + 1]) < 0) return i;\n        return -1;\n    }\n\n    static <T extends Comparable<? super T>> void swap(T[] sequence, int i, int j) {\n        T tmp = sequence[i];\n        sequence[i] = sequence[j];\n        sequence[j] = tmp;\n    }\n\n    public static void main(String[] args) {\n        FastScanner fs = new FastScanner();\n        int N = fs.nextInt();\n        Integer[] P = new Integer[N];\n        Integer[] Q = new Integer[N];\n        for (int i = 0; i < N; ++i) P[i] = fs.nextInt();\n        for (int i = 0; i < N; ++i) Q[i] = fs.nextInt();\n\n        Integer[] arr = new Integer[N];\n        for (int i = 0; i < N; ++i) arr[i] = i+1;\n\n        int cnt = 1, pNum = 0, qNum = 0;\n        do {\n            if (Arrays.toString(arr).equals(Arrays.toString(P))) pNum = cnt;\n            if (Arrays.toString(arr).equals(Arrays.toString(Q))) qNum = cnt;\n            ++cnt;\n        } while (nextPermutation(arr));\n\n        System.out.println(Math.abs(pNum - qNum));\n\n    }\n\n\n    static class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            }else{\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while(true){\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                }else if(b == -1 || !isPrintableChar(b)){\n                    return minus ? -n : n;\n                }else{\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        public int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        public double nextDouble() { return Double.parseDouble(next());}\n    }\n\n}", "code2": "def g;gets.split.map &:to_i;end\nr=1..n=g[0]\nw=[0]+r.map{[0]+[1e9]*n}\nr.map{f,_,*t=g;t.map{|i|w[f][i]=1}}\nr.each{|k|r.each{|i|r.each{|j|(a=(b=w[i])[k]+w[k][j])<b[j]&&b[j]=a}}}\ng[0].times{s,d,v=g;puts v<(c=w[s][d]+1)?:NA:c}", "label": 0, "name1": "s792830085.java", "name2": "s754069394.rb"}, {"id": 786, "code1": "\nimport java.util.HashMap;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main \n{\n\tstatic HashMap<String, String> groupdef;\n\tstatic String firstgroup;\n\tstatic TreeSet<String> members;\n\tstatic TreeSet<String> checked;\n\t\n\tstatic void get(String g)\n\t{\n\t\tString con = groupdef.get(g);\n//\t\tSystem.out.println(\"Getting \" + g + \"...\");\n\t\tif(checked.contains(g))return;\n\t\t\n\t\tint start = 0;\n\t\tint mem = 0;\n\t\tfor(int i = 0; i < con.length(); i++)\n\t\t{\n\t\t\tif(con.charAt(i) == ',' || con.charAt(i) == '.')\n\t\t\t{\n\t\t\t\tString word = con.substring(start, i);\n\t\t\t\tstart = i+1;\n\t\t\t\t\n\t\t\t\tif(groupdef.containsKey(word))\n\t\t\t\t{\n\t\t\t\t\tget(word);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmembers.add(word);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tchecked.add(g);\n//\t\tcache.put(g, mem);\n\t}\n\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0)break;\n\t\t\tgroupdef = new HashMap<String, String>();\n//\t\t\tcache = new HashMap<String, Integer>();\n\t\t\tmembers = new TreeSet<String>();\n\t\t\tchecked = new TreeSet<String>();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tString s = sc.next();\n\t\t\t\tint lim = s.indexOf(':');\n\t\t\t\tString groupname = s.substring(0, lim);\n\t\t\t\tString groupcon = s.substring(lim+1);\n\t\t\t\tif(i == 0)firstgroup = groupname;\n\t\t\t\tgroupdef.put(groupname, groupcon);\n\t\t\t}\n\t\t\t\n\t\t\tget(firstgroup);\n\t\t\tSystem.out.println(members.size());\n//\t\t\tSystem.out.println(members);\n\t\t}\n\t\t\n\n\t}\n\n}\n\n", "code2": "eval'*A=#'+`tr ' ' ,`\ns=m=10**9+7\nf=1\ni=0\np A.sum{i+=1\nf=f*i%m\n-_1+(_1+A[-i])*s+=i.pow(m-2,m)}*f%m", "label": 0, "name1": "s001547590.java", "name2": "s587168748.rb"}, {"id": 334, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n    private static int[] arr;\n\n    public static void main(String[] args) {\n\n        Scanner scanner = new Scanner(System.in);\n        String input = scanner.nextLine();\n        arr = Arrays.stream(input.split(\"\")).mapToInt(Integer::parseInt).toArray();\n\n        long sum = calc(0, arr.length - 1);\n        System.out.println(sum);\n    }\n\n    private static long calc(int position, int end) {\n        if (position > end) return 0;\n\n        long tmp = 0;\n        for (int i = position; i < end; i++) {\n            tmp += toInt(position, i) * Math.pow(2, (end - i - 1)) + calc(i + 1, end);\n        }\n        tmp += toInt(position, end);\n        return tmp;\n    }\n\n    private static long toInt(int start, int end) {\n        if (start == end) {\n//            System.out.println(\"start: \" + start + \" end: \" + end + \" -> \" + arr[start]);\n            return arr[start];\n        }\n\n        long tmp = 0;\n        for (int i = start; i <= end; i++) {\n            tmp += arr[i] * Math.pow(10, (end - i));\n        }\n//        System.out.println(\"start: \" + start + \" end: \" + end + \" -> \" + tmp);\n        return tmp;\n    }\n}", "code2": "$s = gets.chomp\n$result = 0\n\ndef calc(idxs)\n  sum = 0\n  start = 0\n  idxs.each do |idx|\n    sum += $s[start..(idx-1)].to_i\n    start = idx\n  end\n  return sum + $s[start..($s.size-1)].to_i\nend\n\ndef explore(idx=0, idxs=[])\n  if idx == $s.size-1 then\n    $result += calc(idxs)\n  else\n    explore(idx+1, idxs)\n    explore(idx+1, idxs + [idx+1])\n  end\nend\n\nexplore()\nputs $result", "label": 1, "name1": "s752481979.java", "name2": "s268035195.rb"}, {"id": 534, "code1": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic long LINF = 1L << 55;\n\tstatic int MOD = 1000000007;\n\tstatic int[] mh4 = { 0, -1, 1, 0 };\n\tstatic int[] mw4 = { -1, 0, 0, 1 };\n\tstatic int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\tstatic int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n\tstatic class TaskX {\n\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tint n = in.nextInt();\n\t\t\tint[] a = in.nextIntArray(n);\n\n\t\t\tint count = 0;\n\n\t\t\tfor (int l = 0, r = 0; l < n; l = r) {\n\t\t\t\twhile (r < n && a[l] == a[r]) {\n\t\t\t\t\tr++;\n\t\t\t\t}\n\t\t\t\tint len = r-l;\n\t\t\t\tcount += len/2;\n\t\t\t}\n\n\t\t\tout.println(count);\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\t}\n\n}\n", "code2": "puts (1..$_.to_i).map{a,b,c=gets.split.map &:to_i;[a,b+c]}.max_by{|i,j|j}*\" \"while gets>=?1", "label": 0, "name1": "s729269653.java", "name2": "s404961830.rb"}, {"id": 734, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.util.NoSuchElementException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author HBonsai\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CMultipleGift solver = new CMultipleGift();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CMultipleGift {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            long X = in.nextLong();\n            long Y = in.nextLong();\n            int ans = 1;\n            long A = X;\n            while (A <= Y) {\n                A *= 2;\n                if (A > Y) break;\n                ans++;\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class FastScanner implements Closeable {\n        private final InputStream in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        public FastScanner(InputStream in) {\n            this.in = in;\n        }\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        public boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n            return hasNextByte();\n        }\n\n        public long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        public void close() {\n            try {\n                in.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n}\n\n", "code2": "# ?????????????????????????????????????\u00a7???????????????????????????????\n# @param [Array]   g Edge ?????????????????\u00a7??\u00a8???????????\u00b0??????\n# @param [Integer] s ????\u00a7????????????????\n# @return [Array]  ?????????????????\u00a7???????\u00a8?????????????????\u00b4????????????????\n# g ??????????????????????????\u00a7?????????\n# g_i ?????? i ???????????????????????????????????\u00a8??????????????????????????\u00a8??????????\u00b4?????????????\ndef dijkstra(g, s)\n  def enq(pq, val)\n    pq << val\n    cd = pq.size\n    pr = cd / 2\n    until pr.zero? || (pq[pr - 1] <=> pq[cd - 1]) < 0\n      pq[pr - 1], pq[cd - 1] = pq[cd - 1], pq[pr - 1]\n      cd = pr\n      pr = cd / 2\n    end\n  end\n\n  def deq(pq)\n    rs = pq[0]\n    pq[0] = pq[-1]\n    pq.delete_at(-1)\n    unless pq.empty?\n      pr = 1\n      cd = [pr * 2, pr * 2 + 1].select { |i| pq[i - 1] }.min_by { |i| pq[i - 1] }\n      until cd.nil? || (pq[pr - 1] <=> pq[cd - 1]) < 0\n        pq[pr - 1], pq[cd - 1] = pq[cd - 1], pq[pr - 1]\n        pr = cd\n        cd = [pr * 2, pr * 2 + 1].select { |i| pq[i - 1] }.min_by { |i| pq[i - 1] }\n      end\n    end\n    rs\n  end\n\n  pq = []\n  d = Array.new(g.size) { Float::INFINITY }\n  d[s] = 0\n  enq(pq, [0, s])\n\n  until pq.empty?\n    v_cost, v = deq(pq)\n    next if d[v] < v_cost\n    g[v].each do |e|\n      if d[e.to] > d[v] + e.cost\n        d[e.to] = d[v] + e.cost\n        enq(pq, [d[e.to], e.to])\n      end\n    end\n  end\n\n  d\nend\n\nEdge = Struct.new('Edge', :to, :cost)\n\nv, e, r = gets.split.map(&:to_i)\ng = Array.new(v) { [] }\ne.times do\n  s, t, d = gets.split.map(&:to_i)\n  g[s] << Edge.new(t, d)\nend\n\ndijkstra(g, r).each do |sum|\n  puts (sum == Float::INFINITY ? 'INF' : sum)\nend", "label": 0, "name1": "s947131740.java", "name2": "s587327683.rb"}, {"id": 218, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[] fact = new int[9];\n\n\n\tpublic static void main(String[] args) {\n\t\tfact[1] = 1;\n\t\tfor(int i = 2; i <= 8; i++)\n\t\t\tfact[i] = fact[i-1] * i;\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] p = new int[n];\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tp[i] = sc.nextInt();\n\n\t\tint[] q = new int[n];\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tq[i] = sc.nextInt();\n\n\t\tint ans = Math.abs(getPosi(p) - getPosi(q));\n\t\tSystem.out.println(ans);\n        return;\n    }\n\n\tstatic private int getPosi(int[] x) {\n\n\t\t\tint l = x.length;\n\t\t\tint p = 1;\n\n\t\t\tfor(int i = 0; i < l; i++) {\n\t\t\t\tp += fact[l-i-1] * (x[i]-1);\n\t\t\t\tfor(int j = i+1; j < l; j++) {\n\t\t\t\t\tif(x[j] > x[i])\n\t\t\t\t\t\tx[j]--;\n\t\t\t\t}\n\t\t\t}\n\t\treturn p;\n\n\t}\n\n}\n\n", "code2": "n = gets.to_i\nps = gets.split(\" \").map(&:to_i)\nq = gets.split(\" \").map(&:to_i)\n\npermu = []\n(1..n).each do |i|\n    permu.push(i)\n    i += 1\nend\n\nflag_p = 0\nflag_q = 0\ncount = 0\n\npermu.permutation(n) do |a|\n    current_permu = a\n    if current_permu == ps\n        flag_p = count\n    end\n    if current_permu == q\n        flag_q = count\n    end\n    count = count + 1\nend\n\nputs (flag_p - flag_q).abs", "label": 1, "name1": "s530732207.java", "name2": "s303474561.rb"}, {"id": 516, "code1": "import java.util.*;\n \npublic class Main{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    double H = sc.nextDouble();\n    double W = sc.nextDouble();\n    if (H != 1 && W != 1)\n\t\t\tSystem.out.println((long) Math.ceil(H * W / 2));\n\t\telse\n\t\t\tSystem.out.println(1);\n  }\n}\n    ", "code2": "until (n = gets.strip.to_i) == 0\n\tpoints = gets.strip.split(\" \").map {|i| i.to_f}\n\tavg = (points.reduce(0.0){|sum, p| sum += p}) / n.to_f\n\tvar = points.reduce(0.0){|sum, p| sum += (p - avg) ** 2} / n.to_f\n\tstd = var ** 0.5\n\tputs std.floor(4)\nend\n", "label": 0, "name1": "s603185414.java", "name2": "s105211939.rb"}, {"id": 395, "code1": "\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scn = new Scanner(System.in);\n\n        long a = scn.nextLong(), b = scn.nextLong(), x = scn.nextLong();\n        long ans = 0;\n\n        ans = (b / x) - (a / x);\n\n        if(a % x == 0){\n            ans++;\n        }\n\n        System.out.println(ans);\n\n    }\n\n}", "code2": "a,b,x=gets.split.map &:to_i\np b/x-~-a/x", "label": 1, "name1": "s378055358.java", "name2": "s895458650.rb"}, {"id": 579, "code1": "import java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\n\n \nclass Main implements Runnable {\n  // static Scanner in;\n  static FastReader in;\n  static PrintWriter out;\n  static int[][] dirs8 = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1, 1}, {-1, -1}, {-1, 1}, {1, -1}};\n  static int[][] dirs = {{0, -1}, {1, 0}, {0, +1}, {-1, 0}};\n \n  static int[][] E;\n  // static List<int[]>[] adj;\n  static List<Integer>[] adj;\n  static int[] vis;\n \n  static long INFL = (long) 1e15 + 7;\n  static int INF = (int) 1e9 + 7;\n  static int mod = 998244353;\n  \n  static int T, n, m, k, count, cur, w;\n  static boolean flag;\n  static int[] a, b;\n  static int[][] map;\n\n  static int[] par;\n  static boolean[] dp;\n\n  static void solve() throws Exception {\n    n = in.nextInt();\n    k = in.nextInt();\n    a = new int[n]; \n    for (int i = 0; i < n; i++) {a[i] = in.nextInt();}\n    dp = new boolean[k + 1];\n    // dp[i]: win(true) or loss(false) if \"I\" have i stones left and I am to play this round\n    dp[0] = false;\n    for (int i = 1; i <= k; i++) {\n      for (int x : a) {\n        if (x > i) {break;}\n        if (!dp[i - x]) {dp[i] = true; break;}\n      }\n    }\n    out.println(dp[k] ? \"First\" : \"Second\");\n  }\n\n\n  public static void main(String[] args) throws Exception {\n \n    // in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n    in = new FastReader();\n    out = new PrintWriter(System.out);\n \n    // int numOfTests = in.nextInt();\n    // for (int caseNum = 1; caseNum <= numOfTests; caseNum++) {\n    //   // Thread t = new Thread(null, new Main(), \"Main\", 1 << 28);\n    //   // t.start();\n    //   // t.join();\n    //   solve();\n    // }\n \n    // // Thread t = new Thread(null, new Main(), \"Main\", 1 << 28);\n    // // t.start();\n    // // t.join();\n    solve();\n \n    out.flush();\n    out.close();\n  }\n \n  @Override\n  public void run() {\n    try {\n      solve();\n    } catch (Exception e) {\n      e.printStackTrace(); \n    }\n  }\n \n  static class FastReader {\n    public BufferedReader br; \n    StringTokenizer st; \n    public FastReader() {br = new BufferedReader(new InputStreamReader(System.in));} \n    String next() { \n      while (st == null || !st.hasMoreElements()) { \n          try {st = new StringTokenizer(br.readLine());} \n          catch (IOException e) {e.printStackTrace();} \n      } \n      return st.nextToken(); \n    } \n    int nextInt() {return Integer.parseInt(next());} \n    long nextLong() {return Long.parseLong(next());} \n    double nextDouble() {return Double.parseDouble(next());} \n    String nextLine() {\n      String str = \"\"; \n        try {str = br.readLine();} \n        catch (IOException e) {e.printStackTrace();} \n        return str; \n    }\n  }\n\n  static void as(boolean result) throws Exception {\n    if (!result) {\n      throw new Exception();\n    }\n  }\n\n  static int modInverse(int a, int m) { \n    int m0 = m; \n    int y = 0, x = 1; \n    if (m == 1) {return 0;} \n    while (a > 1) { \n      // q is quotient \n      int q = a / m; \n      int t = m; \n      // m is remainder now, process \n      // same as Euclid's algo \n      m = a % m; \n      a = t; \n      t = y; \n      // Update x and y \n      y = x - q * y; \n      x = t; \n    } \n    // Make x positive \n    if (x < 0) \n      x += m0; \n    return x; \n  } \n} \n", "code2": "d=*1..gets.to_i;gets.bytes{|c|x=0;N=d.pop;d.map!{|a|x+=-c%3*N+a*=1-c%3;x%=10**9+7}};p N", "label": 0, "name1": "s772358717.java", "name2": "s201614079.rb"}, {"id": 586, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tMyInput in = new MyInput(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic long LINF = 1L << 55;\n\tstatic int MOD = 1000000007;\n\tstatic int[] mh4 = { 0, -1, 1, 0 };\n\tstatic int[] mw4 = { -1, 0, 0, 1 };\n\tstatic int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\tstatic int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n\tstatic class TaskX {\n\n\t\tpublic void solve(int testNumber, MyInput in, PrintWriter out) {\n\n\t\t\tint n = in.nextInt();\n\t\t\tchar[] s = in.nextChars();\n\n\t\t\tlong[][] dp = new long[n+1][n+1];\n\t\t\tArrays.fill(dp[0], 1);\n\n\t\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\t\tif (s[i] == '<') {\n\t\t\t\t\tfor (int j = 0; j < n-i; j++) {\n\t\t\t\t\t\tdp[i+1][j] += dp[i][j];\n\t\t\t\t\t\tdp[i+1][j] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (int j = 0; j < n-i; j++) {\n\t\t\t\t\t\tdp[i+1][0] += dp[i][j];\n\t\t\t\t\t\tdp[i+1][j] -= dp[i][j] - MOD;\n\t\t\t\t\t\tdp[i+1][0] %= MOD;\n\t\t\t\t\t\tdp[i+1][j] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 1; j < n-1-i; j++) {\n\t\t\t\t\tdp[i+1][j] += dp[i+1][j-1];\n\t\t\t\t\tdp[i+1][j] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout.println(dp[n-1][0]);\n\n\t\t}\n\t}\n\n\tstatic class MyInput {\n\t\tprivate final BufferedReader in;\n\t\tprivate static int pos;\n\t\tprivate static int readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500 * 8 * 2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic {\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tisDigit['0' + i] = true;\n\t\t\t}\n\t\t\tisDigit['-'] = true;\n\t\t\tisSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n\t\t\tisLineSep['\\r'] = isLineSep['\\n'] = true;\n\t\t}\n\n\t\tpublic MyInput(InputStream is) {\n\t\t\tin = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (pos >= readLen) {\n\t\t\t\tpos = 0;\n\t\t\t\ttry {\n\t\t\t\t\treadLen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException();\n\t\t\t\t}\n\t\t\t\tif (readLen <= 0) {\n\t\t\t\t\tthrow new MyInput.EndOfFileRuntimeException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buffer[pos++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\tint i = 0;\n\t\t\tint ret = 0;\n\t\t\tif (str[0] == '-') {\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t\tfor (; i < len; i++)\n\t\t\t\tret = ret * 10 + str[i] - '0';\n\t\t\tif (str[0] == '-') {\n\t\t\t\tret = -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\tint i = 0;\n\t\t\tlong ret = 0;\n\t\t\tif (str[0] == '-') {\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t\tfor (; i < len; i++)\n\t\t\t\tret = ret * 10 + str[i] - '0';\n\t\t\tif (str[0] == '-') {\n\t\t\t\tret = -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic char nextChar() {\n\t\t\twhile (true) {\n\t\t\t\tfinal int c = read();\n\t\t\t\tif (!isSpace[c]) {\n\t\t\t\t\treturn (char) c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic String nextString() {\n\t\t\treturn new String(nextChars());\n\t\t}\n\n\t\tpublic char[] nextChars() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\treturn Arrays.copyOf(str, len);\n\t\t}\n\n\t\tint reads(int len, boolean[] accept) {\n\t\t\ttry {\n\t\t\t\twhile (true) {\n\t\t\t\t\tfinal int c = read();\n\t\t\t\t\tif (accept[c]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (str.length == len) {\n\t\t\t\t\t\tchar[] rep = new char[str.length * 3 / 2];\n\t\t\t\t\t\tSystem.arraycopy(str, 0, rep, 0, str.length);\n\t\t\t\t\t\tstr = rep;\n\t\t\t\t\t}\n\t\t\t\t\tstr[len++] = (char) c;\n\t\t\t\t}\n\t\t\t} catch (MyInput.EndOfFileRuntimeException e) {\n\t\t\t}\n\t\t\treturn len;\n\t\t}\n\n\t\tpublic int[] nextIntArray(final int n) {\n\t\t\tfinal int[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArray1Index(final int n) {\n\t\t\tfinal int[] res = new int[n + 1];\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArrayDec(final int n) {\n\t\t\tfinal int[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(final int n) {\n\t\t\tfinal long[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray1Index(final int n) {\n\t\t\tfinal long[] res = new long[n + 1];\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArrayDec(final int n) {\n\t\t\tfinal long[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic double[] nextDoubleArray(int n) {\n\t\t\tdouble[] res = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextDouble();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\t}\n\n\t}\n\n}\n", "code2": "#!/usr/bin/env ruby\n\nrequire 'set'\n\nclass Hash\n  def push(key, value)\n    self[key] = [] if self[key] == nil\n    self[key].push(value)\n  end\nend\n\nclass Array\n  def lower_bound(value)\n    left = -1;\n    right = self.length;\n    while left + 1 < right\n      mid = left + (right - left) / 2;\n      if self[mid] >= value\n        right = mid\n      else\n        left = mid\n      end\n    end\n    right\n  end\n\n  def unique\n    res = [self.first]\n    each_cons(2) do |a, b|\n      if a != b\n        res.push(b)\n      end\n    end\n    res\n  end\nend\n\ndef get_ints\n  gets.chomp.split.map(&:to_i)\nend\n\ndef get_ints_minus_one\n  get_ints.map { |x| x - 1 }\nend\n\ndef get_int\n  gets.chomp.to_i\nend\n\nA, B, C = get_ints\n\nsum = A + B + C\nstock = [A, B, C].max * 3\n\nwaru = (stock - sum)/2\namari = (stock - sum) % 2\n\nputs waru + (amari == 1 ? 2 : 0)\n", "label": 0, "name1": "s819730919.java", "name2": "s046246097.rb"}, {"id": 254, "code1": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n\n        char[] s = sc.next().toCharArray();\n        char[] t = sc.next().toCharArray();\n\n        boolean isAns = false;\n        for (int i = s.length-1; i >= t.length-1; i--) {\n            char[] tmp = s.clone();\n            isAns = true;\n            for (int j = 0; j < t.length; j++) {\n                if (s[i-j] == t[t.length-1-j] || s[i-j] == '?') {\n                    tmp[i-j] = t[t.length-1-j];\n                } else {\n                    isAns = false;\n                    break;\n                }\n            }\n\n            if (isAns) {\n                s = tmp;\n                break;\n            }\n        }\n\n        if (isAns) {\n            for (char c : s)\n                System.out.print(c == '?' ? 'a' : c);\n        } else {\n            System.out.println(\"UNRESTORABLE\");\n        }\n    }\n\n    static class MyScanner {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in), 1 << 15);\n        StringTokenizer tokenizer;\n\n        String next() {\n            try {\n                while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                }\n            } catch (IOException ignored) {\n            }\n            return tokenizer.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}", "code2": "WORM_EATEN_S = STDIN.gets.strip!\nHINT = STDIN.gets.strip!\ncandidates = []\n\ndef apply_hint(given_str, start, hint)\n\n  if start + hint.length > given_str.length\n    return ''\n  end\n\n  applied = Marshal.load(Marshal.dump(given_str))\n\n  (0..hint.length-1).each do |idx|\n    target_char = given_str[start+idx]\n\n    unless ( target_char == '?' || target_char == hint[idx] )\n      return ''\n    end\n\n    applied[start+idx] = hint[idx]\n  end\n\n  return applied\nend\n\n# gather candidate strings\nresult = ''\n(0..WORM_EATEN_S.length-1).each do |idx|\n  result = apply_hint(Marshal.load(Marshal.dump(WORM_EATEN_S)), idx, HINT)\n  candidates.push(result.gsub(/\\?/, 'a')) if result != ''\nend\n\n# print the result\nif candidates.length == 0\n  puts 'UNRESTORABLE'\nelse\n  puts candidates.min\nend\n", "label": 1, "name1": "s842757542.java", "name2": "s297009778.rb"}, {"id": 994, "code1": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nclass Main {\n    static final int MOD = 1000000007;\n    static final int INF = 1 << 30;\n\n    Main() {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.next();\n        for (int i=1; i < s.length(); i++) {\n            String a = s.substring(0, (s.length()-i)/2);\n            String b = s.substring((s.length()-i)/2,s.length()-i);\n            if(a.equals(b)){\n                System.err.println(a);\n                System.out.println(s.length()-i);\n                return;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main();\n    }\n}\n", "code2": "### main\n\nwhile true\n  t = gets.strip.to_i\n  break if t == 0\n\n  n = gets.strip.to_i\n\n  sum = 0\n  n.times do\n    ts, tf = gets.strip.split(' ').map{|s| s.to_i}\n    sum += (tf - ts)\n  end\n\n  puts (sum >= t ? 'OK' : t - sum)\nend", "label": 0, "name1": "s734506720.java", "name2": "s837017781.rb"}, {"id": 736, "code1": "import java.util.*;\nimport java.io.*;\n\npublic class Main implements Runnable {\n    public static void main(String[] args) {\n        Thread.setDefaultUncaughtExceptionHandler((t,e)->System.exit(1));\n        // keep stack\n        new Thread(null, new Main(), \"\", 16 * 1024 * 1024).start();\n    }\n    public void run() {\n        FastScanner sc = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        long X = sc.nextLong();\n        long Y = sc.nextLong();\n\n        long count = 1;\n        while(true) {\n            long A = X * 2;\n            if (Y < A) {\n                break;\n            }\n            X = A;\n            count++;\n        }\n        out.printf(\"%d\\n\", count);\n        out.flush();\n    }\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        } else {\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int readByte() {\n        if (hasNextByte()) {\n            return buffer[ptr++];\n        }\n        else {\n            return -1;\n        }\n    }\n\n    private static boolean isPrintableChar(int c) {\n        return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n        while (hasNextByte() && !isPrintableChar(buffer[ptr])) {\n            ptr++;\n        }\n    }\n\n    public boolean hasNext() {\n        skipUnprintable();\n        return hasNextByte();\n    }\n\n    public String next() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public int nextInt() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        int n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b)) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n\n    public long nextLong() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b)) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}", "code2": "def dijkstra(g, s)\n  def enq(pq, val)\n    pq << val\n    cd = pq.size\n    pr = cd / 2\n    until pr.zero? || (pq[pr - 1] <=> pq[cd - 1]) < 0\n      pq[pr - 1], pq[cd - 1] = pq[cd - 1], pq[pr - 1]\n      cd = pr\n      pr = cd / 2\n    end\n  end\n\n  def deq(pq)\n    pq[0], pq[-1] = pq[-1], pq[0]\n    rs = pq.delete_at(-1)\n    unless pq.empty?\n      pr = 1\n      cd = [pr * 2, pr * 2 + 1].select { |i| pq[i - 1] }.min_by { |i| pq[i - 1] }\n      until cd.nil? || (pq[pr - 1] <=> pq[cd - 1]) < 0\n        pq[pr - 1], pq[cd - 1] = pq[cd - 1], pq[pr - 1]\n        pr = cd\n        cd = [pr * 2, pr * 2 + 1].select { |i| pq[i - 1] }.min_by { |i| pq[i - 1] }\n      end\n    end\n    rs\n  end\n\n  pq = []\n  d = Array.new(g.size) { Float::INFINITY }\n  d[s] = 0\n  enq(pq, [0, s])\n\n  until pq.empty?\n    v_cost, v = deq(pq)\n    next if d[v] < v_cost\n    g[v].each do |e|\n      if d[e.to] > d[v] + e.cost\n        d[e.to] = d[v] + e.cost\n        enq(pq, [d[e.to], e.to])\n      end\n    end\n  end\n\n  d\nend\n\nEdge = Struct.new('Edge', :to, :cost)\n\nv, e, r = gets.split.map(&:to_i)\ng = Array.new(v) { [] }\ne.times do\n  s, t, d = gets.split.map(&:to_i)\n  g[s] << Edge.new(t, d)\nend\n\ndijkstra(g, r).each do |sum|\n  puts (sum == Float::INFINITY ? 'INF' : sum)\nend", "label": 0, "name1": "s869503854.java", "name2": "s716711304.rb"}, {"id": 909, "code1": "import java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int h = scanner.nextInt();\n        int w = scanner.nextInt();\n        String[] letters = new String[h];\n\n        int[] occurrences = new int[26];\n        int numOfFours = 0;\n        int numOfTwos = 0;\n        int numOfOnes = 0;\n\n        for (int i = 0; i < letters.length; i++) {\n            letters[i] = scanner.next();\n            for (int j = 0; j < letters[i].length(); j++) {\n                occurrences[letters[i].charAt(j) - 'a']++;\n            }\n        }\n        boolean isPossible = true;\n\n        if (h % 2 == 0 && w % 2 == 0){\n            for (int occurrence : occurrences) {\n                if (occurrence % 4 != 0) {\n                    isPossible = false;\n                    break;\n                } else numOfFours += (occurrence / 4);\n            }\n\n            if (numOfFours != (h/2)*(w/2)) isPossible = false;\n        }\n        else if (h % 2 == 0 && w % 2 == 1){\n            for (int i = 0; i < occurrences.length; i++) {\n                if (occurrences[i] != 0 && occurrences[i] % 2 == 0){\n                    while (numOfFours < (h/2)*(w/2) && occurrences[i] >= 4){\n                        numOfFours ++;\n                        occurrences[i] -= 4;\n                    }\n                }\n            }\n\n            for (int i = 0; i < occurrences.length; i++) {\n                if (occurrences[i] % 2 != 0){\n                    isPossible = false;\n                    break;\n                }\n                if (occurrences[i] != 0 && occurrences[i] % 2 == 0){\n                    while (numOfTwos < (h/2) && occurrences[i] > 0){\n                        numOfTwos ++;\n                        occurrences[i] -= 2;\n                    }\n                }\n            }\n\n            for (int occurrence : occurrences) {\n                if (occurrence != 0) {\n                    isPossible = false;\n                    break;\n                }\n            }\n\n            if (numOfFours != (h/2)*(w/2) || numOfTwos != (h/2)) isPossible = false;\n        }\n        else if (h % 2 == 1 && w % 2 == 0){\n            for (int i = 0; i < occurrences.length; i++) {\n                if (occurrences[i] != 0 && occurrences[i] % 2 == 0){\n                    while (numOfFours < (h/2)*(w/2) && occurrences[i] >= 4){\n                        numOfFours ++;\n                        occurrences[i] -= 4;\n                    }\n                }\n            }\n\n            for (int i = 0; i < occurrences.length; i++) {\n                if (occurrences[i] % 2 != 0){\n                    isPossible = false;\n                    break;\n                }\n                if (occurrences[i] != 0 && occurrences[i] % 2 == 0){\n                    while (numOfTwos < (w/2) && occurrences[i] > 0){\n                        numOfTwos ++;\n                        occurrences[i] -= 2;\n                    }\n                }\n            }\n\n            for (int occurrence : occurrences) {\n                if (occurrence != 0) {\n                    isPossible = false;\n                    break;\n                }\n            }\n\n            if (numOfFours != (h/2)*(w/2) || numOfTwos != (w/2)) isPossible = false;\n        }\n        else {\n            for (int i = 0; i < occurrences.length; i++) {\n                if (occurrences[i] != 0){\n                    while (numOfFours < (h/2)*(w/2) && occurrences[i] >= 4){\n                        numOfFours ++;\n                        occurrences[i] -= 4;\n                    }\n                }\n            }\n\n            for (int i = 0; i < occurrences.length; i++) {\n                if (occurrences[i] != 0){\n                    while (numOfTwos < ((h/2) + (w/2)) && occurrences[i] >= 2){\n                        numOfTwos ++;\n                        occurrences[i] -= 2;\n                    }\n                }\n            }\n\n            for (int i = 0; i < occurrences.length; i++) {\n                if (occurrences[i] == 1) {\n                    numOfOnes++;\n                    occurrences[i] -= 1;\n                }\n            }\n\n            for (int occurrence : occurrences) {\n                if (occurrence != 0) {\n                    isPossible = false;\n                    break;\n                }\n            }\n\n            if (numOfFours != (h/2)*(w/2) || numOfTwos != (h/2) + (w/2) || numOfOnes != 1) isPossible = false;\n        }\n\n        System.out.println(isPossible?\"Yes\":\"No\");\n    }\n}\n", "code2": "a=[]\na[0] = gets.chomp.split(//)\na[1] = gets.chomp.split(//)\na[2] = gets.chomp.split(//)\nhash={'a'=> 0, 'b'=> 1, 'c'=> 2}\nturn = 'a'\nwhile true\n  if a[hash[turn]].empty?\n    puts turn.upcase\n    break\n  end\n  turn = a[hash[turn]].shift\nend\n\n\n", "label": 0, "name1": "s327920885.java", "name2": "s231209920.rb"}, {"id": 916, "code1": "import java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\t// \u5165\u529b\n\t\tfinal String[] s = new String[3];\n\t\ttry(Scanner scan = new Scanner(System.in)) {\n\t\t\ts[0] = scan.next();\n\t\t\ts[1] = scan.next();\n\t\t\ts[2] = scan.next();\n\t\t}\n\t\t\n\t\tint[] index = {0, -1, -1};\n\t\t\n\n\t\tint next = 0;\n\t\twhile (s[next].length() > index[next]) {\n\t\t\tnext = (int) (s[next].charAt(index[next]) - 'a');\n\t\t\tindex[next]++;\n\t\t}\n\t\t\n\t\tchar result = (char) (next + 'A');\n\t\t\n\t\t// \u51fa\u529b\n\t\ttry (PrintWriter out = new PrintWriter(System.out)) {\n\t\t\tout.println(result);\n\t\t}\n\n\t}\n\n}\n", "code2": "N = gets.to_i\ns = []\nN.times{ s << gets.to_i }\ns.sort!\n\nsum = s.inject(:+)\n\nif sum % 10 != 0\n  \n  puts sum\n  \nelse\n  \n  t = []\n  s.each{ |x| t << x if x % 10 != 0 }\n  \n  if t.size == 0\n    puts 0\n  else\n    puts sum - t[0]\n  end\nend\n", "label": 0, "name1": "s981758342.java", "name2": "s641490234.rb"}, {"id": 87, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tblood_groups();\n\t}\n\n\tprivate static void blood_groups() {\n\t\tint[] bg = new int[4];\n\n\t\twhile (sc.hasNext()) {\n\t\t\tString[] datas = sc.nextLine().split(\",\");\n\n\t\t\tswitch( datas[1] ) {\n\t\t\tcase \"A\":\n\t\t\t\tbg[0]++;\n\t\t\t\tbreak;\n\t\t\tcase \"B\":\n\t\t\t\tbg[1]++;\n\t\t\t\tbreak;\n\t\t\tcase \"AB\":\n\t\t\t\tbg[2]++;\n\t\t\t\tbreak;\n\t\t\tcase \"O\":\n\t\t\t\tbg[3]++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(bg[0]);\n\t\tSystem.out.println(bg[1]);\n\t\tSystem.out.println(bg[2]);\n\t\tSystem.out.println(bg[3]);\n\n\t}\n\n}\n\n", "code2": "count = {\n  \"A\"  => 0,\n  \"B\"  => 0,\n  \"AB\" => 0,\n  \"O\"  => 0\n}\n\nwhile line = gets\n  data = line.chomp.split(\",\")\n  count[data[1]] += 1\nend\n\nputs count[\"A\"]\nputs count[\"B\"]\nputs count[\"AB\"]\nputs count[\"O\"]", "label": 1, "name1": "s776356865.java", "name2": "s431000983.rb"}, {"id": 46, "code1": "import java.util.Scanner;\nimport java.util.Arrays;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\nclass Main{\n          public static void main(String[] args) {\n                  Scanner scan = new Scanner(System.in);\n                  int count = 0;\n                  int N = scan.nextInt();\n                  int a[] = new int[N];\n                  for (int i = 0; i < N; i++) {\n                          a[i] = scan.nextInt();\n                  }\n                  for(int j = 1; j < N; j++){\n                          if (a[j-1] == a[j]) {\n                                  a[j] = 10001;\n                                  count++;\n                          }\n                  }\n                  System.out.println(count);\n                  }\n}\n", "code2": "def main(argv)\n  n = gets.chomp.to_i\n  a = gets.chomp.split(' ').map(&:to_i)\n\n  as = [[]]\n  prev = a[0]\n  n.times do |i|\n    if prev != a[i] then\n      as.push([a[i]])\n      prev = a[i]\n    else\n      as[as.size - 1].push(a[i])\n    end\n  end\n  \n  puts as.map{|a| a.size / 2}.reduce(:+).to_s\nend\n\nif self.to_s == 'main' then\n  main(ARGV)\nend", "label": 1, "name1": "s420774674.java", "name2": "s355654198.rb"}, {"id": 864, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nclass Main {\n\tpublic static void main(String args[]) throws IOException {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tSolver solver = new Solver();\n\t\tsolver.init();\n\t\tsolver.readHead(in.readLine());\n\t\tfor (; solver.hasNext();) {\n\t\t\tsolver.readBody(in.readLine());\n\t\t}\n\t\tsolver.solve();\n\t}\n}\n\nclass Solver {\n\tint N;\n\tint cnt;\n\n\tpublic void init() {\n\t\tN = 0;\n\t\tcnt = 0;\n\t}\n\n\tpublic void readHead(String str) {\n\t\tString[] strArr = str.split(\"\\\\s+\");\n\t\tN = Integer.parseInt(strArr[0]);\n\t\t// System.out.println(N);\n\t\tM = Integer.parseInt(strArr[1]);\n\t\tAC = new int[N + 1];\n\t\tWA = new int[N + 1];\n\t}\n\n\tint M;\n\n\tpublic boolean hasNext() {\n\t\t// return cnt < N;\n\t\treturn cnt < M;\n\t}\n\n\tint[] AC;\n\tint[] WA;\n\n\tpublic void readBody(String str) {\n\t\t// System.out.println(str);\n\t\tString[] strArr = str.split(\"\\\\s+\");\n\t\tint p = Integer.parseInt(strArr[0]);\n\t\tif (AC[p] == 0) {\n\t\t\tif (\"AC\".equals(strArr[1]))\n\t\t\t\tAC[p] = 1;\n\t\t\telse {\n\t\t\t\tWA[p]++;\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t}\n\n\tpublic void solve() {\n\t\tint a = 0;\n\t\tint w = 0;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tif (AC[i] > 0) {\n\t\t\t\ta++;\n\t\t\t\tw += WA[i];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(a + \" \" + w);\n\t}\n}\n", "code2": "def cin\n  gets.split.map(&:to_i)\nend\n\na, b, c, x, y = cin\nans1, ans2, ans3 = 0\nmin, max = [x, y].minmax\n\nans1 = c * max * 2\nans2 = if x >= y\n         c * min * 2 + a * (x - y)\n       else\n         c * min * 2 + b * (y - x)\n       end\n\nans3 = a * x + b * y\nputs [ans1, ans2, ans3].min\n", "label": 0, "name1": "s230790918.java", "name2": "s125556838.rb"}, {"id": 91, "code1": "import java.util.*;\n\npublic class Main{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    long n = sc.nextLong();\n    long k = sc.nextLong();\n\n    long a = n % k;\n    long b = Math.abs(a - k);\n\n    if(a>b){\n      System.out.println(b);\n    }else{\n      System.out.println(a);\n    }\n\n\n  }\n}", "code2": "N, K = gets.chomp.split(\" \").map(&:to_i)\n\ns, m = N.divmod(K)\nputs [N, m, (m-K).abs].min\n", "label": 1, "name1": "s483882254.java", "name2": "s201038310.rb"}, {"id": 40, "code1": "import java.util.Scanner;\npublic class Main { \n    public static void main(String[] args) {\n        try (Scanner sc = new Scanner(System.in)) { \n        while (true) { \n        int n = sc.nextInt(); \n            if (n == 0) { \n            break; \n            } \n            int[] scores = new int[n]; \n            for (int i = 0; i < scores.length; i++) { \n            scores[i] = sc.nextInt(); \n            } \n            double average = 0, variance = 0;\n            for(int i = 0; i < scores.length; i++){ \n                average += scores[i]; \n            } \n            average = average/n; \n            for(int i = 0; i < scores.length; i++){ \n                variance += (scores[i]-average)*(scores[i]-average); \n            }\n            variance = variance/n;\n            System.out.println(Math.sqrt(variance)); \n            } \n        } \n    }\n}\n", "code2": "res=Array.new\nloop do\nn=gets.to_i\nif n==0 then break end\nd=gets.split(' ').map(&:to_f)\nm=d.inject(0.00000){|r,i|r+=i}/d.size\ns=0\nd.each do |x|\n  s+=(x-m)*(x-m)\nend\nres.push(Math.sqrt(s/n))\nend\n\nres.each do |r|\n    printf(\"%f\\n\",r)\nend", "label": 1, "name1": "s272580744.java", "name2": "s936689019.rb"}, {"id": 72, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main{\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint unko=sc.nextInt();\n\t\tboolean ike=false;\n\t\tint N=0;\n\t\tfor(int i=0; i<=500; i++) {\n\t\t\tif(unko==i*(i+1)/2) {\n\t\t\t\tike=true;\n\t\t\t\tN=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(unko<i*(i+1)/2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ike) {\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\tSystem.out.println(N+1);\n\t\t\tint[][] ary=new int[N+1][N];\n\t\t\tint[] kaz=new int[N+2];\n\t\t\tfor(int i=0; i<=N; i++) {\n\t\t\t\tfor(int j=0; j<N; j++) {\n\t\t\t\t\tary[i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<=N+1; i++) {\n\t\t\t\tkaz[i]=0;\n\t\t\t}\n\t\t\tint counter=1;\n\t\t\tfor(int i=1; i<=N+1; i++) {\n\t\t\t\tfor(int j=1; j<i; j++) {\n\t\t\t\t\tary[i-1][kaz[i-1]]=counter;\n\t\t\t\t\tkaz[i-1]++;\n\t\t\t\t\tary[j-1][kaz[j-1]]=counter;\n\t\t\t\t\tkaz[j-1]++;\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tString buri=\"\";\n\t\t\tfor(int i=0; i<N+1; i++) {\n\t\t\t\tburi=Arrays.toString(ary[i]);\n\t\t\t\tburi=buri.replaceAll(\",\",\"\");\n\t\t\t\tburi=buri.replace(\"[\",\" \");\n\t\t\t\tburi=buri.replace(\"]\",\"\");\n\t\t\t\tSystem.out.println(N+buri);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t}\n}", "code2": "n = gets.chomp.to_i\n\nif n == 1\n  puts 'Yes'\n  puts '2'\n  puts '1 1'\n  puts '1 1'\n  exit\nend\n\nif n == 3\n  puts 'Yes'\n  puts '3'\n  puts '2 1 2'\n  puts '2 3 1'\n  puts '2 2 3'\n  exit\nend\n\noks = [1]\n2.upto(10**5) do |i|\n  if i == (oks.last + oks.size + 1)\n    oks.push(i)\n  end\nend\n\nif !oks.include?(n)\n  puts 'No'\n  exit\nend\n\nnum = oks.index(n) + 1\n\nans = Array.new(num + 1) { Array.new }\ncounts = Array.new(n, 0)\n\ni = 1\n(1..num + 1).to_a.combination(2) do |a, b|\n  ans[a-1].push(i)\n  ans[b-1].push(i)\n   i += 1\nend\n\nputs 'Yes'\np num + 1\nans.each do |an|\n  puts \"#{an.size} #{an.join(' ')}\"\nend\n", "label": 1, "name1": "s468399402.java", "name2": "s963991485.rb"}, {"id": 259, "code1": "import java.util.*;\n \nclass Main{\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n \n        String S = sc.next();\n        String T = sc.next();\n        int ls = S.length();\n        int lt = T.length();\n        String a = \"?\";\n\n        if(ls<lt){\n            System.out.println(\"UNRESTORABLE\");\n            return;\n        }\n        int x = -1;\n        for(int i=0; i<=ls-lt; i++){\n            if(S.charAt(i)==T.charAt(0) || S.charAt(i)==a.charAt(0)){\n                for(int j=0; j<lt; j++){\n                    if(S.charAt(i+j)!=T.charAt(j) && S.charAt(i+j)!=a.charAt(0)){\n                        break;\n                    }\n                    if(j==lt-1){\n                        x = i;\n                    }\n                }\n            }\n        }\n        if(x==-1){\n            System.out.println(\"UNRESTORABLE\");\n            return;\n        }\n        else if(ls==lt){\n            S = T;\n            System.out.println(S);\n            return;\n        }\n        else if(x==0){\n            S = T + S.substring(lt);\n        }\n        else if(x!=0){\n            if(x+lt-1==ls){\n                S = S.substring(0, x) + T;\n            }\n            else{\n                S = S.substring(0, x) + T + S.substring(x + lt);\n            }\n        }\n        String st = \"\";\n        for(int i=0; i<ls; i++){\n            if(S.charAt(i)==a.charAt(0)){\n                st += \"a\";\n            }\n            else{\n                st += String.valueOf((char)S.charAt(i));\n            }\n        }\n        System.out.println(st);\n    }\n}", "code2": "S = gets.chomp.chars\nT = gets.chomp.chars\n\ns = S.length\nt = T.length\n\n(s-t).downto(0).each do |i|\n  check = S[i..i+t-1].zip(T).all?{|a,b| a == b or a == \"?\"}\n  if check\n    retval = S.join.gsub(\"?\", \"a\").chars\n    retval[i..i+t-1] = T\n    puts(retval.join)\n    exit\n  end\nend\n\nputs \"UNRESTORABLE\"", "label": 1, "name1": "s748827885.java", "name2": "s623715533.rb"}, {"id": 604, "code1": "import java.util.*;\npublic class Main{\npublic static void main(String[] args){\nScanner sc = new Scanner(System.in);\n  int Q = sc.nextInt();\n  for(int i=0;i<Q;i++){\n    long f = sc.nextLong();\n    long s = sc.nextLong();\n    long a = Math.max(f, s);\n    long b = Math.min(f, s);\n    long K = a*b;\n    long L = (long) Math.sqrt(K);\n    long M = (K-1)/L;\n    long N = Math.max(-1,M-b-1);\n    System.out.println(L+N+b-1);\n  }\n}}\n", "code2": "X = gets.chomp\n\nchars = Array.new(X.size) {0}\nsp = 0\n\ndecrease = 0\nX.chars.each_with_index do |s, i|\n  if s == 'S'\n    sp += 1\n  else\n    next if sp == 0\n    sp -= 1\n    decrease += 1\n  end\nend\n\nputs X.size - decrease * 2\n", "label": 0, "name1": "s709576716.java", "name2": "s860052839.rb"}, {"id": 781, "code1": "import java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n    static void solve() {\n        int n = nextInt();\n\n        long ans = nextLong();\n//        System.out.println(ans);\n        for (int i = 1; i < n; i++) {\n            long t = nextLong();\n            ans = lcm(ans, t);\n//            System.out.println(ans);\n        }\n        out.println(ans);\n    }\n\n    static final int MOD = 1_000_000_007;\n    static long[] fac, finv, inv;\n\n    // nCk\u306e\u521d\u671f\u5316\n    static void comInit(int max) {\n        fac = new long[max];\n        finv = new long[max];\n        inv = new long[max];\n        fac[0] = fac[1] = 1;\n        finv[0] = finv[1] = 1;\n        inv[1] = 1;\n\n        for (int i = 2; i < max; i++) {\n            fac[i] = fac[i - 1] * i % MOD;\n            inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n            finv[i] = finv[i - 1] * inv[i] % MOD;\n        }\n    }\n\n    // nCk\u306e\u8a08\u7b97\n    static long com(int n, int k) {\n        if (n < k)\n            return 0;\n        if (n < 0 || k < 0)\n            return 0;\n        return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n    }\n\n    static PrintWriter out;\n    static Scanner sc;\n\n    static int[][] newIntArray(int h, int w, int value) {\n        int[][] ret = new int[h][w];\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                ret[i][j] = value;\n            }\n        }\n        return ret;\n    }\n\n    static int nextInt() {\n        return Integer.parseInt(sc.next());\n    }\n\n    static long nextLong() {\n        return Long.parseLong(sc.next());\n    }\n\n    static String nextString() {\n        return sc.next();\n    }\n\n    static int[] nextIntArray(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = nextInt();\n        }\n        return a;\n    }\n\n    static List<Integer> nextIntList(int n) {\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add(nextInt());\n        }\n        return list;\n    }\n\n    static List<Double> nextDoubleList(int n) {\n        List<Double> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add((double) nextInt());\n        }\n        return list;\n    }\n\n    static List<Long> nextLongList(int n) {\n        List<Long> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add(nextLong());\n        }\n        return list;\n    }\n\n    static char[][] nextCharArray(int h, int w) {\n        char[][] c = new char[h][w];\n        for (int i = 0; i < h; i++) {\n            String str = nextString();\n            for (int j = 0; j < w; j++) {\n                c[i][j] = str.charAt(j);\n            }\n        }\n        return c;\n    }\n\n    static <T extends Comparable<? super T>> void sort(List<T> list) {\n        Collections.sort(list);\n    }\n\n    // greatest common divisor\n    // \u6700\u5927\u516c\u7d04\u6570\n    static long gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    // least common multiple\n    // \u6700\u5c0f\u516c\u500d\u6570\n    static long lcm(long a, long b) {\n        if (a >= b && a % b == 0)\n            return a;\n        if (b > a && b % a == 0)\n            return b;\n\n//        return a * b / gcd(a, b);\n        if (a > b) {\n            return (a / gcd(a, b)) * b;\n        } else {\n            return (b / gcd(a, b)) * a;\n        }\n    }\n\n    // base\u306en\u4e57\u3092\u8a08\u7b97\u3092\u8fd4\u3059\n    static int pow(int base, int n) {\n        int ret = 1;\n        for (int i = 0; i < n; i++) {\n            ret *= base;\n        }\n        return ret;\n    }\n\n    // return n^k mod m\n    static long powMod(long n, long k, long m) {\n        if (k == 0) {\n            return 1;\n        } else if (k % 2 == 1) {\n            return powMod(n, k - 1, m) * n % m;\n        } else {\n            long tmp = powMod(n, k / 2, m);\n            return tmp * tmp % m;\n        }\n    }\n\n    // int\u3092length\u6841\u306ebit\u6587\u5b57\u5217\u306b\u5909\u63db\n    static String toBitString(int length, int n) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = length - 1; i >= 0; i--) {\n            if ((n >> i) % 2 == 1) {\n                sb.append(\"1\");\n            } else {\n                sb.append(\"0\");\n            }\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        out = new PrintWriter(System.out);\n        sc = new Scanner(System.in);\n\n        solve();\n\n        out.flush();\n        sc.close();\n    }\n\n}\n", "code2": "N, K, L = gets.split.map(&:to_i)\n\nroad = [*0..N]\nroad_r = Array.new(N + 1) { 1 }\n\nrail = [*0..N]\nrail_r = Array.new(N + 1) { 1 }\n\ndef root uf, i\n  uf[i] == i ? i : uf[i] = root(uf, uf[i])\nend\n\ndef set_union_find n, uf, rank\n  n.times do\n    x, y = gets.split.map(&:to_i)\n    x = root(uf, x)\n    y = root(uf, y)\n\n    next if x == y\n\n    if rank[x] > rank[y]\n      uf[y] = x\n    else\n      uf[x] = y\n      rank[y] += 1 if rank[x] == rank[y]\n    end\n  end\nend\n\nset_union_find K, road, road_r\nset_union_find L, rail, rail_r\n\nh = Hash.new {|h, k| h[k] = [] }\n(1..N).each do |i|\n  h[[root(road, i), root(rail, i)]] << i\nend\n\nresult = Array.new(N + 1) { 0 }\nh.values.each do |arr|\n  arr.each do |j|\n    result[j] = arr.size\n  end\nend\n\nputs (1..N).map {|i| result[i] }.join(' ')", "label": 0, "name1": "s078472493.java", "name2": "s244848536.rb"}, {"id": 912, "code1": "import java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int h = scanner.nextInt();\n        int w = scanner.nextInt();\n        String[] letters = new String[h];\n\n        int[] occurrences = new int[26];\n        int numOfFours = 0;\n        int numOfTwos = 0;\n        int numOfOnes = 0;\n\n        for (int i = 0; i < letters.length; i++) {\n            letters[i] = scanner.next();\n            for (int j = 0; j < letters[i].length(); j++) {\n                occurrences[letters[i].charAt(j) - 'a']++;\n            }\n        }\n        boolean isPossible = true;\n\n        if (h % 2 == 0 && w % 2 == 0){\n            for (int occurrence : occurrences) {\n                if (occurrence % 4 != 0) {\n                    isPossible = false;\n                    break;\n                } else numOfFours += (occurrence / 4);\n            }\n\n            if (numOfFours != (h/2)*(w/2)) isPossible = false;\n        }\n        else if (h % 2 == 0 && w % 2 == 1){\n            for (int i = 0; i < occurrences.length; i++) {\n                if (occurrences[i] != 0 && occurrences[i] % 2 == 0){\n                    while (numOfFours < (h/2)*(w/2) && occurrences[i] >= 4){\n                        numOfFours ++;\n                        occurrences[i] -= 4;\n                    }\n                }\n            }\n\n            for (int i = 0; i < occurrences.length; i++) {\n                if (occurrences[i] % 2 != 0){\n                    isPossible = false;\n                    break;\n                }\n                if (occurrences[i] != 0 && occurrences[i] % 2 == 0){\n                    while (numOfTwos < (h/2) && occurrences[i] > 0){\n                        numOfTwos ++;\n                        occurrences[i] -= 2;\n                    }\n                }\n            }\n\n            for (int occurrence : occurrences) {\n                if (occurrence != 0) {\n                    isPossible = false;\n                    break;\n                }\n            }\n\n            if (numOfFours != (h/2)*(w/2) || numOfTwos != (h/2)) isPossible = false;\n        }\n        else if (h % 2 == 1 && w % 2 == 0){\n            for (int i = 0; i < occurrences.length; i++) {\n                if (occurrences[i] != 0 && occurrences[i] % 2 == 0){\n                    while (numOfFours < (h/2)*(w/2) && occurrences[i] >= 4){\n                        numOfFours ++;\n                        occurrences[i] -= 4;\n                    }\n                }\n            }\n\n            for (int i = 0; i < occurrences.length; i++) {\n                if (occurrences[i] % 2 != 0){\n                    isPossible = false;\n                    break;\n                }\n                if (occurrences[i] != 0 && occurrences[i] % 2 == 0){\n                    while (numOfTwos < (w/2) && occurrences[i] > 0){\n                        numOfTwos ++;\n                        occurrences[i] -= 2;\n                    }\n                }\n            }\n\n            for (int occurrence : occurrences) {\n                if (occurrence != 0) {\n                    isPossible = false;\n                    break;\n                }\n            }\n\n            if (numOfFours != (h/2)*(w/2) || numOfTwos != (w/2)) isPossible = false;\n        }\n        else {\n            for (int i = 0; i < occurrences.length; i++) {\n                if (occurrences[i] != 0){\n                    while (numOfFours < (h/2)*(w/2) && occurrences[i] >= 4){\n                        numOfFours ++;\n                        occurrences[i] -= 4;\n                    }\n                }\n            }\n\n            for (int i = 0; i < occurrences.length; i++) {\n                if (occurrences[i] != 0){\n                    while (numOfTwos < ((h/2) + (w/2)) && occurrences[i] >= 2){\n                        numOfTwos ++;\n                        occurrences[i] -= 2;\n                    }\n                }\n            }\n\n            for (int i = 0; i < occurrences.length; i++) {\n                if (occurrences[i] == 1) {\n                    numOfOnes++;\n                    occurrences[i] -= 1;\n                }\n            }\n\n            for (int occurrence : occurrences) {\n                if (occurrence != 0) {\n                    isPossible = false;\n                    break;\n                }\n            }\n\n            if (numOfFours != (h/2)*(w/2) || numOfTwos != (h/2) + (w/2) || numOfOnes != 1) isPossible = false;\n        }\n\n        System.out.println(isPossible?\"Yes\":\"No\");\n    }\n}\n", "code2": "n = gets.chomp.to_i\ns = []\nssum = 0\nn.times do\n  x = gets.chomp.to_i\n  ssum += x\n  s << x\nend\n\ns.sort!\nif ssum % 10 == 0 then\n  while x = s.shift\n    if x % 10 != 0 then\n      puts ssum - x\n      exit\n    end\n  end\n  puts 0\nelse\n  puts ssum\nend\n", "label": 0, "name1": "s327920885.java", "name2": "s862645033.rb"}, {"id": 598, "code1": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String args[]) {\n\tScanner sc = new Scanner(System.in);\n\n\twhile (true) {\n\t    int n = sc.nextInt();\n\t    int ans = 0;\n\t    if (n == 0) {\n\t\tbreak;\n\t    }\n\t    \n\t    ans = solve(n);\n\t    System.out.println(ans);\n\t}\n    }\n\n    public static int solve(int n) {\n\t//int max = 123456 * 2;\n\t//int prime[] = new prime[123456 * 2 + 1];\n\tboolean is_prime[] = new boolean[123456 * 2 + 1];\n\tint count = 0;\n\n\t//int p = 0;\n\tfor (int i = 0; i <= 2 * n; i++) {\n\t    is_prime[i] = true;\n\t}\n\n\tis_prime[0] = is_prime[1] = false;\n\tfor (int i = 2; i <= 2 * n; i++) {\n\t    if (is_prime[i]) {\n\t\t// prime[p++] = i;\n\t\tfor (int j = 2 * i; j <= 2 * n; j += i) {\n\t\t    is_prime[j] = false;\n\t\t}\n\t    }\n\t}\n\tfor (int i = n + 1; i <= 2 * n; i++) {\n\t    if (is_prime[i]) {\n\t\tcount++;\n\t    }\n\t}\n\t\n\treturn count;\n    }\n}", "code2": "#!/usr/bin/env ruby\n\nrequire 'set'\n\nclass Hash\n  def push(key, value)\n    self[key] = [] if self[key] == nil\n    self[key].push(value)\n  end\nend\n\nclass Array\n  def lower_bound(value)\n    left = -1;\n    right = self.length;\n    while left + 1 < right\n      mid = left + (right - left) / 2;\n      if self[mid] >= value\n        right = mid\n      else\n        left = mid\n      end\n    end\n    right\n  end\n\n  def unique\n    res = [self.first]\n    each_cons(2) do |a, b|\n      if a != b\n        res.push(b)\n      end\n    end\n    res\n  end\nend\n\ndef get_ints\n  gets.chomp.split.map(&:to_i)\nend\n\ndef get_ints_minus_one\n  get_ints.map { |x| x - 1 }\nend\n\ndef get_int\n  gets.chomp.to_i\nend\n\nQ = get_int\nQ.times do |i|\n  a, b = get_ints\n\n  if a == b\n    puts 2 * (a-1)\n    next\n  end\n  min = [a, b].min\n  max = [a, b].max\n\n  ab = a * b\n\n  high = max - 1\n  low = min\n  while high - low > 1\n    mid = low + (high - low) / 2\n\n    if mid ** 2 >= ab\n      high = mid\n    else\n      low = mid\n    end\n  end\n\n  high, low = [high, low].max, [high, low].min\n  rest = if high * high < ab\n    high + high - min - 1\n  elsif high * low < ab\n    high + low - min - 1\n  else\n    low + low - min - 1\n  end\n\n  puts min - 1 + rest\n\n  # ab = a * b\n  # b_down = (ab/(a+1)).then { |x| x * (a+1) == ab ? x - 1 : x }\n  # b_down_amari = b - b_down - 1\n  #\n  # a_down = (ab/(b+1)).then { |x| x * (b+1) == ab ? x - 1 : x }\n  # a_down_amari = a - a_down - 1\n  #\n  # binding.pry if a == 22\n  # puts b_down + a_down + [a_down_amari, b_down_amari].min\nend\n", "label": 0, "name1": "s027703193.java", "name2": "s516108110.rb"}, {"id": 321, "code1": "\npublic class Main {\n\n  static int mod = 1000003;\n  static int[][] fif = enumFIF(mod * 3, mod);\n\n  private static void solve() {\n    int q = ni();\n\n    for (int i = 0; i < q; i++) {\n      int x = ni();\n      int d = ni();\n      int n = ni();\n      out.println(f(x, d, n));\n    }\n  }\n\n  private static long f(int x, int d, int n) {\n    if (x == 0) {\n      return 0;\n    } else if (d == 0) {\n      return pow(x, n, mod);\n    }\n\n    int y = (int) (x * invl(d, mod) % mod);\n    if (n >= mod || y % mod > (y + n - 1) % mod) {\n      return 0;\n    }\n\n    long z = fif[0][y + n - 1] * invl(fif[0][y - 1], mod) % mod;\n    z *= pow(d, n, mod);\n    z %= mod;\n\n    return z;\n  }\n\n  public static long pow(long a, long n, long mod) {\n    // a %= mod;\n    long ret = 1;\n    int x = 63 - Long.numberOfLeadingZeros(n);\n    for (; x >= 0; x--) {\n      ret = ret * ret % mod;\n      if (n << 63 - x < 0)\n        ret = ret * a % mod;\n    }\n    return ret;\n  }\n\n\n  public static int[][] enumFIF(int n, int mod) {\n    int[] f = new int[n + 1];\n    int[] invf = new int[n + 1];\n    f[0] = 1;\n    for (int i = 1; i <= n; i++) {\n      f[i] = (int) ((long) f[i - 1] * i % mod);\n    }\n    long a = f[n];\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    invf[n] = (int) (p < 0 ? p + mod : p);\n    for (int i = n - 1; i >= 0; i--) {\n      invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n    }\n    return new int[][] {f, invf};\n  }\n\n  public static long invl(long a, long mod) {\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    return p < 0 ? p + mod : p;\n  }\n\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n\n", "code2": "o=->a,n{n<1?1:a**n[0]*o[a,n/2]**2%M}\nf=f=1,*(1..M=1000003).map{|i|f=f*i%M}\ngets\n$<.map{|s|x,d,n=s.split.map &:to_i\np d<1?o[x,n]:(u=f[n+t=x*o[d,M-2]%M-1])?u*o[f[t],M-2]*o[d,n]%M: 0}", "label": 1, "name1": "s606179301.java", "name2": "s369167080.rb"}, {"id": 279, "code1": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String args[])\n    {\n        Scanner sc=new Scanner(System.in);\n       int ar[]=new int[] {0,0,0,0};\n       for(int i=0;i<3;i++)\n       {\n           int a=sc.nextInt();\n           int b=sc.nextInt();\n           ar[a-1]+=1;\n           ar[b-1]+=1;\n       }\n       \n       for(int i = 0; i < 4; i++) {\n\t\t\tif(ar[i] < 1 || ar[i] > 2) {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"YES\");\n       \n//       for(int i:ar)\n//       {\n//           if(i>2)\n//           {\n//               System.out.println(\"NO\");\n//               System.exit(0);\n//           }\n//       }\n//       System.out.println(\"YES\");\n    }\n}", "code2": "array =[]\nfor i in (0..2)\n  array[i]=gets.split(\" \").map{|a| a.to_i}\nend\nanswer =\"YES\"\nfor i in(1..4)\n  num =0\n  array.each{|a|\n  if a.include?(i) then\n    num +=1\n  end\n  if num ==3\n    answer = \"NO\"\n  end\n  }\nend\nputs answer\n", "label": 1, "name1": "s048278962.java", "name2": "s124375185.rb"}, {"id": 101, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in);) {\n\t\t\tdouble a = sc.nextDouble();\n\t\t\tdouble b = sc.nextDouble();\n\t\t\tdouble c = sc.nextDouble();\n\t\t\t//\uff12\u70b9\u9593\u306e\u8ddd\u96e2\n\t\t\tdouble s = (a * b / 2 * Math.sin(Math.toRadians(c)));\n\t\t\t\tSystem.out.println(s);\n\t\t\tdouble l = (a + b +Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) - 2 * a * b\n\t\t\t\t\t* Math.cos(Math.toRadians(c))));\n\t\t\t\tSystem.out.println(l);\n\t\t\tdouble h = (b * Math.sin(Math.toRadians(c)));\n\t\t\t\tSystem.out.println(h);\n\t\t}\n\t}\n}\n", "code2": "inputs = gets.strip.split(\" \").map{|i| i.to_f}\na, b, c = inputs[0], inputs[1], inputs[2]\nrad_c = (Math::PI / 180.0) * c \nd = Math.sqrt(a**2 + b**2 - 2*a*b*Math.cos(rad_c))\ns = 0.5 * a * b * Math.sin(rad_c)\nl = a + b + d\nh = 2*s / a\nputs s.floor(4)\nputs l.floor(4)\nputs h.floor(4)\n", "label": 1, "name1": "s947759194.java", "name2": "s843747761.rb"}, {"id": 701, "code1": "import java.util.*;\npublic class Main {\n\tstatic int yono;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tArrayList<Integer> al = new ArrayList<Integer>();\n\t\tint N = Integer.parseInt(sc.next());\n\t\tyono = N - 1;\n\t\tint M = sc.nextInt();\n\t\ttree = new int[N];\n\t\tArrays.fill(tree, -1);\n\t\tfor (int i = 0; i < M; i++)union(Integer.parseInt(sc.next()) - 1, Integer.parseInt(sc.next()) - 1);\n\t\tSystem.out.println(yono);\n\t}\n\t\n\tstatic int[] tree;\n\tstatic void union(int x, int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif(x != y) {\n\t\t\tyono--;\n\t\t\tif(tree[x] < tree[y]) {\n\t\t\t\tx ^= y; y ^= x; x^= y;\n\t\t\t}\n\t\t\ttree[x] += tree[y];\n\t\t\ttree[y] = x;\n\t\t}\n\t}\n\tstatic boolean find(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tstatic int root(int x) {\n\t\treturn tree[x] < 0 ? x : (tree[x] = root(tree[x]));\n\t}\n}", "code2": "f=f=1,*(1..m=1000003).map{f=f*_1%m}\ngets\n$<.map{x,d,n=_1.split.map &:to_i\np d<1?x.pow(n,m):(u=f[n+t=x*d.pow(m-2,m)%m-1])?u*f[t].pow(m-2,m)*d.pow(n,m)%m:0}", "label": 0, "name1": "s179713562.java", "name2": "s744865172.rb"}, {"id": 844, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.util.Comparator;\nimport java.util.Collections;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        final static long INF = (long) 4.1e18;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            long L = 2L * in.nextInt();\n            long T = in.nextInt() * 2L;\n            TaskC.Chameleon[] chameleon = new TaskC.Chameleon[n];\n            int[] cnt = new int[3];\n            for (int i = 0; i < n; ++i) {\n                chameleon[i] = new TaskC.Chameleon();\n                chameleon[i].start = in.nextInt() * 2L;\n                chameleon[i].color = 0;\n                chameleon[i].dir = in.nextInt() == 1 ? 1 : -1;\n                chameleon[i].indexInInput = i;\n                ++cnt[chameleon[i].dir + 1];\n            }\n\n            // Determine new positions\n            for (TaskC.Chameleon c : chameleon) {\n                c.newPos = ((c.start + T * c.dir) % L + L) % L;\n            }\n\n            TaskC.Chameleon[] res;\n\n            if (cnt[0] == 0 || cnt[2] == 0) {\n                // No meetings at all.\n                for (TaskC.Chameleon c : chameleon) {\n                    c.newColor = c.color;\n                }\n                res = chameleon.clone();\n            } else {\n                // Determine new colors\n                {\n                    TaskC.Chameleon[] perm = chameleon.clone();\n                    Arrays.sort(perm, new Comparator<TaskC.Chameleon>() {\n                        public int compare(TaskC.Chameleon a, TaskC.Chameleon b) {\n                            if (a.newPos < b.newPos) {\n                                return -1;\n                            } else if (a.newPos > b.newPos) {\n                                return 1;\n                            } else {\n                                return 0;\n                            }\n                        }\n                    });\n\n                    int indNextReverse = 0;\n                    for (int ind = 0; ind < n; ++ind) {\n                        TaskC.Chameleon c = perm[ind];\n                        if (c.dir > 0)\n                            c.newColor = c.color;\n                        else {\n                            while (perm[indNextReverse].dir < 0)\n                                indNextReverse = (indNextReverse + 1) % n;\n                            TaskC.Chameleon d = perm[indNextReverse];\n                            long delta = c.start - d.start;\n                            if (delta < 0)\n                                delta += L;\n                            if (delta <= 2 * T) {\n                                // There was at least one change of color!\n                                c.newColor = d.color;\n                            } else {\n                                c.newColor = c.color;\n                            }\n                        }\n                        if (indNextReverse == ind)\n                            indNextReverse = (indNextReverse + 1) % n;\n                    }\n                }\n\n                TaskC.Chameleon first;\n                TaskC.Chameleon firstMapsTo;\n                // Detemine which chameleon did the first one become\n                {\n                    List<TaskC.Chameleon> positive = new ArrayList<TaskC.Chameleon>();\n                    List<TaskC.Chameleon> negative = new ArrayList<TaskC.Chameleon>();\n                    for (TaskC.Chameleon c : chameleon) {\n                        if (c.dir == 1)\n                            positive.add(c);\n                        else\n                            negative.add(c);\n                    }\n                    Collections.sort(positive, new Comparator<TaskC.Chameleon>() {\n                        public int compare(TaskC.Chameleon a, TaskC.Chameleon b) {\n                            if (a.start < b.start) {\n                                return -1;\n                            } else if (a.start > b.start) {\n                                return 1;\n                            } else {\n                                return 0;\n                            }\n                        }\n                    });\n                    Collections.sort(negative, new Comparator<TaskC.Chameleon>() {\n                        public int compare(TaskC.Chameleon a, TaskC.Chameleon b) {\n                            if (a.start < b.start) {\n                                return -1;\n                            } else if (a.start > b.start) {\n                                return 1;\n                            } else {\n                                return 0;\n                            }\n                        }\n                    });\n                    first = positive.get(0);\n                    TaskC.Chameleon closestNegative = negative.get(0);\n                    long deltaBest = closestNegative.start - first.start;\n                    if (deltaBest < 0)\n                        deltaBest += L;\n                    for (TaskC.Chameleon c : negative) {\n                        long deltaCur = c.start - first.start;\n                        if (deltaCur < 0)\n                            deltaCur += L;\n                        if (deltaCur < deltaBest) {\n                            closestNegative = c;\n                            deltaBest = deltaCur;\n                        }\n                    }\n                    long timeLeft = T;\n                    if (timeLeft < deltaBest / 2) {\n                        // The first chameleon stayed himself\n                        firstMapsTo = first;\n                    } else {\n                        timeLeft -= deltaBest / 2;\n                        List<Long> positiveDeltas = new ArrayList<Long>();\n                        positiveDeltas.add(0L);\n                        long sum = 0;\n                        for (int i = 0; i < positive.size(); ++i) {\n                            long delta = positive.get((positive.size() - i) % positive.size()).start - positive.get((positive.size() - i - 1) % positive.size()).start;\n                            if (delta < 0)\n                                delta += L;\n                            sum += delta;\n                            positiveDeltas.add(sum);\n                        }\n                        int shift = negative.indexOf(closestNegative);\n                        List<Long> negativeDeltas = new ArrayList<Long>();\n                        negativeDeltas.add(0L);\n                        sum = 0;\n                        for (int i = 0; i < negative.size(); ++i) {\n                            long delta = negative.get((shift + i + 1) % negative.size()).start - negative.get((shift + i) % negative.size()).start;\n                            if (delta < 0)\n                                delta += L;\n                            sum += delta;\n                            negativeDeltas.add(sum);\n                        }\n                        long l = 0;\n                        long r = INF;\n                        while (r - l > 1) {\n                            long m = (l + r) / 2;\n                            long cntPositive = (m + 1) / 2;\n                            long cntNegative = m / 2;\n                            long positiveTimeSpent = mulWithInf(cntPositive / positive.size(), L) + positiveDeltas.get((int) (cntPositive % positive.size()));\n                            long negativeTimeSpent = mulWithInf(cntNegative / negative.size(), L) + negativeDeltas.get((int) (cntNegative % negative.size()));\n                            if (positiveTimeSpent + negativeTimeSpent <= timeLeft * 2)\n                                l = m;\n                            else\n                                r = m;\n                        }\n                        if (l % 2 == 0) {\n                            firstMapsTo = negative.get((int) ((shift + l / 2) % negative.size()));\n                        } else {\n                            firstMapsTo = positive.get(((int) ((positive.size() - (l + 1) / 2) % positive.size()) + positive.size()) % positive.size());\n                        }\n                    }\n                }\n\n                // Now, create the final mapping!\n                {\n                    TaskC.Chameleon[] firstSortedByPos = chameleon.clone();\n                    Arrays.sort(firstSortedByPos, new Comparator<TaskC.Chameleon>() {\n                        public int compare(TaskC.Chameleon a, TaskC.Chameleon b) {\n                            if (a.start < b.start) {\n                                return -1;\n                            } else if (a.start > b.start) {\n                                return 1;\n                            } else {\n                                return 0;\n                            }\n                        }\n                    });\n                    TaskC.Chameleon[] finalSortedByPos = chameleon.clone();\n                    Arrays.sort(finalSortedByPos, new Comparator<TaskC.Chameleon>() {\n                        public int compare(TaskC.Chameleon a, TaskC.Chameleon b) {\n                            if (a.newPos < b.newPos) {\n                                return -1;\n                            } else if (a.newPos > b.newPos) {\n                                return 1;\n                            } else {\n                                return 0;\n                            }\n                        }\n                    });\n                    int delta = Arrays.asList(finalSortedByPos).indexOf(firstMapsTo) - Arrays.asList(firstSortedByPos).indexOf(first);\n                    res = new TaskC.Chameleon[chameleon.length];\n                    for (int i = 0; i < chameleon.length; ++i) {\n                        res[firstSortedByPos[i].indexInInput] = finalSortedByPos[((i + delta) % chameleon.length + chameleon.length) % chameleon.length];\n                    }\n                }\n            }\n\n            for (TaskC.Chameleon c : res) {\n                out.println(c.newPos / 2);\n            }\n        }\n\n        private long mulWithInf(long a, long b) {\n            if (a == 0)\n                return 0;\n            else if (INF / a <= b)\n                return INF;\n            else\n                return a * b;\n        }\n\n        static class Chameleon {\n            long start;\n            long newPos;\n            int newColor;\n            int color;\n            int dir;\n            int indexInInput;\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "code2": "\nrtimes = []\n\n24.times.each do\n  rn, rt = gets.strip.split(\" \")\n  rtimes << [rn, rt.to_f]\nend\n\nsemifinals = []\nrests = []\n\nfor t in (0..2)\n  race = rtimes[(t * 8), 8].sort{|a, b| a[1] <=> b[1]}\n  semifinals << race.shift\n  semifinals << race.shift\n  rests += race\nend\n\nrests.sort!{|a, b| a[1] <=> b[1]}\nsemifinals << rests.shift\nsemifinals << rests.shift\n\nsemifinals.each{|rn, rt| printf(\"%s %.2f\\n\", rn, rt)}", "label": 0, "name1": "s438673994.java", "name2": "s012250587.rb"}, {"id": 332, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint a = scanner.nextInt(),b = scanner.nextInt(),c = scanner.nextInt();\n\t\tint[] x = {a,b,c};\n\t\tArrays.sort(x);\n\t\tSystem.out.println(x[0]+x[1]);\n\t}\n\n}\n", "code2": "A, B, C = gets.chomp.split(\" \").map(&:to_i)\nputs [A + B, A + C, B + C].min", "label": 1, "name1": "s134824979.java", "name2": "s953311606.rb"}, {"id": 369, "code1": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\tboolean eof;\n\t\n\tlong go(long a, long b, long c) {\n\t\tif (a < 0 || b < 0 || c < 0) {\n\t\t\treturn Long.MIN_VALUE;\n\t\t}\n\t\t\n\t\treturn a + b + c - (a & 1) - (b & 1) - (c & 1);\n\t}\n\n\tvoid solve() throws IOException {\n\t\tlong i = nextLong();\n\t\tlong o = nextLong();\n\t\tlong t = nextLong();\n\t\tlong j = nextLong();\n\t\tlong l = nextLong();\n\t\tlong s = nextLong();\n\t\tlong z = nextLong();\n\t\t\n\t\tlong ans = o + Math.max(go(i, j, l), go(i - 1, j - 1, l - 1) + 3);\n\t\t\n\t\tout.println(ans);\n\t}\n\n\tMain() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e) {\n\t\t\t\teof = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\teof = true;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}", "code2": "a,b,c,d,e,f,g = gets.split.map(&:to_i)\nans = 0\nans += b*2\nans += (a/2)*4\nans += (d/2)*4\nans += (e/2)*4\nif a.odd? && d.odd? && e.odd?\n    ans += 6\nelsif d.odd? && e.odd? && a != 0\n    ans += 2\nelsif a.odd? && ((d.odd? && e != 0) || (e.odd? && d != 0))\n    ans += 2\nend\nputs ans/2", "label": 1, "name1": "s508741257.java", "name2": "s340171115.rb"}, {"id": 153, "code1": "import java.io.*;\nimport java.util.*;\n \npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n \n    static class TaskD {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n \n            int N = in.nextInt();\n            for (int i = 0; i < N; i++) {\n                long A = in.nextLong();\n                long B = in.nextLong();\n \n                long a = Math.min(A, B);\n                long b = Math.max(A, B);\n \n                long ans = 2L * (a - 1) + przedzial(a, b);\n \n                out.println(ans);\n            }\n        }\n \n        private long przedzial(long a, long b) {\n            if (a == b || a + 1 == b) {\n                return 0;\n            }\n \n            return 1L + szukaj(a + 1, b - 2, a * b);\n        }\n \n        private long szukaj(long a, long b, long LIMIT) {\n            if (a > b) return 0;\n            if (a == b) {\n                return a * b < LIMIT ? 1 : 0;\n            }\n            long lo = a, hi = b;\n            while (lo + 1 < hi) {\n                long m = lo + (hi - lo) / 2;\n                if (m * m >= LIMIT) {\n                    hi = m;\n                } else {\n                    lo = m;\n                }\n            }\n            long ans1 = 1 + 2L * (lo - 1 - a + 1);\n            long ans2 = 0;\n            if (lo * (lo + 1) < LIMIT) {\n                ans2 = 2L * (lo - a + 1);\n            }\n            return Math.max(ans1, ans2);\n        }\n    }\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n    }\n}", "code2": "Q = $stdin.gets.chomp.to_i\n\nsums = []\n\nQ.times do |i|\n    # a <= b\n    a, b = $stdin.gets.chomp.split(' ').map(&:to_i).sort\n    prod = a * b\n    sum = 0\n    sum += a - 1\n    sqrt = Math.sqrt(prod)\n    sqrt_f = sqrt == sqrt.floor ? sqrt.floor - 1 : sqrt.floor\n    l = [sqrt_f, a].max\n    sum += l - a\n    r = (prod - 1) / (l + 1)\n    sum += r\n    sums.push(sum)\nend\n\nprint sums.join(\"\\n\")", "label": 1, "name1": "s546530291.java", "name2": "s305871249.rb"}, {"id": 419, "code1": "import java.math.BigInteger;\nimport java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = Integer.parseInt(sc.next());\n\t\tlong m = Long.parseLong(sc.next());\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tm = lcm(m, Long.parseLong(sc.next()));\n\t\tSystem.out.println(m);\n\t}\n\tpublic static long lcm(long m, long n) {\n\t\tBigInteger M = new BigInteger(String.valueOf(m));\n\t\tBigInteger N = new BigInteger(String.valueOf(n));\n\t\tBigInteger G = new BigInteger(String.valueOf(gcd(m, n)));\n\t\treturn M.multiply(N).divide(G).longValue();\n\t}\n\tpublic static long gcd(long m, long n) {\n\t\tif (m < n) {\n\t\t\tlong tem = m;\n\t\t\tm = n;\n\t\t\tn = tem;\n\t\t}\n\t\tlong r = -1;\n\t\twhile (r != 0) {\n\t\t\tr = m % n;\n\t\t\tm = n;\n\t\t\tn = r;\n\t\t}\n\t\treturn m;\n\t}\n}", "code2": "p gets.to_i.times.map{gets.to_i}.reduce(&:lcm)", "label": 1, "name1": "s725061223.java", "name2": "s977919645.rb"}, {"id": 15, "code1": "import java.util.*;\n \nclass Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    \n    String s = sc.next();\n    boolean a = true, b = true;\n \n    for(int i=0;i<s.length();i+=2){\n        if(s.charAt(i) == 'L'){\n            a = false;\n            break;\n        }\n    }\n    \n    for(int i=1;i<s.length();i+=2){\n        if (!a){break;}\n        if(s.charAt(i) == 'R'){\n            b = false;\n            break;\n        }\n    }\n    \n    if(a&&b){System.out.println(\"Yes\");}\n    else{System.out.println(\"No\");}\n  }\n}", "code2": "ary = gets.chomp.chars \nx = ary.each_slice(2).map { |a, b| [a, b] }.transpose\nputs x[0].include?(\"L\") || x[1].include?(\"R\") ? \"No\" : \"Yes\"", "label": 1, "name1": "s301964893.java", "name2": "s268735595.rb"}, {"id": 244, "code1": "import java.util.*;\n\nclass Main {\n    public static void main(String[] args) {\n        new Solver().run();\n    }\n}\n\nclass Solver {\n\n    public void run() {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int[] a = new int[N];\n\n        for (int i = 0; i < N; i++) {\n            a[i] = sc.nextInt();\n            a[i]--;\n        }\n\n        int cnt = 0;\n        for (int i = 0; i < N; i++) {\n            if (i == a[a[i]]) cnt++;\n        }\n\n        System.out.println(cnt / 2);\n\n        return;\n    }\n\n}", "code2": "n = gets.to_i\na = gets.chomp.split(\" \").map(&:to_i)\n\n#b = Array.new(n+1).map{Array.new}\nh = Hash.new{|k,v| k[v]=0}\n\na.each_with_index do |n, i|\n  t = [n, i+1].sort!\n  h[t] += 1\n  #b[n] << i+1\n  #b[i+1] << n\nend\np h.to_a.select{|t| t[1]==2}.size\n\n\n#b.select{|t| }\n", "label": 1, "name1": "s246692563.java", "name2": "s972469766.rb"}, {"id": 668, "code1": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n\n        char[] s = sc.next().toCharArray();\n        char[] t = sc.next().toCharArray();\n\n        boolean isAns = false;\n        for (int i = s.length-1; i >= t.length-1; i--) {\n            char[] tmp = s.clone();\n            isAns = true;\n            for (int j = 0; j < t.length; j++) {\n                if (s[i-j] == t[t.length-1-j] || s[i-j] == '?') {\n                    tmp[i-j] = t[t.length-1-j];\n                } else {\n                    isAns = false;\n                    break;\n                }\n            }\n\n            if (isAns) {\n                s = tmp;\n                break;\n            }\n        }\n\n        if (isAns) {\n            for (char c : s)\n                System.out.print(c == '?' ? 'a' : c);\n        } else {\n            System.out.println(\"UNRESTORABLE\");\n        }\n    }\n\n    static class MyScanner {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in), 1 << 15);\n        StringTokenizer tokenizer;\n\n        String next() {\n            try {\n                while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                }\n            } catch (IOException ignored) {\n            }\n            return tokenizer.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}", "code2": "A, B, C, K = gets.chomp.split(' ').map(&:to_i)\n\nif (A >= K)\n  p K\n  return\nend\n\nif (A + B >= K)\n  p A\n  return\nend\n\np A - (K - (A + B))", "label": 0, "name1": "s842757542.java", "name2": "s053433058.rb"}, {"id": 69, "code1": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\t//\u305d\u308c\u305e\u308c\u306e\u60a3\u8005\u306e\u756a\u53f7 p\n\t\t//1\u56de\u76ee\u306b\u6b69\u3044\u305f\u8ddd\u96e2 d1\n\t\t//2\u56de\u76ee\u306b\u6b69\u3044\u305f\u8ddd\u96e2 d2\n\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();//\u60a3\u8005\u306e\u6570 n\n\t\t\tint maxWalk = 0;//\u4e00\u756a\u6b69\u3044\u305f\u4eba\u306e\u8ddd\u96e2\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tMap<Integer, Integer> walkSum = new HashMap<Integer, Integer>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tint d1 = sc.nextInt();\n\t\t\t\tint d2 = sc.nextInt();\n\t\t\t\tint sumWalk = d1 + d2;\n\t\t\t\tif(sumWalk > maxWalk)maxWalk = sumWalk;\n\t\t\t\twalkSum.put(sumWalk,p);\n\t\t\t}\n\t\t\tSystem.out.println(walkSum.get((Object)maxWalk)+\" \"+maxWalk);\n\t\t}\n\t}\n}", "code2": "while (n=gets.chomp)!=\"0\"\n  id,d = 0,0\n  n.to_i.times do\n    p,d1,d2 = gets.split.map!(&:to_i)\n    if d<d1+d2\n      d=d1+d2\n      id=p\n    end\n  end\n  puts [id,d].join(' ')\nend", "label": 1, "name1": "s421023762.java", "name2": "s045283570.rb"}, {"id": 76, "code1": "import java.util.*;\n\nclass Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int k = findK(n);\n        if(k==-1){\n            System.out.println(\"No\");\n            System.exit(0);\n        }\n        int[][] res = new int[k][k-1];\n        for(int i=0;i<k-1;i++) res[0][i] = i+1;\n        int[] index = new int[k];\n        for(int i=0;i<k;i++) index[i]=i;\n        for(int row=1;row<k;row++){\n            int idx = 0;\n            for(int j=0;j<row;j++) res[row][idx++] = res[j][index[j]++];\n            if(row==k-1) continue;\n            res[row][idx++]=res[row-1][k-2]+1;\n            while(idx<k-1){\n                res[row][idx] = res[row][idx-1]+1;\n                idx++;\n            }\n        }\n        System.out.println(\"Yes\");\n        System.out.println(k);\n        for(int i=0;i<k;i++){\n            System.out.print(Integer.toString(k-1)+\" \");\n            for(int j=0;j<k-1;j++){\n                System.out.print(Integer.toString(res[i][j])+\" \");\n            }\n            System.out.println(\"\");\n        }\n    }\n    static int findK(int n){\n        int k=1;\n        while(k*(k-1)<=2*n){\n            if(k*(k-1)==2*n) return k;\n            k++;\n        }\n        return -1;\n    }\n}\n", "code2": "N = gets.to_i\nh = {}\n1.upto(1.0/0){|i|\n  edge = i * (i - 1) / 2\n  h[edge] = i\n  break if edge > 10**5\n}\n\nif !h[N]\n  puts:No\n  exit\nend\n\nvortex = h[N]\nedges = vortex.times.map{[]}\nn = 1\nvortex.times{|i|\n  i.times{|j|\n    edges[i] << n\n    edges[j] << n\n    n += 1\n  }\n}\nputs:Yes\np vortex\nedges.each{|e|\n  puts [e.size, *e]* \" \"\n}\n", "label": 1, "name1": "s741808618.java", "name2": "s612660257.rb"}, {"id": 208, "code1": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\t\n\tpublic static void main(String[] args){\n\t\tnew Main();\n\t}\n\tpublic Main(){\n\t\tnew A().doIt();\n\t}\n\tclass A{\n\t\tlong euclid(long a, long b){\n\t\t    long temp;\n\n\t\t    if(a < b) { \n\t\t    \ttemp = a;\n\t\t    \ta = b;\n\t\t    \tb = temp;\n\t\t    }\n\t\t    if(a % b == 0) return b;\n\t\t    return euclid( b, a % b );\n\t\t}\n\t\tvoid doIt(){\n\t\t\tint n = sc.nextInt();\n\t\t\tlong A = 1;\n\t\t\tlong B = 1;\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tlong aa = sc.nextLong();\n\t\t\t\tlong bb = sc.nextLong();\n\t\t\t\tif(A % aa != 0)A = A + aa - (A % aa);\n\t\t\t\tif(B % bb != 0)B = B + bb - (B % bb);\n\t\t\t\tlong max = Math.max(A/aa,B/bb);\n\t\t\t\tA = max * aa;\n\t\t\t\tB = max * bb;\n//\t\t\t\tSystem.out.println(A+\" \"+B);\n\t\t\t}\n\t\t\tSystem.out.println(A+B);\n\t\t}\n\t}\n}\n", "code2": "N = gets.to_i\nTs = Array.new(N)\nAs = Array.new(N)\nN.times do |i|\n  Ts[i], As[i] = gets.split.map(&:to_i)\nend\n\ntz = az = 1\nN.times do |i|\n  tk = (tz + Ts[i] - 1) / Ts[i]\n  ak = (az + As[i] - 1) / As[i]\n  k = [tk, ak].max\n  tz = Ts[i] * k\n  az = As[i] * k\nend\n\nputs tz + az\n", "label": 1, "name1": "s857617870.java", "name2": "s973322062.rb"}, {"id": 473, "code1": "import java.util.*;\n\npublic class Main{\n    public static void main(String args[]){\n        Scanner sc = new Scanner(System.in);\n        \n        int N = sc.nextInt();\n        int[] a = new int[N];\n        int[] b = new int[N];\n        for(int i = 0; i < N; i++)\n            a[i] = sc.nextInt();\n        for(int i = 0; i < N; i++)\n            b[i] = sc.nextInt();\n        sc.close();\n        long sum1 = 0;\n        long sum2 = 0;\n        for(int i = 0; i < N; i++){\n            if(a[i] > b[i]){\n                sum1 += (a[i]-b[i]);\n            } else {\n                sum2 += (b[i]-a[i])/2;\n            }\n        }\n        if(sum1 <= sum2)\n            System.out.println(\"Yes\");\n        else\n            System.out.println(\"No\");\n\n    }\n}", "code2": "gets;a,b=$<.map{|s|s.split.map &:to_i};\nt=eval((b*?+)+?-+(a*?-));\nA=[a,b].transpose.reduce(0){|s,a|s+=a[0]>a[1] ?a[0]-a[1]:0};\nB=[a,b].transpose.reduce(0){|s,a|s+=a[0]>a[1] ?0:(a[1]-a[0]+1)/2};\nputs [A,B].max>t ?:No: :Yes", "label": 1, "name1": "s462003664.java", "name2": "s344898645.rb"}, {"id": 657, "code1": "import java.util.*;\nimport java.io.*;\n\nclass Main {\n    static int searchP(long p,int[] ws){\n        int count = 1;\n        int sum = 0; \n        for(int i = 0; i < ws.length; i++){\n            if(sum + ws[i] <= p) {\n            sum += ws[i];\n            } else {\n                count++;\n                if(ws[i] <= p){\n                sum = ws[i];\n                } else{\n                    count += 99999;\n                }\n            }\n        }\n        return count;\n    }\n    static long solve(long p, int[] ws, long k){\n        long right = p;\n        long left = 0;\n        long mid;\n        while(right - left > 1) {\n            mid = (left + right) / 2;\n            int v = searchP(mid,ws);\n            if(k >= v) {\n                right = mid;\n            } else {\n               left = mid;\n                \n            }\n        }\n    return right;\n    }\n    public static void main(String...args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        \n        String[] info = br.readLine().split(\" \");\n        int n = Integer.parseInt(info[0]);\n        int k = Integer.parseInt(info[1]);\n        int[] ws = new int[n];\n        for(int i = 0; i < n; i++) {\n            ws[i] = Integer.parseInt(br.readLine());\n        }\n        long p = 100000 * 10000;\n        System.out.println(solve(p,ws,k));\n        \n    }\n}\n\n\n\n", "code2": "n = gets.to_i\na = gets.chomp.split(' ').map(&:to_i)\n\ncnt = 0\n\na.each_with_index do |num,idx|\n    if idx+1 < num\n        if a[num-1] == idx+1\n            cnt+=1\n        end\n    end\nend\n\nputs cnt", "label": 0, "name1": "s705576178.java", "name2": "s867955134.rb"}, {"id": 391, "code1": "import java.util.*;\nimport java.lang.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        long a = sc.nextLong();\n        long b = sc.nextLong();\n        long x = sc.nextLong();\n        long countA = a ==0 ? 0 : (a-1)/x+1;\n        long countB = b/x+1;\n        System.out.println(countB-countA);\n\n    }\n}\n", "code2": "a,b,x=gets.split.map &:to_i\np b/x-(a-1)/x", "label": 1, "name1": "s118772140.java", "name2": "s276778558.rb"}, {"id": 246, "code1": "import java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.util.Scanner;\n\npublic class Main{\n\tstatic Scanner sc;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t//InputStream in = new FileInputStream(\"src/input.txt\");\n\t\tInputStream in = System.in;\n\t\t//PrintStream out = new PrintStream(\"src/output.txt\");\n\n\t\t//System.setOut(out);\n\n\t\tsc = new Scanner(in);\n\n\t\tint N = sc.nextInt();\n\t\tint[] a = new int[N];\n\t\tint answer = 0;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(a[a[i]-1] == i+1){\n\t\t\t\tanswer++;\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(answer/2);\n\n\t\t//out.close();\n\t}\n}", "code2": "n = gets.to_i\na = gets.chomp.split(\" \").map(&:to_i)\n\n#b = Array.new(n+1).map{Array.new}\nh = Hash.new{|k,v| k[v]=0}\n\na.each_with_index do |n, i|\n  t = [n, i+1].sort!\n  h[t] += 1\n  #b[n] << i+1\n  #b[i+1] << n\nend\np h.to_a.select{|t| t[1]==2}.size\n\n\n#b.select{|t| }\n", "label": 1, "name1": "s219137444.java", "name2": "s972469766.rb"}, {"id": 425, "code1": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tString s;\n\t\t\tString[][] a = new String[n][];\n\t\t\tint p;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\ts = sc.next().replaceAll(\":\", \" \").replaceAll(\",\", \" \");\n\t\t\t\ta[i] = s.split(\" \");\n\t\t\t\tp = a[i].length-1;\n\t\t\t\ta[i][p] = a[i][p].substring(0,a[i][p].length()-1);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<String> list = new ArrayList<String>();\n\t\t\tfor(int i=1;i<a[0].length;i++) list.add(a[0][i]);\n\t\t\t\n\t\t\tboolean flag;\n\t\t\twhile(true){\n\t\t\t\tflag = false;\n\t\t\t\tfor(int i=1;i<n;i++){\n\t\t\t\t\tif(list.contains(a[i][0])==true){\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tlist.remove(list.indexOf(a[i][0]));\n\t\t\t\t\t\tfor(int j=1;j<a[i].length;j++){\n\t\t\t\t\t\t\tif(list.contains(a[i][j])==false) list.add(a[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag==false) break;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(list.size());\n\t\t}\t\n\t}\t\n}", "code2": "def find(x, root)\n  return unless @group[x]\n  return true if @group[x].include?(root)\n  @group[x].each do |m|\n    return true if find(m, root)\n  end\n  false\nend\n\nwhile n = gets.to_i\n  break if n == 0\n  root = ''\n  @group = {}\n  n.times do |i|\n    g, m = gets.split(':')\n    root = g if i == 0\n    ms = m[0..-3].split(',')\n    ms.each{ |m| @group[m] ||= []; @group[m] << g }\n  end\n  cnt = 0\n  leaf = @group.keys\n  @group.values.each{ |vs| vs.each{ |v| leaf.delete(v) } }\n  leaf.each do |name|\n    if find(name, root)\n      cnt += 1\n    end\n  end\n  p cnt\nend", "label": 1, "name1": "s663814901.java", "name2": "s748086673.rb"}, {"id": 797, "code1": "import java.io.*;\nimport java.util.*;\n \npublic class Main {\n\tstatic final Reader in = new Reader();\n\tstatic final long M=(long)1e9+7;\n\t\n\tpublic static void main(String[] args) {\n\t\tint n=in.nextInt();\n\t\tlong[] ps = new long[n+1];\n\t\tlong nf=1;\n\t\tfor(int i=1; i<=n; ++i) {\n\t\t\tps[i]=(ps[i-1]+in.nextInt())%M;\n\t\t\tnf=nf*i%M;\n\t\t}\n\t\tlong ans=nf*ps[n]%M, s=0;\n\t\tfor(int i=1; i<=n-1; ++i) {\n\t\t\ts=(s+ps[n-i]-ps[i]+M)%M;\n\t\t\tans=(ans+nf*modI((long)(i+1)*(i>=n-1?1:i+2), M)%M*2*s+nf*modI(i+1, M)%M*(ps[i]+ps[n]-ps[n-i]+M))%M;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\t\n\tstatic long modI(long a, long m) {\n\t\treturn (a%=m)<=1?1:(1-modI(m%a, a)*m)/a+m;\n\t}\n\t\n\tstatic class Reader {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st;\n\t\tString next() {\n\t\t\twhile(st==null||!st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch(Exception e) {}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t}\n}", "code2": "N = gets.to_i\nR = Array.new(N + 1) { [] }\n(N - 1).times do\n  a, b = gets.split.map(&:to_i)\n  R[a].push b\n  R[b].push a\nend\n\nG = Array.new(N + 1)\nq1 = [1]\nq2 = [N]\nuntil q1.empty? && q2.empty?\n  nq1 = []\n  q1.each do |x|\n    if G[x].nil?\n      G[x] = 1\n      nq1 += R[x]\n    else\n      next\n    end\n  end\n  nq2 = []\n  q2.each do |x|\n    if G[x].nil?\n      G[x] = 2\n      nq2 += R[x]\n    else\n      next\n    end\n  end  \n  q1 = nq1\n  q2 = nq2\nend\n\nif G.count(1) > N / 2\n  puts \"Fennec\"\nelse\n  puts \"Snuke\"\nend", "label": 0, "name1": "s013996602.java", "name2": "s034251111.rb"}, {"id": 636, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        CTwoAlpinists solver = new CTwoAlpinists();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CTwoAlpinists {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            long[] t = in.readLongArray(n);\n            long[] a = in.readLongArray(n);\n\n            long[] max = new long[n];\n            long[] actual = new long[n];\n\n            {\n                for (int i = 0; i < n; i++) {\n                    max[i] = Math.min(t[i], a[i]);\n                }\n            }\n\n            {\n                long prev = 0;\n                for (int i = 0; i < n; i++) {\n                    if (t[i] > prev) {\n                        if (t[i] > max[i]) {\n                            out.printLine(0);\n                            return;\n                        }\n                        actual[i] = t[i];\n                        prev = t[i];\n                    }\n                }\n            }\n\n            {\n                long prev = 0;\n                for (int i = n - 1; i >= 0; i--) {\n                    if (a[i] > prev) {\n                        if (a[i] > max[i]) {\n                            out.printLine(0);\n                            return;\n                        }\n                        actual[i] = a[i];\n                        prev = a[i];\n                    }\n                }\n            }\n\n            long ans = 1;\n            for (int i = 0; i < n; i++) {\n                if (actual[i] != 0) continue;\n                ans = (ans * max[i]) % MiscUtils.MOD7;\n            }\n\n            out.printLine(ans);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public long[] readLongArray(int size) {\n            long[] array = new long[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readLong();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long readLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class MiscUtils {\n        public static final int MOD7 = (int) (1e9 + 7);\n\n    }\n}\n\n", "code2": "# matrix\u306e\u57fa\u672c\u64cd\u4f5c\n\ndef same_el(array_)\n  if array_.kind_of?(Array)\n    output = []\n    for i in  0..(array_.count-1)\n      output.push(array_[i])\n    end\n  end\n  return output\nend\n\n# ---------------------------------------------\n\ndef replace(n)\n\n  sgn=[]\n  remain=[]\n  output=[] #n!\u500b\u306e\u8981\u7d20\u3092\u6301\u3064\u914d\u5217\u3092\u8fd4\u3059\n  for i in 0..n\n    sgn << i\n    remain << i\n  end\n  output << []\n  for i in 0..n\n    output[0] << i\n  end\n\n  while true\n    remain_act = same_el(remain)\n    remain_act.delete(0)\n    for i in 1..n-1\n      judge_order = true\n      for j in i+1..n-1\n        sgn[j]<sgn[j+1] && judge_order = false\n      end\n      judge_order && break\n      remain_act.delete(sgn[i])\n    end\n    singular = i\n    remain_act.sort!\n    for i in 0..n-(singular-2)\n      if sgn[singular] == remain_act[i]\n        sgn[singular] = remain_act[i+1]\n        break\n      end\n    end\n    remain_act.delete(sgn[singular])\n    for i in singular+1..n\n      sgn[i] = remain_act[i-(singular+1)]\n    end\n    inp =same_el(sgn)\n    output << inp\n    lastmat=true\n    for i in 1..n\n      sgn[i] != n+1-i && lastmat=false\n    end\n    lastmat && break\n  end\n\n  for i in 0..output.count-1\n    output[i].delete(0)\n  end\n  output\nend\n\n# ---------------------------------------------\n\ndef signal(replaces)\n  output = Array.new\n  index = Array.new\n\n  replace.size.times do |i|\n    for j in 0..replaces.size-1\n      index[j] = j+1\n    end\n    i_op = i.clone\n    while true\n      j = 0\n      nimotu = index[0]\n      sgn_part = -1\n      while true\n        if i_op[j] == nimotu\n\n        else\n        end\n      end\n\n    end\n    output << sgn\n  end\nend\n\nN=gets.to_i\nar=replace(N)\nps=gets.split.map(&:to_i)\nqs=gets.split.map(&:to_i)\np (ar.index(ps)-ar.index(qs)).abs", "label": 0, "name1": "s071160485.java", "name2": "s189807644.rb"}, {"id": 116, "code1": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        int c = sc.nextInt();\n\n        int min = Math.min(a, b);\n        int max = Math.max(a, b);\n        \n        boolean ans = false;\n        if (min < c && c < max)\n            ans = true;\n        System.out.println(ans ? \"Yes\" : \"No\");\n    }\n}", "code2": "A, B, C = gets.split.map(&:to_i)\nif ( A < C and C < B ) || ( B < C and C < A ) then\n\tputs \"Yes\"\nelse\n\tputs \"No\"\nend\n", "label": 1, "name1": "s912321420.java", "name2": "s698620069.rb"}, {"id": 614, "code1": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t\n\tint cmp (String p1, String p2) {\n\t\tif( p1.length() != p2.length() ) return p2.length() - p1.length();\n\t\treturn p2.compareTo(p1);\n\t}\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif((w|h) == 0 ) break;\n\t\t\t\n\t\t\tString[][] dp = new String[h+1][w+1];\n\t\t\tString pass = \"\";\n\t\t\tchar[][] map = new char[h+1][w+1];\n\t\t\t\n\t\t\tfor(String[] a: dp) fill(a, \"\");\n\t\t\t\n\t\t\tfor(int i=1;i<=h;i++) {\n\t\t\t\tString str = sc.next();\n\t\t\t\tfor(int j=1;j<=w;j++) {\n\t\t\t\t\tmap[i][j] = str.charAt(j-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=1;i<=h;i++) for(int j=1;j<=w;j++) {\n\t\t\t\tif( '0' <= map[i][j] && map[i][j] <= '9' ) {\n\t\t\t\t\tif( map[i][j] == '0' && dp[i-1][j].equals(\"\") && dp[i][j-1].equals(\"\") ) continue;\n\t\t\t\t\tdp[i][j] = ( cmp(dp[i-1][j], dp[i][j-1])<0? dp[i-1][j]: dp[i][j-1] ) + (char)map[i][j];\n\t\t\t\t}\n\t\t\t\tpass = cmp(pass, dp[i][j])<0? pass: dp[i][j];\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(pass);\n\t\t\t\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}", "code2": "a,b = gets.split(\" \").map(&:to_i)\nputs a <= b ? a : a-1", "label": 0, "name1": "s246113848.java", "name2": "s970317079.rb"}, {"id": 14, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString s= sc.next();\n\t\tfor (int i=0;i<s.length();i++) {\n\t\t\tif (s.charAt(i)=='R'||s.charAt(i)=='L') {\n\t\t\t\tif (i%2==0&&s.charAt(i)!='R')\t{\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t\treturn ;\n\t\t\t\t} else if (i%2==1&&s.charAt(i)!='L'){\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t\treturn ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\treturn ;\n\t\t}\n\t}\n}\n", "code2": "s_array = gets.chomp.split(\"\")\n\nret = \"Yes\"\ns_array.each_with_index do |e, i|\n    if i.odd?\n        if ![\"L\", \"U\", \"D\"].include?(e)\n            ret = \"No\"\n            break\n        end\n    else\n        if ![\"R\", \"U\", \"D\"].include?(e)\n            ret = \"No\"\n            break\n        end\n    end\nend\n\nputs ret", "label": 1, "name1": "s922990944.java", "name2": "s814130091.rb"}, {"id": 385, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n\n    void solve() throws IOException {\n        int h = ni(), w = ni();\n        String[] a = nsa(h);\n\n        char[][] ansR = new char[h][w];\n        char[][] ansB = new char[h][w];\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (i == 0 || i < h - 1 && j % 2 == 0) {\n                    ansR[i][j] = '#';\n                    ansB[i][j] = '.';\n                } else {\n                    ansR[i][j] = '.';\n                    ansB[i][j] = '#';\n                }\n            }\n        }\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (a[i].charAt(j) == '#') {\n                    ansR[i][j] = '#';\n                    ansB[i][j] = '#';\n                }\n            }\n        }\n\n        for (int i = 0; i < h; i++) {\n            out.println(String.valueOf(ansR[i]));\n        }\n        out.println();\n        for (int i = 0; i < h; i++) {\n            out.println(String.valueOf(ansB[i]));\n        }\n    }\n\n    String ns() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine(), \" \");\n        }\n        return tok.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.parseInt(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.parseLong(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.parseDouble(ns());\n    }\n\n    String[] nsa(int n) throws IOException {\n        String[] res = new String[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ns();\n        }\n        return res;\n    }\n\n    int[] nia(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ni();\n        }\n        return res;\n    }\n\n    long[] nla(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nl();\n        }\n        return res;\n    }\n\n    class INA {\n        int[][] a;\n\n        INA(int n, int m) throws IOException {\n            this(n, m, -1);\n        }\n\n        INA(int n, int m, int t) throws IOException {\n            a = new int[m][n];\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    a[j][i] = ni() + t;\n                }\n            }\n        }\n\n        int[] get(int i) {\n            return a[i - 1];\n        }\n    }\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        tok = new StringTokenizer(\"\");\n        Main main = new Main();\n        main.solve();\n        out.close();\n    }\n}", "code2": "H,W=gets.split.map &:to_i\nA=H.times.map{gets.chop}\nr=Array.new(H){\".\"*W}\nb=Array.new(H){\".\"*W}\nH.times{|i|r[i][0]=b[i][-1]=?#}\n0.step(H-1,2){|i|(W-1).times{|j|r[i][j]=?#}}\n1.step(H-1,2){|i|1.upto(W-1){|j|b[i][j]=?#}}\nH.times{|i|W.times{|j|r[i][j]=b[i][j]=?# if A[i][j]==?#}}\nputs r*\"\\n\", \"\", b*\"\\n\"", "label": 1, "name1": "s104811718.java", "name2": "s962419029.rb"}, {"id": 149, "code1": "import java.util.*;\npublic class Main {\n\tint n;\n\tint[] num;\n\tScanner stdin =new Scanner(System.in);\n\t\n\tvoid Solve(){\n\t\tnum=new int[21000000];\n\t\twhile(true){\n\t\t\tn=stdin.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tSystem.out.println(findPrime(n+1,2*n));\n\t\t}\n\t\t\n\t}\n\tint findPrime(int a,int b){\n\t\tint count=0;\n\t\tfor(int i=a;i<=b;i++){\n\t\t\tif(judgePrime(i)) count++;\n\t\t}\n\t\t\n\t\treturn count;\n\t}\n\t\n\tboolean judgePrime(int p){\n\t\tif(num[p]==1) return true;\n\t\tif(num[p]==-1) return false;\n\t\t\n\t\tif(p<4){\n\t\t\tnum[p]=1;\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\tif(p%2==0){\n\t\t\t\tnum[p]=-1;\n\t\t\t\treturn false; \n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=3;i<p;i++){\n\t\t\t\tif(p%i==0){\n\t\t\t\t\tnum[p]=-1;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tnum[p]=1;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\t\n\t\n\tpublic static void main(String args[]){\n\t\tMain m=new Main();\n\t\tm.Solve();\n\t}\n\t\n}", "code2": "require \"prime\"\n\nuntil (n = gets.to_i).zero?\n  puts Prime.each(2 * n).to_a.count{ |i| n < i }\nend", "label": 1, "name1": "s726742249.java", "name2": "s242670642.rb"}, {"id": 471, "code1": "import java.util.*;\n\npublic class Main{\n    public static void main(String args[]){\n        Scanner sc = new Scanner(System.in);\n        \n        int N = sc.nextInt();\n        int[] a = new int[N];\n        int[] b = new int[N];\n        for(int i = 0; i < N; i++)\n            a[i] = sc.nextInt();\n        for(int i = 0; i < N; i++)\n            b[i] = sc.nextInt();\n        sc.close();\n        long sum1 = 0;\n        long sum2 = 0;\n        for(int i = 0; i < N; i++){\n            if(a[i] > b[i]){\n                sum1 += (a[i]-b[i]);\n            } else {\n                sum2 += (b[i]-a[i])/2;\n            }\n        }\n        if(sum1 <= sum2)\n            System.out.println(\"Yes\");\n        else\n            System.out.println(\"No\");\n\n    }\n}", "code2": "N = gets.to_i\nA = gets.split.map(&:to_i)\nB = gets.split.map(&:to_i)\n\nlimit = B.inject(:+) - A.inject(:+)\ncnt1 = 0\ncnt2 = 0\n\nA.zip(B).each do |a, b|\n  next if a == b\n\n  if a > b\n    cnt1 += a - b\n  else\n    cnt2 += ((b - a) / 2.0).ceil\n  end\nend\n\nif cnt1 <= limit && cnt2 <= limit\n  puts 'Yes'\nelse\n  puts 'No'\nend\n", "label": 1, "name1": "s462003664.java", "name2": "s143550502.rb"}, {"id": 365, "code1": "import java.util.ArrayList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n/**\n * Created by shoya on 2017/04/12.\n */\npublic class Main {\n    public static void main(String... args) {\n        Scanner sc = new Scanner(System.in);\n        int V = sc.nextInt();\n        int E = sc.nextInt();\n        int r = sc.nextInt();\n        DijkstraClass dijkstra = new DijkstraClass(V, E, r);\n        for (int i = 0; i < E; i++) {\n            int s = sc.nextInt();\n            int d = sc.nextInt();\n            int c = sc.nextInt();\n            dijkstra.addDistande(s, d, c);\n        }\n        int[] dist = dijkstra.dikstra();\n        for (int i = 0; i < dist.length; i++){\n            if (dist[i] == 1 << 30)\n                System.out.println(\"INF\");\n            else\n                System.out.println(dist[i]);\n        }\n        return;\n    }\n\n\n    private static class DijkstraClass {\n        class edge{\n            int dest, cost;\n            edge(int dest, int cost){\n                this.dest = dest;\n                this.cost = cost;\n            }\n        }\n\n        private final int INF = 1 << 30;\n        private int S;\n        private int V;\n        private ArrayList<ArrayList<edge>> edgesOfNodes = new ArrayList<ArrayList<edge>>();\n\n        DijkstraClass(int V, int E, int Start){\n            this.S = Start;\n            this.V = V;\n            for (int i = 0; i < V; i++)\n                edgesOfNodes.add(new ArrayList<edge>());\n        }\n\n        void addDistande(int source, int dest, int cost){\n            edgesOfNodes.get(source).add(new edge(dest, cost));\n        }\n\n\n        int[] dikstra(){\n            class costAndNode implements Comparable {\n                int cost, node;\n                costAndNode(int cost, int node){\n                    this.cost = cost;\n                    this.node = node;\n                }\n                @Override\n                public int compareTo(Object o) {\n                    return this.cost - ((costAndNode) o).cost;\n                }\n            }\n\n            PriorityQueue<costAndNode> pque = new PriorityQueue<costAndNode>();\n            int[] distances = new int[V];\n            for (int i = 0; i < V; i++)\n                distances[i] = INF;\n            distances[S] = 0;\n\n            pque.add(new costAndNode(0, S));\n            while (!pque.isEmpty()){\n                costAndNode item = pque.poll();\n                if (distances[item.node] < item.cost)\n                    continue;\n\n                //System.out.printf(\"Focusing on Node %d\\n\", item.node);\n                //for (int i = 0; i < V; i++)\n                //    System.out.printf(\"%d \", distances[i]);\n                //System.out.println();\n\n                for (edge e : edgesOfNodes.get(item.node)) {\n                    //System.out.printf(\"Node %d -> %d, Cost %d -> %d\\n\",\n                    //        item.node, e.dest, distances[e.dest],\n                    //        distances[item.node] + e.cost);\n                    if (distances[e.dest] > distances[item.node] + e.cost) {\n                        distances[e.dest] = distances[item.node] + e.cost;\n                        pque.add(new costAndNode(distances[e.dest], e.dest));\n                    }\n                }\n            }\n\n            return distances;\n        }\n\n    }\n}", "code2": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif @array[i][1] < @array[j][1]\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if new_key >= @array[i][1]\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif @array[i][1] > @array[j][1]\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = (@array[j][1] < @array[k][1] ? j : k)\n\t\t\tif @array[i][1] > @array[l][1]\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_neighbour_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef dijkstra(start, goal = nil)\n\t\tstart = Set[start] if !start.kind_of?(Enumerable)\n\t\tgoal = Set[goal] if goal && !goal.kind_of?(Enumerable)\n\n\t\th = Heap.new\n\t\treached = Set.new\n\t\tstart.each{|v|\n\t\t\th.add(v, 0)\n\t\t\treached << v\n\t\t}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if goal && goal.include?(u)\n\t\t\tdist[u] = key\n\t\t\teach_neighbour_of(u){|v|\n\t\t\t\td = dist[u] + edge_length(u, v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tgoal ? nil : dist\n\tend\nend\n\nclass Digraph\n\tinclude Graphical\n\trequire 'set'\n\n\tdef add_node(label = nil)\n\t\tNode.new(label)\n\tend\n\n\tdef add_edge(u, v, label = nil)\n\t\te = Edge.new(u, v, label)\n\t\tu.outgoings[v] = e\n\t\tv.incomings[u] = e\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.outgoings.delete(v)\n\t\tv.incomings.delete(u)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(label)\n\t\t\t@label = label\n\t\t\t@outgoings = {}\n\t\t\t@incomings = {}\n\t\tend\n\n\t\tdef to_s\n\t\t\t@label\n\t\tend\n\t\t\n\t\tattr_accessor :incomings, :outgoings\n\t\tattr_reader :label\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, label = nil)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\t\t@label = label\n\t\tend\n\t\tattr_reader :from, :to, :label\n\tend\n\n\n\tdef get_path_bfs(s, t)\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\tu.outgoings.each{|e|\n\t\t\t\tv = e.to\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tpath_edge[v] = e\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = []\n\t\t\t\t\twhile e = path_edge[v]\n\t\t\t\t\t\tpath.unshift e\n\t\t\t\t\t\tv = e.from\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_dfs(s, t, reached = Set.new)\n\t\treached << s\t\n\t\ts.outgoings.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\treturn [e] if v == t\n\t\t\t\n\t\t\tpath = get_path_dfs(v, t, reached) \n\t\t\treturn [e] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef layers_from(start)\n\t\treached = Set[*start]\n\t\tlayers = [start]\n\n\t\tloop {\n\t\t\tlayers << []\n\t\t\tlayers[-2].each{|u|\n\t\t\t\tu.to_nodes.each{|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tlayers[-1] << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\tif layers[-1].empty?\n\t\t\t\tlayers.pop\n\t\t\t\treturn layers\n\t\t\tend\n\t\t}\n\tend\n\n\t#--- for Graphical module ---\n\tdef each_neighbour_of(u)\n\t\tu.outgoings.each_key{|v|\n\t\t\tyield v\n\t\t}\n\tend\n\n\tdef edge_length(u, v)\n\t\tu.outgoints[v] ? 1 : nil\n\tend\n\t#----------------------------\n\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\tu.outgoings.each{|e|\n\t\t\t\t\tv = e.to\n\t\t\t\t\td = f_dist[u] + e.label\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\tu.incomings.each{|e|\n\t\t\t\t\tv = e.from\n\t\t\t\t\td = b_dist[u] + e.label\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\nend\n\nclass WeightedDigraph < Digraph\n\tdef add_edge(u, v, length, label = nil)\n\t\te = Edge.new(u, v, length, label)\n\t\tu.outgoings[v] = e\n\t\tv.incomings[u] = e\n\t\te\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, length, label = nil)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\t\t@length = length\n\t\t\t@label = label\n\t\tend\n\t\tattr_reader :from, :to, :length, :label\n\tend\n\n\tdef edge_length(u, v)\n\t\tu.outgoings[v].length\n\tend\nend\n\nn, m, r = gets.split.map &:to_i\ng = WeightedDigraph.new\nnodes = (1..n).map{ g.add_node }\nm.times{\n\ti, j, c = gets.split.map &:to_i\n\tg.add_edge(nodes[i], nodes[j], c)\n}\ndist = g.dijkstra(nodes[r])\nputs (0..n-1).map {|i| dist[nodes[i]] || 'INF'}", "label": 1, "name1": "s575620429.java", "name2": "s482014619.rb"}, {"id": 2, "code1": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String str = sc.next();\n        int n = str.length();\n        int digitSum = 0;\n        for (int i = 0; i < n; i++)\n            digitSum += (str.charAt(i) - '0');\n        if(digitSum % 9 == 0) {\n            System.out.println(\"Yes\");\n        }\n        else {\n            System.out.println(\"No\");\n        }\n    }\n}\n\n", "code2": "n=gets.chomp\nx=0\nn = n.split('')\nn.each do |a|\n  x += a.to_i\nend\n\nputs (x%9==0) ? 'Yes' : 'No'", "label": 1, "name1": "s204970720.java", "name2": "s669617296.rb"}, {"id": 948, "code1": "import java.util.*;\n\npublic class Main {\n    public static void main(String args[]){\n        Scanner stdIn = new Scanner(System.in);\n        int n = stdIn.nextInt();\n        int c[] = new int[26];\n        int s[][] = new int[n][26];\n        \n        for(int i = 0; i < 26; i++){\n            c[i] = stdIn.nextInt();\n        }\n        \n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < 26; j++){\n                s[i][j] = stdIn.nextInt();\n            }\n        }\n        \n        /* \n        for(int i = 0; i < n; i++){\n            int max = 0;\n            int index = 0;\n            for(int j = 0; j < 26; j++){\n                if(s[i][j] > max){\n                    max = s[i][j];\n                    index = j;\n                }\n            }\n            System.out.println(index + 1);\n        }\n        */\n        \n        for(int i = 1; i < n + 1; i++){\n            System.out.println(i % 26 + 1);\n        }\n        \n        //System.out.println(\"XXXXXXXX\");\n    }\n}\n", "code2": "n, m, k = gets.split.map(&:to_i)\n\nputs (0..n).any?{|i| (0..m).any?{|j| m*i+n*j-2*i*j==k}} ? \"Yes\" : \"No\"", "label": 0, "name1": "s555776282.java", "name2": "s891763589.rb"}, {"id": 6, "code1": "import java.util.*;\n\nclass Main{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    String N = sc.next();\n    int sum = 0;\n    for(int i = 0;i<N.length();i++){\n      sum+=Integer.parseInt(N.substring(i,i+1));\n      sum=sum%9;\n    }\n    if(sum == 0){\n      System.out.println(\"Yes\");\n    }else{\n      System.out.println(\"No\");\n    }\n  }\n}", "code2": "n=gets.chomp\nx=0\nn = n.split('')\nn.each do |a|\n  x += a.to_i\nend\n\nputs (x%9==0) ? 'Yes' : 'No'", "label": 1, "name1": "s788833633.java", "name2": "s669617296.rb"}, {"id": 889, "code1": "import java.io.*;\nimport java.math.*;\nimport java.security.*;\nimport java.text.*;\nimport java.util.*;\nimport java.util.stream.*;\nimport java.util.concurrent.*;\nimport java.util.regex.*;\nimport java.util.function.*;\nimport static java.lang.System.out;\n\npublic final class Main {\n    public static void main(String[] args) throws Exception {\n        try (var input = new Reader()) {\n            int k = input.nextInt();\n            int a = input.nextInt();\n          \tint b = input.nextInt();\n          \tfor (int i = a; i <= b; ++i) {\n              \tif (i % k == 0) {\n                  out.printf(\"OK%n\");\n                  return;\n                }\n            }\n          \tout.printf(\"NG%n\");\n        }\n    }\n\n    private static final class Reader implements AutoCloseable {\n        private final int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private FileInputStream fis;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        private Reader() {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        private Reader(String filename) throws IOException {\n            fis = new FileInputStream(filename);\n            din = new DataInputStream(fis);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        private String readLine() throws IOException {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') { break; }\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        private int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') { c = read(); }\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg) { return -ret; }\n            return ret;\n        }\n\n        private long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ') { c = read(); }\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg) { return -ret; }\n            return ret;\n        }\n\n        private double nextDouble() throws IOException {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ') { c = read(); }\n            boolean neg = (c == '-');\n            if (neg) { c = read(); }\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg) { return -ret; }\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1) { buffer[0] = -1; }\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead) { fillBuffer(); }\n            return buffer[bufferPointer++];\n        }\n\n        @Override\n        public void close() throws Exception {\n            if (fis != null) {\n                fis.close();\n            }\n\n            if (din != null) {\n                din.close();\n            }\n        }\n    }\n}\n\n", "code2": "N,M=$<.read.split.map(&:to_i)\n\nputs ((N-M)*100+M*1900)*(2**M)", "label": 0, "name1": "s495906634.java", "name2": "s652082327.rb"}, {"id": 840, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\t\n\t\tint n = stdIn.nextInt();\n\t\tint[] a = new int[n];\n\t\tint i;\n\t\t\n\t\tfor (i = 0; i < n; i++)\n\t\t\ta[i] = stdIn.nextInt();\n\t\t\n\t\tint count = SelectionSort(a, n);\n\t\t\n\t\tSystem.out.print(a[0]);\n\t\tfor (i = 1; i < n; i++)\n\t\t\tSystem.out.print(\" \" + a[i]);\n\t\tSystem.out.println();\n\t\tSystem.out.println(count);\n\t}\n\t\n\tpublic static int SelectionSort(int[] a, int n) {\n\t\tint i, j, minat, t, count = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tminat = i;\n\t\t\tfor (j = i + 1; j < n; j++)\n\t\t\t\tif (a[j] < a[minat])\n\t\t\t\t\tminat = j;\n\t\t\tif (i != minat) {\n\t\t\t\tt = a[i];\n\t\t\t\ta[i] = a[minat];\n\t\t\t\ta[minat] = t;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}", "code2": "r=[*$<];a,b,c=r[0,8].sort_by{|t|t.split[1].to_f},r[8,8].sort_by{|t|t.split[1].to_f},r[16,8].sort_by{|t|t.split[1].to_f};puts a[0,2],b[0,2],c[0,2];*u=*a[2,6],*b[2,6],*c[2,6];\nputs u.sort_by{|t|t.split[1].to_f}[0,2]\n", "label": 0, "name1": "s307544938.java", "name2": "s099521906.rb"}, {"id": 850, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tRunner[] a = new Runner[18];\n\t\tint cnt=0;\n\t\tfor(int  j = 0;j<3;j++){\n\t\t\tRunner[] b = new Runner[8];\n\t\t\tfor(int i = 0;i<8;i++){\n\t\t\t\tint num = cin.nextInt();\n\t\t\t\tdouble time= cin.nextDouble();\n\t\t\t\tb[i]=new Runner(num,time);\n\t\t\t}\n\t\t\tArrays.sort(b);\n\t\t\tfor(int i = 0;i<6;i++){\n\t\t\t\ta[cnt++]=b[i+2];\n\t\t\t}\n\t\t\tSystem.out.println(b[0].num + \" \" + b[0].timestr);\n\t\t\tSystem.out.println(b[1].num + \" \" + b[1].timestr);\n\t\t}\n\t\tArrays.sort(a);\n\t\tSystem.out.println(a[0].num + \" \" + a[0].timestr);\n\t\tSystem.out.println(a[1].num + \" \" + a[1].timestr);\n\t}\n}\nclass Runner implements Comparable{\n\tint num;\n\tdouble time;\n\tString timestr;\n\tRunner(int a,double b){\n\t\tnum=a;\n\t\ttime=b;\n\t\ttimestr=String.valueOf(time);\n\t\tif(timestr.length()==4){\n\t\t\ttimestr = timestr+\"0\";\n\t\t}\n\t\t\n\t}\n\tpublic int compareTo(Object o) {\n\t\tRunner r = (Runner)o;\n\t\tif(this.time-r.time > 0)\n\t\t\treturn 1;\n\t\telse if(this.time-r.time == 0)\n\t\t\treturn 0;\n\t\telse{\n\t\t\treturn -1;\n\t\t}\n\t}\n}", "code2": "require 'pp'\n\nn = gets.chomp!.to_i\na_n = gets.chomp!.split(\" \").map(&:to_i)\n\nmemo = {}\nmin = 10 ** 10\nmin_id = -1\na_n.each_with_index do |a, i|\n    memo[i] = a\n    if a < min\n        min = a\n        min_id = i\n    end \nend\n\n#pp min\n#pp min_id\n\nwhile memo.size > 1\n    del_list = []\n    now_min = min\n    now_min_id = min_id\n\n    memo.each do |id, v|\n        next if id == now_min_id\n\n        memo[id] = memo[id] % now_min\n        if memo[id] == 0\n            del_list << id\n        elsif memo[id] < min\n            min = memo[id]\n            min_id = id\n        end\n    end\n\n    del_list.each {|id| memo.delete(id) }\nend \n\nputs memo.values.first\n", "label": 0, "name1": "s761209201.java", "name2": "s169875807.rb"}, {"id": 664, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tpublic void solve() {\n\t\tint N = nextInt();\n\t\tint[] a = new int[N];\n\t\tfor(int i = 0;i < N;i++){\n\t\t\ta[i] = nextInt() - 1;\n\t\t}\n\t\tboolean[] used = new boolean[N];\n\t\tint ans = 0;\n\t\tfor(int i = 0;i < N;i++){\n\t\t\tint x = a[i];\n\t\t\tint y = a[x];\n\t\t\tif(used[x])continue;\n\t\t\tif(used[y])continue;\n\t\t\tif(x == a[y] && y == a[x]){\n\t\t\t\tans++;\n\t\t\t\tused[x] = true;\n\t\t\t\tused[y] = true;\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}", "code2": "s = gets.chomp\nt = gets.chomp\nk = s.length - t.length + 1\ni = 0\nflag = false\nwhile i < k && !flag\n\tcp = s.clone\n\tcp[cp.length-t.length-i,t.length] = t\n\tcheck = true\n\t(cp.length).times do |j|\n\t\tcheck = false if s[j] != cp[j] && s[j] != \"?\"\n\tend\n\tflag = true if check\n\ti += 1\nend\nif flag\n\t(cp.length).times do |j|\n\t\tcp[j] = \"a\" if cp[j] == \"?\"\n\tend\n\tputs cp\nelse\n\tputs \"UNRESTORABLE\"\nend\n", "label": 0, "name1": "s188425538.java", "name2": "s763613339.rb"}, {"id": 346, "code1": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\nclass Solver extends Main{\n\tSolver(){\n\t\t\n\t}\n}//Solver_end\n\n@SuppressWarnings(\"unchecked\")\nclass Main{\n\tstatic int imax=Integer.MAX_VALUE;\n\tstatic long lmax=Long.MAX_VALUE;\n\t\n\tpublic static void main(String[] args) throws FileNotFoundException{\n\t\t\n\t\t\n\t\tScanner sc=new Scanner(System.in);\n\t\t//Scanner sc=new Scanner(fp);\n\t\t\n\t\tint[] data=readlnI(sc,\" \");\n\t\tint n=data[0];\n\t\tint m=data[1];\n\t\tint[] path=new int[200000];\n\t\t\n\t\tfor(int i=0;i<m; i++){\n\t\t\tint[] line=readlnI(sc,\" \");\n\t\t\tif(line[0]==1){\n\t\t\t\tpath[line[1]-1]+=1;\n\t\t\t}else if(line[1]==n){\n\t\t\t\tpath[line[0]-1]+=1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean fnd=false;\n\t\t\n\t\tfor(int x:path){\n\t\t\tif(x==2)fnd=true;\n\t\t}\n\t\t\n\t\tputs(fnd==true ? \"POSSIBLE\" : \"IMPOSSIBLE\");\n\t\t\n\t}//main_end\n\t\n//---------------------------------------------------------------------------\n\tstatic int readI(Scanner sc){\n\t\treturn Integer.parseInt(sc.nextLine().trim());\n\t}\n\tstatic long readL(Scanner sc){\n\t\treturn Long.parseLong(sc.nextLine().trim());\n\t}\n\tstatic String readS(Scanner sc){\n\t\treturn sc.nextLine().trim();\n\t}\n\tstatic int[] readlnI(Scanner sc, String dl){\n\t\treturn Arrays.stream(sc.nextLine().trim().split(dl)).mapToInt(Integer::parseInt).toArray();\n\t}\n\tstatic long[] readlnL(Scanner sc, String dl){\n\t\treturn Arrays.stream(sc.nextLine().trim().split(dl)).mapToLong(Long::parseLong).toArray();\n\t}\n\tstatic String[] readlnS(Scanner sc, String dl){\n\t\treturn sc.nextLine().trim().split(dl);\n\t}\n\t@SuppressWarnings(\"unchecked\")\n\tstatic <T> void puts(T... args){\n\t\tfor(int i=0; i<args.length-1; i++){\n\t\t\tSystem.out.printf(\"%s \",args[i]);\n\t\t}\n\t\tSystem.out.println(args[args.length-1]);\n\t}\n\tstatic void puts(int[] ary){\n\t\tfor(int i=0; i<ary.length-1; i++){\n\t\t\tSystem.out.printf(\"%d \",ary[i]);\n\t\t}\n\t\tSystem.out.println(ary[ary.length-1]);\n\t}\n\tstatic void puts(long[] ary){\n\t\tfor(int i=0; i<ary.length-1; i++){\n\t\t\tSystem.out.printf(\"%d \",ary[i]);\n\t\t}\n\t\tSystem.out.println(ary[ary.length-1]);\n\t}\n\tstatic void bs(){\n\t\tSystem.out.println(\"\");\n\t}\n\tstatic int sum(int[] ary){\n\t\tint sum=0;\n\t\tfor(int i=0; i<ary.length; i++) sum+=ary[i];\n\t\treturn sum;\n\t}\n\tstatic long sum(long[] ary){\n\t\tlong sum=0;\n\t\tfor(int i=0; i<ary.length; i++) sum+=ary[i];\n\t\treturn sum;\n\t}\n\tstatic void tblSort(int[][] tbl){\n\t\tArrays.sort(tbl, new Comparator<int[]>(){\n\t\t\t@Override\n\t\t\tpublic int compare(int[] a, int[] b){\n\t\t\t\tif(a[0]==b[0]){\n\t\t\t\t\treturn b[1]-a[1];\n\t\t\t\t}else{\n\t\t\t\t\treturn b[0]-a[0];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n", "code2": "N, M = gets.split.map(&:to_i)\nneighbor = Array.new(N+1){Hash.new}\nM.times do |i|\n    a, b = gets.split.map(&:to_i)\n    neighbor[a][b] = true\nend\n\n(2..(N-1)).each do |i|\n    if neighbor[1][i] && neighbor[i][N]\n        puts 'POSSIBLE'\n        exit\n    end\nend\nputs 'IMPOSSIBLE'", "label": 1, "name1": "s766623172.java", "name2": "s467668333.rb"}, {"id": 382, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\n\n/*\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n            pass System Test!\n*/\n\npublic class Main {\n  private static class Task {\n    void solve(FastScanner in, PrintWriter out) {\n      int H = in.nextInt();\n      int W = in.nextInt();\n      char[][] map = new char[H][];\n      for (int i = 0; i < H; i++) {\n        map[i] = in.next().toCharArray();\n      }\n\n      boolean[][] red = new boolean[H][W];\n      boolean[][] blue = new boolean[H][W];\n      for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n          if (j == 0) red[i][j] = true;\n          else if (j == W - 1) blue[i][j] = true;\n          else if (i % 2 == 0) red[i][j] = true;\n          else blue[i][j] = true;\n        }\n      }\n\n      for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n          if (map[i][j] == '.') continue;\n          blue[i][j] = true;\n          red[i][j] = true;\n        }\n      }\n\n      for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n          out.print(red[i][j] ? \"#\" : \".\");\n        }\n        out.println();\n      }\n      out.println();\n      for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n          out.print(blue[i][j] ? \"#\" : \".\");\n        }\n        out.println();\n      }\n    }\n  }\n\n  /**\n   * \u3053\u3053\u304b\u3089\u4e0b\u306f\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u3067\u3059\u3002\n   */\n  public static void main(String[] args) {\n    OutputStream outputStream = System.out;\n    FastScanner in = new FastScanner();\n    PrintWriter out = new PrintWriter(outputStream);\n    Task solver = new Task();\n    solver.solve(in, out);\n    out.close();\n  }\n  private static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n      int[] array = new int[n];\n      for (int i = 0; i < n; i++) array[i] = nextInt();\n      return array;\n    }\n\n    public long[] nextLongArray(int n) {\n      long[] array = new long[n];\n      for (int i = 0; i < n; i++) array[i] = nextLong();\n      return array;\n    }\n\n    public String[] nextStringArray(int n) {\n      String[] array = new String[n];\n      for (int i = 0; i < n; i++) array[i] = next();\n      return array;\n    }\n\n    public char[][] nextCharMap(int n) {\n      char[][] array = new char[n][];\n      for (int i = 0; i < n; i++) array[i] = next().toCharArray();\n      return array;\n    }\n  }\n}\n", "code2": "H, W = gets.split.map(&:to_i)\nas = []\nans1 = []\nans2 = []\nH.times do |i|\n    as[i] = gets.chomp\n    ans1[i] = as[i].dup\n    ans2[i] = as[i].dup\nend\n\nH.times do |i|\n    if i%2 == 0\n        ans1[i] = '#'*(W-1) + '.'\n    else\n        ans2[i] = '.' + '#'*(W-1)\n    end\n    ans1[i][0] = '#'\n    ans2[i][-1] = '#'\nend\n\nputs ans1\nputs\nputs ans2\n\n# result = Array.new(H){'.'*W}\n# H.times do |i|\n#     W.times do |j|\n#         result[i][j] = '#' if ans1[i][j] == '#' && ans2[i][j] == '#'\n#     end\n# end\n# puts result", "label": 1, "name1": "s871155444.java", "name2": "s793571533.rb"}, {"id": 901, "code1": "// package arc.arc085;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int m = in.nextInt();\n        long time = m * 1900 + (n - m) * 100;\n\n        out.println(time * (1<<m));\n        out.flush();\n    }\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}", "code2": "h, w = gets.split.map(&:to_i)\na = h.times.map { gets.chomp }\ns = a.join(\"\")\ncnt = {}\n?a.upto(?z) { |c| cnt[c] = s.count(c) }\n\nif w == 1\n  if h.odd?\n    puts cnt.values.select { |x| x.odd? }.size == 1 ? \"Yes\" : \"No\"\n  else\n    puts cnt.values.select { |x| x.odd? }.size == 0 ? \"Yes\" : \"No\"\n  end\nelse\n  if h.even? && w.even?\n    puts cnt.values.select { |x| x % 4 != 0 }.size == 0 ? \"Yes\" : \"No\"\n  elsif h.odd? && w.odd?\n    ume = 0\n    ?a.upto(?z) do |c|\n      if cnt[c] >= 4 && (h - 1) * (w - 1) > ume\n        ume += (cnt[c] / 4) * 4\n        cnt[c] -= (cnt[c] / 4) * 4\n        if (h - 1) * (w - 1) < ume\n          cnt[c] += ume - (h - 1) * (w - 1)\n          ume = (h - 1) * (w - 1)\n        end\n      end\n    end\n    if ume != (h - 1) * (w - 1)\n      puts \"No\"\n      exit\n    end\n    puts cnt.values.select { |x| x.odd? }.size == 1 ? \"Yes\" : \"No\"\n  else\n    ume = 0\n    t = h.odd? ? w : h\n    ?a.upto(?z) do |c|\n      if cnt[c] >= 4 && h * w - t > ume\n        ume += (cnt[c] / 4) * 4\n        cnt[c] -= (cnt[c] / 4) * 4\n        if h * w - t < ume\n          cnt[c] += ume - h * w - t\n          ume = h * w - t\n        end\n      end\n    end\n    if ume != h * w - t\n      puts \"No\"\n      exit\n    end\n    puts cnt.values.select { |x| x.odd? }.size == 0 ? \"Yes\" : \"No\"\n  end\nend\n", "label": 0, "name1": "s269596398.java", "name2": "s670958543.rb"}, {"id": 168, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() { return Double.parseDouble(next());}\n}\npublic class Main {\n\tstatic FastScanner stdIn=new FastScanner();\n\tpublic static void main(String[] args) {\n\t\tString X=stdIn.next();\n\t\tint N=X.length();\n\t\tint s=0,t=0,ans=N;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tchar a=X.charAt(i);\n\t\t\tif(a=='S')\n\t\t\t\ts++;\n\t\t\telse{\n\t\t\t\tif(s!=0){\n\t\t\t\t\tans-=2;\n\t\t\t\t\ts--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n", "code2": "r=0;gets.bytes.map{|c|c>83?r<0&&r+=1:r-=1};p~r*2", "label": 1, "name1": "s724983945.java", "name2": "s239261496.rb"}, {"id": 133, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tMyInput in = new MyInput(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic long LINF = 1L << 55;\n\tstatic int MOD = 1000000007;\n\tstatic int[] mh4 = { 0, -1, 1, 0 };\n\tstatic int[] mw4 = { -1, 0, 0, 1 };\n\tstatic int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\tstatic int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n\tstatic class TaskX {\n\n\t\tpublic void solve(int testNumber, MyInput in, PrintWriter out) {\n\n\t\t\tint n = in.nextInt();\n\t\t\tchar[] s = in.nextChars();\n\n\t\t\tlong[][] dp = new long[n+1][n+1];\n\t\t\tArrays.fill(dp[0], 1);\n\n\t\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\t\tif (s[i] == '<') {\n\t\t\t\t\tfor (int j = 0; j < n-i; j++) {\n\t\t\t\t\t\tdp[i+1][j] += dp[i][j];\n\t\t\t\t\t\tdp[i+1][j] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (int j = 0; j < n-i; j++) {\n\t\t\t\t\t\tdp[i+1][0] += dp[i][j];\n\t\t\t\t\t\tdp[i+1][j] -= dp[i][j] - MOD;\n\t\t\t\t\t\tdp[i+1][0] %= MOD;\n\t\t\t\t\t\tdp[i+1][j] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 1; j < n-1-i; j++) {\n\t\t\t\t\tdp[i+1][j] += dp[i+1][j-1];\n\t\t\t\t\tdp[i+1][j] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout.println(dp[n-1][0]);\n\n\t\t}\n\t}\n\n\tstatic class MyInput {\n\t\tprivate final BufferedReader in;\n\t\tprivate static int pos;\n\t\tprivate static int readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500 * 8 * 2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic {\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tisDigit['0' + i] = true;\n\t\t\t}\n\t\t\tisDigit['-'] = true;\n\t\t\tisSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n\t\t\tisLineSep['\\r'] = isLineSep['\\n'] = true;\n\t\t}\n\n\t\tpublic MyInput(InputStream is) {\n\t\t\tin = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (pos >= readLen) {\n\t\t\t\tpos = 0;\n\t\t\t\ttry {\n\t\t\t\t\treadLen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException();\n\t\t\t\t}\n\t\t\t\tif (readLen <= 0) {\n\t\t\t\t\tthrow new MyInput.EndOfFileRuntimeException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buffer[pos++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\tint i = 0;\n\t\t\tint ret = 0;\n\t\t\tif (str[0] == '-') {\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t\tfor (; i < len; i++)\n\t\t\t\tret = ret * 10 + str[i] - '0';\n\t\t\tif (str[0] == '-') {\n\t\t\t\tret = -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\tint i = 0;\n\t\t\tlong ret = 0;\n\t\t\tif (str[0] == '-') {\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t\tfor (; i < len; i++)\n\t\t\t\tret = ret * 10 + str[i] - '0';\n\t\t\tif (str[0] == '-') {\n\t\t\t\tret = -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic char nextChar() {\n\t\t\twhile (true) {\n\t\t\t\tfinal int c = read();\n\t\t\t\tif (!isSpace[c]) {\n\t\t\t\t\treturn (char) c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic String nextString() {\n\t\t\treturn new String(nextChars());\n\t\t}\n\n\t\tpublic char[] nextChars() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\treturn Arrays.copyOf(str, len);\n\t\t}\n\n\t\tint reads(int len, boolean[] accept) {\n\t\t\ttry {\n\t\t\t\twhile (true) {\n\t\t\t\t\tfinal int c = read();\n\t\t\t\t\tif (accept[c]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (str.length == len) {\n\t\t\t\t\t\tchar[] rep = new char[str.length * 3 / 2];\n\t\t\t\t\t\tSystem.arraycopy(str, 0, rep, 0, str.length);\n\t\t\t\t\t\tstr = rep;\n\t\t\t\t\t}\n\t\t\t\t\tstr[len++] = (char) c;\n\t\t\t\t}\n\t\t\t} catch (MyInput.EndOfFileRuntimeException e) {\n\t\t\t}\n\t\t\treturn len;\n\t\t}\n\n\t\tpublic int[] nextIntArray(final int n) {\n\t\t\tfinal int[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArray1Index(final int n) {\n\t\t\tfinal int[] res = new int[n + 1];\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArrayDec(final int n) {\n\t\t\tfinal int[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(final int n) {\n\t\t\tfinal long[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray1Index(final int n) {\n\t\t\tfinal long[] res = new long[n + 1];\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArrayDec(final int n) {\n\t\t\tfinal long[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic double[] nextDoubleArray(int n) {\n\t\t\tdouble[] res = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextDouble();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\t}\n\n\t}\n\n}\n", "code2": "d=*1..gets.to_i;\ngets.chop.bytes{|c|\n\tx=0;\n\td.map!{|a|x=(x+d[-1]*c[1]+(1-c%3)*a).%10**9+7}.pop\n}\np *d", "label": 1, "name1": "s819730919.java", "name2": "s005244405.rb"}, {"id": 849, "code1": "import java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\n\nclass Person implements Comparable<Person> {\n\n    final int no;\n    final double time;\n\n    Person( final int no, final double time ) {\n\tthis.no = no;\n\tthis.time = time;\n    }\n    \n    public int compareTo( final Person p ) {\n\treturn Double.compare( time, p.time );\n    }\n\n    public String toString() {\n\treturn String.format( \"%d %.2f\", no, time );\n    }\n}\n\nclass Main {\n\n    public static void main( final String[] args ) {\n\n\tfinal Scanner stdin = new Scanner( System.in );\n\tfinal ArrayList<Person> last = new ArrayList<Person>();\n\tfinal ArrayList<Person> rest = new ArrayList<Person>();\n\t\n\tfor ( int i = 0; i < 3; i++ ) {\n\t    final ArrayList<Person> semifinal = new ArrayList<Person>();\n\t    for ( int j = 0; j < 8; j++ ) {\n\t\tsemifinal.add( new Person( stdin.nextInt(), stdin.nextDouble() ) );\n\t    }\n\t    Collections.sort( semifinal );\n\t    last.add( semifinal.remove( 0 ) );\n\t    last.add( semifinal.remove( 0 ) );\n\t    rest.addAll( semifinal );\n\t}\n\tCollections.sort( rest );\n\tlast.add( rest.remove( 0 ) );\n\tlast.add( rest.remove( 0 ) );\n\tfor ( Person p : last ) {\n\t    System.out.println( p );\n\t}\n    }    \n}", "code2": "def gcd(a,b)\n  if a % b == 0\n    b\n  elsif b % a == 0\n    a\n  elsif a < b\n    gcd(a, b % a)\n  else\n    gcd(a % b, b)\n  end\nend\n\nn = gets.to_i\nary = gets.split.map(&:to_i)\n\np ary.reduce { |a,b| gcd(a,b) }\n", "label": 0, "name1": "s209430606.java", "name2": "s961208113.rb"}, {"id": 564, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        final Scanner sc = new Scanner(System.in);\n\n        final long n = sc.nextLong();\n        final long k = sc.nextLong();\n\n        final long t = n % k;\n        System.out.println(Math.min(t, k-t));\n    }\n}\n", "code2": "a, b, c = gets.chomp!.split(\" \").map!(&:to_i)\n\nputs ((a..b).include?(c)  || (b..a).include?(c)) ? \"Yes\" : \"No\"\n", "label": 0, "name1": "s071954198.java", "name2": "s629547340.rb"}, {"id": 908, "code1": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n\tvoid solve() {\n\t\tint r = in.nextInt(), c = in.nextInt();\n\t\tint[] cnt = new int[26];\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\tfor (char ch : in.nextToken().toCharArray()){ \n\t\t\t\tcnt[ch - 'a']++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt4 = (r / 2) * (c / 2);\n\t\tint cnt2 = (r / 2) * (c % 2) + (c / 2) * (r % 2);\n\t\tint cnt1 = (r % 2) * (c % 2);\n\t\t\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\twhile (cnt[i] >= 4 && cnt4 > 0) {\n\t\t\t\tcnt[i] -= 4;\n\t\t\t\tcnt4--;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\twhile (cnt[i] >= 2 && cnt2 > 0) {\n\t\t\t\tcnt[i] -= 2;\n\t\t\t\tcnt2--;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\twhile (cnt[i] >= 1 && cnt1 > 0) {\n\t\t\t\tcnt[i] -= 1;\n\t\t\t\tcnt1--;\n\t\t\t}\n\t\t}\n\t\tout.println((cnt1 == 0 && cnt2 == 0 && cnt4 == 0) ? \"Yes\" : \"No\");\n\t}\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tvoid run() {\n\t\tin = new FastScanner();\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(s));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic String nextToken() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n", "code2": "player = {}\n%w[a b c].each { |a| player[a] = gets.chomp.chars.reverse }\n\nwinner = ''\nturn = 'a'\nloop do\n  if player[turn].empty?\n    winner = turn\n    break\n  end\n\n  turn = player[turn].pop\nend\nputs winner.upcase\n", "label": 0, "name1": "s917006414.java", "name2": "s025363057.rb"}, {"id": 23, "code1": "import java.util.*;\n \npublic class Main{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    double H = sc.nextDouble();\n    double W = sc.nextDouble();\n    if (H != 1 && W != 1)\n\t\t\tSystem.out.println((long) Math.ceil(H * W / 2));\n\t\telse\n\t\t\tSystem.out.println(1);\n  }\n}\n    ", "code2": "H, W = gets.split.map(&:to_i)\n\nif H == 1 || W == 1\n  puts 1\nelse\n  puts (H * W / 2.0).ceil\nend", "label": 1, "name1": "s603185414.java", "name2": "s406316016.rb"}, {"id": 752, "code1": "// -*- coding: utf-8 -*-\n//import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream;\n    if (args.length > 0 && args[0].equals(\"devTesting\")) {\n      try {\n        inputStream = new FileInputStream(args[1]);\n      } catch(FileNotFoundException e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      inputStream = System.in;\n    }\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskC solver = new TaskC();\n    int testCase = 1;\n    solver.solve(1, in, out);\n    out.close();\n  }\n  \n  static class TaskC {\n    long h, w;\n    \n    void solve(int testNumber, InputReader in, PrintWriter out) {\n      h = in.nextInt();\n      w = in.nextInt();\n      char[][] superpost = new char[(int) h][];\n      for (int i = 0; i < h; ++i)\n        superpost[i] = in.next().toCharArray();\n      for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j)\n          if (i % 2 == 0 && j < w - 1 || j == 0 || superpost[i][j] == '#')\n            out.print('#');\n          else\n            out.print('.');\n        out.println();\n      }\n      out.println();\n      for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j)\n          if (i % 2 == 1 && j > 0 || j == w - 1 || superpost[i][j] == '#')\n            out.print('#');\n          else\n            out.print('.');\n          out.println();\n      }\n    }\n    \n  }\n      \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public boolean hasInput() {\n      try {\n        if (tokenizer != null && tokenizer.hasMoreTokens()) {\n          return true;\n        }\n        reader.mark(1);\n        int ch = reader.read();\n        if (ch != -1) {\n          reader.reset();\n          return true;\n        }\n        return false;\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n  }\n}\n", "code2": "class Problem\n  attr_accessor :a, :b, :n, :m, :h, :w, :x, :y, :s ,:t\n\n  def initialize\n    @a,@b,@x = gets.to_s.split.map{ |v| v.to_i }\n  end\n\n  def solve\n    count(b,x) - count(a-1,x)\n  end\n\n  def count(a,x)\n    a / x + 1\n  end\n\n  def show(ans)\n    puts ans\n  end\nend\n\nProblem.new.instance_eval do\n  show(solve)\nend\n", "label": 0, "name1": "s133216279.java", "name2": "s568523037.rb"}, {"id": 355, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n\t\treturn (int) nl;\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n}\npublic class Main {\n\tstatic FastScanner scan=new FastScanner();\n\tstatic Scanner scanner=new Scanner(System.in);\n\tstatic long mod=1000000007;\n\tstatic double eps=0.0000000001;\n\tstatic int big=Integer.MAX_VALUE;\n\tstatic long gcd (long a, long b) {return b>0?gcd(b,a%b):a;}\n\tstatic long lcm (long a, long b) {return a*b/gcd(a,b);}\n\tstatic int max(int a,int b) {return a>b?a:b;}\n\tstatic int min(int a,int b) {return a<b?a:b;}\n\tstatic long factorial(int i) {return i==1?1:i*factorial(i-1);}\n\tstatic int lower_bound(int a[],int key) {\n\t\tint low=0,high=a.length;\n\t\twhile(low<high) {\n\t\t\tint mid=((high-low)/2)+low;\n\t\t\tif(a[mid]<=key)low=mid+1;\n\t\t\telse high=mid;\n\t\t}\n\t\treturn high;\n\t}\n\tstatic int upper_bound(int a[],int key) {\n\t\tint low=0,high=a.length;\n\t\twhile(low<high) {\n\t\t\tint mid=((high-low)/2)+low;\n\t\t\tif(a[mid]<key)low=mid+1;\n\t\t\telse high=mid;\n\t\t}\n\t\treturn high;\n\t}\n\tstatic boolean isPrime (long n) {\n\t\tif (n==2) return true;\n\t\tif (n<2 || n%2==0) return false;\n\t\tdouble d = Math.sqrt(n);\n\t\tfor (int i=3; i<=d; i+=2)if(n%i==0){return false;}\n\t\treturn true;\n\t}\n\tstatic int upper_division(int a,int b) {\n\t\tif(a%b==0) {\n\t\t\treturn a/b;\n\t\t}\n\t\telse {\n\t\t\treturn a/b+1;\n\t\t}\n\t}\n\tstatic long lupper_division(long a,long b) {\n\t\tif(a%b==0) {\n\t\t\treturn a/b;\n\t\t}\n\t\telse {\n\t\t\treturn a/b+1;\n\t\t}\n\t}\n\tstatic long lmax(long a,long b) {return Math.max(a, b);}\n\tstatic long lmin(long a,long b) {return Math.min(a, b);}\n\tstatic int[] setArray(int a) {\n\t\tint b[]=new int[a];\n\t\tfor(int i=0;i<a;i++) {\n\t\t\tb[i]=scan.nextInt();\n\t\t}\n\t\treturn b;\n\t}\n\tstatic long[] lsetArray(int a) {\n\t\tlong b[]=new long[a];\n\t\tfor(int i=0;i<a;i++) {\n\t\t\tb[i]=scan.nextLong();\n\t\t}\n\t\treturn b;\n\t}\n\tstatic String reverce(String str) {\n\t\tString strr=\"\";\n\t\tfor(int i=str.length()-1;i>=0;i--) {\n\t\t\tstrr+=str.charAt(i);\n\t\t}\n\t\treturn strr;\n\t}\n\tpublic static void printArray(char[] ch) {\n\t\tfor(int i=0;i<ch.length-1;i++) {\n\t\t\tSystem.out.print(ch[i]+\" \");\n\t\t}\n\t\tSystem.out.println(ch[ch.length-1]);\n\t}\n\tpublic static int[][] doublesort(int[][]a) {\n\t\tArrays.sort(a,(x,y)->Integer.compare(x[0],y[0]));\n\t\treturn a;\n\t}\n\tstatic long modpow(long x,long n,long mo) {\n\t\tlong sum=1;\n\t\twhile(n>0) {\n\t\t\tif((n&1)==1) {\n\t\t\t\tsum=sum*x%mo;\n\t\t\t}\n\t\t\tx=x*x%mo;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn sum;\n\t}\n\tpublic static char[] revch(char ch[]) {\n\t\tchar ret[]=new char[ch.length];\n\t\tfor(int i=ch.length-1,j=0;i>=0;i--,j++) {\n\t\t\tret[j]=ch[i];\n\t\t}\n\t\treturn ret;\n\t}\n\tpublic static int[] revint(int ch[]) {\n\t\tint ret[]=new int[ch.length];\n\t\tfor(int i=ch.length-1,j=0;i>=0;i--,j++) {\n\t\t\tret[j]=ch[i];\n\t\t}\n\t\treturn ret;\n\t}\n\tpublic static void warshall_floyd(int v[][],int n) {\n\t\tfor(int k=0;k<n;k++)\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t\tv[i][j]=min(v[i][j],v[i][k]+v[k][j]);\n\t}\n\tpublic static void main(String[] args) {\n\t\tlong a=scan.nextLong();\n\t\tlong b=scan.nextLong();\n\t\tint cnt=0;\n\t\tlong now=a;\n\t\twhile(now<=b) {\n\t\t\tcnt++;\n\t\t\tnow*=2;\n\t\t}\n\t\tSystem.out.println(cnt);\n\t}\n}", "code2": "X,Y = $stdin.gets.chomp.split(\" \").map{ |a| a.to_i }\nputs (Y/X).to_s(2).size", "label": 1, "name1": "s941851054.java", "name2": "s056155066.rb"}, {"id": 820, "code1": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int a[][] = new int[n][n];\n\n        for (int i = 0; i < m; i++) {\n            int t1 = in.nextInt() - 1;\n            int t2 = in.nextInt() - 1;\n            a[t1][t2] = 1;\n            a[t2][t1] = 1;\n        }\n        List<Integer> order = new ArrayList<>();\n        order.add(0);\n        List<Integer> remain = new ArrayList<>();\n        for (int i = 1; i < n; i++) {\n            remain.add(i);\n        }\n        System.out.println(f(order, remain, a));\n    }\n\n    static int f(List<Integer> order, List<Integer> remain, int edges[][]) {\n        if (remain.size() == 0) {\n            int cur = order.get(0);\n            int next;\n            for (int p = 1; p < order.size(); p++) {\n                next = order.get(p);\n                if (edges[cur][next] == 1 || edges[next][cur] == 1) {\n                    cur = next; \n                } else {\n                    return 0;\n                }\n            }\n            return 1;\n        }\n\n        int total = 0;\n        for (int p = 0; p < remain.size(); p++) {\n            order.add(remain.get(p));\n            remain.remove(p);\n            total += f(order, remain, edges);\n            remain.add(p, order.get(order.size() - 1));\n            order.remove(order.size() - 1);\n        }\n        return total;\n    }\n}", "code2": "a, b, c = gets.split.map(&:to_i)\n\nputs (a==b && a==c && b == c) || (a != b && a != c && c != b) ? \"No\": \"Yes\"", "label": 0, "name1": "s216336518.java", "name2": "s674156319.rb"}, {"id": 10, "code1": "import java.util.*;\n\npublic class Main{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n\n    String[] s = sc.next().split(\"\");\n    int l =  s.length;\n    int count =0;\n    for(int i=0; i<l; i++){\n      if(s[i].equals(\"U\")||s[i].equals(\"D\")){\n        count +=1;\n        continue;\n      }\n\n\n      if(i%2==0){\n        if(s[i].equals(\"R\")){\n          count += 1;\n        }\n      }else{\n        if(s[i].equals(\"L\")){\n          count += 1;\n        }\n      }\n    }\n    if(count == l){\n      System.out.println(\"Yes\");\n    }else{\n      System.out.println(\"No\");\n    }\n\n\n\n\n  }\n}", "code2": "s = gets.chomp.split(\"\")\ndir = [[\"R\", \"U\", \"D\"], [\"L\", \"U\", \"D\"]]\nflag = 1\nid = 0\ns.each do |c|\n  tmpflag = 0\n  dir[id%2].each do |d|\n    if c == d\n      tmpflag = 1\n      break\n    end\n  end\n  if tmpflag == 0\n    flag = 0\n    break\n  end\n  id += 1\nend\nif flag == 1\n  puts \"Yes\"\nelse\n  puts \"No\"\nend", "label": 1, "name1": "s855266906.java", "name2": "s423509236.rb"}, {"id": 606, "code1": "/**\n * Created at 16:38 on 2019-08-27\n */\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n  static FastScanner sc = new FastScanner();\n  static Output out = new Output(System.out);\n\n  static final int[] dx = {0, 1, 0, -1};\n  static final int[] dy = {-1, 0, 1, 0};\n\n  static final long MOD = (long) (1e9 + 7);\n  static final long INF = Long.MAX_VALUE / 2;\n\n  public static class Solver {\n    public Solver() {\n\n      int Q = sc.nextInt();\n\n      for (int q=0; q<Q; q++) {\n        long A = sc.nextLong();\n        long B = sc.nextLong();\n        long P = A * B;\n\n        long sqrt = sqrt(P-1);\n\n        long ans = 2*sqrt;\n\n        if (Math.min(A, B) <= sqrt) ans--; //\u9ad8\u6a4b\u541b\u3068\u540c\u3058\u9806\u4f4d\u306b\u306a\u3063\u3066\u3044\u308b\u3082\u306e\u3092\u9664\u304f\n        if (sqrt * (sqrt+1) > P-1) ans--; //\u30c0\u30d6\u30eb\u30ab\u30a6\u30f3\u30c8\u3057\u3066\u3044\u308b\u3082\u306e\u3092\u9664\u304f(x == y \u306e\u3068\u304d)\n\n        out.println(ans);\n      }\n\n\n    }\n\n    long sqrt(long n) {\n      long res = (long)Math.floor(Math.sqrt(n));\n      while (res * res > n) res--;\n      while ((res+1) * (res+1) <= n) res++;\n      return res;\n    }\n\n  }\n\n  public static void main(String[] args) {\n    new Solver();\n    out.flush();\n  }\n\n  static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int N, boolean oneBased) {\n      if (oneBased) {\n        int[] array = new int[N + 1];\n        for (int i = 1; i <= N; i++) {\n          array[i] = sc.nextInt();\n        }\n        return array;\n      } else {\n        int[] array = new int[N];\n        for (int i = 0; i < N; i++) {\n          array[i] = sc.nextInt();\n        }\n        return array;\n      }\n    }\n\n    public long[] nextLongArray(int N, boolean oneBased) {\n      if (oneBased) {\n        long[] array = new long[N + 1];\n        for (int i = 1; i <= N; i++) {\n          array[i] = sc.nextLong();\n        }\n        return array;\n      } else {\n        long[] array = new long[N];\n        for (int i = 0; i < N; i++) {\n          array[i] = sc.nextLong();\n        }\n        return array;\n      }\n    }\n  }\n\n  static class Output extends PrintWriter {\n\n    public Output(PrintStream ps) {\n      super(ps);\n    }\n\n    public void print(int[] a, String separator) {\n      for (int i = 0; i < a.length; i++) {\n        if (i == 0) print(a[i]);\n        else print(separator + a[i]);\n      }\n      println();\n    }\n\n    public void print(long[] a, String separator) {\n      for (int i = 0; i < a.length; i++) {\n        if (i == 0) print(a[i]);\n        else print(separator + a[i]);\n      }\n      println();\n    }\n\n    public void print(String[] a, String separator) {\n      for (int i = 0; i < a.length; i++) {\n        if (i == 0) print(a[i]);\n        else print(separator + a[i]);\n      }\n      println();\n    }\n\n    public void print(ArrayList a, String separator) {\n      for (int i = 0; i < a.size(); i++) {\n        if (i == 0) print(a.get(i));\n        else print(separator + a.get(i));\n      }\n      println();\n    }\n  }\n\n}\n", "code2": "# The Secret Number from Aizu Online Judge\n\n# \u6f38\u5316\u5f0f:\n#    S(i, j) = max( S(i-1,j), S(i,j-1) ) D_ij if D_ij \u2208 { 0,1,2,3,4,5,6,7,8,9 }\n#            = \u03c6 otherwise\n\ndef secret_number(w, h, matrix)\n  subsol = Array.new(h+1) { |i| Array.new(w+1) { |j| i*j==0 ? '' : nil } }\n  1.upto h do |i|\n    1.upto w do |j|\n      c = matrix[i-1][j-1]\n      subsol[i][j] = if c =~ /\\d/\n                       [subsol[i-1][j], subsol[i][j-1]].max_by(&:to_i) + c\n                     else\n                       ''\n                     end\n    end\n  end\n  subsol.map { |row| row.max_by(&:to_i) }.max_by(&:to_i).to_i\nend\n\n# ----------------------------------------\nloop do\n  w, h = gets.split.map(&:to_i)\n  break if [w,h] == [0,0]\n\n  matrix = h.times.map { gets.chomp.chars }\n  ans = secret_number(w, h, matrix)\n  puts ans\nend", "label": 0, "name1": "s001351994.java", "name2": "s488110677.rb"}, {"id": 308, "code1": "import java.io.*;\nimport java.util.StringTokenizer;\n\npublic final class Main{\n    public static void main(String[] args){\n        FastScanner stdIn = new FastScanner(System.in);\n        long a = stdIn.nextLong();\n        long b = stdIn.nextLong();\n        long c = stdIn.nextLong();\n\n        if(c-(a-b)<0){\n            System.out.println(0);\n        }else{\n            System.out.println(c-(a-b));\n        }\n    }\n}\n\nclass FastScanner {\n    private BufferedReader reader = null;\n    private StringTokenizer tokenizer = null;\n\n    public FastScanner(InputStream in) {\n        reader = new BufferedReader(new InputStreamReader(in));\n        tokenizer = null;\n    }\n\n    public String next() {\n        if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public String nextLine() {\n        if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        return tokenizer.nextToken(\"\\n\");\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n    \n    public long nextInt() {\n        return Integer.parseInt(next());\n    }\n\n}\n", "code2": "a,b,c=gets.split.map(&:to_i)\np [0, c-a+b].max", "label": 1, "name1": "s641134227.java", "name2": "s732080470.rb"}, {"id": 553, "code1": "import java.io.*;\nimport java.util.*;\nimport static java.lang.System.out;\n\npublic class Main {\n    static MyReader in = new MyReader();\n\n    public static void main(String[] args) {\n        int N = in.i();\n        int k = ((int)Math.sqrt(1 + 8 * N) + 1) / 2;\n        out.println(k * (k - 1) / 2 == N ? solve(k) : \"No\");\n    }\n\n    static String solve(int k) {\n        StringBuilder sb = new StringBuilder(\"Yes\\n\");\n        sb.append(k).append('\\n');\n\n        for (int i = 1; i < k; i++) {\n            sb.append(k - 1).append(' ');\n\n            int t = 1 + i * (i - 1) / 2;\n            for (int j = 1; j < i; j++) {\n                sb.append(t++).append(' ');\n            }\n\n            for (int j = i; j < k; j++) {\n                sb.append(t).append(' ');\n                t += j;\n            }\n            sb.append('\\n');\n        }\n\n        sb.append(k - 1).append(' ');\n        int t = 1;\n        for (int i = 2; i <= k; i++) {\n            sb.append(t).append(' ');\n            t += i;\n        }\n\n        return sb.toString();\n    }\n}\n\nclass MyReader extends BufferedReader {\n    char[] cbuf = new char[1024];\n    int head = 0;\n    int tail = 0;\n\n    MyReader() {\n        super(new InputStreamReader(System.in));\n    }\n\n    char next() {\n        if (head == tail) {\n            try {\n                tail = super.read(cbuf, 0, cbuf.length);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            head = 0;\n        }\n        return cbuf[head++];\n    }\n\n    void back() {\n        head--;\n    }\n\n    boolean minus() {\n        boolean minus;\n        while (true) {\n            char c = next();\n            if (!isDelimiter(c)) {\n                if (!(minus = c == '-')) back();\n                return minus;\n            }\n        }\n    }\n\n    void skip() {\n        while (isDelimiter(next()));\n        back();\n    }\n\n    char[] s(int N) {\n        char[] cbuf = new char[N];\n        read(cbuf, 0, N);\n        return cbuf;\n    }\n\n    public int read(char[] cbuf, int off, int len) {\n        skip();\n        int i;\n        for (i = 0; i < cbuf.length; i++) {\n            char c = next();\n            if (isDelimiter(c)) {\n                break;\n            }\n            cbuf[i] = c;\n        }\n        return i;\n    }\n\n    boolean isDelimiter(char c) {\n        return c == ' ' || c == '\\n' || c == '\\r';\n    }\n\n    int i() {\n        boolean minus = minus();\n        int n = 0;\n        while (true) {\n            int k = next() - '0';\n            if (k < 0 || 9 < k) break;\n            n = 10 * n + k;\n        }\n        return minus ? -n : n;\n    }\n\n    int[] ii(final int N) {\n        int[] a = new int[N];\n        for (int j = 0; j < a.length; j++) a[j] = i();\n        return a;\n    }\n\n    long l() {\n        boolean minus = minus();\n        long n = 0;\n        while (true) {\n            int k = next() - '0';\n            if (k < 0 || 9 < k) break;\n            n = 10 * n + k;\n        }\n        return minus ? -n : n;\n    }\n}\n", "code2": "N, K = gets.chomp.split(\" \").map(&:to_i)\n\ns, m = N.divmod(K)\nputs [N, m, (m-K).abs].min\n", "label": 0, "name1": "s799940458.java", "name2": "s201038310.rb"}, {"id": 920, "code1": "import java.util.*;\n\npublic class Main {    \n    \n  public static void main(String[] args) {              \n     Scanner sc = new Scanner(System.in);\n     \n     int N = sc.nextInt();\n     \n     int sum = 0;\n     int min = Integer.MAX_VALUE;\n     \n     int count = 0;\n     for(int i = 0;i < N;i++){\n         int a = sc.nextInt();\n         if(a%10 == 0){\n               count++;\n         }\n         sum += a;\n         if(a%10 != 0){\n           min = Math.min(min,a);\n         }\n     }\n     \n     if(count == N){\n         System.out.println(0);\n         return;\n     }     \n                           \n     if(sum%10 != 0){\n         System.out.println(sum);\n         return;\n     }else{\n         System.out.println(sum - min);\n         return;\n     }\n      \n  }          \n}", "code2": "N=gets.to_i\nM=10**9+7\n*F=I=[r=1,t=1]\nR=1,1,*(2..N).map{|i|I<<z=M/i*-I[M%i]%M;F<<r=r*i%M;t=t*z%M}\n(-~N/2...N).each{|i|r-=F[i-1]*R[2*i-N]*F[i]%M}\np r%M\n###############################################\n###############################################\n###############################################\n###############################################\n###############################################", "label": 0, "name1": "s839075233.java", "name2": "s817895786.rb"}, {"id": 475, "code1": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\n\t\tint n = sc.nextInt();\n\n\t\tint a[] = new int[n];\n\t\tint b[] = new int[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tb[i] = sc.nextInt();\n\t\t}\n\n\t\tlong ba = 0;\n\t\tlong ab = 0;\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (b[i] > a[i]) {\n\t\t\t\tba += (b[i] - a[i]) / 2;\n\t\t\t} else {\n\t\t\t\tab += (a[i] - b[i]);\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tSystem.out.println(ab <= ba ? \"Yes\" : \"No\");\n\t}\n}\n", "code2": "gets;a,b=$<.map{|s|s.split.map &:to_i};\nt=eval((b*?+)+?-+(a*?-));\nA=[a,b].transpose.reduce(0){|s,a|s+=a[0]>a[1] ?a[0]-a[1]:0};\nB=[a,b].transpose.reduce(0){|s,a|s+=a[0]>a[1] ?0:(a[1]-a[0]+1)/2};\nputs [A,B].max>t ?:No: :Yes", "label": 1, "name1": "s582242118.java", "name2": "s344898645.rb"}, {"id": 596, "code1": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint[] pri = new int[25000];\n\t\tpri[0] = 2;\n\t\tpri[1] = 3;\n\t\tpri[2] = 5;\n\t\tpri[3] = 7;\n\t\tpri[4] = 11;\n\t\tpri[5] = 13;\n\t\tpri[6] = 17;\n\t\tpri[7] = 19;\n\t\tpri[8] = 23;\n\t\tpri[9] = 29;\n\t\tint fl = 0;\n\t\tint a=0;\n\t\tint b=0;\n\t\tint c=0;\n\t\twhile(pri[a]<=250000){\n\t\t\tfl++;\n\t\t\tfor(int i=0;i<8;i++){\n\t\t\t\ta=0;\n\t\t\t\tb=0;\n\t\t\t\tc=0;\t\t\t\t\n\t\t\t\tif(i==0){\n\t\t\t\t\tc=1;\n\t\t\t\t}else if(i>0){\n\t\t\t\t\tc=pri[2+i];\n\t\t\t\t}\n\t\t\t\twhile(pri[a]!=0){\n\t\t\t\t\tif((30*fl + c)%pri[a]==0){\n\t\t\t\t\t\tb=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ta++;\n\t\t\t\t}\n\t\t\t\tif(b==0){\n\t\t\t\t\tpri[a]=(30*fl + c);\n\t\t\t\t}\n\t\t\t}\t\t\t\t\t\n\t\t}\n\t\t\n\t\tboolean exit = true;\n\t\twhile(exit==true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)exit=false;\n\t\t\tif(exit==true){\n\t\t\t\tint sum=-1;\n\t\t\t\tint i=0;\n\t\t\t\twhile(true){\n\t\t\t\t\tif(pri[i]>n)sum++;\n\t\t\t\t\tif(pri[i]>2*n)break;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(sum);\n\t\t\t}\n\t\t}\n\t}\n\t\n}", "code2": "q=gets.to_i\nq.times{\n  a,b=gets.split.map(&:to_i)\n  s=a*b\n  c=Math.sqrt(s).to_i\n  c-=1 if c**2==s\n  if a==b\n    p 2*a-2\n  else\n    p c*(c+1)>=s ? 2*c-2:2*c-1\n  end\n}\n", "label": 0, "name1": "s593802453.java", "name2": "s038330329.rb"}, {"id": 794, "code1": "import java.io.*;\nimport java.util.*;\n \npublic class Main {\n\tstatic final Reader in = new Reader();\n\tstatic final long M=(long)1e9+7;\n\t\n\tpublic static void main(String[] args) {\n\t\tint n=in.nextInt();\n\t\tlong[] ps = new long[n+1];\n\t\tlong nf=1;\n\t\tfor(int i=1; i<=n; ++i) {\n\t\t\tps[i]=(ps[i-1]+in.nextInt())%M;\n\t\t\tnf=nf*i%M;\n\t\t}\n\t\tlong ans=nf*ps[n]%M, s=0;\n\t\tfor(int i=1; i<=n-1; ++i) {\n\t\t\ts=(s+ps[n-i]-ps[i]+M)%M;\n\t\t\tans=(ans+nf*modI((long)(i+1)*(i>=n-1?1:i+2), M)%M*2*s+nf*modI(i+1, M)%M*(ps[i]+ps[n]-ps[n-i]+M))%M;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\t\n\tstatic long modI(long a, long m) {\n\t\treturn (a%=m)<=1?1:(1-modI(m%a, a)*m)/a+m;\n\t}\n\t\n\tstatic class Reader {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st;\n\t\tString next() {\n\t\t\twhile(st==null||!st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch(Exception e) {}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t}\n}", "code2": "require \"date\"\n\nYEAR = 2004\nWDAY = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n\nwhile true\n  m, d = gets.split.map(&:to_i)\n  \n  break if m == 0 && d == 0\n  \n  puts WDAY[Date.new(YEAR, m, d).wday]\nend", "label": 0, "name1": "s013996602.java", "name2": "s853442568.rb"}, {"id": 273, "code1": "import java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc= new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint count=0;\n\t\t\tint n=sc.nextInt();\n\t\t\tint x=sc.nextInt();\n\t\t\tif(n==0 && x==0) break;\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=i+1;j<=n;j++){\n\t\t\t\t\tfor(int k=j+1;k<=n;k++){\n\t\t\t\t\t\tif(i+j+k == x) count++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}", "code2": "require 'scanf'\nwhile true\ninput = scanf(\"%d %d\")\nn = input[0];\nx = input[1];\nif n == 0 && x == 0\nbreak\nend\ncnt = 0\nfor r in 1...n+1\nfor c in r + 1...n+1\nfor f in c + 1...n+1\nif r + c + f == x\ncnt += 1\nend\nend\nend\nend\nputs cnt\nend", "label": 1, "name1": "s030330226.java", "name2": "s364906499.rb"}, {"id": 67, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\n\n\npublic class Main {\n\n\tprivate BufferedReader reader = new BufferedReader(new InputStreamReader(System.in), 1);\n\n\tprivate String inputData = null;\n\n\tpublic String[] data = null;\n\n\tpublic int num = 0;\n\n\tpublic int count = 0;\n\n\tpublic HashMap<Integer, Integer> humanData = new HashMap<Integer, Integer>();\n\n\tpublic ArrayList<Integer> topId = new ArrayList<Integer>();\n\n\tpublic ArrayList<Integer> topLength = new ArrayList<Integer>();\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().start();\n\t\tSystem.exit(0);\n\t}\n\n\tpublic void start() {\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\tthis.inputData = reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t\t\tthis.data = this.inputData.split(\" \");\n\n\t\t\tif (this.data.length == 1) {\n\t\t\t\tif (this.data[0].equals(\"0\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tthis.num = Integer.parseInt(this.data[0]);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.humanData.clear();\n\n\t\t\tfor (int i = 0; i < this.num; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.inputData = reader.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tthis.data = this.inputData.split(\" \");\n\n\t\t\t\tthis.humanData.put(Integer.parseInt(data[0]),\n\t\t\t\t\t\tInteger.parseInt(data[1]) + Integer.parseInt(data[2]));\n\n\t\t\t}\n\n\t\t\tIterator<Integer> itId = this.humanData.keySet().iterator();\n\t\t\tint numCount = 0;\n\t\t\twhile (itId.hasNext()) {\n\t\t\t\tint id = itId.next();\n\t\t\t\tif (numCount == 0) {\n\t\t\t\t\tthis.topId.add(id);\n\t\t\t\t\tthis.topLength.add(this.humanData.get(id));\n\t\t\t\t} else {\n\t\t\t\t\tif (this.topLength.get(count) <= this.humanData.get(id)) {\n\t\t\t\t\t\tthis.topId.set(this.count, id);\n\t\t\t\t\t\tthis.topLength.set(this.count, this.humanData.get(id));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnumCount++;\n\t\t\t}\n\n\t\t\tthis.count++;\n\n\t\t}\n\n\t\tfor (int i = 0; i < this.topId.size(); i++) {\n\t\t\tSystem.out.println(this.topId.get(i) + \" \" + this.topLength.get(i));\n\t\t}\n\n\t}\n\n}", "code2": "while (n=gets.chomp)!=\"0\"\n  id,d = 0,0\n  n.to_i.times do\n    p,d1,d2 = gets.split.map!(&:to_i)\n    if d<d1+d2\n      d=d1+d2\n      id=p\n    end\n  end\n  puts [id,d].join(' ')\nend", "label": 1, "name1": "s083635030.java", "name2": "s045283570.rb"}, {"id": 474, "code1": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\n\t\tint n = sc.nextInt();\n\n\t\tint a[] = new int[n];\n\t\tint b[] = new int[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tb[i] = sc.nextInt();\n\t\t}\n\n\t\tlong ba = 0;\n\t\tlong ab = 0;\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (b[i] > a[i]) {\n\t\t\t\tba += (b[i] - a[i]) / 2;\n\t\t\t} else {\n\t\t\t\tab += (a[i] - b[i]);\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tSystem.out.println(ab <= ba ? \"Yes\" : \"No\");\n\t}\n}\n", "code2": "#input of int(split by space)\ndef get_i()\n  return gets.chomp.split(\" \").map(&:to_i)\nend\n#input of float(split by space)\ndef get_f()\n  return gets.chomp.split(\" \").map(&:to_f)\nend\n#input of string(split by space)\ndef get()\n  return gets.chomp.split(\" \")\nend\n#input of string(split per one character)\ndef get_nsp()\n  return gets.chomp.split(\"\")\nend\n#yes or no decision\ndef yn_judge(bool,y=\"Yes\",n=\"No\")\n  return bool ? y : n \nend\n#create of array\ndef array(size1,init=nil,size2=-1)\n  if size2==-1\n    return Array.new(size1){init}\n  else\n    return Array.new(size2){Array.new(size1){init}}\n  end\nend\n\ndef max(a,b)\n    return a>b ? a : b\nend\n\ndef min(a,b)\n    return a>b ? b : a\nend\n\nINF=Float::INFINITY\n\nN=gets.to_i\na=get_i\nb=get_i\nadd=0\nN.times do|i|\n    if a[i]>b[i]\n        add+=a[i]-b[i]\n    end\nend\nN.times do|i|\n  if a[i]<b[i]\n      r=(b[i]-a[i])/2\n      add-=r\n  end\nend\nif add>0\n    puts \"No\"\nelse\n    puts \"Yes\"\nend", "label": 1, "name1": "s582242118.java", "name2": "s323281467.rb"}, {"id": 420, "code1": "import java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n    static void solve() {\n        int n = nextInt();\n\n        long ans = nextLong();\n//        System.out.println(ans);\n        for (int i = 1; i < n; i++) {\n            long t = nextLong();\n            ans = lcm(ans, t);\n//            System.out.println(ans);\n        }\n        out.println(ans);\n    }\n\n    static final int MOD = 1_000_000_007;\n    static long[] fac, finv, inv;\n\n    // nCk\u306e\u521d\u671f\u5316\n    static void comInit(int max) {\n        fac = new long[max];\n        finv = new long[max];\n        inv = new long[max];\n        fac[0] = fac[1] = 1;\n        finv[0] = finv[1] = 1;\n        inv[1] = 1;\n\n        for (int i = 2; i < max; i++) {\n            fac[i] = fac[i - 1] * i % MOD;\n            inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n            finv[i] = finv[i - 1] * inv[i] % MOD;\n        }\n    }\n\n    // nCk\u306e\u8a08\u7b97\n    static long com(int n, int k) {\n        if (n < k)\n            return 0;\n        if (n < 0 || k < 0)\n            return 0;\n        return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n    }\n\n    static PrintWriter out;\n    static Scanner sc;\n\n    static int[][] newIntArray(int h, int w, int value) {\n        int[][] ret = new int[h][w];\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                ret[i][j] = value;\n            }\n        }\n        return ret;\n    }\n\n    static int nextInt() {\n        return Integer.parseInt(sc.next());\n    }\n\n    static long nextLong() {\n        return Long.parseLong(sc.next());\n    }\n\n    static String nextString() {\n        return sc.next();\n    }\n\n    static int[] nextIntArray(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = nextInt();\n        }\n        return a;\n    }\n\n    static List<Integer> nextIntList(int n) {\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add(nextInt());\n        }\n        return list;\n    }\n\n    static List<Double> nextDoubleList(int n) {\n        List<Double> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add((double) nextInt());\n        }\n        return list;\n    }\n\n    static List<Long> nextLongList(int n) {\n        List<Long> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add(nextLong());\n        }\n        return list;\n    }\n\n    static char[][] nextCharArray(int h, int w) {\n        char[][] c = new char[h][w];\n        for (int i = 0; i < h; i++) {\n            String str = nextString();\n            for (int j = 0; j < w; j++) {\n                c[i][j] = str.charAt(j);\n            }\n        }\n        return c;\n    }\n\n    static <T extends Comparable<? super T>> void sort(List<T> list) {\n        Collections.sort(list);\n    }\n\n    // greatest common divisor\n    // \u6700\u5927\u516c\u7d04\u6570\n    static long gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    // least common multiple\n    // \u6700\u5c0f\u516c\u500d\u6570\n    static long lcm(long a, long b) {\n        if (a >= b && a % b == 0)\n            return a;\n        if (b > a && b % a == 0)\n            return b;\n\n//        return a * b / gcd(a, b);\n        if (a > b) {\n            return (a / gcd(a, b)) * b;\n        } else {\n            return (b / gcd(a, b)) * a;\n        }\n    }\n\n    // base\u306en\u4e57\u3092\u8a08\u7b97\u3092\u8fd4\u3059\n    static int pow(int base, int n) {\n        int ret = 1;\n        for (int i = 0; i < n; i++) {\n            ret *= base;\n        }\n        return ret;\n    }\n\n    // return n^k mod m\n    static long powMod(long n, long k, long m) {\n        if (k == 0) {\n            return 1;\n        } else if (k % 2 == 1) {\n            return powMod(n, k - 1, m) * n % m;\n        } else {\n            long tmp = powMod(n, k / 2, m);\n            return tmp * tmp % m;\n        }\n    }\n\n    // int\u3092length\u6841\u306ebit\u6587\u5b57\u5217\u306b\u5909\u63db\n    static String toBitString(int length, int n) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = length - 1; i >= 0; i--) {\n            if ((n >> i) % 2 == 1) {\n                sb.append(\"1\");\n            } else {\n                sb.append(\"0\");\n            }\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        out = new PrintWriter(System.out);\n        sc = new Scanner(System.in);\n\n        solve();\n\n        out.flush();\n        sc.close();\n    }\n\n}\n", "code2": "a = []\ngets.to_i.times{ a << gets.to_i }\nputs a.inject{|x, y| x.lcm(y) }", "label": 1, "name1": "s078472493.java", "name2": "s688834112.rb"}, {"id": 421, "code1": "import java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n    static void solve() {\n        int n = nextInt();\n\n        long ans = nextLong();\n//        System.out.println(ans);\n        for (int i = 1; i < n; i++) {\n            long t = nextLong();\n            ans = lcm(ans, t);\n//            System.out.println(ans);\n        }\n        out.println(ans);\n    }\n\n    static final int MOD = 1_000_000_007;\n    static long[] fac, finv, inv;\n\n    // nCk\u306e\u521d\u671f\u5316\n    static void comInit(int max) {\n        fac = new long[max];\n        finv = new long[max];\n        inv = new long[max];\n        fac[0] = fac[1] = 1;\n        finv[0] = finv[1] = 1;\n        inv[1] = 1;\n\n        for (int i = 2; i < max; i++) {\n            fac[i] = fac[i - 1] * i % MOD;\n            inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n            finv[i] = finv[i - 1] * inv[i] % MOD;\n        }\n    }\n\n    // nCk\u306e\u8a08\u7b97\n    static long com(int n, int k) {\n        if (n < k)\n            return 0;\n        if (n < 0 || k < 0)\n            return 0;\n        return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n    }\n\n    static PrintWriter out;\n    static Scanner sc;\n\n    static int[][] newIntArray(int h, int w, int value) {\n        int[][] ret = new int[h][w];\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                ret[i][j] = value;\n            }\n        }\n        return ret;\n    }\n\n    static int nextInt() {\n        return Integer.parseInt(sc.next());\n    }\n\n    static long nextLong() {\n        return Long.parseLong(sc.next());\n    }\n\n    static String nextString() {\n        return sc.next();\n    }\n\n    static int[] nextIntArray(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = nextInt();\n        }\n        return a;\n    }\n\n    static List<Integer> nextIntList(int n) {\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add(nextInt());\n        }\n        return list;\n    }\n\n    static List<Double> nextDoubleList(int n) {\n        List<Double> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add((double) nextInt());\n        }\n        return list;\n    }\n\n    static List<Long> nextLongList(int n) {\n        List<Long> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add(nextLong());\n        }\n        return list;\n    }\n\n    static char[][] nextCharArray(int h, int w) {\n        char[][] c = new char[h][w];\n        for (int i = 0; i < h; i++) {\n            String str = nextString();\n            for (int j = 0; j < w; j++) {\n                c[i][j] = str.charAt(j);\n            }\n        }\n        return c;\n    }\n\n    static <T extends Comparable<? super T>> void sort(List<T> list) {\n        Collections.sort(list);\n    }\n\n    // greatest common divisor\n    // \u6700\u5927\u516c\u7d04\u6570\n    static long gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    // least common multiple\n    // \u6700\u5c0f\u516c\u500d\u6570\n    static long lcm(long a, long b) {\n        if (a >= b && a % b == 0)\n            return a;\n        if (b > a && b % a == 0)\n            return b;\n\n//        return a * b / gcd(a, b);\n        if (a > b) {\n            return (a / gcd(a, b)) * b;\n        } else {\n            return (b / gcd(a, b)) * a;\n        }\n    }\n\n    // base\u306en\u4e57\u3092\u8a08\u7b97\u3092\u8fd4\u3059\n    static int pow(int base, int n) {\n        int ret = 1;\n        for (int i = 0; i < n; i++) {\n            ret *= base;\n        }\n        return ret;\n    }\n\n    // return n^k mod m\n    static long powMod(long n, long k, long m) {\n        if (k == 0) {\n            return 1;\n        } else if (k % 2 == 1) {\n            return powMod(n, k - 1, m) * n % m;\n        } else {\n            long tmp = powMod(n, k / 2, m);\n            return tmp * tmp % m;\n        }\n    }\n\n    // int\u3092length\u6841\u306ebit\u6587\u5b57\u5217\u306b\u5909\u63db\n    static String toBitString(int length, int n) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = length - 1; i >= 0; i--) {\n            if ((n >> i) % 2 == 1) {\n                sb.append(\"1\");\n            } else {\n                sb.append(\"0\");\n            }\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        out = new PrintWriter(System.out);\n        sc = new Scanner(System.in);\n\n        solve();\n\n        out.flush();\n        sc.close();\n    }\n\n}\n", "code2": "p gets.to_i.times.map{gets.to_i}.reduce(&:lcm)", "label": 1, "name1": "s078472493.java", "name2": "s977919645.rb"}, {"id": 979, "code1": "import java.io.*;\nimport java.util.*;\n\n/**\n * @author baito\n */\npublic class Main\n{\n    static StringBuilder sb = new StringBuilder();\n    static FastScanner sc = new FastScanner(System.in);\n    static int INF = 12345678;\n    static long LINF = 123456789123456789L;\n    static long MINF = -123456789123456789L;\n    static long MOD = 1000000007;\n    static int[] y4 = {0, 1, 0, -1};\n    static int[] x4 = {1, 0, -1, 0};\n    static int[] y8 = {0, 1, 0, -1, -1, 1, 1, -1};\n    static int[] x8 = {1, 0, -1, 0, 1, -1, 1, -1};\n    static long[] F;//factorial\n    static boolean[] isPrime;\n    static int[] primes;\n    static char[][] map;\n\n    static int N, A, B;\n    static int[] h;\n\n\n    public static void main(String[] args)\n    {\n        N = sc.nextInt();\n        A = sc.nextInt();\n        B = sc.nextInt();\n        h = sc.nextIntArray(N);\n        int ok = (int) Math.ceil(max(h) * 1.0 / B);\n        int ng = 0;\n        System.out.println(mgr(ok,ng));\n\n    }\n\n    static int mgr(int ok, int ng)\n    {\n        while (Math.abs(ok - ng) > 1)\n        {\n            int mid = (ok + ng) / 2;\n            if (solve(mid))\n            {\n                ok = mid;\n            }\n            else\n            {\n                ng = mid;\n            }\n        }\n        return ok;\n    }\n\n    static boolean solve(long K)\n    {\n        long k = 0;\n        for (int i = 0; i < N; i++)\n        {\n            long hp = h[i];\n            hp -= K * B;\n            if (hp <= 0) continue;\n            k += (long) Math.ceil(hp * 1.0 / (A - B));\n        }\n        if (K < k) return false;\n        else return true;\n    }\n\n    public static boolean isOutofIndex(int x, int y)\n    {\n        if (x < 0 || y < 0) return true;\n        if (map[0].length <= x || map.length <= y) return true;\n        return false;\n    }\n\n    public static void setPrimes()\n    {\n        int n = 100001;\n        isPrime = new boolean[n];\n        List<Integer> prs = new ArrayList<>();\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n        for (int i = 2; i * i <= n; i++)\n        {\n            if (!isPrime[i]) continue;\n            prs.add(i);\n            for (int j = i * 2; j < n; j += i)\n            {\n                isPrime[j] = false;\n            }\n        }\n        primes = new int[prs.size()];\n        for (int i = 0; i < prs.size(); i++)\n            primes[i] = prs.get(i);\n    }\n\n    public static void revSort(int[] a)\n    {\n        Arrays.sort(a);\n        reverse(a);\n    }\n\n    public static void revSort(long[] a)\n    {\n        Arrays.sort(a);\n        reverse(a);\n    }\n\n    public static int[][] copy(int[][] ar)\n    {\n        int[][] nr = new int[ar.length][ar[0].length];\n        for (int i = 0; i < ar.length; i++)\n            for (int j = 0; j < ar[0].length; j++)\n                nr[i][j] = ar[i][j];\n        return nr;\n    }\n\n    public static long sumMod(long... lar)\n    {\n        long sum = 0;\n        for (long l : lar)\n            sum = (sum + l % MOD) % MOD;\n        return sum;\n    }\n\n    /**\n     * <h1>\u6307\u5b9a\u3057\u305f\u5024\u4ee5\u4e0a\u306e\u5148\u982d\u306e\u30a4\u30f3\u30c7\u30af\u30b9\u3092\u8fd4\u3059</h1>\n     * <p>\u914d\u5217\u8981\u7d20\u304c\uff10\u306e\u3068\u304d\u306f\u3001\uff10\u304c\u8fd4\u308b\u3002</p>\n     *\n     * @return<b>int</b> \uff1a \u63a2\u7d22\u3057\u305f\u5024\u4ee5\u4e0a\u3067\u3001\u5148\u982d\u306b\u306a\u308b\u30a4\u30f3\u30c7\u30af\u30b9\n     */\n    public static int lowerBound(final int[] arr, final int value)\n    {\n        int low = 0;\n        int high = arr.length;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (\u30aa\u30fc\u30d0\u30fc\u30d5\u30ed\u30fc\u5bfe\u7b56)\n            if (arr[mid] < value)\n            {\n                low = mid + 1;\n            }\n            else\n            {\n                high = mid;\n            }\n        }\n        return low;\n    }\n\n    /**\n     * <h1>\u6307\u5b9a\u3057\u305f\u5024\u3088\u308a\u5927\u304d\u3044\u5148\u982d\u306e\u30a4\u30f3\u30c7\u30af\u30b9\u3092\u8fd4\u3059</h1>\n     * <p>\u914d\u5217\u8981\u7d20\u304c\uff10\u306e\u3068\u304d\u306f\u3001\uff10\u304c\u8fd4\u308b\u3002</p>\n     *\n     * @return<b>int</b> \uff1a \u63a2\u7d22\u3057\u305f\u5024\u3088\u308a\u4e0a\u3067\u3001\u5148\u982d\u306b\u306a\u308b\u30a4\u30f3\u30c7\u30af\u30b9\n     */\n    public static int upperBound(final int[] arr, final int value)\n    {\n        int low = 0;\n        int high = arr.length;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (\u30aa\u30fc\u30d0\u30fc\u30d5\u30ed\u30fc\u5bfe\u7b56)\n            if (arr[mid] <= value)\n            {\n                low = mid + 1;\n            }\n            else\n            {\n                high = mid;\n            }\n        }\n        return low;\n    }\n\n    //\u6b21\u306e\u9806\u5217\u306b\u66f8\u304d\u63db\u3048\u308b\u3001\u6700\u5927\u5024\u306a\u3089false\u3092\u8fd4\u3059\n    public static boolean nextPermutation(int A[])\n    {\n        int len = A.length;\n        int pos = len - 2;\n        for (; pos >= 0; pos--)\n        {\n            if (A[pos] < A[pos + 1]) break;\n        }\n        if (pos == -1) return false;\n\n        //pos\u3088\u308a\u5927\u304d\u3044\u6700\u5c0f\u306e\u6570\u3092\u4e8c\u5206\u63a2\u7d22\n        int ok = pos + 1;\n        int ng = len;\n        while (Math.abs(ng - ok) > 1)\n        {\n            int mid = (ok + ng) / 2;\n            if (A[mid] > A[pos]) ok = mid;\n            else ng = mid;\n\n        }\n\n        swap(A, pos, ok);\n        reverse(A, pos + 1, len - 1);\n\n\n        return true;\n    }\n\n    //\u6b21\u306e\u9806\u5217\u306b\u66f8\u304d\u63db\u3048\u308b\u3001\u6700\u5c0f\u5024\u306a\u3089false\u3092\u8fd4\u3059\n    public static boolean prevPermutation(int A[])\n    {\n        int len = A.length;\n        int pos = len - 2;\n        for (; pos >= 0; pos--)\n        {\n            if (A[pos] > A[pos + 1]) break;\n        }\n        if (pos == -1) return false;\n\n        //pos\u3088\u308a\u5c0f\u3055\u3044\u6700\u5927\u306e\u6570\u3092\u4e8c\u5206\u63a2\u7d22\n        int ok = pos + 1;\n        int ng = len;\n        while (Math.abs(ng - ok) > 1)\n        {\n            int mid = (ok + ng) / 2;\n            if (A[mid] < A[pos]) ok = mid;\n            else ng = mid;\n\n        }\n\n        swap(A, pos, ok);\n        reverse(A, pos + 1, len - 1);\n\n\n        return true;\n    }\n\n    //\u2193nCr\u3092mod\u8a08\u7b97\u3059\u308b\u305f\u3081\u306b\u5fc5\u8981\u3002\u3000***factorial(N)\u3092\u547c\u3076\u5fc5\u8981\u304c\u3042\u308b***\n    static long ncr(int n, int r)\n    {\n        if (n < r) return 0;\n        else if (r == 0) return 1;\n\n        factorial(n);\n        return F[n] / (F[n - r] * F[r]);\n    }\n\n    static long ncr2(int a, int b)\n    {\n        if (b == 0) return 1;\n        else if (a < b) return 0;\n        long res = 1;\n        for (int i = 0; i < b; i++)\n        {\n            res *= a - i;\n            res /= i + 1;\n        }\n        return res;\n    }\n\n    static long ncrdp(int n, int r)\n    {\n        if (n < r) return 0;\n        long[][] dp = new long[n + 1][r + 1];\n        for (int ni = 0; ni < n + 1; ni++)\n        {\n            dp[ni][0] = dp[ni][ni] = 1;\n            for (int ri = 1; ri < ni; ri++)\n            {\n                dp[ni][ri] = dp[ni - 1][ri - 1] + dp[ni - 1][ri];\n            }\n        }\n        return dp[n][r];\n    }\n\n    static long modNcr(int n, int r)\n    {\n        long result = F[n];\n        result = result * modInv(F[n - r]) % MOD;\n        result = result * modInv(F[r]) % MOD;\n        return result;\n    }\n\n    static long modInv(long n)\n    {\n        return modPow(n, MOD - 2);\n    }\n\n    static void factorial(int n)\n    {\n        F = new long[n + 1];\n        F[0] = F[1] = 1;\n        for (int i = 2; i <= n; i++)\n        {\n            F[i] = (F[i - 1] * i) % MOD;\n        }\n    }\n\n    static long modPow(long x, long n)\n    {\n        long res = 1L;\n        while (n > 0)\n        {\n            if ((n & 1) == 1)\n            {\n                res = res * x % MOD;\n            }\n            x = x * x % MOD;\n            n >>= 1;\n        }\n        return res;\n    }\n\n    //\u2191nCr\u3092mod\u8a08\u7b97\u3059\u308b\u305f\u3081\u306b\u5fc5\u8981\n\n    static int gcd(int n, int r)\n    {\n        return r == 0 ? n : gcd(r, n % r);\n    }\n\n    static long gcd(long n, long r)\n    {\n        return r == 0 ? n : gcd(r, n % r);\n    }\n\n    static <T> void swap(T[] x, int i, int j)\n    {\n        T t = x[i];\n        x[i] = x[j];\n        x[j] = t;\n    }\n\n    static void swap(int[] x, int i, int j)\n    {\n        int t = x[i];\n        x[i] = x[j];\n        x[j] = t;\n    }\n\n    public static void reverse(int[] x)\n    {\n        int l = 0;\n        int r = x.length - 1;\n        while (l < r)\n        {\n            int temp = x[l];\n            x[l] = x[r];\n            x[r] = temp;\n            l++;\n            r--;\n        }\n    }\n\n    public static void reverse(long[] x)\n    {\n        int l = 0;\n        int r = x.length - 1;\n        while (l < r)\n        {\n            long temp = x[l];\n            x[l] = x[r];\n            x[r] = temp;\n            l++;\n            r--;\n        }\n    }\n\n    public static void reverse(int[] x, int s, int e)\n    {\n        int l = s;\n        int r = e;\n        while (l < r)\n        {\n            int temp = x[l];\n            x[l] = x[r];\n            x[r] = temp;\n            l++;\n            r--;\n        }\n    }\n\n    static int length(int a)\n    {\n        int cou = 0;\n        while (a != 0)\n        {\n            a /= 10;\n            cou++;\n        }\n        return cou;\n    }\n\n    static int length(long a)\n    {\n        int cou = 0;\n        while (a != 0)\n        {\n            a /= 10;\n            cou++;\n        }\n        return cou;\n    }\n\n    static int countC2(char[][] a, char c)\n    {\n        int co = 0;\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[0].length; j++)\n                if (a[i][j] == c) co++;\n        return co;\n    }\n\n    static int countI(int[] a, int key)\n    {\n        int co = 0;\n        for (int i = 0; i < a.length; i++)\n            if (a[i] == key) co++;\n        return co;\n    }\n\n    static int countI(int[][] a, int key)\n    {\n        int co = 0;\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[0].length; j++)\n                if (a[i][j] == key) co++;\n        return co;\n    }\n\n    static void fill(int[][] a, int v)\n    {\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[0].length; j++)\n                a[i][j] = v;\n    }\n\n\n    static void fill(long[][] a, long v)\n    {\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[0].length; j++)\n                a[i][j] = v;\n    }\n\n    static void fill(int[][][] a, int v)\n    {\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[0].length; j++)\n                for (int k = 0; k < a[0][0].length; k++)\n                    a[i][j][k] = v;\n    }\n\n    static int max(int a, int b, int c)\n    {\n        return Math.max(a, Math.max(b, c));\n    }\n\n    static int max(int[] ar)\n    {\n        int res = Integer.MIN_VALUE;\n        for (int i : ar)\n            res = Math.max(res, i);\n        return res;\n    }\n\n    static int max(int[][] ar)\n    {\n        int res = Integer.MIN_VALUE;\n        for (int i[] : ar)\n            res = Math.max(res, max(i));\n        return res;\n    }\n\n    static int min(int a, int b, int c)\n    {\n        return Math.min(a, Math.min(b, c));\n    }\n\n    static int min(int[] ar)\n    {\n        int res = Integer.MAX_VALUE;\n        for (int i : ar)\n            res = Math.min(res, i);\n        return res;\n    }\n\n    static int min(int[][] ar)\n    {\n        int res = Integer.MAX_VALUE;\n        for (int i[] : ar)\n            res = Math.min(res, min(i));\n        return res;\n    }\n\n    static int sum(int[] a)\n    {\n        int cou = 0;\n        for (int i : a)\n            cou += i;\n        return cou;\n    }\n\n    static int abs(int a)\n    {\n        return Math.abs(a);\n    }\n\n    static class FastScanner\n    {\n\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public FastScanner(InputStream in)\n        {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        public String next()\n        {\n            if (tokenizer == null || !tokenizer.hasMoreTokens())\n            {\n                try\n                {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        /*public String nextChar(){\n            return (char)next()[0];\n        }*/\n        public String nextLine()\n        {\n            if (tokenizer == null || !tokenizer.hasMoreTokens())\n            {\n                try\n                {\n                    return reader.readLine();\n                } catch (IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        public int[] nextIntArray(int n)\n        {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n            {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        public int[] nextIntArrayDec(int n)\n        {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n            {\n                a[i] = nextInt() - 1;\n            }\n            return a;\n        }\n\n        public int[][] nextIntArray2(int h, int w)\n        {\n            int[][] a = new int[h][w];\n            for (int hi = 0; hi < h; hi++)\n            {\n                for (int wi = 0; wi < w; wi++)\n                {\n                    a[hi][wi] = nextInt();\n                }\n            }\n            return a;\n        }\n\n        public int[][] nextIntArray2Dec(int h, int w)\n        {\n            int[][] a = new int[h][w];\n            for (int hi = 0; hi < h; hi++)\n            {\n                for (int wi = 0; wi < w; wi++)\n                {\n                    a[hi][wi] = nextInt() - 1;\n                }\n            }\n            return a;\n        }\n\n        //\u8907\u6570\u306e\u914d\u5217\u3092\u53d7\u3051\u53d6\u308b\n        public void nextIntArrays2ar(int[] a, int[] b)\n        {\n            for (int i = 0; i < a.length; i++)\n            {\n                a[i] = sc.nextInt();\n                b[i] = sc.nextInt();\n            }\n        }\n\n        public void nextIntArrays2arDec(int[] a, int[] b)\n        {\n            for (int i = 0; i < a.length; i++)\n            {\n                a[i] = sc.nextInt() - 1;\n                b[i] = sc.nextInt() - 1;\n            }\n        }\n\n        //\u8907\u6570\u306e\u914d\u5217\u3092\u53d7\u3051\u53d6\u308b\n        public void nextIntArrays3ar(int[] a, int[] b, int[] c)\n        {\n            for (int i = 0; i < a.length; i++)\n            {\n                a[i] = sc.nextInt();\n                b[i] = sc.nextInt();\n                c[i] = sc.nextInt();\n            }\n        }\n\n        //\u8907\u6570\u306e\u914d\u5217\u3092\u53d7\u3051\u53d6\u308b\n        public void nextIntArrays3arDec(int[] a, int[] b, int[] c)\n        {\n            for (int i = 0; i < a.length; i++)\n            {\n                a[i] = sc.nextInt() - 1;\n                b[i] = sc.nextInt() - 1;\n                c[i] = sc.nextInt() - 1;\n            }\n        }\n\n        public Integer[] nextIntegerArray(int n)\n        {\n            Integer[] a = new Integer[n];\n            for (int i = 0; i < n; i++)\n            {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        public char[] nextCharArray(int n)\n        {\n            char[] a = next().toCharArray();\n\n            return a;\n        }\n\n        public char[][] nextCharArray2(int h, int w)\n        {\n            char[][] a = new char[h][w];\n            for (int i = 0; i < h; i++)\n            {\n                a[i] = next().toCharArray();\n            }\n            return a;\n        }\n\n        //\u30b9\u30da\u30fc\u30b9\u304c\u5165\u3063\u3066\u3044\u308b\u5834\u5408\n        public char[][] nextCharArray2s(int h, int w)\n        {\n            char[][] a = new char[h][w];\n            for (int i = 0; i < h; i++)\n            {\n                a[i] = nextLine().replace(\" \", \"\").toCharArray();\n            }\n            return a;\n        }\n\n        public char[][] nextWrapCharArray2(int h, int w, char c)\n        {\n            char[][] a = new char[h + 2][w + 2];\n            //char c = '*';\n            int i;\n            for (i = 0; i < w + 2; i++)\n                a[0][i] = c;\n            for (i = 1; i < h + 1; i++)\n            {\n                a[i] = (c + next() + c).toCharArray();\n            }\n            for (i = 0; i < w + 2; i++)\n                a[h + 1][i] = c;\n            return a;\n        }\n\n        //\u30b9\u30da\u30fc\u30b9\u304c\u5165\u3063\u3066\u308b\u6642\u7528\n        public char[][] nextWrapCharArray2s(int h, int w, char c)\n        {\n            char[][] a = new char[h + 2][w + 2];\n            //char c = '*';\n            int i;\n            for (i = 0; i < w + 2; i++)\n                a[0][i] = c;\n            for (i = 1; i < h + 1; i++)\n            {\n                a[i] = (c + nextLine().replace(\" \", \"\") + c).toCharArray();\n            }\n            for (i = 0; i < w + 2; i++)\n                a[h + 1][i] = c;\n            return a;\n        }\n\n        public long[] nextLongArray(int n)\n        {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n            {\n                a[i] = nextLong();\n            }\n            return a;\n        }\n\n        public long[][] nextLongArray2(int h, int w)\n        {\n            long[][] a = new long[h][w];\n            for (int hi = 0; hi < h; hi++)\n            {\n                for (int wi = 0; wi < h; wi++)\n                {\n                    a[h][w] = nextLong();\n                }\n            }\n            return a;\n        }\n    }\n}\n", "code2": "n,*a=`dd`.split.map &:to_i;a.sort!;b=[0]+n.times.map{|j|a[j]*(-1)**j%24};s=24;n.times{|j|(j+1..n).each{|k|s=[s,(b[j]-b[k])%24,(b[k]-b[j])%24].min}};p s", "label": 0, "name1": "s118659723.java", "name2": "s732644795.rb"}, {"id": 74, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main{\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint unko=sc.nextInt();\n\t\tboolean ike=false;\n\t\tint N=0;\n\t\tfor(int i=0; i<=500; i++) {\n\t\t\tif(unko==i*(i+1)/2) {\n\t\t\t\tike=true;\n\t\t\t\tN=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(unko<i*(i+1)/2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ike) {\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\tSystem.out.println(N+1);\n\t\t\tint[][] ary=new int[N+1][N];\n\t\t\tint[] kaz=new int[N+2];\n\t\t\tfor(int i=0; i<=N; i++) {\n\t\t\t\tfor(int j=0; j<N; j++) {\n\t\t\t\t\tary[i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<=N+1; i++) {\n\t\t\t\tkaz[i]=0;\n\t\t\t}\n\t\t\tint counter=1;\n\t\t\tfor(int i=1; i<=N+1; i++) {\n\t\t\t\tfor(int j=1; j<i; j++) {\n\t\t\t\t\tary[i-1][kaz[i-1]]=counter;\n\t\t\t\t\tkaz[i-1]++;\n\t\t\t\t\tary[j-1][kaz[j-1]]=counter;\n\t\t\t\t\tkaz[j-1]++;\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tString buri=\"\";\n\t\t\tfor(int i=0; i<N+1; i++) {\n\t\t\t\tburi=Arrays.toString(ary[i]);\n\t\t\t\tburi=buri.replaceAll(\",\",\"\");\n\t\t\t\tburi=buri.replace(\"[\",\" \");\n\t\t\t\tburi=buri.replace(\"]\",\"\");\n\t\t\t\tSystem.out.println(N+buri);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t}\n}", "code2": "N = gets.to_i\nh = {}\n1.upto(1.0/0){|i|\n  edge = i * (i - 1) / 2\n  h[edge] = i\n  break if edge > 10**5\n}\n\nif !h[N]\n  puts:No\n  exit\nend\n\nvortex = h[N]\nedges = vortex.times.map{[]}\nn = 1\nvortex.times{|i|\n  i.times{|j|\n    edges[i] << n\n    edges[j] << n\n    n += 1\n  }\n}\nputs:Yes\np vortex\nedges.each{|e|\n  puts [e.size, *e]* \" \"\n}\n", "label": 1, "name1": "s468399402.java", "name2": "s612660257.rb"}, {"id": 428, "code1": "\nimport java.util.HashMap;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main \n{\n\tstatic HashMap<String, String> groupdef;\n\tstatic String firstgroup;\n\tstatic TreeSet<String> members;\n\tstatic TreeSet<String> checked;\n\t\n\tstatic void get(String g)\n\t{\n\t\tString con = groupdef.get(g);\n//\t\tSystem.out.println(\"Getting \" + g + \"...\");\n\t\tif(checked.contains(g))return;\n\t\t\n\t\tint start = 0;\n\t\tint mem = 0;\n\t\tfor(int i = 0; i < con.length(); i++)\n\t\t{\n\t\t\tif(con.charAt(i) == ',' || con.charAt(i) == '.')\n\t\t\t{\n\t\t\t\tString word = con.substring(start, i);\n\t\t\t\tstart = i+1;\n\t\t\t\t\n\t\t\t\tif(groupdef.containsKey(word))\n\t\t\t\t{\n\t\t\t\t\tget(word);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmembers.add(word);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tchecked.add(g);\n//\t\tcache.put(g, mem);\n\t}\n\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0)break;\n\t\t\tgroupdef = new HashMap<String, String>();\n//\t\t\tcache = new HashMap<String, Integer>();\n\t\t\tmembers = new TreeSet<String>();\n\t\t\tchecked = new TreeSet<String>();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tString s = sc.next();\n\t\t\t\tint lim = s.indexOf(':');\n\t\t\t\tString groupname = s.substring(0, lim);\n\t\t\t\tString groupcon = s.substring(lim+1);\n\t\t\t\tif(i == 0)firstgroup = groupname;\n\t\t\t\tgroupdef.put(groupname, groupcon);\n\t\t\t}\n\t\t\t\n\t\t\tget(firstgroup);\n\t\t\tSystem.out.println(members.size());\n//\t\t\tSystem.out.println(members);\n\t\t}\n\t\t\n\n\t}\n\n}\n\n", "code2": "### classes\n\nclass Group\n  attr_accessor :id, :n, :reqs, :deps, :ms\n\n  def initialize(_id)\n    @id = _id; @n = 0; @reqs = []; @deps = []; @ms = []\n  end\nend\n\n### main\n\nloop do\n  n = gets.to_i\n  break if n == 0\n\n  gids = {}\n  gn = 0\n  mlists = []\n\n  n.times do\n    gname, mlist = gets.strip.delete('.').split(':')\n    gids[gname] = gn\n    mlists << mlist\n    gn += 1\n  end\n  #p gids\n  #p mlists\n\n  grps = (0...n).map{|id| Group.new(id)}\n  mids = {}\n  mn = 0\n\n  for id in (0...n)\n    grp = grps[id]\n\n    for mem in mlists[id].split(',')\n      gid = gids[mem]\n      if gid.nil?\n        if mids[mem].nil?\n          mids[mem] = mn\n          mn += 1\n        end\n        grp.ms << mids[mem]\n      else\n        grp.deps << gid\n        grps[gid].reqs << id\n      end\n    end\n  end\n  #p grps\n\n  q = grps.select{|g| g.deps.empty?}\n  #p q\n\n  while ! q.empty?\n    grp = q.shift\n\n    for req in grp.reqs\n      greq = grps[req]\n      greq.ms += grp.ms\n      greq.ms.uniq!\n      greq.n += 1\n\n      if greq.n == greq.deps.length\n        q << greq\n      end\n    end\n  end\n  #p grps\n\n  puts grps.first.ms.length\nend", "label": 1, "name1": "s001547590.java", "name2": "s641255023.rb"}, {"id": 992, "code1": "import java.util.*;\npublic class Main{\n\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        String s = sc.next();\n        String ss =s.substring(0,s.length()-1);\n        int len = ss.length();\n        \n        for(int i =0;i<len;i++){\n            if(ss.length()%2==0){\n                String s1=ss.substring(0,(ss.length()/2));\n                String s2=ss.substring(ss.length()/2,ss.length());\n                if(s1.equals(s2)){\n                    System.out.println(ss.length());\n                    break;\n                }\n            }\n            ss = ss.substring(0,ss.length()-1);\n        }\n    }\n}\n\n\n\n\n", "code2": "loop{\n\nif (target = gets.to_i) == 0\n\tbreak\nend\n\ntime = Array.new(gets.to_i);\n\ntime.size.times do |i|\n\ttime[i] = gets.chomp\n\ttarget = target - (time[i].split(nil)[1].to_i - time[i].split(nil)[0].to_i)\nend\n\nif target <= 0\n\tprint \"OK\\n\"\nelsif\n\tprint target,\"\\n\"\nend\n\n}", "label": 0, "name1": "s456132043.java", "name2": "s022863364.rb"}, {"id": 522, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tMyInput in = new MyInput(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic long LINF = 1L << 55;\n\tstatic int MOD = 1000000007;\n\tstatic int[] mh4 = { 0, -1, 1, 0 };\n\tstatic int[] mw4 = { -1, 0, 0, 1 };\n\tstatic int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\tstatic int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n\tstatic class TaskX {\n\n\t\tpublic void solve(int testNumber, MyInput in, PrintWriter out) {\n\n\t\t\tint n = in.nextInt();\n\t\t\tlong a = in.nextLong(), b = in.nextLong();\n\t\t\tlong[] x = in.nextLongArray(n);\n\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\t\tans += Math.min(a * (x[i+1] - x[i]), b);\n\t\t\t}\n\t\t\tout.println(ans);\n\n\t\t}\n\t}\n\n\tstatic class MyInput {\n\t\tprivate final BufferedReader in;\n\t\tprivate static int pos;\n\t\tprivate static int readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500 * 8 * 2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic {\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tisDigit['0' + i] = true;\n\t\t\t}\n\t\t\tisDigit['-'] = true;\n\t\t\tisSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n\t\t\tisLineSep['\\r'] = isLineSep['\\n'] = true;\n\t\t}\n\n\t\tpublic MyInput(InputStream is) {\n\t\t\tin = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (pos >= readLen) {\n\t\t\t\tpos = 0;\n\t\t\t\ttry {\n\t\t\t\t\treadLen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException();\n\t\t\t\t}\n\t\t\t\tif (readLen <= 0) {\n\t\t\t\t\tthrow new MyInput.EndOfFileRuntimeException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buffer[pos++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\tint i = 0;\n\t\t\tint ret = 0;\n\t\t\tif (str[0] == '-') {\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t\tfor (; i < len; i++)\n\t\t\t\tret = ret * 10 + str[i] - '0';\n\t\t\tif (str[0] == '-') {\n\t\t\t\tret = -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\tint i = 0;\n\t\t\tlong ret = 0;\n\t\t\tif (str[0] == '-') {\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t\tfor (; i < len; i++)\n\t\t\t\tret = ret * 10 + str[i] - '0';\n\t\t\tif (str[0] == '-') {\n\t\t\t\tret = -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic char nextChar() {\n\t\t\twhile (true) {\n\t\t\t\tfinal int c = read();\n\t\t\t\tif (!isSpace[c]) {\n\t\t\t\t\treturn (char) c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic String nextString() {\n\t\t\treturn new String(nextChars());\n\t\t}\n\n\t\tpublic char[] nextChars() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\treturn Arrays.copyOf(str, len);\n\t\t}\n\n\t\tpublic char[][] next2DChars(int h, int w) {\n\t\t\tchar[][] s = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\ts[i] = nextChars();\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\n\t\tint reads(int len, boolean[] accept) {\n\t\t\ttry {\n\t\t\t\twhile (true) {\n\t\t\t\t\tfinal int c = read();\n\t\t\t\t\tif (accept[c]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (str.length == len) {\n\t\t\t\t\t\tchar[] rep = new char[str.length * 3 / 2];\n\t\t\t\t\t\tSystem.arraycopy(str, 0, rep, 0, str.length);\n\t\t\t\t\t\tstr = rep;\n\t\t\t\t\t}\n\t\t\t\t\tstr[len++] = (char) c;\n\t\t\t\t}\n\t\t\t} catch (MyInput.EndOfFileRuntimeException e) {\n\t\t\t}\n\t\t\treturn len;\n\t\t}\n\n\t\tpublic int[] nextIntArray(final int n) {\n\t\t\tfinal int[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArray1Index(final int n) {\n\t\t\tfinal int[] res = new int[n + 1];\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArrayDec(final int n) {\n\t\t\tfinal int[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(final int n) {\n\t\t\tfinal long[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray1Index(final int n) {\n\t\t\tfinal long[] res = new long[n + 1];\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArrayDec(final int n) {\n\t\t\tfinal long[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic double[] nextDoubleArray(int n) {\n\t\t\tdouble[] res = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextDouble();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\t}\n\n\t}\n\n}\n", "code2": "N = gets.chomp.to_i\nAn = gets.chomp.split(\" \").map(&:to_i)\n\ncnt = 0\nprev = 0\nfor i in 0...N do\n  if prev == An[i] then\n    cnt += 1\n    prev = 0\n  else\n    prev = An[i]\n  end\nend\n\np cnt", "label": 0, "name1": "s004356600.java", "name2": "s973857858.rb"}, {"id": 704, "code1": "import java.io.*;\nimport java.util.StringTokenizer;\n\npublic final class Main{\n    public static void main(String[] args){\n        FastScanner stdIn = new FastScanner(System.in);\n        long a = stdIn.nextLong();\n        long b = stdIn.nextLong();\n        long c = stdIn.nextLong();\n\n        if(c-(a-b)<0){\n            System.out.println(0);\n        }else{\n            System.out.println(c-(a-b));\n        }\n    }\n}\n\nclass FastScanner {\n    private BufferedReader reader = null;\n    private StringTokenizer tokenizer = null;\n\n    public FastScanner(InputStream in) {\n        reader = new BufferedReader(new InputStreamReader(in));\n        tokenizer = null;\n    }\n\n    public String next() {\n        if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public String nextLine() {\n        if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        return tokenizer.nextToken(\"\\n\");\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n    \n    public long nextInt() {\n        return Integer.parseInt(next());\n    }\n\n}\n", "code2": "f=f=1,*(1..m=1000003).map{f=f*_1%m}\ngets\n$<.map{x,d,n=_1.split.map &:to_i\np d<1?x.pow(n,m):(u=f[n+t=x*d.pow(m-2,m)%m-1])?u*f[t].pow(m-2,m)*d.pow(n,m)%m:0}", "label": 0, "name1": "s641134227.java", "name2": "s744865172.rb"}, {"id": 922, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n    void solve(){\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int[] s = new int[n];\n        int sum = 0;\n        for(int i = 0; i < n; i++){\n            s[i] = in.nextInt();\n            sum += s[i];\n        }\n        \n        if(sum % 10 != 0){\n            System.out.println(sum);\n            return;\n        }else{\n            Arrays.sort(s);\n            int i = 0;\n            while(sum%10==0 && i < n){\n                if(s[i]%10 != 0){\n                    sum -= s[i];\n                }\n                i++;\n            }\n            if(i == n){\n                sum = 0;\n            }\n        }\n        System.out.println(sum);\n    }\n    \n    public static void main(String[] args){\n        new Main().solve();\n    }\n}", "code2": "N=gets.to_i;M=10**9+7;I=[1,1];*F=I;*R=I;2.upto(N){|i|I<<z=(M-M/i)*I[M%i]%M;F<<i*F[-1]%M;R<<z*R[-1]%M};r=F[N];(-~N/2...N).each{|i|r=(r-F[i-1]*R[2*i-N]*F[i])%M};p r", "label": 0, "name1": "s390984007.java", "name2": "s917510432.rb"}, {"id": 111, "code1": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n    \tScanner sc = new Scanner(System.in);\n      \tint A,B,C;\n      \tA = sc.nextInt();\n      \tB = sc.nextInt();\n      \tC = sc.nextInt();\n      \tif ((A < C && C < B) || (B < C && C < A)) {\n            \tSystem.out.print(\"Yes\");\n        }  else {\n        \tSystem.out.print(\"No\");\n        }   \n    }\n}", "code2": "i = gets.split(\" \")\nif i[0].to_i < i[1].to_i then\n  if i[0].to_i < i[2].to_i and i[2].to_i < i[1].to_i then\n    print \"Yes\"\n  else\n    print \"No\"\n  end\n  else\n    if i[0].to_i > i[2].to_i and i[2].to_i > i[1].to_i then\n      print \"Yes\"\n    else\n      print \"No\"\n    end\n    end", "label": 1, "name1": "s403728510.java", "name2": "s608185400.rb"}, {"id": 724, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        PrintWriter out = new PrintWriter(System.out);\n        InputStreamScanner in = new InputStreamScanner(System.in);\n        new Main().solve(in, out);\n        out.flush();\n    }\n\n    private void solve(InputStreamScanner in, PrintWriter out) {\n        String s = in.next();\n\n        long t = 0;\n        for (int i = 0; i < 1 << (s.length() - 1); i++) {\n            int p = 0;\n            for (int j = 0; j < s.length() - 1; j++) {\n                if ((1 & i >> j) == 1) {\n                    t += Long.parseLong(s.substring(p, j + 1));\n                    p = j + 1;\n                }\n            }\n            t += Long.parseLong(s.substring(p));\n        }\n\n        out.println(t);\n    }\n\n    static class InputStreamScanner {\n\n        private InputStream in;\n\n        private byte[] buf = new byte[1024];\n        private int len = 0;\n        private int off = 0;\n\n        InputStreamScanner(InputStream in)\t{\n            this.in = in;\n        }\n\n        String next() {\n            StringBuilder sb = new StringBuilder();\n            for (int b = skip(); !isSpace(b);){\n                sb.appendCodePoint(b);\n                b = read();\n            }\n            return sb.toString();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        char nextChar() {\n            return (char)skip();\n        }\n\n        int skip() {\n            for (int b; (b = read()) != -1;) {\n                if (!isSpace(b)) {\n                    return b;\n                }\n            }\n            return -1;\n        }\n\n        private boolean isSpace(int c) {\n            return c < 33 || c > 126;\n        }\n\n        private int read() {\n            if (len == -1) {\n                throw new InputMismatchException(\"End of Input\");\n            }\n            if (off >= len){\n                off = 0;\n                try {\n                    len = in.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException(e.getMessage());\n                }\n                if (len <= 0) {\n                    return -1;\n                }\n            }\n            return buf[off++];\n        }\n    }\n}", "code2": "n,*z=$<.map &:split;y=z.to_h;puts\"#{z.all?{|a,b|a>?1||y[b]!=n[0]}?:IM:\"\"}POSSIBLE\"", "label": 0, "name1": "s838868939.java", "name2": "s984752060.rb"}, {"id": 348, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tint N,M;\n\tboolean[] first,second;\n\n\tpublic void solve() {\n\n\t\tN = nextInt();\n\t\tM = nextInt();\n\n\t\tfirst = new boolean[N];\n\t\tsecond = new boolean[N];\n\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tint a = nextInt()-1;\n\t\t\tint b = nextInt()-1;\n\n\t\t\tif(a == 0){\n\t\t\t\tfirst[b] = true;\n\t\t\t}\n\n\t\t\tif(b == N-1){\n\t\t\t\tsecond[a] = true;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1;i < N - 1;i++){\n\t\t\tif(first[i] && second[i]){\n\t\t\t\tout.println(\"POSSIBLE\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tout.println(\"IMPOSSIBLE\");\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}", "code2": "N, M = gets.split.map(&:to_i)\nneighbor = Array.new(N+1){Hash.new}\nM.times do |i|\n    a, b = gets.split.map(&:to_i)\n    neighbor[a][b] = true\nend\n\n(2..(N-1)).each do |i|\n    if neighbor[1][i] && neighbor[i][N]\n        puts 'POSSIBLE'\n        exit\n    end\nend\nputs 'IMPOSSIBLE'", "label": 1, "name1": "s651303084.java", "name2": "s467668333.rb"}, {"id": 316, "code1": "import java.util.*;\n\npublic class Main {\n  public static long MOD = (long)Math.pow(10, 6) + 3;\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    long[] kai = new long[(int)MOD];\n//    long[] inkai = new long[(int)MOD];\n//    long[] in = new long[(int)MOD];\n    kai[0] = 1;\n    kai[1] = 1;\n//    inkai[0] = 1;\n//    inkai[1] = 1;\n//    in[1] = 1;\n    for(long i = 2; i < MOD; i++) {\n      kai[(int)i] = (i * kai[(int)i - 1]) % MOD;\n//      inkai[(int)i] = func(kai[(int)i], MOD - 2);\n//      in[(int)i] = func(i, MOD - 2);\n    }\n    int q = sc.nextInt();\n    for(int i = 0; i < q; i++) {\n      long x = sc.nextLong();\n      long d = sc.nextLong();\n      long n = sc.nextLong();\n      long ans = 0;\n      if(d == 0) {\n        if(x == 0) {\n          ans = 0;\n        } else {\n          ans = func(x, n % (MOD - 1));\n        }\n      } else {\n        long inv = func(d, MOD - 2);\n        x = (x * inv) % MOD;\n        if(x == 0) {\n          ans = 0;\n        } else {\n          if((int)(x + n - 1) >= MOD) {\n            ans = 0;\n          } else {\n            long t = func(d, n % (MOD - 1));\n            long invkai = func(kai[(int)x - 1], MOD - 2);\n            ans = (((kai[(int)(x + n - 1)] * invkai) % MOD) * t) % MOD;\n          }\n        }\n      }\n      System.out.println(ans);\n    }\n  }\n  public static long func(long a, long x) {\n    if(x == 0) return 1;\n    if(x >= 1) {\n      if(x % 2 == 0) {\n        long t = func(a, x / 2);\n        return (t * t) % MOD;\n      } else {\n        long t = func(a, x - 1);\n        return (a * t) % MOD;\n      }\n    }\n    return 0;\n  } \n}", "code2": "M=1000003\no=->a,n{n<1?1:(n%2>0?a:1)*o[a,n/2]**2%M}\n*f=1\n1.upto(M){|i|f<<f[i-1]*i%M}\ngets\n$<.map{|s|x,d,n=s.split.map &:to_i\nt=x*o[d,M-2]%M\np d<1?o[x,n]:M<t+n||t<1?0:f[t+n-1]*o[f[t-1],M-2]*o[d,n]%M}", "label": 1, "name1": "s406339057.java", "name2": "s699536087.rb"}, {"id": 322, "code1": "\npublic class Main {\n\n  static int mod = 1000003;\n  static int[][] fif = enumFIF(mod * 3, mod);\n\n  private static void solve() {\n    int q = ni();\n\n    for (int i = 0; i < q; i++) {\n      int x = ni();\n      int d = ni();\n      int n = ni();\n      out.println(f(x, d, n));\n    }\n  }\n\n  private static long f(int x, int d, int n) {\n    if (x == 0) {\n      return 0;\n    } else if (d == 0) {\n      return pow(x, n, mod);\n    }\n\n    int y = (int) (x * invl(d, mod) % mod);\n    if (n >= mod || y % mod > (y + n - 1) % mod) {\n      return 0;\n    }\n\n    long z = fif[0][y + n - 1] * invl(fif[0][y - 1], mod) % mod;\n    z *= pow(d, n, mod);\n    z %= mod;\n\n    return z;\n  }\n\n  public static long pow(long a, long n, long mod) {\n    // a %= mod;\n    long ret = 1;\n    int x = 63 - Long.numberOfLeadingZeros(n);\n    for (; x >= 0; x--) {\n      ret = ret * ret % mod;\n      if (n << 63 - x < 0)\n        ret = ret * a % mod;\n    }\n    return ret;\n  }\n\n\n  public static int[][] enumFIF(int n, int mod) {\n    int[] f = new int[n + 1];\n    int[] invf = new int[n + 1];\n    f[0] = 1;\n    for (int i = 1; i <= n; i++) {\n      f[i] = (int) ((long) f[i - 1] * i % mod);\n    }\n    long a = f[n];\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    invf[n] = (int) (p < 0 ? p + mod : p);\n    for (int i = n - 1; i >= 0; i--) {\n      invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n    }\n    return new int[][] {f, invf};\n  }\n\n  public static long invl(long a, long mod) {\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    return p < 0 ? p + mod : p;\n  }\n\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n\n", "code2": "M=1000003\no=->a,n{n<1?1:(n%2>0?a:1)*o[a,n/2]**2%M}\nf=f=1,*(1..M).map{|i|f=f*i%M}\ngets\n$<.map{|s|x,d,n=s.split.map &:to_i\np d<1?o[x,n]:M-n<=(t=x*o[d,M-2]%M-1)?0:f[t+n]*o[f[t],M-2]*o[d,n]%M}", "label": 1, "name1": "s606179301.java", "name2": "s763901366.rb"}, {"id": 45, "code1": "import java.util.Scanner;\nimport java.util.Arrays;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\nclass Main{\n          public static void main(String[] args) {\n                  Scanner scan = new Scanner(System.in);\n                  int count = 0;\n                  int N = scan.nextInt();\n                  int a[] = new int[N];\n                  for (int i = 0; i < N; i++) {\n                          a[i] = scan.nextInt();\n                  }\n                  for(int j = 1; j < N; j++){\n                          if (a[j-1] == a[j]) {\n                                  a[j] = 10001;\n                                  count++;\n                          }\n                  }\n                  System.out.println(count);\n                  }\n}\n", "code2": "N = gets.chomp.to_i\nAn = gets.chomp.split(\" \").map(&:to_i)\n\ncnt = 0\nprev = 0\nfor i in 0...N do\n  if prev == An[i] then\n    cnt += 1\n    prev = 0\n  else\n    prev = An[i]\n  end\nend\n\np cnt", "label": 1, "name1": "s420774674.java", "name2": "s973857858.rb"}, {"id": 410, "code1": "import java.util.Scanner;\n\npublic class Main {\n  private static Scanner sc;\n\n  public static void main(String[] args) {\n    sc = new Scanner(System.in);\n    new Main().solve();\n  }\n\n  private void solve() {\n    int N = sc.nextInt();\n    int[] a = new int[N + 2];\n    for (int i = 0; i < N; i++) {\n      a[i + 1] = sc.nextInt();\n    }\n    int sum = 0;\n    for (int i = 0; i <= N; i++) {\n      sum += Math.abs(a[i] - a[i + 1]);\n    }\n\n    for (int i = 0; i < N; i++) {\n      System.out.println(sum - Math.abs(a[i] - a[i + 1]) - Math.abs(a[i + 2] - a[i + 1]) + Math.abs(a[i] - a[i + 2]));\n    }\n  }\n}\n", "code2": "n = gets.to_i\nnum = gets.chomp.split.map(&:to_i)\nnum.unshift(0)\nnum.push(0)\n#num\u306e\u9577\u3055\u306fn+2\u3060\u3088\nsum = 0\n(n+1).times do |i|\n  sum += (num[i+1]-num[i]).abs\nend\nfor i in 1..n\n  puts sum-(num[i]-num[i-1]).abs-(num[i+1]-num[i]).abs+(num[i+1]-num[i-1]).abs\nend", "label": 1, "name1": "s142792447.java", "name2": "s132287654.rb"}, {"id": 28, "code1": "import java.util.*;\nimport java.io.*;\n\nimport static java.lang.System.in;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long A = sc.nextLong();\n        long B = sc.nextLong();\n        long[] x = new long[n];\n        for(int i=0;i<n;i++) x[i]=sc.nextLong();\n        long ans= 0;\n        for(int i=0;i<n-1;i++){\n            ans += Math.min(A*(x[i+1]-x[i]),B);\n        }\n        PrintWriter out = new PrintWriter(System.out);\n        out.println(ans);\n        out.flush();\n    }\n}\n", "code2": "\nn,a,b = gets.split.map(&:to_i)\nx = gets.split.map(&:to_i)\n\ncost = 0\nlast = x[0]\n\n(1...n).each{|i|\n    if (x[i]-last)*a < b\n        cost += (x[i]-last)*a\n    else\n        cost += b\n    end\n    last = x[i]\n}\n\np cost\n", "label": 1, "name1": "s316016733.java", "name2": "s273635362.rb"}, {"id": 295, "code1": "import java.util.*;\npublic class Main {\n        static Scanner sc = new Scanner(System.in);\n        static void myout(Object t){System.out.println(t);}//standard output\n        static void myerr(Object t){System.err.println(t);}//standard error\n        static String getStr(){return sc.next();}\n        static int getInt(){return Integer.parseInt(getStr());}\n        static long getLong(){return Long.parseLong(getStr());}\n        static boolean isNext(){return sc.hasNext();}\n        static String[] mySplit(String str){return str.split(\"\");}\n        public static void main(String[] args){\n          int N = getInt();\n          int M = getInt();\n          if(N >= M){\n            myout(0);\n            return;\n          }\n          long output = 0;\n          ArrayList<Integer> list = new ArrayList<Integer>(M);\n          for(int i = 0; i < M; i++){\n            list.add(getInt());\n          }\n          Collections.sort(list);\n          //myout(list);\n          PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\n          for(int i = 1; i < M; i++){\n            pq.add(Math.abs(list.get(i)-list.get(i-1)));\n          }\n          for(int i = 0; i < N-1; i++){\n            pq.poll();\n          }\n          while(pq.size() != 0){\n            output += pq.poll();\n          }\n          myout(output);\n        }\n        //\u4fbf\u5229\u30e1\u30bd\u30c3\u30c9\u8ffd\u52a0\u67a0\u3053\u3053\u304b\u3089\n\n        //\u4fbf\u5229\u30e1\u30bd\u30c3\u30c9\u8ffd\u52a0\u67a0\u3053\u3053\u307e\u3067\n}\n", "code2": "n,m=gets.chomp.split(\" \").map(&:to_i)\nx=gets.chomp.split(\" \").map(&:to_i)\nif m==1 or n>m\n  puts 0\nelse\nx.sort!\nans=x[m-1]-x[0]\ndis=[]\n(m-1).times do|i|\n  dis.push(x[i+1]-x[i])\nend\ndis.sort!.reverse!\n(n-1).times do|i|\n  ans-=dis[i]\nend\nputs ans\n\nend\n", "label": 1, "name1": "s460372083.java", "name2": "s775569908.rb"}, {"id": 517, "code1": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map.Entry;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nclass Main {\n    static final int MOD = 1000000007;\n    static final int INF = 1 << 30;\n\n    Main() {\n        Scanner sc = new Scanner(System.in);\n        long ans = 0;\n        long H = sc.nextLong();\n        long W = sc.nextLong();\n        if(H==1 || W==1){\n        System.out.println(1);\n        return;\n        }\n        long ht = H/2+H%2;\n        long hd = H/2;\n        long wt = W/2+W%2;\n        long wd = W/2;\n        ans += ht*wt;\n        ans += hd*wd;\n        System.out.println(ans);\n    }\n\n    public static void main(String[] args) {\n        new Main();\n    }\n}\n ", "code2": "while true do\n    n = gets.to_i\n    break if n == 0\n    array=gets.chomp.split(\" \").map(&:to_f)\n    average = array.inject(:+)/n\n    puts format(\"%0.5f\", (array.map {|e| (e-average)**2}.inject(:+)/n)**0.5)\nend\n", "label": 0, "name1": "s490391243.java", "name2": "s834861200.rb"}, {"id": 845, "code1": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint l = sc.nextInt();\n\t\tint t = sc.nextInt();\n\t\tint[] x = new int[n];\n\t\tint[] w = new int[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tx[i] = sc.nextInt();\n\t\t\tw[i] = sc.nextInt();\n\t\t}\n\n\t\tint cnt = 0;\n\t\tfor(int i=1; i<n; i++){\n\t\t\tif(w[0]==1 && w[i]==2){\n\t\t\t\tif(t*2>=x[i]-x[0]){\n\t\t\t\t\tcnt += (1+(t*2-x[i]+x[0])/l);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(w[0]==2 && w[i]==1){\n\t\t\t\tif(t*2>=l-x[i]+x[0]){\n\t\t\t\t\tcnt -= (1+(t*2-l+x[i]-x[0])/l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(w[0]==1){\n\t\t\tcnt %= n;\n\t\t}\n\t\telse{\n\t\t\tcnt = ((cnt%n)+n)%n;\n\t\t}\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif(w[i]==1){\n\t\t\t\tx[i] = (x[i]+t)%l;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tx[i] = ((x[i]-t)%l+l)%l;\n\t\t\t}\n\t\t}\n\t\tint dist0 = x[0];\n\t\tArrays.sort(x);\n\t\tint index0 = 0;\n\t\tif(w[0]==1){\n\t\t\tfor(int i=n-1; i>=0; i--){\n\t\t\t\tif(x[i]==dist0){\n\t\t\t\t\tindex0 = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(x[i]==dist0){\n\t\t\t\t\tindex0 = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<n; i++){\n\t\t\tSystem.out.println(x[(index0-cnt+n+i)%n]);\n\t\t}\n\t}\n}", "code2": "n=gets.to_i\na=gets.split.map(&:to_i)\ng=a.pop\na.each{|v|g=v.gcd g}\nputs g", "label": 0, "name1": "s799989824.java", "name2": "s558839561.rb"}, {"id": 766, "code1": "import java.io.FileNotFoundException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tMaxHeapSort maxheap = new MaxHeapSort(new int[] {});\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tmaxheap.add(a[i]);\n\t\t}\n\t\ta = maxheap.sortedArray();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tSystem.out.print(a[i] + (i == n - 1 ? \"\\n\" : \" \"));\n\t\t}\n\t}\n\n\tclass MaxHeapSort {\n\t\tint n;\n\t\tint[] v;\n\n\t\tpublic MaxHeapSort(int[] v_) {\n\t\t\tif (v_.length > 1_000_000)\n\t\t\t\tthrow new AssertionError();\n\t\t\tv = Arrays.copyOf(v_, 1_000_000);\n\t\t\tn = v_.length;\n\t\t\tfor (int i = n; i >= 0; --i) {\n\t\t\t\tmaxHeapify(i);\n\t\t\t}\n\t\t}\n\n\t\tvoid add(int val) {\n\t\t\tv[n] = val;\n\t\t\tint cur = n;\n\t\t\t++n;\n\t\t\twhile (cur > 0) {\n\t\t\t\tcur = (cur - 1) / 2;\n\t\t\t\tmaxHeapify(cur);\n\t\t\t}\n\t\t}\n\n\t\tint[] sortedArray() {\n\t\t\tint sz = n;\n\t\t\tint[] ret = new int[sz];\n\t\t\tfor (int i = 0; i < sz; ++i) {\n\t\t\t\tret[sz - 1 - i] = poll();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tint poll() {\n\t\t\tint ret = v[0];\n\t\t\tv[0] = v[n - 1];\n\t\t\tv[n - 1] = ret;\n\t\t\t--n;\n\t\t\tmaxHeapify(0);\n\t\t\treturn ret;\n\t\t}\n\n\t\tvoid maxHeapify(int cur) {\n\t\t\tif (2 * cur + 1 >= n)\n\t\t\t\treturn;\n\t\t\tif (v[cur] >= v[2 * cur + 1] && (2 * cur + 2 >= n || v[cur] >= v[2 * cur + 2])) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint dst = -1;\n\t\t\tif (2 * cur + 2 >= n || v[2 * cur + 1] >= v[2 * cur + 2]) {\n\t\t\t\tdst = 2 * cur + 1;\n\t\t\t} else {\n\t\t\t\tdst = 2 * cur + 2;\n\t\t\t}\n\t\t\tint tmp = v[cur];\n\t\t\tv[cur] = v[dst];\n\t\t\tv[dst] = tmp;\n\t\t\tmaxHeapify(dst);\n\t\t}\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}", "code2": "n = gets.chomp.to_i\nt = gets.chomp.split(' ').map {|v| v.to_i}\nt.unshift(0)\nt.push(0)\n\not = Array.new(t.length, 0)\n\nall = 0\nfor i in 1...t.length do\n  v = t[i] - t[i - 1]\n  ot[i] = v\n  all += v.abs\nend\n\nfor i in 1...t.length - 1 do\n  f = all - ot[i].abs - ot[i + 1].abs\n  v = t[i + 1] - t[i - 1]\n  f += v.abs\n\n  puts f\nend\n\n\n", "label": 0, "name1": "s534493670.java", "name2": "s176193708.rb"}, {"id": 326, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[] total = new int[3];\n\n\t\ttotal[0] = sc.nextInt();\n\t\ttotal[1] = sc.nextInt();\n\t\ttotal[2] = sc.nextInt();\n\n\t\tsc.close();\n\n\t\tArrays.sort(total);\n\n\t\tSystem.out.println(total[0] + total[1]);\n\t}\n}", "code2": "price = gets.split.map(&:to_i)\nsorted_p = price.sort\nans = sorted_p[0] + sorted_p[1]\nputs ans", "label": 1, "name1": "s443302375.java", "name2": "s680191741.rb"}, {"id": 400, "code1": "//\u0083\\\u0081[\u0083g\u0082\u00b7\u0082\u00e9\u0083v\u0083\u008d\u0083O\u0083\u0089\u0083\u0080\u0081i\u0082\u008e\u0082\u00cc\u0092l\u0082\u00cd1,000,000\u0088\u00c8\u0089\u00ba\u0081j\nimport java.util.*;\npublic class Main {\n\n\tpublic void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tTreeSet<Integer> set = new TreeSet<Integer>();\n\t\tTreeMap<Integer,Integer> map = new TreeMap<Integer, Integer>();\n\n\t\tfor(int i=0; i < n; i++){\n\t\t\tint temp = sc.nextInt();\n\t\t\tif( set.contains(temp)){\n\t\t\t\tif(map.containsKey(temp)){\n\t\t\t\t\tmap.put(temp, map.get(temp) + 1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmap.put(temp, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tset.add(temp);\n\t\t\t}\n\t\t}\n\t\tfor(int num: set){\n\t\t\tif(map.containsKey(num)){\n\t\t\t\tfor(int i=0; i < map.get(num);i++){\n\t\t\t\t\tSystem.out.print(num + \" \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(num == set.last()){\n\t\t\t\tSystem.out.println(num);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.print(num + \" \");\n\t\t\t}\n\n\t\t}\n\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doIt();\n\n\t}\n\n}", "code2": "gets\nputs gets.split.map(&:to_i).sort.join \" \"", "label": 1, "name1": "s012590995.java", "name2": "s947283729.rb"}, {"id": 772, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n + 2];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tsc.close();\n\n\t\tint sum = 0;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsum += Math.abs(a[i] - a[i + 1]);\n\t\t}\n\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tSystem.out.println(sum + Math.abs(a[i- 1] - a[i + 1])\n\t\t\t\t\t- Math.abs(a[i] - a[i + 1]) - Math.abs(a[i] - a[i - 1]));\n\t\t}\n\t}\n}\n", "code2": "def main()\n  n = gets.chomp.to_i\n  x = []\n  for i in 0..n-1 do\n     x << gets.chomp.to_i\n  end\n  puts x.inject(:lcm)\nend\n\nmain()", "label": 0, "name1": "s784073174.java", "name2": "s027645540.rb"}, {"id": 110, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint a = Integer.parseInt(sc.next());\n\t\tint b = Integer.parseInt(sc.next());\n\t\tint c = Integer.parseInt(sc.next());\n\n\t\tif (a < c && c < b || b < c && c < a){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t}else {\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t}\n}", "code2": "# frozen_string_literal: true\n\na, b, c = gets.split.map(&:to_i)\n\nif a < c && c < b || b < c && c < a\n  puts :Yes\nelse\n  puts :No\nend", "label": 1, "name1": "s898770223.java", "name2": "s741716266.rb"}, {"id": 515, "code1": "import java.util.Scanner;\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\n\t\tlong h = stdIn.nextLong();\n\t\tlong w = stdIn.nextLong();\n\t\t\n\t\tlong cnt = 0;\n\t\tif(h==1 || w == 1) {\n\t\t\tSystem.out.println(1);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(h % 2 == 0 && w % 2 == 0) { //h\u5076\u6570\u3001w\u5076\u6570\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tcnt += w/2;\n\t\t\t}\n\t\t}else if(h % 2 == 0 && w % 2 != 0) { //h\u5076\u6570\u3001w\u5947\u6570\n\t\t\tfor(int i = 0; i < h ; i++) {\n\t\t\t\tif(i % 2 == 0) {\n\t\t\t\t\tcnt += (w+1)/2;\n\t\t\t\t}else {\n\t\t\t\t\tcnt += w/2;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( h % 2 != 0 && w % 2 == 0) { // h\u5947\u6570,w\u5076\u6570\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tcnt += w/2;\n\t\t\t}\n\t\t}else {                                //h\u5947\u6570,w\u5947\u6570\n\t\t\tfor(int i = 0; i < h ; i++) {\n\t\t\t\tif(i % 2 == 0) {\n\t\t\t\t\tcnt += (w+1)/2;\n\t\t\t\t}else {\n\t\t\t\t\tcnt += w/2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(cnt);\n\n\t}\n\n}\n", "code2": "include Math\nwhile n = gets.to_i\n  break if n == 0\n  s = gets.split.map(&:to_f)\n  m = s.map.inject(:+) / n\n  sum = 0\n  s.each { |v| sum +=((v-m) ** 2)}\n  puts sqrt(sum /n)\nend", "label": 0, "name1": "s990691093.java", "name2": "s839318707.rb"}, {"id": 823, "code1": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int a[][] = new int[n][n];\n\n        for (int i = 0; i < m; i++) {\n            int t1 = in.nextInt() - 1;\n            int t2 = in.nextInt() - 1;\n            a[t1][t2] = 1;\n            a[t2][t1] = 1;\n        }\n        List<Integer> order = new ArrayList<>();\n        order.add(0);\n        List<Integer> remain = new ArrayList<>();\n        for (int i = 1; i < n; i++) {\n            remain.add(i);\n        }\n        System.out.println(f(order, remain, a));\n    }\n\n    static int f(List<Integer> order, List<Integer> remain, int edges[][]) {\n        if (remain.size() == 0) {\n            int cur = order.get(0);\n            int next;\n            for (int p = 1; p < order.size(); p++) {\n                next = order.get(p);\n                if (edges[cur][next] == 1 || edges[next][cur] == 1) {\n                    cur = next; \n                } else {\n                    return 0;\n                }\n            }\n            return 1;\n        }\n\n        int total = 0;\n        for (int p = 0; p < remain.size(); p++) {\n            order.add(remain.get(p));\n            remain.remove(p);\n            total += f(order, remain, edges);\n            remain.add(p, order.get(order.size() - 1));\n            order.remove(order.size() - 1);\n        }\n        return total;\n    }\n}", "code2": "N = gets.to_i\nS = gets.chomp\n\new = we = 0\nN.times do |i|\n  we += 1 if S[i] == 'E'\nend\n\nans = 1000000\nN.times do |i|\n  we -= 1 if S[i] == 'E'\n  ans = [ans, ew + we].min\n  ew += 1 if S[i] == 'W'\nend\n\nputs ans\n", "label": 0, "name1": "s216336518.java", "name2": "s770679196.rb"}, {"id": 634, "code1": "\nimport static java.lang.Math.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic int modP = 1000000007;\n\n\tstatic class TaskX {\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tint n = in.nextInt();\n\t\t\tlong[] t = in.nextLongArray(n), a = in.nextLongArray(n);\n\n\t\t\tlong[] tCalc = new long[n];\n\t\t\tArrays.fill(tCalc, -1);\n\n\t\t\tlong[] aCalc = new long[n];\n\t\t\tArrays.fill(aCalc, -1);\n\n\t\t\tlong[] tDef = new long[n];\n\t\t\tlong[] aDef = new long[n];\n\n\t\t\tlong tMax = -1, aMax = -1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (tMax < t[i]) {\n\t\t\t\t\ttMax = t[i];\n\t\t\t\t\ttDef[i] = t[i];\n\t\t\t\t} else {\n\t\t\t\t\ttCalc[i] = tMax;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = n-1; i >= 0; i--) {\n\t\t\t\tif (aMax < a[i]) {\n\t\t\t\t\taMax = a[i];\n\t\t\t\t\taDef[i] = a[i];\n\t\t\t\t} else {\n\t\t\t\t\taCalc[i] = aMax;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (aCalc[i] == -1 && tCalc[i] == -1) {\n\t\t\t\t\tif (aDef[i] != tDef[i]) {\n\t\t\t\t\t\tout.println(0);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else if (aCalc[i] == -1) {\n\t\t\t\t\tif (aDef[i] > tCalc[i]) {\n\t\t\t\t\t\tout.println(0);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else if (tCalc[i] == -1) {\n\t\t\t\t\tif (tDef[i] > aCalc[i]) {\n\t\t\t\t\t\tout.println(0);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong ans = 1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (tCalc[i] == -1 || aCalc[i] == -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tans = ans * min(aCalc[i],tCalc[i]) % modP;\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\n\t}\n\n}\n", "code2": "N = gets.to_i\nTs = Array.new(N)\nAs = Array.new(N)\nN.times do |i|\n  Ts[i], As[i] = gets.split.map(&:to_i)\nend\n\ntz = az = 1\nN.times do |i|\n  tk = (tz + Ts[i] - 1) / Ts[i]\n  ak = (az + As[i] - 1) / As[i]\n  k = [tk, ak].max\n  tz = Ts[i] * k\n  az = As[i] * k\nend\n\nputs tz + az\n", "label": 0, "name1": "s083135979.java", "name2": "s973322062.rb"}, {"id": 384, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n\n    void solve() throws IOException {\n        int h = ni(), w = ni();\n        String[] a = nsa(h);\n\n        char[][] ansR = new char[h][w];\n        char[][] ansB = new char[h][w];\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (i == 0 || i < h - 1 && j % 2 == 0) {\n                    ansR[i][j] = '#';\n                    ansB[i][j] = '.';\n                } else {\n                    ansR[i][j] = '.';\n                    ansB[i][j] = '#';\n                }\n            }\n        }\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (a[i].charAt(j) == '#') {\n                    ansR[i][j] = '#';\n                    ansB[i][j] = '#';\n                }\n            }\n        }\n\n        for (int i = 0; i < h; i++) {\n            out.println(String.valueOf(ansR[i]));\n        }\n        out.println();\n        for (int i = 0; i < h; i++) {\n            out.println(String.valueOf(ansB[i]));\n        }\n    }\n\n    String ns() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine(), \" \");\n        }\n        return tok.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.parseInt(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.parseLong(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.parseDouble(ns());\n    }\n\n    String[] nsa(int n) throws IOException {\n        String[] res = new String[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ns();\n        }\n        return res;\n    }\n\n    int[] nia(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ni();\n        }\n        return res;\n    }\n\n    long[] nla(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nl();\n        }\n        return res;\n    }\n\n    class INA {\n        int[][] a;\n\n        INA(int n, int m) throws IOException {\n            this(n, m, -1);\n        }\n\n        INA(int n, int m, int t) throws IOException {\n            a = new int[m][n];\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    a[j][i] = ni() + t;\n                }\n            }\n        }\n\n        int[] get(int i) {\n            return a[i - 1];\n        }\n    }\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        tok = new StringTokenizer(\"\");\n        Main main = new Main();\n        main.solve();\n        out.close();\n    }\n}", "code2": "H, W = gets.split.map(&:to_i)\nas = []\nans1 = []\nans2 = []\nH.times do |i|\n    as[i] = gets.chomp\n    ans1[i] = as[i].dup\n    ans2[i] = as[i].dup\nend\n\nH.times do |i|\n    if i%2 == 0\n        ans1[i] = '#'*(W-1) + '.'\n    else\n        ans2[i] = '.' + '#'*(W-1)\n    end\n    ans1[i][0] = '#'\n    ans2[i][-1] = '#'\nend\n\nputs ans1\nputs\nputs ans2\n\n# result = Array.new(H){'.'*W}\n# H.times do |i|\n#     W.times do |j|\n#         result[i][j] = '#' if ans1[i][j] == '#' && ans2[i][j] == '#'\n#     end\n# end\n# puts result", "label": 1, "name1": "s104811718.java", "name2": "s793571533.rb"}, {"id": 883, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tchar a=scan.next().charAt(0);\n\t\tchar b=scan.next().charAt(0);\n\t\tif(a=='H' && b!='D') System.out.println(\"H\");\n\t\telse if(b=='H' && a!='D') System.out.println(\"H\");\n\t\telse if(a=='D' && b=='D') System.out.println(\"H\");\n\t\telse System.out.println(\"D\");\n\t}\n\n}\n", "code2": "1000.times do\n  puts \"Hello World\"\nend", "label": 0, "name1": "s111953334.java", "name2": "s534011518.rb"}, {"id": 963, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main\n{\n\n  public static void main(String[] args) throws IOException\n  {\n    BufferedReader r = new BufferedReader(new InputStreamReader(System.in), 1);\n    String[] sl = r.readLine().split(\"[\\\\s]+\");\n    int n = Integer.parseInt(sl[0]);\n    int c = Integer.parseInt(sl[1]);\n    int d[][] = new int[30][30];\n    int count[][] = new int[3][30];\n\n    for(int i = 0; i < c; i++)\n    {\n      sl = r.readLine().split(\"[\\\\s]+\");\n      for(int j = 0; j < c; j++)\n      {\n        d[i][j] = Integer.parseInt(sl[j]);\n      }\n    }\n\n    for(int i = 0; i < n; i++)\n    {\n      sl = r.readLine().split(\"[\\\\s]+\");\n      for(int j = 0; j < n; j++)\n      {\n        count[(i + j) % 3][Integer.parseInt(sl[j]) - 1]++;\n      }\n    }\n    \n    int sel[] = new int[3];\n    int min = Integer.MAX_VALUE;\n    \n    for(sel[0] = 0; sel[0] < c; sel[0]++)\n    {\n      for(sel[1] = 0; sel[1] < c; sel[1]++)\n      {\n        if(sel[0] == sel[1])\n        {\n          continue;\n        }\n        for(sel[2] = 0; sel[2] < c; sel[2]++)\n        {\n          if(sel[1] == sel[2] || sel[0] == sel[2])\n          {\n            continue;\n          }\n          \n          int stress = 0;\n          for(int i = 0; i < 3; i++)\n          {\n            for(int j = 0; j < c; j++)\n            {\n              stress += count[i][j] * d[j][sel[i]];\n            }\n          }\n          min = Math.min(min, stress);\n        }\n      }\n    }\n    \n    System.out.println(min);\n\n  }\n\n\n}", "code2": "n = gets.chomp.to_i\na = gets.chomp.split().map(&:to_i)\nb = gets.chomp.split().map(&:to_i)\nc = gets.chomp.split().map(&:to_i)\n\na.sort!\nb.sort!\nc.sort!\n\n# p a, b, c\n\nans = 0\nb.each do |e|\n#  p ['loop', e]\n  aa_index = a.bsearch_index{|x| e <= x}\n#  p ['aa_i', aa_index]\n  aa_index ||= n\n\n  cc_index = c.bsearch_index{|x| e < x}\n#  p ['cc_i', cc_index]\n  next if cc_index.nil?\n\n#  p [e, ' ', aa_index, n-cc_index]\n  ans += aa_index * (n-cc_index)\nend\n\nputs ans", "label": 0, "name1": "s743770667.java", "name2": "s764468939.rb"}, {"id": 746, "code1": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\tboolean eof;\n\t\n\tlong go(long a, long b, long c) {\n\t\tif (a < 0 || b < 0 || c < 0) {\n\t\t\treturn Long.MIN_VALUE;\n\t\t}\n\t\t\n\t\treturn a + b + c - (a & 1) - (b & 1) - (c & 1);\n\t}\n\n\tvoid solve() throws IOException {\n\t\tlong i = nextLong();\n\t\tlong o = nextLong();\n\t\tlong t = nextLong();\n\t\tlong j = nextLong();\n\t\tlong l = nextLong();\n\t\tlong s = nextLong();\n\t\tlong z = nextLong();\n\t\t\n\t\tlong ans = o + Math.max(go(i, j, l), go(i - 1, j - 1, l - 1) + 3);\n\t\t\n\t\tout.println(ans);\n\t}\n\n\tMain() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e) {\n\t\t\t\teof = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\teof = true;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}", "code2": "h,w=gets.split.map &:to_i\nm=$<.map{|e|e.chomp[1..-2]}\n2.times{|i|h.times{|y|s=['#'*(w-2),m[y]][y%2^i];puts [\"##{s}.\",\".#{s}#\"][i]};puts}", "label": 0, "name1": "s508741257.java", "name2": "s463208227.rb"}, {"id": 947, "code1": "import static java.lang.Math.exp;\nimport static java.lang.Math.max;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.function.IntUnaryOperator;\nimport java.util.function.LongUnaryOperator;\n\npublic class Main {\n    public static void main(String[] args) {\n        new Solver(false);\n    }\n}\n\nclass Solver {\n    final In in;\n\n    static final int D = 365;\n    static final int A = 26;\n\n    static final int SWAP_WIDTH = 10;\n    final int[] c = new int[A];\n    final int[][] s = new int[D][A];\n    final double[][] w = new double[D][A];\n    final int[] x = new int[D];\n    final Random rnd = new Random();\n\n    static final double START_TEMP = 1000;\n    static final double END_TEMP = 15;\n    static final double DEL_TEMP = END_TEMP - START_TEMP;\n\n    static final long TIME_LIMIT = 1_900_000_000l;\n    final long startTime = System.nanoTime();\n    final long endTime = startTime + TIME_LIMIT;\n\n    int score;\n    int iteration = 0;\n\n    public Solver (boolean debug) {\n        if (debug) {\n            try {\n                System.setIn(new FileInputStream(new File(\"./marathon/tester/example/sample2.in\")));\n                System.setOut(new PrintStream(new File(\"./marathon/debug_output\")));\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        in = new In();\n        input();\n        // setWeight(50);\n        // annealing(debug);\n        greedy3();\n        output();\n        if (debug) {\n            long time = (System.nanoTime() - startTime) / 1_000_000;\n            System.out.println(String.format(\"Time: %d ms\", time));\n            int expected = score();\n            if (expected != score) {\n                System.out.println(score);\n                System.out.println(expected);\n                String err = String.format(\"\\nexpected = %d\\nactual = %d\", expected, score);\n                throw new RuntimeException(err);\n            }\n            score = max(score + 1000000, 0);\n            System.out.printf(\"Iteration: %d\\nScore: %d\\n\", iteration, score);\n        }\n    }\n\n    public void initialize() {\n        greedy3();\n    }\n\n    public void annealing(boolean debug) {\n        initialize();\n        long nowTime = System.nanoTime();\n        while (nowTime < endTime) {\n            if ((++iteration & 3) == 0) {\n                tryChange(nowTime);\n                if ((iteration & 0x3ff) == 0) nowTime = System.nanoTime();\n            } else {\n                trySwap(nowTime);\n            }\n        }\n    }\n\n    public void tryChange(long nowTime) {\n        int day = rnd.nextInt(D);\n        int fr = x[day];\n        // int to = weightedRandomContest(day);\n        int to = rnd.nextInt(A);\n        int newScore = ifChanged(day, fr, to, score);\n        double temp = START_TEMP + DEL_TEMP * (nowTime - startTime) / TIME_LIMIT;\n        double prob = exp((newScore - score) / temp);\n        if (prob > rnd.nextDouble()) {\n            x[day] = to;\n            score = newScore;\n        }\n    }\n\n    public void trySwap(long nowTime) {\n        int day1 = rnd.nextInt(D);\n        int day2;\n        do {day2 = randomSwapDay(day1);} while (x[day1] == x[day2]);\n        int newScore = ifSwapped(day1, day2, score);\n        double temp = START_TEMP + DEL_TEMP * (nowTime - startTime) / TIME_LIMIT;\n        double prob = exp((newScore - score) / temp);\n        if (prob > rnd.nextDouble()) {\n            int tmp = x[day1]; x[day1] = x[day2]; x[day2] = tmp;\n            score = newScore;\n        }\n    }\n\n    public int ifChanged(int day, int fr, int to, int oldScore) {\n        int newScore = oldScore + s[day][to] - s[day][fr];\n        newScore += (day - higher(day, fr)) * (day - lower(day, fr)) * c[fr];\n        newScore -= (day - higher(day, to)) * (day - lower(day, to)) * c[to];\n        return newScore;\n    }\n\n    public int ifSwapped(int day1, int day2, int oldScore) {\n        int x1 = x[day1], x2 = x[day2];\n        int newScore = ifChanged(day1, x1, x2, oldScore);\n        x[day1] = x2;\n        newScore = ifChanged(day2, x2, x1, newScore);\n        x[day1] = x1;\n        return newScore;\n    }\n\n    public void setWeight(int param) {\n        for (int i = 0; i < D; i++) {\n            double sum = 0;\n            for (int j = 0; j < A; j++) sum += c[j] * param + s[i][j];\n            for (int j = 0; j < A; j++) {\n                w[i][j] = (c[j] * param + s[i][j]) / sum;\n                if (j > 0) w[i][j] += w[i][j - 1];\n            }\n        }\n    }\n\n    public int weightedRandomContest(int day) {\n        double v = rnd.nextDouble();\n        for (int i = 0; i < A; i++) if (w[day][i] >= v) return i;\n        return A - 1;\n        // int l = -1, r = A;\n        // while (r - l > 1) {\n        //     int m = (l + r) >> 1;\n        //     if (w[day][m] < v) l = m;\n        //     else r = m;\n        // }\n        // return r == A ? 0 : r;\n    }\n\n    public int randomSwapDay(int day) {\n        int l = Math.min(day, SWAP_WIDTH);\n        int r = Math.min(D - 1 - day, SWAP_WIDTH);\n        int v = rnd.nextInt(l + r);\n        return v < l ? day - l + v : day - l + v + 1;\n    }\n\n    public void greedy() {\n        int[] last = new int[A];\n        for (int i = 0; i + 2 < D; i += 3) {\n            int max = -Const.IINF;\n            int mx1 = -1, mx2 = -1, mx3 = -1;\n            for (int x1 = 0; x1 < A; x1++) for (int x2 = 0; x2 < A; x2++) for (int x3 = 0; x3 < A; x3++) {\n                int l1 = last[x1], l2 = last[x2], l3 = last[x3];\n                int delta = 0;\n                last[x1] = i + 1;\n                delta += s[i][x1];\n                for (int j = 0; j < A; j++) delta -= c[j] * (i + 1 - last[j]);\n                last[x2] = i + 2;\n                delta += s[i + 1][x2];\n                for (int j = 0; j < A; j++) delta -= c[j] * (i + 2 - last[j]);\n                last[x3] = i + 3;\n                delta += s[i + 2][x3];\n                for (int j = 0; j < A; j++) delta -= c[j] * (i + 3 - last[j]);\n                if (delta > max) {\n                    max = delta;\n                    mx1 = x1; mx2 = x2; mx3 = x3;\n                }\n                last[x1] = l1; last[x2] = l2; last[x3] = l3;\n            }\n            x[i] = mx1; x[i + 1] = mx2; x[i + 2] = mx3;\n            last[mx1] = i + 1; last[mx2] = i + 2; last[mx3] = i + 3;\n            score += max;\n        }\n        int max = -Const.IINF;\n        int mx1 = -1, mx2 = -1;\n        for (int x1 = 0; x1 < A; x1++) for (int x2 = 0; x2 < A; x2++) {\n            int l1 = last[x1], l2 = last[x2];\n            int delta = 0;\n            last[x1] = D - 1;\n            delta += s[D - 2][x1];\n            for (int j = 0; j < A; j++) delta -= c[j] * (D - 1 - last[j]);\n            last[x2] = D;\n            delta += s[D - 1][x2];\n            for (int j = 0; j < A; j++) delta -= c[j] * (D - last[j]);\n            if (delta > max) {\n                max = delta;\n                mx1 = x1; mx2 = x2;\n            }\n            last[x1] = l1; last[x2] = l2;\n        }\n        x[D - 2] = mx1; x[D - 1] = mx2;\n        last[mx1] = D - 1; last[mx2] = D;\n        score += max;\n    }\n\n    public void greedy2() {\n        for (int i = 0; i < A; i++) score -= D * (D + 1) * c[i] / 2;\n        int[] last = new int[A];\n        Arrays.fill(last, -1);\n        for (int i = 0; i < D; i++) {\n            int max = 0, xi = -1;\n            for (int j = 0; j < A; j++) {\n                int delta = s[i][j] + (D - i) * (i - last[j]) * c[j];\n                if (delta > max) {\n                    max = delta;\n                    xi = j;\n                }\n            }\n            last[xi] = i;\n            x[i] = xi;\n            score += max;\n        }\n    }\n\n    public void greedy3() {\n        for (int i = 0; i < A; i++) score -= D * (D + 1) * c[i] / 2;\n        int[] last = new int[A];\n        Arrays.fill(last, -1);\n        for (int i = 0; i + 3 < D; i += 4) {\n            int max = 0;\n            int mx1 = -1, mx2 = -1, mx3 = -1, mx4 = -1;\n            for (int x1 = 0; x1 < A; x1++) for (int x2 = 0; x2 < A; x2++) \n            for (int x3 = 0; x3 < A; x3++) for (int x4 = 0; x4 < A; x4++) {\n                int l1 = last[x1], l2 = last[x2], l3 = last[x3], l4 = last[x4];\n                int delta = 0;\n                delta += s[i][x1] + (D - i) * (i - last[x1]) * c[x1];\n                last[x1] = i;\n                delta += s[i + 1][x2] + (D - i - 1) * (i + 1 - last[x2]) * c[x2];\n                last[x2] = i + 1;\n                delta += s[i + 2][x3] + (D - i - 2) * (i + 2 - last[x3]) * c[x3];\n                last[x3] = i + 2;\n                delta += s[i + 3][x4] + (D - i - 3) * (i + 3 - last[x4]) * c[x4];\n                last[x4] = i + 3;\n                if (delta > max) {\n                    max = delta;\n                    mx1 = x1; mx2 = x2; mx3 = x3; mx4 = x4;\n                }\n                last[x1] = l1; last[x2] = l2; last[x3] = l3; last[x4] = l4;\n            }\n            x[i] = mx1; x[i + 1] = mx2; x[i + 2] = mx3; x[i + 3] = mx4;\n            last[mx1] = i; last[mx2] = i + 1; last[mx3] = i + 2; last[mx4] = i + 3;\n            score += max;\n        }\n        int max = 0;\n        int mx1 = -1;\n        for (int x1 = 0; x1 < A; x1++) {\n            int l1 = last[x1];\n            int delta = 0;\n            delta += s[D - 1][x1] + (D - 1 - last[x1]) * c[x1];\n            last[x1] = D - 1;\n            if (delta > max) {\n                max = delta;\n                mx1 = x1;\n            }\n            last[x1] = l1;\n        }\n        x[D - 1] = mx1;\n        last[mx1] = D - 1;\n        score += max;\n    }\n\n    public void input() {\n        in.ni();\n        Arrays.setAll(c, $ -> in.ni());\n        for (int i = 0; i < D; i++) Arrays.setAll(s[i], $ -> in.ni());\n    }\n\n    public void output() {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < D; i++) sb.append(x[i] + 1).append('\\n');\n        System.out.print(sb);\n    }\n\n    public int score() {\n        int[] last = new int[A];\n        int score = 0;\n        for (int i = 0; i < D; i++) {\n            last[x[i]] = i + 1;\n            score += s[i][x[i]];\n            for (int j = 0; j < A; j++) score -= c[j] * (i + 1 - last[j]);\n        }\n        return score;\n    }\n\n    public int higher(int day, int v) {\n        for (int i = day + 1; i < D; i++) if (x[i] == v) return i;\n        return D;\n    }\n\n    public int lower(int day, int v) {\n        for (int i = day - 1; i >= 0; i--) if (x[i] == v) return i;\n        return -1;\n    }\n}\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class In {\n    final FastScanner fsc = new FastScanner();\n    public int ni() {return fsc.nextInt();}\n    public int[] ni(final int n) {\n        final int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = fsc.nextInt();\n        return a;\n    }\n    public int[] ni(final int n, final IntUnaryOperator f) {\n        final int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = f.applyAsInt(fsc.nextInt());\n        return a;\n    }\n    public int[][] ni(final int n, final int m) {\n        final int[][] a = new int[n][m];\n        for (int i = 0; i < n; i++) a[i] = ni(m);\n        return a;\n    }\n    public int[][] ni(final int n, final int m, final IntUnaryOperator f) {\n        final int[][] a = new int[n][m];\n        for (int i = 0; i < n; i++) a[i] = ni(m, f);\n        return a;\n    }\n    public long nl() {return fsc.nextLong();}\n    public long[] nl(final int n) {\n        final long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = fsc.nextLong();\n        return a;\n    }\n    public long[] nl(final int n, final LongUnaryOperator f) {\n        final long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = f.applyAsLong(fsc.nextLong());\n        return a;\n    }\n    public long[][] nl(final int n, final int m) {\n        final long[][] a = new long[n][m];\n        for (int i = 0; i < n; i++) a[i] = nl(m);\n        return a;\n    }\n    public long[][] nl(final int n, final int m, final LongUnaryOperator f) {\n        final long[][] a = new long[n][m];\n        for (int i = 0; i < n; i++) a[i] = nl(m, f);\n        return a;\n    }\n    public char[] nc() {return fsc.next().toCharArray();}\n    public char[][] nc(final int n) {\n        final char[][] c = new char[n][];\n        for (int i = 0; i < n; i++) c[i] = nc();\n        return c;\n    }\n    public double nd() {return fsc.nextDouble();}\n    public double[] nd(final int n) {\n        final double[] a = new double[n];\n        for (int i = 0; i < n; i++) a[i] = fsc.nextDouble();\n        return a;\n    }\n    public double[][] nd(final int n, final int m) {\n        final double[][] a = new double[n][m];\n        for (int i = 0; i < n; i++) a[i] = nd(m);\n        return a;\n    }\n    public String ns() {return fsc.next();}\n    public String[] ns(final int n) {\n        final String[] s = new String[n];\n        for (int i = 0; i < n; i++) s[i] = fsc.next();\n        return s;\n    }\n    public boolean[][] grid(final int h, final int w, final char trueCharacter) {\n        final boolean[][] grid = new boolean[h][w];\n        for (int i = 0; i < h; i++) {\n            final char[] s = fsc.next().toCharArray();\n            for (int j = 0; j < w; j++) grid[i][j] = s[j] == trueCharacter;\n        }\n        return grid;\n    }\n}\n\n\nfinal class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try {buflen = in.read(buffer);}\n        catch (final IOException e) {e.printStackTrace();}\n        return buflen > 0;\n    }\n    private int readByte() {return hasNextByte() ? buffer[ptr++] : -1;}\n    public boolean hasNext() {\n        while (hasNextByte() && !(33 <= buffer[ptr] && buffer[ptr] <= 126)) ptr++;\n        return hasNextByte();\n    }\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        final StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (33 <= b && b <= 126) {sb.appendCodePoint(b); b = readByte();}\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {minus = true; b = readByte();}\n        if (b < '0' || '9' < b) throw new NumberFormatException();\n        for (; ; b = readByte()) {\n            if ('0' <= b && b <= '9') n = n * 10 + b - '0';\n            else if (b == -1 || !(33 <= b && b <= 126)) return minus ? -n : n;\n            else throw new NumberFormatException();\n        }\n    }\n    public int nextInt() {return Math.toIntExact(nextLong());}\n    public double nextDouble() {return Double.parseDouble(next());}\n}\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass Const {\n    public static final long MOD7 = 1_000_000_007;\n    public static final long MOD9 = 1_000_000_009;\n    public static final long MOD99 = 998_244_353;\n\n    public static final long LINF = Long.MAX_VALUE >> 2;\n    public static final int IINF = Integer.MAX_VALUE >> 1;\n    public static final double DINF = 1e150;\n\n    public static final double SDELTA = 1e-12;\n    public static final double DELTA = 1e-9;\n    public static final double LDELTA = 1e-6;\n\n    public static final int[] dx8 = {1, 0, -1, 0, 1, -1, -1, 1};\n    public static final int[] dy8 = {0, 1, 0, -1, 1, 1, -1, -1};\n    public static final int[] dx4 = {1, 0, -1, 0};\n    public static final int[] dy4 = {0, 1, 0, -1};\n\n    private Const(){}\n}\n\nfinal class Random {\n    private static final double DOUBLE_UNIT = 0x1.0p-53;\n    private int x = 123456789;\n    private int y = 362436069;\n    private int z = 521288629;\n    private int w = 88675123;\n    public int nextInt() {\n        int t = x ^ (x << 11);\n        x = y; y = z; z = w;\n        return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n    }\n    public long nextLong() {\n        return ((long) (nextInt()) << 32) + nextInt();\n    }\n    public int nextInt(int bound) {\n        return nextInt() % bound;\n    }\n    public boolean nextBoolean() {\n        return (nextInt() & 1) == 0;\n    }\n    public double nextDouble() {\n        return (((long) (next(26)) << 27) + next(27)) * DOUBLE_UNIT;\n    }\n    private int next(int bits) {\n        int mask = bits == 32 ? -1 : (1 << bits) - 1;\n        return nextInt() & mask;\n    }\n}\n", "code2": "N,M,K=gets.split.map &:to_i;puts (0..N).any?{|k|x=K-k*M;y=N-2*k;y==0?x==0:(l=x/y;x%y==0&&0<=l&&l<=M)}?:Yes: :No", "label": 0, "name1": "s001261503.java", "name2": "s741962711.rb"}, {"id": 411, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n + 2];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tsc.close();\n\n\t\tint sum = 0;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsum += Math.abs(a[i] - a[i + 1]);\n\t\t}\n\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tSystem.out.println(sum + Math.abs(a[i- 1] - a[i + 1])\n\t\t\t\t\t- Math.abs(a[i] - a[i + 1]) - Math.abs(a[i] - a[i - 1]));\n\t\t}\n\t}\n}\n", "code2": "N = gets.chomp.to_i\nA = gets.chomp.split.map(&:to_i)\nA.push(0)\nA.unshift(0)\nsum = 0\nbalance = Array.new(N,0)\n1.upto(A.length-1) do |n|\n\tsum += (A[n-1]-A[n]).abs\n\tif n<balance.length+1\n\t\tbalance[n-1] = (A[n-1]-A[n+1]).abs-((A[n-1]-A[n]).abs+(A[n]-A[n+1]).abs)\n\tend\nend\nbalance.each do |b|\n\tp b+sum\nend", "label": 1, "name1": "s784073174.java", "name2": "s447319638.rb"}, {"id": 853, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tRunner[] a = new Runner[18];\n\t\tint cnt=0;\n\t\tfor(int  j = 0;j<3;j++){\n\t\t\tRunner[] b = new Runner[8];\n\t\t\tfor(int i = 0;i<8;i++){\n\t\t\t\tint num = cin.nextInt();\n\t\t\t\tdouble time= cin.nextDouble();\n\t\t\t\tb[i]=new Runner(num,time);\n\t\t\t}\n\t\t\tArrays.sort(b);\n\t\t\tfor(int i = 0;i<6;i++){\n\t\t\t\ta[cnt++]=b[i+2];\n\t\t\t}\n\t\t\tSystem.out.println(b[0].num + \" \" + b[0].timestr);\n\t\t\tSystem.out.println(b[1].num + \" \" + b[1].timestr);\n\t\t}\n\t\tArrays.sort(a);\n\t\tSystem.out.println(a[0].num + \" \" + a[0].timestr);\n\t\tSystem.out.println(a[1].num + \" \" + a[1].timestr);\n\t}\n}\nclass Runner implements Comparable{\n\tint num;\n\tdouble time;\n\tString timestr;\n\tRunner(int a,double b){\n\t\tnum=a;\n\t\ttime=b;\n\t\ttimestr=String.valueOf(time);\n\t\tif(timestr.length()==4){\n\t\t\ttimestr = timestr+\"0\";\n\t\t}\n\t\t\n\t}\n\tpublic int compareTo(Object o) {\n\t\tRunner r = (Runner)o;\n\t\tif(this.time-r.time > 0)\n\t\t\treturn 1;\n\t\telse if(this.time-r.time == 0)\n\t\t\treturn 0;\n\t\telse{\n\t\t\treturn -1;\n\t\t}\n\t}\n}", "code2": "n,m=gets.chomp.split(\" \").map{|s| s.to_i}\np=[]\ns=[]\nfor i in 0..m-1\n  p[i],s[i]=gets.chomp.split(\" \")\n  p[i]=p[i].to_i\nend\nt=[]\nfor i in 0..m-1\n  if t[p[i]].nil?\n    t[p[i]]=[1,0] if s[i]==\"AC\"\n    t[p[i]]=[0,1] if s[i]==\"WA\"\n  else\n    if t[p[i]][0]==0\n      if s[i]==\"AC\"\n        t[p[i]][0]=1\n      else s[i]==\"WA\"\n        t[p[i]][1]+=1\n      end\n    end\n  end\nend\n\nac=0\nwa=0\nfor i in 0..n\n  if !t[i].nil?\n    if t[i][0]==1\n      ac+=1\n      wa+=t[i][1]\n    end\n  end\nend\nprint \"#{ac} #{wa}\"", "label": 0, "name1": "s761209201.java", "name2": "s134805528.rb"}, {"id": 467, "code1": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.Stack;\n\nclass Main{\n\tpublic static void main(String[] args) {\n\t\tint INF=1000000007;\n\t\tScanner sc=new Scanner(System.in);\n\t\tint V=sc.nextInt();\n\t\tArrayList<ArrayList<Integer>> v=new ArrayList<ArrayList<Integer>>();\n\t\tfor(int i=0; i<=V; i++) {\n\t\t\tv.add(new ArrayList<Integer>());\n\t\t}\n\t\tfor(int i=0; i<V-1; i++) {\n\t\t\tint a=sc.nextInt();\n\t\t\tint b=sc.nextInt();\n\t\t\t(v.get(a)).add(b);\n\t\t\t(v.get(b)).add(a);\n\t\t}\n\t\tint[] Fe=new int[V+1];\n\t\tint[] Su=new int[V+1];\n\t\tboolean[] Fe_V=new boolean[V+1];\n\t\tboolean[] Su_V=new boolean[V+1];\n\t\tArrays.fill(Fe, INF);\n\t\tArrays.fill(Su, INF);\n\t\tFe[1]=0;\n\t\tSu[V]=0;\n\t\tStack<Integer> Q=new Stack<Integer>();\n\t\tQ.add(1);\n\t\twhile(!Q.isEmpty()) {\n\t\t\tint tmp=Q.pop();\n\t\t\tfor(int i=0; i<v.get(tmp).size(); i++) {\n\t\t\t\tif(!Fe_V[v.get(tmp).get(i)] && Fe[tmp]+1<Fe[v.get(tmp).get(i)]) {\n\t\t\t\t\tFe_V[v.get(tmp).get(i)]=true;\n\t\t\t\t\tFe[v.get(tmp).get(i)]=Fe[tmp]+1;\n\t\t\t\t\tQ.push(v.get(tmp).get(i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tQ.add(V);\n\t\twhile(!Q.isEmpty()) {\n\t\t\tint tmp=Q.pop();\n\t\t\tfor(int i=0; i<v.get(tmp).size(); i++) {\n\t\t\t\tif(!Su_V[v.get(tmp).get(i)] && Su[tmp]+1<Su[v.get(tmp).get(i)]) {\n\t\t\t\t\tSu_V[v.get(tmp).get(i)]=true;\n\t\t\t\t\tSu[v.get(tmp).get(i)]=Su[tmp]+1;\n\t\t\t\t\tQ.push(v.get(tmp).get(i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint Su_w=0;\n\t\tint Fe_w=0;\n\t\tfor(int i=1; i<=V; i++) {\n\t\t\tif(Fe[i]<=Su[i]) {\n\t\t\t\tFe_w++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSu_w++;\n\t\t\t}\n\t\t}\n\t\tif(Su_w>=Fe_w) {\n\t\t\tSystem.out.println(\"Snuke\");\n\t\t\tSystem.out.flush();\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"Fennec\");\n\t\t\tSystem.out.flush();\n\t\t}\n\t}\n}", "code2": "n=gets.to_i\nr=(1..n-1).map{gets.split.map(&:to_i)}\n\nstate=[1]+[0]*(n-2)+[2]\nroot=(r+r.map{|a,b|[b,a]}).group_by{|a,b|a}.sort_by{|k,v|k}.map{|k,v|v.map{|a,b|b-1}}\n\nfen=root[0]\nsnu=root[-1]\nwhile fen[0]||snu[0]\n  fen=fen.select{|i|state[i]==0}.flat_map{|i|state[i]=1;root[i]}\n  snu=snu.select{|i|state[i]==0}.flat_map{|i|state[i]=2;root[i]}\nend\n\nputs state.count(1)>n/2?\"Fennec\":\"Snuke\"\n", "label": 1, "name1": "s522721717.java", "name2": "s277944300.rb"}, {"id": 791, "code1": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Map;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class TaskX {\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tint n = in.nextInt();\n\t\t\tint k = in.nextInt();\n\t\t\tint l = in.nextInt();\n\t\t\tUnionFind u1 = new UnionFind(n);\n\t\t\tUnionFind u2 = new UnionFind(n);\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tint p = in.nextInt()-1;\n\t\t\t\tint q = in.nextInt()-1;\n\t\t\t\tu1.link(p, q);\n\t\t\t}\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tint r = in.nextInt()-1;\n\t\t\t\tint s = in.nextInt()-1;\n\t\t\t\tu2.link(r, s);\n\t\t\t}\n\t\t\tMap<Long, Integer> roots = new HashMap<Long, Integer>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tlong code = (long)u1.root(i)<< 32 | u2.root(i);\n\t\t\t\troots.merge(code, 1, Integer::sum);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i > 0)out.print(\" \");\n\t\t\t\tlong code = (long)u1.root(i) << 32 | u2.root(i);\n\t\t\t\tout.print(roots.get(code));\n\t\t\t}\n\n\t\t}\n\n\t\tpublic class UnionFind {\n\t\t\tint[] data;\n\n\t\t\tpublic UnionFind(int n) {\n\t\t\t\tdata = new int[n];\n\t\t\t\tArrays.fill(data, -1);\n\t\t\t}\n\n\t\t\tboolean link(int x, int y) {\n\t\t\t\tx = root(x);\n\t\t\t\ty = root(y);\n\t\t\t\tif (x != y) {\n\t\t\t\t\tif (data[y] < data[x]) {\n\t\t\t\t\t\tdata[y] += data[x];\n\t\t\t\t\t\tdata[x] = y;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdata[x] += data[y];\n\t\t\t\t\t\tdata[y] = x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn x != y;\n\t\t\t}\n\n\t\t\tint root(int x) {\n\t\t\t\treturn data[x] < 0 ? x : (data[x] = root(data[x]));\n\t\t\t}\n\t\t}\n\t}\n\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\n\t}\n\n}\n", "code2": "require \"date\"\n\nYEAR = 2004\nWDAY = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n\nwhile true\n  m, d = gets.split.map(&:to_i)\n  \n  break if m == 0 && d == 0\n  \n  puts WDAY[Date.new(YEAR, m, d).wday]\nend", "label": 0, "name1": "s544715299.java", "name2": "s853442568.rb"}, {"id": 477, "code1": "import java.util.*;\n\npublic class Main {\n\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    int cnt = 0;\n\n    List<Integer>[] lists = new ArrayList[n];\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    void run() {\n\n        for (int i=0; i<n; i++) lists[i] = new ArrayList<>();\n\n        int m = sc.nextInt();\n        for (int i=0; i<m; i++) {\n            int s = sc.nextInt() - 1;\n            int t = sc.nextInt() - 1;\n            lists[s].add(t);\n            lists[t].add(s);\n        }\n\n        dfs(\"\", n);\n\n        System.out.println(cnt);\n\n    }\n\n    void dfs(String s, int n) {\n\n        if (s.length() == n) {\n//            System.out.println(s);\n            if (s.charAt(0) == '0') {\n                boolean check = true;\n                for (int i=0; i<s.length()-1; i++) {\n                    if (!lists[s.charAt(i) - 48].contains(s.charAt(i+1) - 48)) {\n                        check = false;\n                        break;\n                    }\n                }\n                if (check) cnt++;\n            }\n\n        } else {\n            for (int i=0; i<n; i++) {\n                if (s.contains(String.valueOf(i))) continue;\n                dfs(s + i, n);\n            }\n        }\n    }\n\n\n}\n\n", "code2": "N, M = gets.split.map(&:to_i)\nedges = M.times.map { gets.split.map(&:to_i) }\ngraph = Array.new(N) { [] }\nedges.each do |u, v|\n  u -= 1\n  v -= 1\n  graph[u].push(v)\n  graph[v].push(u)\nend\n\nrequire 'set'\ndef path_count(u, visited, graph)\n  return 1 if visited.size == N\n  ret = 0\n  graph[u].each do |v|\n    next if visited.include?(v)\n    new_visited = visited | Set.new([v])\n    ret += path_count(v, new_visited, graph)\n  end\n  ret\nend\nvisited = Set.new([0])\nans = path_count(0, visited, graph)\nputs ans", "label": 1, "name1": "s337668331.java", "name2": "s194005594.rb"}, {"id": 270, "code1": "import java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);  \n\t\twhile(true){\n\t\t\t    int n=sc.nextInt();\n\t\t\t    int x=sc.nextInt();\n\t\t\t    if(n==0&&x==0)break;\n\t\t\t    int cnt=0;\n\t\t\t    for(int i=1;i<=n;i++){\n\t\t\t        for(int j=i+1;j<=n;j++){\n\t\t\t            for(int k=j+1;k<=n;k++){\n\t\t\t                if(i+j+k==x)cnt++;\n\t\t\t            }\n\t\t\t        }\n\t\t\t    }\n\t\t\t    System.out.println(cnt);\n\t\t}\n\t}\n}", "code2": "j=0\nwhile true\n   line=gets\n   arr=line.split(\" \")\n   n,x=arr[0].to_i,arr[1].to_i\n\n   if n==0 and x==0\n      break\n   end\n\n   if n >= 3 and n <= 100\n      j=0\n      numbers=Array.new(n)\n      for i in 1..n\n         numbers[i-1]=i\n      end\n   end\n   numbers.combination(3) {|a,b,c| if a+b+c == x\n                                      j+=1\n                                   end}\nprintf(\"%d\\n\",j)\nend", "label": 1, "name1": "s954202209.java", "name2": "s730064206.rb"}, {"id": 641, "code1": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\t\n\tpublic static void main(String[] args){\n\t\tnew Main();\n\t}\n\tpublic Main(){\n\t\tnew A().doIt();\n\t}\n\tclass A{\n\t\tlong euclid(long a, long b){\n\t\t    long temp;\n\n\t\t    if(a < b) { \n\t\t    \ttemp = a;\n\t\t    \ta = b;\n\t\t    \tb = temp;\n\t\t    }\n\t\t    if(a % b == 0) return b;\n\t\t    return euclid( b, a % b );\n\t\t}\n\t\tvoid doIt(){\n\t\t\tint n = sc.nextInt();\n\t\t\tlong A = 1;\n\t\t\tlong B = 1;\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tlong aa = sc.nextLong();\n\t\t\t\tlong bb = sc.nextLong();\n\t\t\t\tif(A % aa != 0)A = A + aa - (A % aa);\n\t\t\t\tif(B % bb != 0)B = B + bb - (B % bb);\n\t\t\t\tlong max = Math.max(A/aa,B/bb);\n\t\t\t\tA = max * aa;\n\t\t\t\tB = max * bb;\n//\t\t\t\tSystem.out.println(A+\" \"+B);\n\t\t\t}\n\t\t\tSystem.out.println(A+B);\n\t\t}\n\t}\n}\n", "code2": "Infinity = 1000000\n\ndef floydwarshall graph\n  n = graph.size\n  dist = Array.new(n).map{Array.new(n, Infinity)}\n  n.times do |i|\n    dist[i][i] = 0\n  end\n  n.times do |i|\n    graph[i].each do |edge|\n      dist[i][edge] = 1\n    end\n  end\n\n  n.times do |k|\n    n.times do |u|\n      n.times do |v|\n        newPop = dist[u][k] + dist[k][v]\n        if newPop < dist[u][v]\n          dist[u][v] = newPop\n        end\n      end\n    end\n  end\n  dist\nend\n\n#\u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u53d6\u5f97\nn = $stdin.gets.to_i\ngraph = Array.new(n).map{Array.new}\nn.times do\n  input = $stdin.gets.split(\" \").map(&:to_i)\n  input[1].times do |t|\n    graph[input[0] - 1] << input[t + 2] - 1\n  end\nend\n\ndist = floydwarshall graph\n\n#\u30d1\u30b1\u30c3\u30c8\u51e6\u7406\n$stdin.gets.to_i.times do\n  s, d, v = $stdin.gets.split(\" \").map(&:to_i)\n  if dist[s - 1][d - 1] + 1 <= v\n    puts dist[s - 1][d - 1] + 1\n  else\n    puts \"NA\"\n  end\nend", "label": 0, "name1": "s857617870.java", "name2": "s930752392.rb"}, {"id": 733, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tint N,M;\n\tboolean[] first,second;\n\n\tpublic void solve() {\n\n\t\tN = nextInt();\n\t\tM = nextInt();\n\n\t\tfirst = new boolean[N];\n\t\tsecond = new boolean[N];\n\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tint a = nextInt()-1;\n\t\t\tint b = nextInt()-1;\n\n\t\t\tif(a == 0){\n\t\t\t\tfirst[b] = true;\n\t\t\t}\n\n\t\t\tif(b == N-1){\n\t\t\t\tsecond[a] = true;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1;i < N - 1;i++){\n\t\t\tif(first[i] && second[i]){\n\t\t\t\tout.println(\"POSSIBLE\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tout.println(\"IMPOSSIBLE\");\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}", "code2": "def dijkstra(g, s)\n  def enq(pq, val)\n    pq << val\n    cd = pq.size\n    pr = cd / 2\n    until pr.zero? || (pq[pr - 1] <=> pq[cd - 1]) < 0\n      pq[pr - 1], pq[cd - 1] = pq[cd - 1], pq[pr - 1]\n      cd = pr\n      pr = cd / 2\n    end\n  end\n\n  def deq(pq)\n    pq[0], pq[-1] = pq[-1], pq[0]\n    rs = pq.delete_at(-1)\n    unless pq.empty?\n      pr = 1\n      cd = [pr * 2, pr * 2 + 1].select { |i| pq[i - 1] }.min_by { |i| pq[i - 1] }\n      until cd.nil? || (pq[pr - 1] <=> pq[cd - 1]) < 0\n        pq[pr - 1], pq[cd - 1] = pq[cd - 1], pq[pr - 1]\n        pr = cd\n        cd = [pr * 2, pr * 2 + 1].select { |i| pq[i - 1] }.min_by { |i| pq[i - 1] }\n      end\n    end\n    rs\n  end\n\n  pq = []\n  d = Array.new(g.size) { Float::INFINITY }\n  d[s] = 0\n  enq(pq, [0, s])\n\n  until pq.empty?\n    v_cost, v = deq(pq)\n    next if d[v] < v_cost\n    g[v].each do |e|\n      if d[e.to] > d[v] + e.cost\n        d[e.to] = d[v] + e.cost\n        enq(pq, [d[e.to], e.to])\n      end\n    end\n  end\n\n  d\nend\n\nEdge = Struct.new('Edge', :to, :cost)\n\nv, e, r = gets.split.map(&:to_i)\ng = Array.new(v) { [] }\ne.times do\n  s, t, d = gets.split.map(&:to_i)\n  g[s] << Edge.new(t, d)\nend\n\ndijkstra(g, r).each do |sum|\n  puts (sum == Float::INFINITY ? 'INF' : sum)\nend", "label": 0, "name1": "s651303084.java", "name2": "s716711304.rb"}, {"id": 386, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n\n    void solve() throws IOException {\n        int h = ni(), w = ni();\n        String[] a = nsa(h);\n\n        char[][] ansR = new char[h][w];\n        char[][] ansB = new char[h][w];\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (i == 0 || i < h - 1 && j % 2 == 0) {\n                    ansR[i][j] = '#';\n                    ansB[i][j] = '.';\n                } else {\n                    ansR[i][j] = '.';\n                    ansB[i][j] = '#';\n                }\n            }\n        }\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (a[i].charAt(j) == '#') {\n                    ansR[i][j] = '#';\n                    ansB[i][j] = '#';\n                }\n            }\n        }\n\n        for (int i = 0; i < h; i++) {\n            out.println(String.valueOf(ansR[i]));\n        }\n        out.println();\n        for (int i = 0; i < h; i++) {\n            out.println(String.valueOf(ansB[i]));\n        }\n    }\n\n    String ns() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine(), \" \");\n        }\n        return tok.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.parseInt(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.parseLong(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.parseDouble(ns());\n    }\n\n    String[] nsa(int n) throws IOException {\n        String[] res = new String[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ns();\n        }\n        return res;\n    }\n\n    int[] nia(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ni();\n        }\n        return res;\n    }\n\n    long[] nla(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nl();\n        }\n        return res;\n    }\n\n    class INA {\n        int[][] a;\n\n        INA(int n, int m) throws IOException {\n            this(n, m, -1);\n        }\n\n        INA(int n, int m, int t) throws IOException {\n            a = new int[m][n];\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    a[j][i] = ni() + t;\n                }\n            }\n        }\n\n        int[] get(int i) {\n            return a[i - 1];\n        }\n    }\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        tok = new StringTokenizer(\"\");\n        Main main = new Main();\n        main.solve();\n        out.close();\n    }\n}", "code2": "h,w=gets.split(\" \").map(&:to_i)\na=[]\nh.times{a<<gets}\nputs \"#\"*w\nfor i in 1..h-2 do\n    out=\"\"\n    for j in 0...w do\n        if j%2==1||a[i][j]==\"#\" then\n            out+=\"#\"\n        else\n            out+=\".\"\n        end\n    end\n    puts out\nend\nputs \".\"*w\nputs \"\"\nputs \".\"*w\nfor i in 1..h-2 do\n    out=\"\"\n    for j in 0...w do\n        if j%2==0||a[i][j]==\"#\" then\n            out+=\"#\"\n        else\n            out+=\".\"\n        end\n    end\n    puts out\nend\nputs \"#\"*w", "label": 1, "name1": "s104811718.java", "name2": "s470579436.rb"}, {"id": 833, "code1": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tstatic final long mod = (long) 1e9 + 7;\n\tstatic final int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };\n\tstatic final int[] dx8 = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\tstatic final int inf = Integer.MAX_VALUE / 3;\n\tstatic final long linf = Long.MAX_VALUE / 3;\n\tstatic final double dinf = Double.MAX_VALUE / 3;\n\tstatic final double eps = 1e-10;\n\tstatic final double pi = Math.PI;\n\tstatic StringBuilder sb = new StringBuilder();\n\n\tstatic void solve() {\n\t\tint n = ni();\n\t\tchar s[] = ns(n);\n\t\t//\u5de6\u304b\u3089W\u3092\u5411\u3044\u3066\u308b\u4eba\u3001\u53f3\u304b\u3089E\u3092\u5411\u3044\u3066\u308b\u4eba\u3092\u6570\u3048\u308b\n\t\tint suml[] = new int[n+1];\n\t\tint sumr[] = new int[n+1];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tsuml[i+1] = suml[i] + (s[i]=='W'?1:0);\n\t\t\tsumr[n-i-1] = sumr[n-i] + (s[n-1-i]=='E'?1:0);\n\t\t}\n\t\t\n\t\tint ans = inf;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint t = suml[i]+sumr[i+1];\n\t\t\tans = min(ans, t);\n\t\t}\n\t\tout.println(ans);\n\t\t\n\t}\n\n\t//libraries\n\tstatic void reverse(int ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tint t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(long ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tlong t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(double ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tdouble t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(char ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tchar t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic String getReverse(String s) {\n\t\tchar c[] = s.toCharArray();\n\t\treverse(c);\n\t\ts = String.valueOf(c);\n\t\treturn s;\n\t}\n\n\tstatic <T> void reverse(List<T> ls) {\n\t\tint sz = ls.size();\n\t\tfor (int i = 0; i < sz / 2; i++) {\n\t\t\tT t = ls.get(i);\n\t\t\tls.set(i, ls.get(sz - 1 - i));\n\t\t\tls.set(sz - 1 - i, t);\n\t\t}\n\t}\n\n\tstatic void sbnl() {//StringBuilder\u306b\u6539\u884c\u6587\u5b57\u3092append\u3059\u308b\n\t\tsb.append(\"\\n\");\n\t}\n\n\tstatic int lowerBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int lowerBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int lowerBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic <T> int lowerBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) >= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) >= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) >= 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int upperBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) > 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) > 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) > 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int rupperBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) < 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) < 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) < 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int rlowerBound(List<T> ls, T x) {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) <= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) <= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) <= 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic int[] concat(int x, int arr[]) {\n\t\tint ret[] = new int[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 1, ret.length - 1);\n\t\tret[0] = x;\n\t\treturn ret;\n\t}\n\n\tstatic int[] concat(int arr[], int x) {\n\t\tint ret[] = new int[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 0, ret.length - 1);\n\t\tret[ret.length - 1] = x;\n\t\treturn ret;\n\t}\n\n\tstatic long[] concat(long x, long arr[]) {\n\t\tlong ret[] = new long[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 1, ret.length - 1);\n\t\tret[0] = x;\n\t\treturn ret;\n\t}\n\n\tstatic long[] concat(long arr[], long x) {\n\t\tlong ret[] = new long[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 0, ret.length - 1);\n\t\tret[ret.length - 1] = x;\n\t\treturn ret;\n\t}\n\n\tstatic int max(int x, int y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic int min(int x, int y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic int max(int x, int y, int z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic int min(int x, int y, int z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic long max(long x, long y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic long min(long x, long y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic long max(long x, long y, long z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic long min(long x, long y, long z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic double max(double x, double y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic double min(double x, double y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic double max(double x, double y, double z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic double min(double x, double y, double z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic void sort(int[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void sort(long[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void sort(double[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void rsort(int[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tint tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void rsort(long[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tlong tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void rsort(double[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tdouble tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void fill(int arr[], int x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(long arr[], long x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(boolean arr[], boolean x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(double arr[], double x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(int arr[][], int x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(long arr[][], long x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(double arr[][], double x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(boolean arr[][], boolean x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\t//MOD culc\n\tstatic long plus(long x, long y) {\n\t\tlong res = (x + y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long sub(long x, long y) {\n\t\tlong res = (x - y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long mul(long x, long y) {\n\t\tlong res = (x * y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long div(long x, long y) {\n\t\tlong res = x * pow(y, mod - 2) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long pow(long x, long y) {\n\t\tif (y < 0)\n\t\t\treturn 0;\n\t\tif (y == 0)\n\t\t\treturn 1;\n\t\tif (y % 2 == 1)\n\t\t\treturn (x * pow(x, y - 1)) % mod;\n\t\tlong root = pow(x, y / 2);\n\t\treturn root * root % mod;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\t//input\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static long[] nla(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n}\n", "code2": "# 3 8 3   n l t\n# 0 1     x w\n# 3 2\n# 6 1\n\nn, l, t = gets.split.map(&:to_i)\n\narray_x = []\narray_w = []\nn.times do \n  x_temp, w_temp = gets.split.map(&:to_i)\n  array_x << x_temp\n  array_w << w_temp\nend\n\ndef round_once_plus(array)\n  array << array[0]\n  array.shift\nend\n\ndef round_once_minus(array)\n  array.unshift(array.last)\n  array.pop\nend\n\narray_position = []\ncount_over = 0\n\narray_x.each_with_index do |x, i|\n  if array_w[i] == 1\n    array_position << (x + t) % l\n    count_over += (x + t) / l\n  else # array_w[i] == 2\n    array_position << (x - t) % l\n    count_over += (x - t) / l\n  end\nend\n\narray_position.sort!\n\nif count_over > 0\n  # count_over = count_over % l\n  count_over.times do\n    round_once_plus(array_position)\n  end\nelsif count_over < 0\n  count_over = count_over.abs\n  # count_over = count_over % l\n  count_over.times do\n    round_once_minus(array_position)\n  end\nend\n\nputs array_position\n", "label": 0, "name1": "s594845311.java", "name2": "s129377988.rb"}, {"id": 258, "code1": "import java.util.*;\n \nclass Main{\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n \n        String S = sc.next();\n        String T = sc.next();\n        int ls = S.length();\n        int lt = T.length();\n        String a = \"?\";\n\n        if(ls<lt){\n            System.out.println(\"UNRESTORABLE\");\n            return;\n        }\n        int x = -1;\n        for(int i=0; i<=ls-lt; i++){\n            if(S.charAt(i)==T.charAt(0) || S.charAt(i)==a.charAt(0)){\n                for(int j=0; j<lt; j++){\n                    if(S.charAt(i+j)!=T.charAt(j) && S.charAt(i+j)!=a.charAt(0)){\n                        break;\n                    }\n                    if(j==lt-1){\n                        x = i;\n                    }\n                }\n            }\n        }\n        if(x==-1){\n            System.out.println(\"UNRESTORABLE\");\n            return;\n        }\n        else if(ls==lt){\n            S = T;\n            System.out.println(S);\n            return;\n        }\n        else if(x==0){\n            S = T + S.substring(lt);\n        }\n        else if(x!=0){\n            if(x+lt-1==ls){\n                S = S.substring(0, x) + T;\n            }\n            else{\n                S = S.substring(0, x) + T + S.substring(x + lt);\n            }\n        }\n        String st = \"\";\n        for(int i=0; i<ls; i++){\n            if(S.charAt(i)==a.charAt(0)){\n                st += \"a\";\n            }\n            else{\n                st += String.valueOf((char)S.charAt(i));\n            }\n        }\n        System.out.println(st);\n    }\n}", "code2": "WORM_EATEN_S = STDIN.gets.strip!\nHINT = STDIN.gets.strip!\ncandidates = []\n\ndef apply_hint(given_str, start, hint)\n\n  if start + hint.length > given_str.length\n    return ''\n  end\n\n  applied = Marshal.load(Marshal.dump(given_str))\n\n  (0..hint.length-1).each do |idx|\n    target_char = given_str[start+idx]\n\n    unless ( target_char == '?' || target_char == hint[idx] )\n      return ''\n    end\n\n    applied[start+idx] = hint[idx]\n  end\n\n  return applied\nend\n\n# gather candidate strings\nresult = ''\n(0..WORM_EATEN_S.length-1).each do |idx|\n  result = apply_hint(Marshal.load(Marshal.dump(WORM_EATEN_S)), idx, HINT)\n  candidates.push(result.gsub(/\\?/, 'a')) if result != ''\nend\n\n# print the result\nif candidates.length == 0\n  puts 'UNRESTORABLE'\nelse\n  puts candidates.min\nend\n", "label": 1, "name1": "s748827885.java", "name2": "s297009778.rb"}, {"id": 957, "code1": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.BigDecimal;\n\npublic class Main{\n    public static void main (String[] args) throws java.lang.Exception {\n        InputReader in = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n        int n = in.nextInt(), m = in.nextInt(), k = in.nextInt();\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j <= m; j++) {\n                long cur = i * m + j * n - 2 * (i * j);\n                if (cur == k) {\n                    w.println(\"Yes\");\n                    w.close();\n                    return;\n                }\n            }\n        }\n        w.println(\"No\");\n        w.close();\n    }\n\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new UnknownError();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new UnknownError();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int peek() {\n            if (numChars == -1)\n                return -1;\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    return -1;\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar];\n        }\n\n        public void skip(int x) {\n            while (x-- > 0)\n                read();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public String nextString() {\n            return next();\n        }\n\n        public String next() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuffer res = new StringBuffer();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        public String nextLine() {\n            StringBuffer buf = new StringBuffer();\n            int c = read();\n            while (c != '\\n' && c != -1) {\n                if (c != '\\r')\n                    buf.appendCodePoint(c);\n                c = read();\n            }\n            return buf.toString();\n        }\n\n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n        public int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n        public long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n        public boolean hasNext() {\n            int value;\n            while (isSpaceChar(value = peek()) && value != -1)\n                read();\n            return value != -1;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}", "code2": "io = STDIN\nn,c=io.gets.split.map(&:to_i)\n$da=[]\nc.times do |i|\n  $da << io.gets.split.map(&:to_i)\nend\n$hash=Hash.new{|h,k|h[k]=Hash.new{|h,k|h[k]=0}}\n#key1:amari\n#key2:color#-1\n#value:count\nn.times do |i|\n  ar = io.gets.split.map(&:to_i).map{|i|i-1}\n  n.times do |j|\n    $hash[(i+j)%3][ar[j]]+=1\n  end\nend\ndef calc(*arg)\n  a,b,c=arg\n  tot=0\n  #a,b,c\u306f\u305d\u308c\u305e\u308c\u3042\u307e\u308a\u304c0,1,2\u306e\u6642\u306e\u306b\u8a2d\u5b9a\u3059\u308b\u8272#-1\n  arg.each_with_index do |amari,i|\n    cl_cnt=$hash[i]\n    cl_cnt.each do |cl,cnt|\n      tot+=$da[cl][amari]*cnt\n    end\n  end\n  tot\nend\n\nans=Float::INFINITY\n(0...c).to_a.permutation(3) do |x,y,z|\n  ans=[calc(x,y,z),ans].min\nend\nputs ans\n", "label": 0, "name1": "s982439298.java", "name2": "s691571255.rb"}, {"id": 418, "code1": "import java.math.BigInteger;\nimport java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = Integer.parseInt(sc.next());\n\t\tlong m = Long.parseLong(sc.next());\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tm = lcm(m, Long.parseLong(sc.next()));\n\t\tSystem.out.println(m);\n\t}\n\tpublic static long lcm(long m, long n) {\n\t\tBigInteger M = new BigInteger(String.valueOf(m));\n\t\tBigInteger N = new BigInteger(String.valueOf(n));\n\t\tBigInteger G = new BigInteger(String.valueOf(gcd(m, n)));\n\t\treturn M.multiply(N).divide(G).longValue();\n\t}\n\tpublic static long gcd(long m, long n) {\n\t\tif (m < n) {\n\t\t\tlong tem = m;\n\t\t\tm = n;\n\t\t\tn = tem;\n\t\t}\n\t\tlong r = -1;\n\t\twhile (r != 0) {\n\t\t\tr = m % n;\n\t\t\tm = n;\n\t\t\tn = r;\n\t\t}\n\t\treturn m;\n\t}\n}", "code2": "a = []\ngets.to_i.times{ a << gets.to_i }\nputs a.inject{|x, y| x.lcm(y) }", "label": 1, "name1": "s725061223.java", "name2": "s688834112.rb"}, {"id": 711, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author cunbidun\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        EProductOfArithmeticProgression solver = new EProductOfArithmeticProgression();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EProductOfArithmeticProgression {\n        private static final int MOD = (int) 1e6 + 3;\n        private InputReader in;\n        private PrintWriter out;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            this.in = in;\n            this.out = out;\n            int q = in.nextInt();\n\n            int[] fac = new int[MOD + 1];\n            int[] inv = new int[MOD + 1];\n            fac[0] = 1;\n            inv[0] = Op.inv(1, MOD);\n            for (int i = 1; i <= MOD; i++) {\n                fac[i] = Op.mulMod(fac[i - 1], i, MOD);\n                inv[i] = Op.inv(fac[i], MOD);\n            }\n\n            while (q-- > 0) {\n                int x = in.nextInt();\n                int d = in.nextInt();\n                int n = in.nextInt();\n                if (d == 0) {\n                    out.println(Op.powMod(x, n, MOD));\n                    continue;\n                }\n                x = Op.mulMod(x, Op.inv(d, MOD), MOD);\n                int ans;\n                if (x + n - 1 >= MOD || x == 0) ans = 0;\n                else\n                    ans = Op.mulMod(fac[x + n - 1], inv[x - 1], MOD);\n                out.println(Op.mulMod(ans, Op.powMod(d, n, MOD), MOD));\n            }\n        }\n\n    }\n\n    static class Op {\n        public static int mulMod(int x, int y, int MOD) {\n            return (int) (((long) x * y) % MOD);\n        }\n\n        public static int powMod(int x, long p, int MOD) {\n            if (p == 0) return 1;\n            int t = powMod(x, p / 2, MOD);\n            if ((p & 1) == 1)\n                return mulMod(mulMod(t, t, MOD), x, MOD);\n            return mulMod(t, t, MOD);\n        }\n\n        public static int inv(int x, int MOD) {\n            return powMod(x, MOD - 2, MOD);\n        }\n\n    }\n\n    static class InputReader extends InputStream {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private static boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n", "code2": "puts gets.split.map(&:to_i).combination(2).map {|x,y| x+y}.min", "label": 0, "name1": "s606724970.java", "name2": "s609833635.rb"}, {"id": 383, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\n\n/*\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n            pass System Test!\n*/\n\npublic class Main {\n  private static class Task {\n    void solve(FastScanner in, PrintWriter out) {\n      int H = in.nextInt();\n      int W = in.nextInt();\n      char[][] map = new char[H][];\n      for (int i = 0; i < H; i++) {\n        map[i] = in.next().toCharArray();\n      }\n\n      boolean[][] red = new boolean[H][W];\n      boolean[][] blue = new boolean[H][W];\n      for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n          if (j == 0) red[i][j] = true;\n          else if (j == W - 1) blue[i][j] = true;\n          else if (i % 2 == 0) red[i][j] = true;\n          else blue[i][j] = true;\n        }\n      }\n\n      for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n          if (map[i][j] == '.') continue;\n          blue[i][j] = true;\n          red[i][j] = true;\n        }\n      }\n\n      for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n          out.print(red[i][j] ? \"#\" : \".\");\n        }\n        out.println();\n      }\n      out.println();\n      for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n          out.print(blue[i][j] ? \"#\" : \".\");\n        }\n        out.println();\n      }\n    }\n  }\n\n  /**\n   * \u3053\u3053\u304b\u3089\u4e0b\u306f\u30c6\u30f3\u30d7\u30ec\u30fc\u30c8\u3067\u3059\u3002\n   */\n  public static void main(String[] args) {\n    OutputStream outputStream = System.out;\n    FastScanner in = new FastScanner();\n    PrintWriter out = new PrintWriter(outputStream);\n    Task solver = new Task();\n    solver.solve(in, out);\n    out.close();\n  }\n  private static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n      int[] array = new int[n];\n      for (int i = 0; i < n; i++) array[i] = nextInt();\n      return array;\n    }\n\n    public long[] nextLongArray(int n) {\n      long[] array = new long[n];\n      for (int i = 0; i < n; i++) array[i] = nextLong();\n      return array;\n    }\n\n    public String[] nextStringArray(int n) {\n      String[] array = new String[n];\n      for (int i = 0; i < n; i++) array[i] = next();\n      return array;\n    }\n\n    public char[][] nextCharMap(int n) {\n      char[][] array = new char[n][];\n      for (int i = 0; i < n; i++) array[i] = next().toCharArray();\n      return array;\n    }\n  }\n}\n", "code2": "H,W=gets.split.map &:to_i\nA=H.times.map{gets.chop}\nr=Array.new(H){\".\"*W}\nb=Array.new(H){\".\"*W}\nH.times{|i|r[i][0]=b[i][-1]=?#}\n0.step(H-1,2){|i|(W-1).times{|j|r[i][j]=?#}}\n1.step(H-1,2){|i|1.upto(W-1){|j|b[i][j]=?#}}\nH.times{|i|W.times{|j|r[i][j]=b[i][j]=?# if A[i][j]==?#}}\nputs r*\"\\n\", \"\", b*\"\\n\"", "label": 1, "name1": "s871155444.java", "name2": "s962419029.rb"}, {"id": 152, "code1": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String args[]) {\n\tScanner sc = new Scanner(System.in);\n\n\twhile (true) {\n\t    int n = sc.nextInt();\n\t    int ans = 0;\n\t    if (n == 0) {\n\t\tbreak;\n\t    }\n\t    \n\t    ans = solve(n);\n\t    System.out.println(ans);\n\t}\n    }\n\n    public static int solve(int n) {\n\t//int max = 123456 * 2;\n\t//int prime[] = new prime[123456 * 2 + 1];\n\tboolean is_prime[] = new boolean[123456 * 2 + 1];\n\tint count = 0;\n\n\t//int p = 0;\n\tfor (int i = 0; i <= 2 * n; i++) {\n\t    is_prime[i] = true;\n\t}\n\n\tis_prime[0] = is_prime[1] = false;\n\tfor (int i = 2; i <= 2 * n; i++) {\n\t    if (is_prime[i]) {\n\t\t// prime[p++] = i;\n\t\tfor (int j = 2 * i; j <= 2 * n; j += i) {\n\t\t    is_prime[j] = false;\n\t\t}\n\t    }\n\t}\n\tfor (int i = n + 1; i <= 2 * n; i++) {\n\t    if (is_prime[i]) {\n\t\tcount++;\n\t    }\n\t}\n\t\n\treturn count;\n    }\n}", "code2": "def ascan; gets.split.map(&:to_i);end\n\nrequire 'prime'\n\npr = []\ng = Prime::EratosthenesGenerator.new\nwhile (t = g.next) < 250000\n    pr << t\nend\n\n\nwhile (n = gets.to_i) != 0\n    p pr.bsearch_index{|x| 2*n < x} - pr.bsearch_index{|x| n < x}\nend\n", "label": 1, "name1": "s027703193.java", "name2": "s902981487.rb"}, {"id": 774, "code1": "import java.util.Scanner;\n\npublic class Main {\n  private static Scanner sc;\n\n  public static void main(String[] args) {\n    sc = new Scanner(System.in);\n    new Main().solve();\n  }\n\n  private void solve() {\n    int N = sc.nextInt();\n    int[] a = new int[N + 2];\n    for (int i = 0; i < N; i++) {\n      a[i + 1] = sc.nextInt();\n    }\n    int sum = 0;\n    for (int i = 0; i <= N; i++) {\n      sum += Math.abs(a[i] - a[i + 1]);\n    }\n\n    for (int i = 0; i < N; i++) {\n      System.out.println(sum - Math.abs(a[i] - a[i + 1]) - Math.abs(a[i + 2] - a[i + 1]) + Math.abs(a[i] - a[i + 2]));\n    }\n  }\n}\n", "code2": "def fold arr\n    arr2 = []\n    arr.each{|name|\n        if @h.key? name\n            @h[name] = fold(@h[name])\n            @h[name].each{|name2| arr2 << name2}\n        else\n            arr2 << name\n        end\n    }\n    arr2.uniq!\n    arr2\nend\n\nwhile true\n    n = gets.to_i\n    break if n == 0\n    @h = Hash.new{|h, k| h[k] = []}\n    firstgroup = nil\n    n.times{|i|\n        group, members = (gets.chomp)[0..-2].split(\":\")\n        members = members.split(\",\")\n        @h[group] = members\n        firstgroup = group if i == 0\n    }\n    puts fold(@h[firstgroup]).length\nend\n", "label": 0, "name1": "s142792447.java", "name2": "s533876771.rb"}, {"id": 691, "code1": "import java.util.*;\n\nclass Main{\n  public static void main(String[] args)\n  {\n    Scanner scanner = new Scanner(System.in);\n    int[] a = new int[3];\n    int[] b = new int[3];\n\n    int iti = 0,ni=0,san=0,si =0;\n\n    int odd=0, even=0;\n\n    for(int i=0; i<3; i++){\n      a[i] = scanner.nextInt();\n      b[i] = scanner.nextInt();\n    }\n\n    for(int i=0; i<3; i++){\n      if(a[i] == 1){\n        iti++;\n      }\n      else if(a[i]==2)\n      {\n        ni++;\n      }else if(a[i] == 3)\n      {\n        san++;\n      }else if(a[i] == 4){\n        si++;\n      }\n\n      if(b[i] == 1){\n        iti++;\n      }\n      else if(b[i]==2)\n      {\n        ni++;\n      }else if(b[i] == 3)\n      {\n        san++;\n      }else if(b[i] == 4){\n        si++;\n      }\n    }\n\n    if(checkEven(iti)){\n      even++;\n    }else{\n      odd++;\n    }\n    if(checkEven(ni)){\n      even++;\n    }else{\n      odd++;\n    }\n    if(checkEven(san)){\n      even++;\n    }else{\n      odd++;\n    }\n\n    if(checkEven(si)){\n      even++;\n    }else{\n      odd++;\n    }\n\n      if(odd == 2 && even == 2)\n      {\n        System.out.println(\"YES\");\n      }else{\n        System.out.println(\"NO\");\n      }\n\n  }\n\n  public static boolean checkEven(int num){\n    if(num %2 == 0){\n      return true;\n    }\n    return false;\n  }\n\n}", "code2": "module AtCoder\n  class DSU\n    def initialize(n = 0)\n      @n = n\n      @parent_or_size = Array.new(n, -1)\n    end\n\n    def merge(a, b)\n      x, y = leader(a), leader(b)\n      return x if x == y\n\n      x, y = y, x if -@parent_or_size[x] < -@parent_or_size[y]\n      @parent_or_size[x] += @parent_or_size[y]\n      @parent_or_size[y] = x\n    end\n\n    def same(a, b)\n      leader(a) == leader(b)\n    end\n\n    def leader(a)\n      return a if @parent_or_size[a] < 0\n\n      @parent_or_size[a] = leader(@parent_or_size[a])\n    end\n\n    def size(a)\n      -@parent_or_size[leader(a)]\n    end\n\n    def groups\n      @n.times.group_by { |i| leader(i) }.values\n    end\n  end\nend\n\nn, m = gets.split.map!(&:to_i)\n\ndsu = AtCoder::DSU.new(n + 1)\nm.times do\n  a, b = gets.split.map!(&:to_i)\n  dsu.merge(a, b)\nend\n\nputs dsu.groups.size - 2\n", "label": 0, "name1": "s151827431.java", "name2": "s989552174.rb"}, {"id": 12, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString s= sc.next();\n\t\tfor (int i=0;i<s.length();i++) {\n\t\t\tif (s.charAt(i)=='R'||s.charAt(i)=='L') {\n\t\t\t\tif (i%2==0&&s.charAt(i)!='R')\t{\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t\treturn ;\n\t\t\t\t} else if (i%2==1&&s.charAt(i)!='L'){\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t\treturn ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tSystem.out.println(\"Yes\");\n\t\t\treturn ;\n\t\t}\n\t}\n}\n", "code2": "s = gets.chomp.split(\"\")\ndir = [[\"R\", \"U\", \"D\"], [\"L\", \"U\", \"D\"]]\nflag = 1\nid = 0\ns.each do |c|\n  tmpflag = 0\n  dir[id%2].each do |d|\n    if c == d\n      tmpflag = 1\n      break\n    end\n  end\n  if tmpflag == 0\n    flag = 0\n    break\n  end\n  id += 1\nend\nif flag == 1\n  puts \"Yes\"\nelse\n  puts \"No\"\nend", "label": 1, "name1": "s922990944.java", "name2": "s423509236.rb"}, {"id": 632, "code1": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\npublic class Main {\n\tstatic final long C =  1000000007;\n\tstatic final int CY = 1000000000;\n\tstatic final int INF = Integer.MAX_VALUE/2;\n\tStringBuilder sb;\n\t//\u30bb\u30c3\u30c8\n\tclass Set<F,S> {\n\t\tF f;\n\t\tS s;\n\t\tSet(F f, S s) {this.f = f;this.s = s;}\n\t}\n\tpublic void calc() {\n\t\tsb = new StringBuilder();\n\n\n\t\tIO sc = new IO();\n\n\t\tint n = sc.nextInt();\n\t\tint[] t = sc.nextIntArray(n);\n\t\tint[] a = sc.nextIntArray(n);\n\n\n\t\tlong ans = 1;\n\t\t//BigInteger bi = new BigInteger(\"1\");\n\t\tint[] min = new int[n];\n\t\tint[] max = new int[n];\n\t\tArrays.fill(min, 1);\n\t\tArrays.fill(max, INF);\n\t\tint b = -1, nb = -1;\n\t\tfor (int i=0; i < n; i++) {\n\t\t\t//System.out.println(\"t\" + i);\n\t\t\tint ni = n-1-i;\n\t\t\tif (b != t[i]) {\n\t\t\t\tmax[i] = Math.min(max[i],t[i]);\n\t\t\t\tmin[i] = Math.max(min[i],t[i]);\n\t\t\t\tb = t[i];\n\t\t\t}else {\n\t\t\t\tmax[i] = Math.min(max[i],t[i]);\n\t\t\t}\n\t\t\tif (nb != a[ni]) {\n\t\t\t\tmax[ni] = Math.min(max[ni],a[ni]);\n\t\t\t\tmin[ni] = Math.max(min[ni],a[ni]);\n\t\t\t\tnb = a[ni];\n\t\t\t}else {\n\t\t\t\tmax[ni] = Math.min(max[ni],a[ni]);\n\t\t\t}\n\n\t\t}\n\n\t\tfor (int i=0; i < n; i++) {\n\t\t\t//System.out.println(min[i] + \":\" + max[i]);\n\t\t\tif (max[i] - min[i] < 0) {\n\t\t\t\tSystem.out.println(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tans *= max[i] - min[i] +1;\n\t\t\tans %= C;\n\t\t\t//bi = bi.multiply(new BigInteger((max[i] - min[i] +1)+\"\" ));\n\n\t\t}\n\n\n\t\tSystem.out.println(ans);\n\t}\n\n\n\tpublic static void main(String[] args) {\n\t\tMain main = new Main();\n\t\tmain.calc();\n\n\t}\n}\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}\n\n", "code2": "t = a = 1\ngets.to_i.times{\n\tu, b = gets.split.map(&:to_i)\n\tm = (u<t || b<a) ? [(t+u-1)/u, (a+b-1)/b].max : 1\n\tt, a = u*m, b*m\n}\np t+a\n", "label": 0, "name1": "s145899300.java", "name2": "s565416710.rb"}, {"id": 690, "code1": "import java.io.BufferedReader;\n\nimport static java.util.Comparator.*;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.lang.reflect.Array;\nimport java.math.BigDecimal;\nimport java.util.AbstractMap;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class Main {\n\t\n//\tpublic static Set<String> mem = new HashSet<String>();\n//\tpublic static boolean[] mem_1 = new boolean[100];\n//\tpublic static boolean[] mem_2 = new boolean[100];\n//\tpublic static Set<Integer> mem = new TreeSet<Integer>();\n//\tpublic static Map<String, Integer> mem_1= new HashMap<String, Integer>();\n//\tpublic static Map<String, Integer> mem_2 = new HashMap<String, Integer>();\n\t\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        \n        Solver solver = new Solver();\n        solver.solve(1, in, out);\n        \n        out.close();\n    }\n    \n    // ======================================================================\n    static class Solver {\n    \t\n\t\tList<Pair<Integer, Integer>> lP = new ArrayList<Pair<Integer, Integer>>();\n\t\tList<Pair<Integer, Integer>> lAns = new ArrayList<Pair<Integer, Integer>>();\n\n    \tpublic void solve(int testNumber, MyInput in, PrintWriter out) {\n    \t\tlong ans = 0L;\n    \t\tint[] cnt = new int[4];\n    \t\tfor(int i=0; i < 6; i++) {\n        \t\tint a = in.nextInt();\n        \t\tcnt[a-1] += 1;\n        // \t\tout.println(\"[\" + a + \"]\");\n    \t\t}\n    \t\tboolean f = true;\n    \t\tfor(int i=0; i < 4; i++) {\n        // \t\tout.println(\"[\" + cnt[i] + \"]\");\n    \t\t\tif(cnt[i] >= 3)\t\tf = false;\n    \t\t}\n    \t\tif(f)   \t\tout.println(\"YES\");\n    \t\telse            out.println(\"NO\");\n        }\n    }\n    // ======================================================================\n    static class Pair<K, V> extends AbstractMap.SimpleEntry<K, V> {\n        /** serialVersionUID. */\n        private static final long serialVersionUID = 6411527075103472113L;\n\n        public Pair(final K key, final V value) {\n            super(key, value);\n        }\n        public String getString() {\n            return \"[\" + getKey() + \"] [\" + getValue() + \"]\";\n        }\n     }    \n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n \n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n \n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n \n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n \n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n \n        public String nextString() {\n        \tString ret = new String(nextDChar()).trim();\n            return ret;\n        }\n \n        public char[] nextDChar() {\n            int len = 0;\n            len = reads(len, isSpace);\n            char[] ret = new char[len + 1];\n            for (int i=0; i < len; i++)\t\tret[i] = str[i];\n            ret[len] = 0x00;\n            return ret;\n        }\n \n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n \n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n \n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n    }\n}\n", "code2": "class DisjointSet\n\tdef initialize(n)\n\t\t@parent = Array.new(n){-1}\n\tend\n\tdef find(a)\n\t\treturn a if @parent[a]<0\n\t\t@parent[a] = find(@parent[a])\n\tend\n\tdef union(a, b)\n\t\tx = find(a)\n\t\ty = find(b)\n\t\treturn x if x == y\n\t\tif size(x) < size(y)\n\t\t\tt = x\n\t\t\tx = y\n\t\t\ty = t\n\t\tend\n\t\t@parent[x] += @parent[y]\n\t\t@parent[y] = x\n\t\tx\n\tend\n\tdef size(a)\n\t\t-@parent[find(a)]\n\tend\nend\n\nN,M=gets.split.map(&:to_i)\nds=DisjointSet.new(N)\nM.times{\n\ta,b=gets.split.map(&:to_i)\n\tds.union(a-1,b-1)\n}\nr=0\n(1 .. N-1).each{|i|\n\tif ds.find(i)!=ds.find(0)\n\t\tds.union(i,0)\n\t\tr+=1\n\tend\n}\nputs r\n", "label": 0, "name1": "s961270278.java", "name2": "s385678464.rb"}, {"id": 207, "code1": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\t\n\tpublic static void main(String[] args){\n\t\tnew Main();\n\t}\n\tpublic Main(){\n\t\tnew A().doIt();\n\t}\n\tclass A{\n\t\tlong euclid(long a, long b){\n\t\t    long temp;\n\n\t\t    if(a < b) { \n\t\t    \ttemp = a;\n\t\t    \ta = b;\n\t\t    \tb = temp;\n\t\t    }\n\t\t    if(a % b == 0) return b;\n\t\t    return euclid( b, a % b );\n\t\t}\n\t\tvoid doIt(){\n\t\t\tint n = sc.nextInt();\n\t\t\tlong A = 1;\n\t\t\tlong B = 1;\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tlong aa = sc.nextLong();\n\t\t\t\tlong bb = sc.nextLong();\n\t\t\t\tif(A % aa != 0)A = A + aa - (A % aa);\n\t\t\t\tif(B % bb != 0)B = B + bb - (B % bb);\n\t\t\t\tlong max = Math.max(A/aa,B/bb);\n\t\t\t\tA = max * aa;\n\t\t\t\tB = max * bb;\n//\t\t\t\tSystem.out.println(A+\" \"+B);\n\t\t\t}\n\t\t\tSystem.out.println(A+B);\n\t\t}\n\t}\n}\n", "code2": "def get_min_point(points, ratio)\n\n  ap, bp = points\n  ar, br = ratio\n\n  an = get_min_count(ap, ar)\n  bn = get_min_count(bp, br)\n\n  mn = [an, bn].max\n  result = [ar*mn, br*mn]\n  result\nend\n\ndef get_min_count(ap, ar)\n  if ap % ar == 0\n    (ap / ar)\n  else\n    (ap / ar) + 1\n  end\nend\n\ninputs = readlines.map(&:chomp)\npoints = inputs[1].split(\" \").map(&:to_i)\nratios = inputs[2..-1].map {|x| x.split(\" \").map(&:to_i) }\n\nratios.each do |ratio|\n  points = get_min_point(points, ratio)\nend\n\nputs points.reduce(:+)\n", "label": 1, "name1": "s857617870.java", "name2": "s308934020.rb"}, {"id": 540, "code1": "import java.util.*;\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int x = 0, y = 0; \n\tstatic String second;\n\tstatic int second_ = 0;\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO \u30c4\u7be0\u30a5\u30c4\u7763\u30e7\u30c4\u9752\u30ab\u30c4\u9752\u30e3\u30c4\u3064\u30a6\u30c4\u3065\u30a7\u30c4\u3064\u30b9\u30c4\u03b4\u30bd\u30c4\u30c3\u30c4\u30c9\u30c4\u30fb\u30c4\u30b9\u30c4\u30bf\u30c4\u30d6\n\t\tread();\t\n\t\tslove();\n\t\t\n\t}\n\tstatic boolean read(){\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tsecond = sc.next();\n\t\t\tsecond_ = second_ + Integer.parseInt(second);\n\t\t}\n\t\t//System.out.println(second_);\n\t\treturn true;\n\t}\n\tstatic void slove(){\n\t\tx = second_/60;\n\t\ty = second_ % 60;\n\t\tSystem.out.println(x);\n\t\tSystem.out.println(y);\n\t}\n}", "code2": "n = gets.chomp.to_i\n\nif n == 1\n  puts 'Yes'\n  puts '2'\n  puts '1 1'\n  puts '1 1'\n  exit\nend\n\nif n == 3\n  puts 'Yes'\n  puts '3'\n  puts '2 1 2'\n  puts '2 3 1'\n  puts '2 2 3'\n  exit\nend\n\noks = [1]\n2.upto(10**5) do |i|\n  if i == (oks.last + oks.size + 1)\n    oks.push(i)\n  end\nend\n\nif !oks.include?(n)\n  puts 'No'\n  exit\nend\n\nnum = oks.index(n) + 1\n\nans = Array.new(num + 1) { Array.new }\ncounts = Array.new(n, 0)\n\ni = 1\n(1..num + 1).to_a.combination(2) do |a, b|\n  ans[a-1].push(i)\n  ans[b-1].push(i)\n   i += 1\nend\n\nputs 'Yes'\np num + 1\nans.each do |an|\n  puts \"#{an.size} #{an.join(' ')}\"\nend\n", "label": 0, "name1": "s543682667.java", "name2": "s963991485.rb"}, {"id": 952, "code1": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args ) throws Exception {\n    Scanner sc = new Scanner(System.in);\n    String A = sc.next();\n    int count=0;\n    char[] B = A.toCharArray();\n    for(int i=0;i<A.length();i++){\n      if(B[i]=='2'){\n      \tcount++;\n      }\n    }\n    System.out.println(count);\n  }\n}\n\n", "code2": "N,M,K=gets.split.map &:to_i;puts (0..N).any?{|k|x=K-k*M;y=N-2*k;y==0?x==0:(l=x/y;x%y==0&&0<=l&&l<=M)}?:Yes: :No", "label": 0, "name1": "s261661305.java", "name2": "s961847715.rb"}, {"id": 969, "code1": "\nimport java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tC();\n\t}\n\t\n\tpublic static void A() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tString s1 = sc.next();\n\t\tString s2 = sc.next();\n\t\tfor(int i=0;i<3;i++) {\n\t\t\tif(s1.charAt(i)!=s2.charAt(2-i)) {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"YES\");\n\t}\n\t\n\t// 1\u304b\u3089\u9806\u306b\uff12\u4e57\u3092\u8a08\u7b97\u3057\u3066\u3001N\u3092\u8d85\u3048\u308b\u304b\u3069\u3046\u304b\u78ba\u8a8d\u3059\u308b\u3002 O(root(N))\n\t//\uff12\u5206\u63a2\u7d22\u3059\u308b\u306a\u3089\u3001O(logN)\n\t// \u4e8c\u5206\u63a2\u7d22\u3067\u3001N\u306e\uff12\u4e57\u3092\u8d85\u3048\u306a\u3044\u6700\u5c0f\u306e\u5e73\u65b9\u6570\u3092\u767a\u898b\n\tpublic static long binsearchN2(long left, long right, int N) {\n\t\tif(left >= right) return (long) Math.pow(right, 2);\n\t\tlong mid = (left+right)/2;\n\t\tif(Math.pow(mid, 2) > N ) return binsearchN2(left, mid-1, N);\n\t\telse {\n\t\t\t//\u7121\u9650\u30eb\u30fc\u30d7\u3092\u9632\u3050\u3000\u518d\u8d77\u3059\u308b\u6642\u306f\u5fc5\u305a\u3001\u63a2\u7d22\u7bc4\u56f2\u304c\uff11\u4ee5\u4e0a\u5c0f\u3055\u304f\u306a\u308b\n\t\t\tif(Math.pow(mid+1, 2) > N) return (long) Math.pow(mid, 2) ;\n\t\t\telse return binsearchN2(mid+1,right, N);\n\t\t}\n\t}\n\t\n\tpublic static void B() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tSystem.out.println(binsearchN2(0,N,N));\n\t}\n\n\t// B\u3092\u4e2d\u5fc3\u306b\u3057\u3066\u4e8c\u5206\u63a2\u7d22\u3057\u3066A\u3068C\u306e\u6570\u3092\u639b\u3051\u5408\u308f\u305b\u308b\n\t//\u3000A\u3092\u4e2d\u5fc3\u3068\u3059\u308b\u3068\u3001O(N^2)\n\t\n\t// B\u3092\u8d85\u3048\u306a\u3044\u8981\u7d20\u6570\u3092\u8fd4\u3059\n\tpublic static void C() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tdouble[] A=new double[N],  C = new double[N];\n\t\tint[] B=new int[N];\n\t\tfor(int i=0;i<N;i++) {\n\t\t\tA[i] = sc.nextDouble();\n\t\t}\n\t\tfor(int i=0;i<N;i++) {\n\t\t\tB[i] = sc.nextInt();\n\t\t}\n\t\tfor(int i=0;i<N;i++) {\n\t\t\tC[i] = sc.nextDouble();\n\t\t}\n\t\tArrays.sort(A);\n\t\tArrays.sort(B);\n\t\tArrays.sort(C);\n\t\tlong sum = 0;\n\t\tfor(int i=0;i<N;i++) {\n\t\t\tdouble b = B[i];\n\t\t\tsum += numlessB(A,b)*(long)numlargerB(C,b);\n\t\t}\n\t\tSystem.out.println(sum);\n\t\t\n\t}\n\t//B\u3088\u308a\u3082\u5c0f\u3055\u3044\u8981\u7d20\u306e\u6570\u3000==B\u306f\u542b\u307e\u306a\u3044 B\u3092\u5c11\u3057\u305a\u3089\u3059\n\tpublic static int numlessB(double[] A, double B){\n\t\tint idx = Arrays.binarySearch(A, B-0.1);\n\t\treturn -idx-1;\n\t}\n\tpublic static int numlargerB(double[] A, double B) {\n\t\tint idx = Arrays.binarySearch(A, B+0.1);\n\t\treturn A.length-(-idx-1);\n\t}\n}\n", "code2": "N, A, B, *HS = $stdin.read.split.map(&:to_i)\ndef cleared?(n)\n  hs = HS.map{|h| h - B*n}.reject{|h| h <= 0}\n  times = hs.map{|h| (h.to_f / (A-B)).ceil}.inject(0, :+)\n  return times <= n\nend\nmin = 0\nmax = HS.inject(0, :+) / B\np (min..max).bsearch{|n| cleared?(n)}\n", "label": 0, "name1": "s892418502.java", "name2": "s961437635.rb"}, {"id": 192, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n  public static void main(String[] args) {\n\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    long[] a = new long[n];\n\n    for (int i = 0; i < n; i++) {\n      a[i] = sc.nextInt();\n    }\n\n    Arrays.sort(a); // \u6607\u9806\n    long sum = a[n - 1];\n\n    if (n == 2) {\n      System.out.println(sum);\n    } else {\n      if (n % 2 == 1) {\n        int num = n / 2;\n        sum += a[n - num - 1];\n        for (int i = n - num; i < n - 1; i++) {\n          sum += 2 * a[i];\n        }\n        System.out.println(sum);\n      } else {\n        int num = n / 2;\n        for (int i = n - num; i < n - 1; i++) {\n          sum += 2 * a[i];\n        }\n        System.out.println(sum);\n      }\n    }\n\n  }\n}", "code2": "N = gets.to_i\nA = gets.split.map(&:to_i).sort\n\nans = A.pop\n(N-2).times do |i|\n  ans += i.odd? ? A.pop : A[-1]\nend\nputs ans", "label": 1, "name1": "s266436818.java", "name2": "s029357848.rb"}, {"id": 197, "code1": "import java.util.*;\nimport java.io.*;\n\n\nclass Main {\n\n    public static void main(String[] args) throws IOException\n    {\n        PrintWriter out = new PrintWriter(System.out);\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        int n = Integer.parseInt(br.readLine());\n        Long arr[] = new Long[n];\n        StringTokenizer st1 = new StringTokenizer(br.readLine());\n        for(int i = 0 ; i < n ; i++)\n        {\n            arr[i] = Long.parseLong(st1.nextToken());\n        }\n        Arrays.sort(arr);\n        long sum = arr[n-1];\n        int ind = n-2;\n        for(int i = 0 ; i < n-2 ; i++)\n        {\n            sum += arr[ind];\n\n            if(i%2 != 0)\n                ind--;\n        }\n        out.println(sum);\n\n        out.flush();\n        out.close();\n\n    }\n\n    static class pair{\n        long x1;\n        long x2;\n\n        public pair(long x1 , long x2)\n        {\n            this.x1 = x1;\n            this.x2 = x2;\n        }\n\n    }\n\n}\n", "code2": "n=gets.to_i-1\nr=0\ngets.split.map(&:to_i).sort.reverse.each_cons(2) do |a,b|\n  n-=1\n  r+=a\n  break if n.zero?\n  n-=1\n  r+=b\n  break if n.zero?\nend\np r", "label": 1, "name1": "s590431029.java", "name2": "s469860951.rb"}, {"id": 33, "code1": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // Your code here!\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long a = sc.nextLong();\n        long b = sc.nextLong();\n        long[] array = new long[n];\n        for (int i = 0; i < n; i++) {\n            array[i] = sc.nextLong();\n        }\n        \n        long ans = 0;\n        for (int i = 1; i < n; i++) {\n            long dis = array[i] - array[i-1];\n            if (dis * a < b) {\n                ans += dis * a;\n            } else {\n                ans += b;\n            }\n        }\n        \n        System.out.println(ans);\n    }\n}", "code2": "n,a,b=gets.split.map(&:to_i)\nx=gets.split.map(&:to_i)\nc=0\n(n-1).times do |i|\n  if (x[i+1]-x[i])*a>b\n    c+=b\n  else\n    c+=(x[i+1]-x[i])*a\n  end\nend\nputs c\n", "label": 1, "name1": "s129000734.java", "name2": "s333982418.rb"}, {"id": 847, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.util.Comparator;\nimport java.util.Collections;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        final static long INF = (long) 4.1e18;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            long L = 2L * in.nextInt();\n            long T = in.nextInt() * 2L;\n            TaskC.Chameleon[] chameleon = new TaskC.Chameleon[n];\n            int[] cnt = new int[3];\n            for (int i = 0; i < n; ++i) {\n                chameleon[i] = new TaskC.Chameleon();\n                chameleon[i].start = in.nextInt() * 2L;\n                chameleon[i].color = 0;\n                chameleon[i].dir = in.nextInt() == 1 ? 1 : -1;\n                chameleon[i].indexInInput = i;\n                ++cnt[chameleon[i].dir + 1];\n            }\n\n            // Determine new positions\n            for (TaskC.Chameleon c : chameleon) {\n                c.newPos = ((c.start + T * c.dir) % L + L) % L;\n            }\n\n            TaskC.Chameleon[] res;\n\n            if (cnt[0] == 0 || cnt[2] == 0) {\n                // No meetings at all.\n                for (TaskC.Chameleon c : chameleon) {\n                    c.newColor = c.color;\n                }\n                res = chameleon.clone();\n            } else {\n                // Determine new colors\n                {\n                    TaskC.Chameleon[] perm = chameleon.clone();\n                    Arrays.sort(perm, new Comparator<TaskC.Chameleon>() {\n                        public int compare(TaskC.Chameleon a, TaskC.Chameleon b) {\n                            if (a.newPos < b.newPos) {\n                                return -1;\n                            } else if (a.newPos > b.newPos) {\n                                return 1;\n                            } else {\n                                return 0;\n                            }\n                        }\n                    });\n\n                    int indNextReverse = 0;\n                    for (int ind = 0; ind < n; ++ind) {\n                        TaskC.Chameleon c = perm[ind];\n                        if (c.dir > 0)\n                            c.newColor = c.color;\n                        else {\n                            while (perm[indNextReverse].dir < 0)\n                                indNextReverse = (indNextReverse + 1) % n;\n                            TaskC.Chameleon d = perm[indNextReverse];\n                            long delta = c.start - d.start;\n                            if (delta < 0)\n                                delta += L;\n                            if (delta <= 2 * T) {\n                                // There was at least one change of color!\n                                c.newColor = d.color;\n                            } else {\n                                c.newColor = c.color;\n                            }\n                        }\n                        if (indNextReverse == ind)\n                            indNextReverse = (indNextReverse + 1) % n;\n                    }\n                }\n\n                TaskC.Chameleon first;\n                TaskC.Chameleon firstMapsTo;\n                // Detemine which chameleon did the first one become\n                {\n                    List<TaskC.Chameleon> positive = new ArrayList<TaskC.Chameleon>();\n                    List<TaskC.Chameleon> negative = new ArrayList<TaskC.Chameleon>();\n                    for (TaskC.Chameleon c : chameleon) {\n                        if (c.dir == 1)\n                            positive.add(c);\n                        else\n                            negative.add(c);\n                    }\n                    Collections.sort(positive, new Comparator<TaskC.Chameleon>() {\n                        public int compare(TaskC.Chameleon a, TaskC.Chameleon b) {\n                            if (a.start < b.start) {\n                                return -1;\n                            } else if (a.start > b.start) {\n                                return 1;\n                            } else {\n                                return 0;\n                            }\n                        }\n                    });\n                    Collections.sort(negative, new Comparator<TaskC.Chameleon>() {\n                        public int compare(TaskC.Chameleon a, TaskC.Chameleon b) {\n                            if (a.start < b.start) {\n                                return -1;\n                            } else if (a.start > b.start) {\n                                return 1;\n                            } else {\n                                return 0;\n                            }\n                        }\n                    });\n                    first = positive.get(0);\n                    TaskC.Chameleon closestNegative = negative.get(0);\n                    long deltaBest = closestNegative.start - first.start;\n                    if (deltaBest < 0)\n                        deltaBest += L;\n                    for (TaskC.Chameleon c : negative) {\n                        long deltaCur = c.start - first.start;\n                        if (deltaCur < 0)\n                            deltaCur += L;\n                        if (deltaCur < deltaBest) {\n                            closestNegative = c;\n                            deltaBest = deltaCur;\n                        }\n                    }\n                    long timeLeft = T;\n                    if (timeLeft < deltaBest / 2) {\n                        // The first chameleon stayed himself\n                        firstMapsTo = first;\n                    } else {\n                        timeLeft -= deltaBest / 2;\n                        List<Long> positiveDeltas = new ArrayList<Long>();\n                        positiveDeltas.add(0L);\n                        long sum = 0;\n                        for (int i = 0; i < positive.size(); ++i) {\n                            long delta = positive.get((positive.size() - i) % positive.size()).start - positive.get((positive.size() - i - 1) % positive.size()).start;\n                            if (delta < 0)\n                                delta += L;\n                            sum += delta;\n                            positiveDeltas.add(sum);\n                        }\n                        int shift = negative.indexOf(closestNegative);\n                        List<Long> negativeDeltas = new ArrayList<Long>();\n                        negativeDeltas.add(0L);\n                        sum = 0;\n                        for (int i = 0; i < negative.size(); ++i) {\n                            long delta = negative.get((shift + i + 1) % negative.size()).start - negative.get((shift + i) % negative.size()).start;\n                            if (delta < 0)\n                                delta += L;\n                            sum += delta;\n                            negativeDeltas.add(sum);\n                        }\n                        long l = 0;\n                        long r = INF;\n                        while (r - l > 1) {\n                            long m = (l + r) / 2;\n                            long cntPositive = (m + 1) / 2;\n                            long cntNegative = m / 2;\n                            long positiveTimeSpent = mulWithInf(cntPositive / positive.size(), L) + positiveDeltas.get((int) (cntPositive % positive.size()));\n                            long negativeTimeSpent = mulWithInf(cntNegative / negative.size(), L) + negativeDeltas.get((int) (cntNegative % negative.size()));\n                            if (positiveTimeSpent + negativeTimeSpent <= timeLeft * 2)\n                                l = m;\n                            else\n                                r = m;\n                        }\n                        if (l % 2 == 0) {\n                            firstMapsTo = negative.get((int) ((shift + l / 2) % negative.size()));\n                        } else {\n                            firstMapsTo = positive.get(((int) ((positive.size() - (l + 1) / 2) % positive.size()) + positive.size()) % positive.size());\n                        }\n                    }\n                }\n\n                // Now, create the final mapping!\n                {\n                    TaskC.Chameleon[] firstSortedByPos = chameleon.clone();\n                    Arrays.sort(firstSortedByPos, new Comparator<TaskC.Chameleon>() {\n                        public int compare(TaskC.Chameleon a, TaskC.Chameleon b) {\n                            if (a.start < b.start) {\n                                return -1;\n                            } else if (a.start > b.start) {\n                                return 1;\n                            } else {\n                                return 0;\n                            }\n                        }\n                    });\n                    TaskC.Chameleon[] finalSortedByPos = chameleon.clone();\n                    Arrays.sort(finalSortedByPos, new Comparator<TaskC.Chameleon>() {\n                        public int compare(TaskC.Chameleon a, TaskC.Chameleon b) {\n                            if (a.newPos < b.newPos) {\n                                return -1;\n                            } else if (a.newPos > b.newPos) {\n                                return 1;\n                            } else {\n                                return 0;\n                            }\n                        }\n                    });\n                    int delta = Arrays.asList(finalSortedByPos).indexOf(firstMapsTo) - Arrays.asList(firstSortedByPos).indexOf(first);\n                    res = new TaskC.Chameleon[chameleon.length];\n                    for (int i = 0; i < chameleon.length; ++i) {\n                        res[firstSortedByPos[i].indexInInput] = finalSortedByPos[((i + delta) % chameleon.length + chameleon.length) % chameleon.length];\n                    }\n                }\n            }\n\n            for (TaskC.Chameleon c : res) {\n                out.println(c.newPos / 2);\n            }\n        }\n\n        private long mulWithInf(long a, long b) {\n            if (a == 0)\n                return 0;\n            else if (INF / a <= b)\n                return INF;\n            else\n                return a * b;\n        }\n\n        static class Chameleon {\n            long start;\n            long newPos;\n            int newColor;\n            int color;\n            int dir;\n            int indexInInput;\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "code2": "require 'pp'\n\nn = gets.chomp!.to_i\na_n = gets.chomp!.split(\" \").map(&:to_i)\n\nmemo = {}\nmin = 10 ** 10\nmin_id = -1\na_n.each_with_index do |a, i|\n    memo[i] = a\n    if a < min\n        min = a\n        min_id = i\n    end \nend\n\n#pp min\n#pp min_id\n\nwhile memo.size > 1\n    del_list = []\n    now_min = min\n    now_min_id = min_id\n\n    memo.each do |id, v|\n        next if id == now_min_id\n\n        memo[id] = memo[id] % now_min\n        if memo[id] == 0\n            del_list << id\n        elsif memo[id] < min\n            min = memo[id]\n            min_id = id\n        end\n    end\n\n    del_list.each {|id| memo.delete(id) }\nend \n\nputs memo.values.first\n", "label": 0, "name1": "s438673994.java", "name2": "s169875807.rb"}, {"id": 286, "code1": "import java.util.*;\n\nclass Main{\n  public static void main(String[] args)\n  {\n    Scanner scanner = new Scanner(System.in);\n    int[] a = new int[3];\n    int[] b = new int[3];\n\n    int iti = 0,ni=0,san=0,si =0;\n\n    int odd=0, even=0;\n\n    for(int i=0; i<3; i++){\n      a[i] = scanner.nextInt();\n      b[i] = scanner.nextInt();\n    }\n\n    for(int i=0; i<3; i++){\n      if(a[i] == 1){\n        iti++;\n      }\n      else if(a[i]==2)\n      {\n        ni++;\n      }else if(a[i] == 3)\n      {\n        san++;\n      }else if(a[i] == 4){\n        si++;\n      }\n\n      if(b[i] == 1){\n        iti++;\n      }\n      else if(b[i]==2)\n      {\n        ni++;\n      }else if(b[i] == 3)\n      {\n        san++;\n      }else if(b[i] == 4){\n        si++;\n      }\n    }\n\n    if(checkEven(iti)){\n      even++;\n    }else{\n      odd++;\n    }\n    if(checkEven(ni)){\n      even++;\n    }else{\n      odd++;\n    }\n    if(checkEven(san)){\n      even++;\n    }else{\n      odd++;\n    }\n\n    if(checkEven(si)){\n      even++;\n    }else{\n      odd++;\n    }\n\n      if(odd == 2 && even == 2)\n      {\n        System.out.println(\"YES\");\n      }else{\n        System.out.println(\"NO\");\n      }\n\n  }\n\n  public static boolean checkEven(int num){\n    if(num %2 == 0){\n      return true;\n    }\n    return false;\n  }\n\n}", "code2": "road = []\n3.times do\n  a, b = gets.chop.split.map(&:to_i)\n  road << a\n  road << b\nend\nif road.find_all{|n| n == 1}.length >= 3 || road.find_all{|n| n == 2}.length >= 3 || road.find_all{|n| n == 3}.length >= 3 || road.find_all{|n| n == 4}.length >= 3\n  puts 'NO'\nelse\n  puts 'YES'\nend", "label": 1, "name1": "s151827431.java", "name2": "s052701711.rb"}, {"id": 890, "code1": "import java.io.*;\nimport java.lang.*;\nimport java.util.Scanner;\nimport java.util.Arrays;\nimport java.util.ArrayList;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint i;\n\t\tfor(i = 0; i < 1000; i++){\n\t\t\tSystem.out.println(\"Hello World\");\n\t\t}\n\t}\n}", "code2": "N,M=gets.split.map(&:to_i)\np (18*M+N)*100*2**M", "label": 0, "name1": "s933848138.java", "name2": "s933045021.rb"}, {"id": 818, "code1": "import java.util.*;\n\npublic class Main {\n\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    int cnt = 0;\n\n    List<Integer>[] lists = new ArrayList[n];\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    void run() {\n\n        for (int i=0; i<n; i++) lists[i] = new ArrayList<>();\n\n        int m = sc.nextInt();\n        for (int i=0; i<m; i++) {\n            int s = sc.nextInt() - 1;\n            int t = sc.nextInt() - 1;\n            lists[s].add(t);\n            lists[t].add(s);\n        }\n\n        dfs(\"\", n);\n\n        System.out.println(cnt);\n\n    }\n\n    void dfs(String s, int n) {\n\n        if (s.length() == n) {\n//            System.out.println(s);\n            if (s.charAt(0) == '0') {\n                boolean check = true;\n                for (int i=0; i<s.length()-1; i++) {\n                    if (!lists[s.charAt(i) - 48].contains(s.charAt(i+1) - 48)) {\n                        check = false;\n                        break;\n                    }\n                }\n                if (check) cnt++;\n            }\n\n        } else {\n            for (int i=0; i<n; i++) {\n                if (s.contains(String.valueOf(i))) continue;\n                dfs(s + i, n);\n            }\n        }\n    }\n\n\n}\n\n", "code2": "array = gets.split(' ').map(&:to_i)\n\narray.uniq!\n\nif array.count == 2\n  puts \"Yes\"\nelse\n  puts \"No\"\nend", "label": 0, "name1": "s337668331.java", "name2": "s533397443.rb"}, {"id": 109, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint a = Integer.parseInt(sc.next());\n\t\tint b = Integer.parseInt(sc.next());\n\t\tint c = Integer.parseInt(sc.next());\n\n\t\tif (a < c && c < b || b < c && c < a){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t}else {\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t}\n}", "code2": "i = gets.split(\" \")\nif i[0].to_i < i[1].to_i then\n  if i[0].to_i < i[2].to_i and i[2].to_i < i[1].to_i then\n    print \"Yes\"\n  else\n    print \"No\"\n  end\n  else\n    if i[0].to_i > i[2].to_i and i[2].to_i > i[1].to_i then\n      print \"Yes\"\n    else\n      print \"No\"\n    end\n    end", "label": 1, "name1": "s898770223.java", "name2": "s608185400.rb"}, {"id": 685, "code1": "import java.util.*;\n\nclass Main {\n\tpublic static void main(String args[]) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint m, f, count = 0, sum;\n\t\tm = scanner.nextInt();\n\t\tf = scanner.nextInt();\n\t\twhile(!(m == 0 && f == 0)) {\n\t\t\tfor(int i = 1;i < m+1;i++) {\n\t\t\t\tfor(int j = 1;j < m+1;j++) {\n\t\t\t\t\tfor(int k = 1;k < m+1;k++) {\n\t\t\t\t\t\t\tsum =  i+j+k;\n\t\t\t\t\t\t\tif(sum == f && (i!=j)&&(j!=k)&&(k!=i)) \n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count/(1*2*3));\n\t\t\tcount = 0;\n\t\t\tm = scanner.nextInt();\n\t\t\tf = scanner.nextInt();\n\t\t}\n\t\tscanner.close();\n\t}\n}", "code2": "input = STDIN.read.split(\"\\n\").map{|l| l.split(\" \").map{|a| a.to_i}}\n\nN = input[0][0]\nM = input[0][1]\n\nX = input[1].sort\n\n\ndef main() \n    diffs = []\n\n    if N >= M \n        return 0\n    end\n\n    for i in 0..(M - 2)\n        d = X[i + 1] - X[i] \n        diffs.push([i, d])\n    end\n\n    ds = diffs.sort_by{|x| x[1]}.reverse.slice(0, N - 1).sort_by{|x| x[0]}\n    moves = 0\n\n    if ds.length > 0\n        for i in 0..(N - 1)\n            if i == 0\n                st = 0\n                ed = ds[i][0]\n            elsif i == (N - 1)\n                st = ds[i - 1][0] + 1\n                ed = M - 1\n            else\n                st = ds[i - 1][0] + 1\n                ed = ds[i][0]\n            end\n            moves = moves + (X[ed] - X[st]).abs\n        end\n    else\n        moves = (X.first - X.last).abs\n    end\n    return moves\nend\n\nputs main()", "label": 0, "name1": "s275047149.java", "name2": "s016750008.rb"}, {"id": 64, "code1": "import java.util.*;\nclass Main {\n\tstatic int n;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\tint maxDistance = 0;\n\t\t\tMap<Integer, Integer> map = new HashMap<Integer, Integer>(n);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tint d = sc.nextInt() + sc.nextInt();\n\t\t\t\tmap.put(d, p);\n\t\t\t\tmaxDistance = Math.max(d, maxDistance);\n\t\t\t}\n\t\t\tSystem.out.printf(\"%d %d\\n\", map.get(maxDistance), maxDistance);\n\t\t}\n\t}\n}", "code2": "while line = gets\n  n = line.chomp.to_i\n  break if n == 0\n\n  answer_p = 0\n  answer_d = -Float::INFINITY\n  n.times do\n    p, d1, d2 = gets.chomp.split.map(&:to_i)\n    d = d1 + d2\n    if answer_d < d\n      answer_p = p\n      answer_d = d\n    end\n  end\n\n  puts \"#{answer_p} #{answer_d}\"\nend", "label": 1, "name1": "s188031790.java", "name2": "s402976256.rb"}, {"id": 675, "code1": "\nimport java.util.*;\n\npublic class Main {\n    public static void main(final String[] args) {\n        final Scanner sc = new Scanner(System.in);\n        // \u6574\u6570\u306e\u5165\u529b\n        // final int a = sc.nextInt();\n        // \u6587\u5b57\u5217\u306e\u5165\u529b\n        // final String s1 = sc.next();\n        final int a = sc.nextInt();\n        final int b = sc.nextInt();\n        final int c = sc.nextInt();\n        final int k = sc.nextInt();\n        sc.close();\n        int result = 0;\n        if (a >= k) {\n            result = k;\n        } else if (b >= k - a) {\n            result = a;\n        } else if (c >= k - b - a) {\n            result = 2 * a + b - k;\n        }\n\n        System.out.println(result);\n    }\n}\n", "code2": "j=0\nwhile true\n   line=gets\n   arr=line.split(\" \")\n   n,x=arr[0].to_i,arr[1].to_i\n\n   if n==0 and x==0\n      break\n   end\n\n   if n >= 3 and n <= 100\n      j=0\n      numbers=Array.new(n)\n      for i in 1..n\n         numbers[i-1]=i\n      end\n   end\n   numbers.combination(3) {|a,b,c| if a+b+c == x\n                                      j+=1\n                                   end}\nprintf(\"%d\\n\",j)\nend", "label": 0, "name1": "s239119083.java", "name2": "s730064206.rb"}, {"id": 277, "code1": "import java.util.*;\n\nclass Main {\n\tpublic static void main(String args[]) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint m, f, count = 0, sum;\n\t\tm = scanner.nextInt();\n\t\tf = scanner.nextInt();\n\t\twhile(!(m == 0 && f == 0)) {\n\t\t\tfor(int i = 1;i < m+1;i++) {\n\t\t\t\tfor(int j = 1;j < m+1;j++) {\n\t\t\t\t\tfor(int k = 1;k < m+1;k++) {\n\t\t\t\t\t\t\tsum =  i+j+k;\n\t\t\t\t\t\t\tif(sum == f && (i!=j)&&(j!=k)&&(k!=i)) \n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tsum = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count/(1*2*3));\n\t\t\tcount = 0;\n\t\t\tm = scanner.nextInt();\n\t\t\tf = scanner.nextInt();\n\t\t}\n\t\tscanner.close();\n\t}\n}", "code2": "while(n,x=gets.split.map &:to_i;n>0)\np [*1..n].combination(3).count{|i,j,k|i+j+k==x}\nend", "label": 1, "name1": "s275047149.java", "name2": "s151756888.rb"}, {"id": 132, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tMyInput in = new MyInput(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic long LINF = 1L << 55;\n\tstatic int MOD = 1000000007;\n\tstatic int[] mh4 = { 0, -1, 1, 0 };\n\tstatic int[] mw4 = { -1, 0, 0, 1 };\n\tstatic int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\tstatic int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n\tstatic class TaskX {\n\n\t\tpublic void solve(int testNumber, MyInput in, PrintWriter out) {\n\n\t\t\tint n = in.nextInt();\n\t\t\tchar[] s = in.nextChars();\n\n\t\t\tlong[][] dp = new long[n+1][n+1];\n\t\t\tArrays.fill(dp[0], 1);\n\n\t\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\t\tif (s[i] == '<') {\n\t\t\t\t\tfor (int j = 0; j < n-i; j++) {\n\t\t\t\t\t\tdp[i+1][j] += dp[i][j];\n\t\t\t\t\t\tdp[i+1][j] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (int j = 0; j < n-i; j++) {\n\t\t\t\t\t\tdp[i+1][0] += dp[i][j];\n\t\t\t\t\t\tdp[i+1][j] -= dp[i][j] - MOD;\n\t\t\t\t\t\tdp[i+1][0] %= MOD;\n\t\t\t\t\t\tdp[i+1][j] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 1; j < n-1-i; j++) {\n\t\t\t\t\tdp[i+1][j] += dp[i+1][j-1];\n\t\t\t\t\tdp[i+1][j] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout.println(dp[n-1][0]);\n\n\t\t}\n\t}\n\n\tstatic class MyInput {\n\t\tprivate final BufferedReader in;\n\t\tprivate static int pos;\n\t\tprivate static int readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500 * 8 * 2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic {\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tisDigit['0' + i] = true;\n\t\t\t}\n\t\t\tisDigit['-'] = true;\n\t\t\tisSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n\t\t\tisLineSep['\\r'] = isLineSep['\\n'] = true;\n\t\t}\n\n\t\tpublic MyInput(InputStream is) {\n\t\t\tin = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (pos >= readLen) {\n\t\t\t\tpos = 0;\n\t\t\t\ttry {\n\t\t\t\t\treadLen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException();\n\t\t\t\t}\n\t\t\t\tif (readLen <= 0) {\n\t\t\t\t\tthrow new MyInput.EndOfFileRuntimeException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buffer[pos++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\tint i = 0;\n\t\t\tint ret = 0;\n\t\t\tif (str[0] == '-') {\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t\tfor (; i < len; i++)\n\t\t\t\tret = ret * 10 + str[i] - '0';\n\t\t\tif (str[0] == '-') {\n\t\t\t\tret = -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\tint i = 0;\n\t\t\tlong ret = 0;\n\t\t\tif (str[0] == '-') {\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t\tfor (; i < len; i++)\n\t\t\t\tret = ret * 10 + str[i] - '0';\n\t\t\tif (str[0] == '-') {\n\t\t\t\tret = -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic char nextChar() {\n\t\t\twhile (true) {\n\t\t\t\tfinal int c = read();\n\t\t\t\tif (!isSpace[c]) {\n\t\t\t\t\treturn (char) c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic String nextString() {\n\t\t\treturn new String(nextChars());\n\t\t}\n\n\t\tpublic char[] nextChars() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\treturn Arrays.copyOf(str, len);\n\t\t}\n\n\t\tint reads(int len, boolean[] accept) {\n\t\t\ttry {\n\t\t\t\twhile (true) {\n\t\t\t\t\tfinal int c = read();\n\t\t\t\t\tif (accept[c]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (str.length == len) {\n\t\t\t\t\t\tchar[] rep = new char[str.length * 3 / 2];\n\t\t\t\t\t\tSystem.arraycopy(str, 0, rep, 0, str.length);\n\t\t\t\t\t\tstr = rep;\n\t\t\t\t\t}\n\t\t\t\t\tstr[len++] = (char) c;\n\t\t\t\t}\n\t\t\t} catch (MyInput.EndOfFileRuntimeException e) {\n\t\t\t}\n\t\t\treturn len;\n\t\t}\n\n\t\tpublic int[] nextIntArray(final int n) {\n\t\t\tfinal int[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArray1Index(final int n) {\n\t\t\tfinal int[] res = new int[n + 1];\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArrayDec(final int n) {\n\t\t\tfinal int[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(final int n) {\n\t\t\tfinal long[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray1Index(final int n) {\n\t\t\tfinal long[] res = new long[n + 1];\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArrayDec(final int n) {\n\t\t\tfinal long[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic double[] nextDoubleArray(int n) {\n\t\t\tdouble[] res = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextDouble();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\t}\n\n\t}\n\n}\n", "code2": "d=*1..gets.to_i;gets.chop.bytes{|c|x=0;n=d.pop;d.map!{|a|x=(x+-c%3*n+a*=1-c%3).%10**9+7}};p *d", "label": 1, "name1": "s819730919.java", "name2": "s665085996.rb"}, {"id": 222, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\n\npublic class Main {\n\n    static <T extends Comparable<? super T>> boolean nextPermutation(T[] sequence) {\n        int first = getFirst(sequence);\n        if (first == -1) return false;\n        int toSwap = sequence.length - 1;\n        while (sequence[first].compareTo(sequence[toSwap]) >= 0) --toSwap;\n        swap(sequence, first++, toSwap);\n        toSwap = sequence.length - 1;\n        while (first < toSwap) swap(sequence, first++, toSwap--);\n        return true;\n    }\n\n    static <T extends Comparable<? super T>> int getFirst(T[] sequence) {\n        for (int i = sequence.length - 2; i >= 0; --i)\n            if (sequence[i].compareTo(sequence[i + 1]) < 0) return i;\n        return -1;\n    }\n\n    static <T extends Comparable<? super T>> void swap(T[] sequence, int i, int j) {\n        T tmp = sequence[i];\n        sequence[i] = sequence[j];\n        sequence[j] = tmp;\n    }\n\n    public static void main(String[] args) {\n        FastScanner fs = new FastScanner();\n        int N = fs.nextInt();\n        Integer[] P = new Integer[N];\n        Integer[] Q = new Integer[N];\n        for (int i = 0; i < N; ++i) P[i] = fs.nextInt();\n        for (int i = 0; i < N; ++i) Q[i] = fs.nextInt();\n\n        Integer[] arr = new Integer[N];\n        for (int i = 0; i < N; ++i) arr[i] = i+1;\n\n        int cnt = 1, pNum = 0, qNum = 0;\n        do {\n            if (Arrays.toString(arr).equals(Arrays.toString(P))) pNum = cnt;\n            if (Arrays.toString(arr).equals(Arrays.toString(Q))) qNum = cnt;\n            ++cnt;\n        } while (nextPermutation(arr));\n\n        System.out.println(Math.abs(pNum - qNum));\n\n    }\n\n\n    static class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            }else{\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while(true){\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                }else if(b == -1 || !isPrintableChar(b)){\n                    return minus ? -n : n;\n                }else{\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        public int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        public double nextDouble() { return Double.parseDouble(next());}\n    }\n\n}", "code2": "n = gets.to_i\nps = gets.split(\" \").map(&:to_i)\nq = gets.split(\" \").map(&:to_i)\n\npermu = []\n(1..n).each do |i|\n    permu.push(i)\n    i += 1\nend\n\nflag_p = 0\nflag_q = 0\ncount = 0\n\npermu.permutation(n) do |a|\n    current_permu = a\n    if current_permu == ps\n        flag_p = count\n    end\n    if current_permu == q\n        flag_q = count\n    end\n    count = count + 1\nend\n\nputs (flag_p - flag_q).abs", "label": 1, "name1": "s792830085.java", "name2": "s303474561.rb"}, {"id": 776, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.util.NoSuchElementException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author HBonsai\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CMultipleClocks solver = new CMultipleClocks();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CMultipleClocks {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int N = in.nextInt();\n            long[] T = in.nextLongArray(N);\n            long ans = T[0];\n            for (int i = 1; i < N; i++) {\n                long gcd = gcd(ans, T[i]);\n                ans = T[i] * (ans / gcd);\n            }\n            out.println(ans);\n        }\n\n        private static long gcd(long m, long n) {\n            if (m < n) return gcd(n, m);\n            if (n == 0) return m;\n            return gcd(n, m % n);\n        }\n\n    }\n\n    static class FastScanner implements Closeable {\n        private final InputStream in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        public FastScanner(InputStream in) {\n            this.in = in;\n        }\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        public boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n            return hasNextByte();\n        }\n\n        public long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        public int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] res = new long[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextLong();\n            }\n            return res;\n        }\n\n        public void close() {\n            try {\n                in.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n}\n\n", "code2": "require 'set'\nloop do\n    n = gets.to_i\n    break if n == 0\n    g = n.times.map{gets.chomp}\n    h = Hash.new(Array.new)\n    f = \"\"\n    g.each_with_index do |s,i|\n        s = s.gsub(\"\\.\",\"\").split(\":\")\n        h[s[0]] = s[1].split(\",\")\n        f = s[0] if i == 0\n    end\n    t = h.to_a[0][0]\n    ans = Set.new\n    a = h[t]\n    while !a.empty?\n        a2 = Set.new\n        a.each do |m|\n            if h.has_key?(m)\n                h[m].each do |mm|\n                    a2.add(mm)\n                end\n            else\n                ans.add(m)\n            end\n        end\n        a = a2.to_a\n    end\n    p ans.size\nend", "label": 0, "name1": "s654794279.java", "name2": "s639565910.rb"}, {"id": 98, "code1": "import java.util.*;\n\npublic class Main {\n\tvoid solve() {\n\t\tScanner scan = new Scanner(System.in);\n\t\tlong n = scan.nextLong();\n\t\tlong k = scan.nextLong();\n\t\tif(n % k == 0) {\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\t\tn %= k;\n\t\tSystem.out.println(Math.min(n, k - n));\n\t\tscan.close();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\n}\n", "code2": "(N, K) = gets.chomp.split.map(&:to_i)\n\nif N == 0 || K == 1\n  puts 0\n  exit\nend\n\nmod = N % K\n\nputs mod > (mod - K).abs ? (mod - K).abs : mod\n", "label": 1, "name1": "s393030652.java", "name2": "s141533301.rb"}, {"id": 607, "code1": "import java.util.*;\npublic class Main{\npublic static void main(String[] args){\nScanner sc = new Scanner(System.in);\n  int Q = sc.nextInt();\n  for(int i=0;i<Q;i++){\n    long f = sc.nextLong();\n    long s = sc.nextLong();\n    long a = Math.max(f, s);\n    long b = Math.min(f, s);\n    long K = a*b;\n    long L = (long) Math.sqrt(K);\n    long M = (K-1)/L;\n    long N = Math.max(-1,M-b-1);\n    System.out.println(L+N+b-1);\n  }\n}}\n", "code2": "$x=0\n$y=0\n$bord = []\n$cnt = 0\n\n\ndef calc()\n\n\tmax = 0\n\tfor i in 0..$x-1\n\t\tfor j in 0..$y-1\n\t\t\tif $bord[j][i] != -1 then\n\t\t\t\tif j > 0 then\n\t\t\t\t\tup = $bord[j-1][i]\n\t\t\t\telse\n\t\t\t\t\tup = -1\n\t\t\t\tend\n\t\t\t\n\t\t\t\tif i > 0 then\n\t\t\t\t\tleft = $bord[j][i-1]\n\t\t\t\telse\n\t\t\t\t\tleft = -1\n\t\t\t\tend\n\n\t\t\t\n\t\t\t\tif up > left and up != -1 then\n\t\t\t\t\t$bord[j][i] += up * 10\n\t\t\t\t\t\n\t\t\t\telsif left != -1 then\n\t\t\t\t\t$bord[j][i] += left * 10\n\t\t\t\tend\n\t\t\t\tif $bord[j][i] > max then\n\t\t\t\t\tmax = $bord[j][i]\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn max\nend\n\t\nloop{\n\tline = gets\n\tif line==nil then\n\t\tbreak\n\tend\n\tsp = line.split(nil)\n\t\n\tif sp.count() != 2 then\n\t\tbreak\n\telse\n\t\t$x = sp[0].to_i()\n\t\t$y = sp[1].to_i()\n\t\tif $x == 0 and $y == 0 then\n\t\t\tbreak\n\t\tend\n\t\t\n\t\tsx = 0\n\t\tsy = 0\n\t\t$cnt = 1 \n\t\t$bord = Array.new($y).map{Array.new($x,0)}\n\t\tfor i in 0..$y-1\n\t\t\tline = gets\n\t\t\tfor j in 0..$x-1\n\t\t\t\ttmp = -1\n\t\t\t\tif line[j] =~ /\\d/ then\n\t\t\t\t\ttmp = line[j].to_i() \n\t\t\t\tend\n\t\t\t\t$bord[i][j] = tmp\n\t\t\tend\n\t\tend\n\t\tprint calc()\n\t\tprint(\"\\n\")\n\tend\n}", "label": 0, "name1": "s709576716.java", "name2": "s033677438.rb"}, {"id": 538, "code1": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        try(Scanner scn = new Scanner(System.in)) {\n            int sum = scn.nextInt() + scn.nextInt() + scn.nextInt() + scn.nextInt();\n            System.out.println(sum / 60);\n            System.out.println(sum % 60);\n        }\n    }\n}", "code2": "while line = gets\n  n = line.chomp.to_i\n  break if n == 0\n\n  answer_p = 0\n  answer_d = -Float::INFINITY\n  n.times do\n    p, d1, d2 = gets.chomp.split.map(&:to_i)\n    d = d1 + d2\n    if answer_d < d\n      answer_p = p\n      answer_d = d\n    end\n  end\n\n  puts \"#{answer_p} #{answer_d}\"\nend", "label": 0, "name1": "s061388848.java", "name2": "s402976256.rb"}, {"id": 557, "code1": "import java.util.Scanner;\n\nclass Main\n{\n\tpublic static void main(String args[])\n\t{\n\t\tScanner sc = new Scanner(System.in).useDelimiter(\"[,\\n]\");\n\t\t\n\t\tint a = 0;\n\t\tint b = 0;\n\t\tint o = 0;\n\t\tint ab = 0;\n\t\t\n\t\twhile (sc.hasNext())\n\t\t{\n\t\t\tsc.nextInt();\n\t\t\tString str = sc.next();\n\t\t\tif (str.equals(\"A\"))\n\t\t\t{\n\t\t\t\ta++;\n\t\t\t}\n\t\t\telse if (str.equals(\"B\"))\n\t\t\t{\n\t\t\t\tb++;\n\t\t\t}\n\t\t\telse if (str.equals(\"O\"))\n\t\t\t{\n\t\t\t\to++;\n\t\t\t}\n\t\t\telse if (str.equals(\"AB\"))\n\t\t\t{\n\t\t\t\tab++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(a);\n\t\tSystem.out.println(b);\n\t\tSystem.out.println(ab);\n\t\tSystem.out.println(o);\n\t}\n}", "code2": "a, b, c = gets.chomp.split.map(&:to_i)\n\nrad_c = Float(c) / 180 * Math::PI\ns = 0.5 * a * b * Math.sin(rad_c)\nputs format(\"%.6f\", s)\n\nc = Math.sqrt(a * a + b * b - 2 * a * b * Math.cos(rad_c))\nputs format(\"%.6f\", a + b + c)\n\nh = 2 * s / a\nputs format(\"%.6f\", h)\n\n", "label": 0, "name1": "s541319729.java", "name2": "s761885510.rb"}, {"id": 282, "code1": "import java.io.BufferedReader;\n\nimport static java.util.Comparator.*;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.lang.reflect.Array;\nimport java.math.BigDecimal;\nimport java.util.AbstractMap;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class Main {\n\t\n//\tpublic static Set<String> mem = new HashSet<String>();\n//\tpublic static boolean[] mem_1 = new boolean[100];\n//\tpublic static boolean[] mem_2 = new boolean[100];\n//\tpublic static Set<Integer> mem = new TreeSet<Integer>();\n//\tpublic static Map<String, Integer> mem_1= new HashMap<String, Integer>();\n//\tpublic static Map<String, Integer> mem_2 = new HashMap<String, Integer>();\n\t\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        \n        Solver solver = new Solver();\n        solver.solve(1, in, out);\n        \n        out.close();\n    }\n    \n    // ======================================================================\n    static class Solver {\n    \t\n\t\tList<Pair<Integer, Integer>> lP = new ArrayList<Pair<Integer, Integer>>();\n\t\tList<Pair<Integer, Integer>> lAns = new ArrayList<Pair<Integer, Integer>>();\n\n    \tpublic void solve(int testNumber, MyInput in, PrintWriter out) {\n    \t\tlong ans = 0L;\n    \t\tint[] cnt = new int[4];\n    \t\tfor(int i=0; i < 6; i++) {\n        \t\tint a = in.nextInt();\n        \t\tcnt[a-1] += 1;\n        // \t\tout.println(\"[\" + a + \"]\");\n    \t\t}\n    \t\tboolean f = true;\n    \t\tfor(int i=0; i < 4; i++) {\n        // \t\tout.println(\"[\" + cnt[i] + \"]\");\n    \t\t\tif(cnt[i] >= 3)\t\tf = false;\n    \t\t}\n    \t\tif(f)   \t\tout.println(\"YES\");\n    \t\telse            out.println(\"NO\");\n        }\n    }\n    // ======================================================================\n    static class Pair<K, V> extends AbstractMap.SimpleEntry<K, V> {\n        /** serialVersionUID. */\n        private static final long serialVersionUID = 6411527075103472113L;\n\n        public Pair(final K key, final V value) {\n            super(key, value);\n        }\n        public String getString() {\n            return \"[\" + getKey() + \"] [\" + getValue() + \"]\";\n        }\n     }    \n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n \n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n \n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n \n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n \n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n \n        public String nextString() {\n        \tString ret = new String(nextDChar()).trim();\n            return ret;\n        }\n \n        public char[] nextDChar() {\n            int len = 0;\n            len = reads(len, isSpace);\n            char[] ret = new char[len + 1];\n            for (int i=0; i < len; i++)\t\tret[i] = str[i];\n            ret[len] = 0x00;\n            return ret;\n        }\n \n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n \n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n \n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n    }\n}\n", "code2": "a = Array.new(3)\nb = Array.new(3)\n\ncounts = Hash.new(0)\n3.times do|i|\n  a, b = gets.split.map(&:to_i)\n  counts[a.to_s] += 1\n  counts[b.to_s] += 1\nend\n\nputs counts.sort { |(k1, v1), (k2, v2)| v1<=>v2 }.map { |k, v| v } == [1, 1, 2, 2] ? 'YES' : 'NO'\n", "label": 1, "name1": "s961270278.java", "name2": "s056579310.rb"}, {"id": 592, "code1": "import java.io.IOException;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\nimport java.io.PrintWriter;\n\n@SuppressWarnings(\"unchecked\")\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        final String s;\n\n        try (\n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(System.in))) {\n            s = reader.readLine();\n        }\n\n        PrintWriter out = new PrintWriter(System.out);\n\n        final String[] sl = s.split(\" \");\n        int A = Integer.parseInt(sl[0]);\n        int B = Integer.parseInt(sl[1]);\n        int C = Integer.parseInt(sl[2]);\n\n        int max = Math.max(A, Math.max(B, C));\n\n        int sum = 3 * max - A - B - C;\n\n        int ans;\n\n        if (sum % 2 == 0) ans = sum / 2;\n        else ans = (int)Math.ceil((double)sum / 2) + 1;\n\n        out.println(ans);\n\n        out.flush();\n    }\n}\n", "code2": "objects = []\n\nmax_n = 123456*2\n\nsosu_arr = []\nsosu_set = {}\n\nmax_n.times.each do |ii|\n  i = ii + 1\n  next if i == 1\n  next if sosu_set.key?(i)\n  sosu_arr.push i\n  sosu_set[i] = true\n  (max_n/i).to_i.times.each do |j|\n    next if j == 0\n    sosu_set[i * (j+1)] = false\n  end\nend\n\nlines = []\nwhile num = gets\n  num = num.to_i\n  break if num == 0\n  if num == 1\n    puts 1\n    next\n  end\n  sum = 0\n  ((num+1)..(num*2)).each do |i|\n    sum = sum + 1 if sosu_set[i]\n  end\n  puts sum\nend", "label": 0, "name1": "s588342457.java", "name2": "s102129990.rb"}, {"id": 872, "code1": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint a = sc.nextInt();\n\t\tint b = sc.nextInt();\n\t\tint c = sc.nextInt();\n\t\tint x = sc.nextInt();\n\t\tint y = sc.nextInt();\n\t\tlong ans = 0;\n\t\tint tmp = Math.min(x, y);\n\t\tx -= tmp;\n\t\ty -= tmp;\n\t\tif(a + b < 2 * c) {\n\t\t\tans += tmp * (a + b);\n\t\t} else {\n\t\t\tans += tmp * 2 * c;\n\t\t}\n\t\tif(x % 2 == 1) {\n\t\t\tif(a < 2 * c) {\n\t\t\t\tans += a;\n\t\t\t} else {\n\t\t\t\tans += 2 * c;\n\t\t\t}\n\t\t\tx--;\n\t\t}\n\t\tif(a < 2 * c) {\n\t\t\tans += a * x;\n\t\t} else {\n\t\t\tans += 2 * c * x;\n\t\t}\n\t\tif(y % 2 == 1) {\n\t\t\tif(b < 2 * c) {\n\t\t\t\tans += b;\n\t\t\t} else {\n\t\t\t\tans += 2 * c;\n\t\t\t}\n\t\t\ty--;\n\t\t}\n\t\tif(b < 2 * c) {\n\t\t\tans += b * y;\n\t\t} else {\n\t\t\tans += 2 * c * y;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n}\n", "code2": "a,b=gets.split\nc=a==?H\nc=!c if b==?D\nputs c ? ?H : ?D", "label": 0, "name1": "s186641609.java", "name2": "s287731219.rb"}, {"id": 578, "code1": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\t\n\tpublic static void main(String[] args) {\n\t\tFastScanner scanner=new FastScanner();\n\t\tint n=scanner.nextInt(),k=scanner.nextInt();\n\t\tint a[]=scanner.readArray(n);\n\t\t\n\t\tboolean dp[]=new boolean[k+1];\n//\t\tArrays.fill(dp, true);\n//\t\tdp[0]=false;\n\t\t\n\t\tfor(int stones=0;stones<=k;stones++) {\n\t\t\tfor(int j:a)\n\t\t\t\tif(j<=stones&&!dp[stones-j]) dp[stones]=true;\n\t\t}\n\t\tif(dp[k]) System.out.println(\"First\");\n\t\telse System.out.println(\"Second\");\n\t\n\t\t\n\t\t\n\n\t}\n\tstatic class FastScanner{\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\t\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tdouble nextDoubel() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tint [] readArray(int n) {\n\t\t\tint a[]=new int[n];\n\t\t\tfor(int i=0;i<n;i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\t\n\t}\n\n}\n\n", "code2": "d=*1..gets.to_i\ngets.bytes{|c|x=0\nN=d.pop\nd.map!{x+=-c%3*N+_1*(1-c%3)\nx%=10**9+7}}\np N", "label": 0, "name1": "s041813111.java", "name2": "s937516961.rb"}, {"id": 349, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tint N,M;\n\tboolean[] first,second;\n\n\tpublic void solve() {\n\n\t\tN = nextInt();\n\t\tM = nextInt();\n\n\t\tfirst = new boolean[N];\n\t\tsecond = new boolean[N];\n\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tint a = nextInt()-1;\n\t\t\tint b = nextInt()-1;\n\n\t\t\tif(a == 0){\n\t\t\t\tfirst[b] = true;\n\t\t\t}\n\n\t\t\tif(b == N-1){\n\t\t\t\tsecond[a] = true;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1;i < N - 1;i++){\n\t\t\tif(first[i] && second[i]){\n\t\t\t\tout.println(\"POSSIBLE\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tout.println(\"IMPOSSIBLE\");\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}", "code2": "nm = gets.split \" \"\nN = nm[0].to_i\nM = nm[1].to_i\nrelays = []\n\nM.times do\n\ts_g = gets.split \" \"\n\tstart = s_g[0].to_i\n\tgoal = s_g[1].to_i\n\tif start == 1\n\t\trelays << goal\n\tend\n\tif goal == N\n\t\trelays << start\n\tend\nend\n\nif relays.length != relays.uniq.length\n\tputs \"POSSIBLE\"\nelse\n\tputs \"IMPOSSIBLE\"\nend", "label": 1, "name1": "s651303084.java", "name2": "s550018243.rb"}, {"id": 231, "code1": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-9;\n\n\tint n;\n\tint start, goal, ttl;\n\tLinkedList<Integer>[] graph;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tn = sc.nextInt();\n\t\tgraph = new LinkedList[n];\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint u = sc.nextInt() - 1;// \u0083\u008b\u0081[\u0083^\u0094\u00d4\u008d\u0086\n\t\t\tint m = sc.nextInt();\n\t\t\tgraph[u] = new LinkedList<Integer>();\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint v = sc.nextInt() - 1;\n\t\t\t\tgraph[u].add(v);\n\t\t\t}\n\t\t}\n\t\tint p = sc.nextInt();\n\t\tfor (int i = 0; i < p; i++) {\n\t\t\tstart = sc.nextInt() - 1;\n\t\t\tgoal = sc.nextInt() - 1;\n\t\t\tttl = sc.nextInt();\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve() {\n\t\tLinkedList<Integer> que = new LinkedList<Integer>();\n\t\tboolean[] visited = new boolean[n];\n\t\tint[] d = new int[n];\n\t\tArrays.fill(d, INF);\n\t\tque.offer(start);\n\t\td[start] = 1;\n\t\tvisited[start] = true;\n\t\tfor (; !que.isEmpty();) {\n\t\t\tint u = que.poll();\n\t\t\tfor (int v : graph[u]) {\n\t\t\t\tif (!visited[v]) {\n\t\t\t\t\tque.offer(v);\n\t\t\t\t\td[v] = d[u] + 1;\n\t\t\t\t\tvisited[v] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[goal] <= ttl) {\n\t\t\tprintln(\"\" + d[goal]);\n\t\t} else {\n\t\t\tprintln(\"NA\");\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s) {\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s) {\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}", "code2": "Infinity = 1000000\n\ndef dijkstra graph, s\n  n = graph.size\n  dist = Array.new(n, Infinity)\n  visited = Array.new(n, false)\n  dist[s] = 0\n  loop do\n    min = -1\n    sd = Infinity\n    n.times do |i|\n      if (! visited[i]) && dist[i] < sd\n        min = i\n        sd = dist[i]\n      end\n    end\n    break if min == -1\n    visited[min] = true\n    graph[min].each do |node|\n      newLen = dist[min] + 1\n      if(newLen < dist[node])\n        dist[node] = newLen\n      end\n    end\n  end\n  dist\nend\n\n#\u30cd\u30c3\u30c8\u30ef\u30fc\u30af\u53d6\u5f97\nn = $stdin.gets.to_i\ngraph = Array.new(n).map{Array.new}\nn.times do\n  input = $stdin.gets.split(\" \").map(&:to_i)\n  input[1].times do |t|\n    graph[input[0] - 1] << input[t + 2] - 1\n  end\nend\n\n#\u30d1\u30b1\u30c3\u30c8\u51e6\u7406\n$stdin.gets.to_i.times do\n  s, d, v = $stdin.gets.split(\" \").map(&:to_i)\n  dist = dijkstra(graph, s - 1)\n  if dist[d - 1] + 1 <= v\n    puts dist[d - 1] + 1\n  else\n    puts \"NA\"\n  end\nend", "label": 1, "name1": "s019260377.java", "name2": "s718030625.rb"}, {"id": 380, "code1": "// -*- coding: utf-8 -*-\n//import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream;\n    if (args.length > 0 && args[0].equals(\"devTesting\")) {\n      try {\n        inputStream = new FileInputStream(args[1]);\n      } catch(FileNotFoundException e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      inputStream = System.in;\n    }\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskC solver = new TaskC();\n    int testCase = 1;\n    solver.solve(1, in, out);\n    out.close();\n  }\n  \n  static class TaskC {\n    long h, w;\n    \n    void solve(int testNumber, InputReader in, PrintWriter out) {\n      h = in.nextInt();\n      w = in.nextInt();\n      char[][] superpost = new char[(int) h][];\n      for (int i = 0; i < h; ++i)\n        superpost[i] = in.next().toCharArray();\n      for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j)\n          if (i % 2 == 0 && j < w - 1 || j == 0 || superpost[i][j] == '#')\n            out.print('#');\n          else\n            out.print('.');\n        out.println();\n      }\n      out.println();\n      for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j)\n          if (i % 2 == 1 && j > 0 || j == w - 1 || superpost[i][j] == '#')\n            out.print('#');\n          else\n            out.print('.');\n          out.println();\n      }\n    }\n    \n  }\n      \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public boolean hasInput() {\n      try {\n        if (tokenizer != null && tokenizer.hasMoreTokens()) {\n          return true;\n        }\n        reader.mark(1);\n        int ch = reader.read();\n        if (ch != -1) {\n          reader.reset();\n          return true;\n        }\n        return false;\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n  }\n}\n", "code2": "H, W = gets.split.map(&:to_i)\nas = []\nans1 = []\nans2 = []\nH.times do |i|\n    as[i] = gets.chomp\n    ans1[i] = as[i].dup\n    ans2[i] = as[i].dup\nend\n\nH.times do |i|\n    if i%2 == 0\n        ans1[i] = '#'*(W-1) + '.'\n    else\n        ans2[i] = '.' + '#'*(W-1)\n    end\n    ans1[i][0] = '#'\n    ans2[i][-1] = '#'\nend\n\nputs ans1\nputs\nputs ans2\n\n# result = Array.new(H){'.'*W}\n# H.times do |i|\n#     W.times do |j|\n#         result[i][j] = '#' if ans1[i][j] == '#' && ans2[i][j] == '#'\n#     end\n# end\n# puts result", "label": 1, "name1": "s133216279.java", "name2": "s793571533.rb"}, {"id": 585, "code1": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable {\n\tFastReader scn;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\n\tvoid solve() {\n\t\tint n = scn.nextInt(), mod = (int) 1e9 + 7;\n\t\tchar[] cmp = scn.next().toCharArray();\n\t\t\n\t\tint[][] dp = new int[n + 1][n + 1];\n\t\tdp[1][1] = 1;\n\t\t\n\t\tfor(int len = 2; len <= n; len++) {\n\t\t\tint[] pref = new int[n + 1];\n\t\t\tfor(int i = 1; i <= n; i++) {\n\t\t\t\tpref[i] = (pref[i - 1] + dp[len - 1][i]) % mod;\n\t\t\t}\n\t\t\tfor(int curr = 1; curr <= len; curr++) {\n\t\t\t\tint L, R;\n\t\t\t\tif(cmp[len - 2] == '<') {\n\t\t\t\t\tL = 1;\n\t\t\t\t\tR = curr - 1;\n\t\t\t\t} else {\n\t\t\t\t\tL = curr;\n\t\t\t\t\tR = n;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(L <= R) {\n\t\t\t\t\tdp[len][curr] += (pref[R] - pref[L - 1]);\n\t\t\t\t\tif(dp[len][curr] >= mod) {\n\t\t\t\t\t\tdp[len][curr] -= mod;\n\t\t\t\t\t} else if(dp[len][curr] < 0) {\n\t\t\t\t\t\tdp[len][curr] += mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor(int curr = 1; curr <= n; curr++) {\n\t\t\tans += dp[n][curr];\n\t\t\tif(ans >= mod) {\n\t\t\t\tans -= mod;\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t}\n\n\tpublic void run() {\n\t\tlong time = System.currentTimeMillis();\n\t\tboolean oj = true;\n\t\tout = new PrintWriter(System.out);\n\t\tscn = new FastReader(oj);\n\t\tsolve();\n\t\tout.flush();\n\t\tif (!oj) {\n\t\t\tSystem.out.println(Arrays.deepToString(new Object[] { System.currentTimeMillis() - time + \" ms\" }));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"Main\", 1 << 26).start();\n\t}\n\n\tclass FastReader {\n\t\tInputStream is;\n\n\t\tpublic FastReader(boolean onlineJudge) {\n\t\t\tis = onlineJudge ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\t}\n\n\t\tpublic FastReader() {\n\t\t\tis = System.in;\n\t\t}\n\n\t\tbyte[] inbuf = new byte[1024];\n\t\tpublic int lenbuf = 0, ptrbuf = 0;\n\n\t\tint readByte() {\n\t\t\tif (lenbuf == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (ptrbuf >= lenbuf) {\n\t\t\t\tptrbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn inbuf[ptrbuf++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tint skip() {\n\t\t\tint b;\n\t\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t\t;\n\t\t\treturn b;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tchar nextChar() {\n\t\t\treturn (char) skip();\n\t\t}\n\n\t\tString next() {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile ((!isSpaceChar(b) || b == ' ')) { // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tchar[] next(int n) {\n\t\t\tchar[] buf = new char[n];\n\t\t\tint b = skip(), p = 0;\n\t\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t\t}\n\n\t\tint nextInt() {\n\t\t\tint num = 0, b;\n\t\t\tboolean minus = false;\n\t\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\tlong num = 0;\n\t\t\tint b;\n\t\t\tboolean minus = false;\n\t\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tchar[][] nextMatrix(int n, int m) {\n\t\t\tchar[][] map = new char[n][];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next(m);\n\t\t\treturn map;\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tint[][] IndIntArray(int n) {\n\t\t\tint[][] a = new int[n][];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = new int[] { nextInt(), i };\n\t\t\treturn a;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tint[][] next2DInt(int n, int m) {\n\t\t\tint[][] arr = new int[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[][] next2DLong(int n, int m) {\n\t\t\tlong[][] arr = new long[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextLongArray(m);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] shuffle(int[] arr) {\n\t\t\tRandom r = new Random();\n\t\t\tfor (int i = 1, j; i < arr.length; i++) {\n\t\t\t\tj = r.nextInt(i);\n\t\t\t\tint c = arr[i];\n\t\t\t\tarr[i] = arr[j];\n\t\t\t\tarr[j] = c;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] shuffle(long[] arr) {\n\t\t\tRandom r = new Random();\n\t\t\tfor (int i = 1, j; i < arr.length; i++) {\n\t\t\t\tj = r.nextInt(i);\n\t\t\t\tlong c = arr[i];\n\t\t\t\tarr[i] = arr[j];\n\t\t\t\tarr[j] = c;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] uniq(int[] arr) {\n\t\t\tarr = scn.shuffle(arr);\n\t\t\tArrays.sort(arr);\n\t\t\tint[] rv = new int[arr.length];\n\t\t\tint pos = 0;\n\t\t\trv[pos++] = arr[0];\n\t\t\tfor (int i = 1; i < arr.length; i++) {\n\t\t\t\tif (arr[i] != arr[i - 1]) {\n\t\t\t\t\trv[pos++] = arr[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Arrays.copyOf(rv, pos);\n\t\t}\n\n\t\tlong[] uniq(long[] arr) {\n\t\t\tarr = scn.shuffle(arr);\n\t\t\tArrays.sort(arr);\n\t\t\tlong[] rv = new long[arr.length];\n\t\t\tint pos = 0;\n\t\t\trv[pos++] = arr[0];\n\t\t\tfor (int i = 1; i < arr.length; i++) {\n\t\t\t\tif (arr[i] != arr[i - 1]) {\n\t\t\t\t\trv[pos++] = arr[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Arrays.copyOf(rv, pos);\n\t\t}\n\n\t\tint[] reverse(int[] arr) {\n\t\t\tint l = 0, r = arr.length - 1;\n\t\t\twhile (l < r) {\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tarr[r] = arr[l] ^ arr[r];\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tl++;\n\t\t\t\tr--;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] reverse(long[] arr) {\n\t\t\tint l = 0, r = arr.length - 1;\n\t\t\twhile (l < r) {\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tarr[r] = arr[l] ^ arr[r];\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tl++;\n\t\t\t\tr--;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] compress(int[] arr) {\n\t\t\tint n = arr.length;\n\t\t\tint[] rv = Arrays.copyOf(arr, n);\n\t\t\trv = uniq(rv);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = Arrays.binarySearch(rv, arr[i]);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] compress(long[] arr) {\n\t\t\tint n = arr.length;\n\t\t\tlong[] rv = Arrays.copyOf(arr, n);\n\t\t\trv = uniq(rv);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = Arrays.binarySearch(rv, arr[i]);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\t}\n}", "code2": "inputs = gets.chomp.split(\" \").map(&:to_i).sort\nans = 0\nis_all = inputs[0]\n\nuntil inputs.all?{|v| v == is_all} do\n    if inputs[0] + 2 <= inputs[2]\n        inputs[0] += 2\n    else\n        inputs[0] += 1\n        inputs[1] += 1\n    end\n    inputs.sort!\n    is_all = inputs[0]\n    ans += 1\nend\n\nputs ans", "label": 0, "name1": "s976963924.java", "name2": "s407672581.rb"}, {"id": 582, "code1": "import java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\n\n \nclass Main implements Runnable {\n  // static Scanner in;\n  static FastReader in;\n  static PrintWriter out;\n  static int[][] dirs8 = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1, 1}, {-1, -1}, {-1, 1}, {1, -1}};\n  static int[][] dirs = {{0, -1}, {1, 0}, {0, +1}, {-1, 0}};\n \n  static int[][] E;\n  // static List<int[]>[] adj;\n  static List<Integer>[] adj;\n  static int[] vis;\n \n  static long INFL = (long) 1e15 + 7;\n  static int INF = (int) 1e9 + 7;\n  static int mod = 998244353;\n  \n  static int T, n, m, k, count, cur, w;\n  static boolean flag;\n  static int[] a, b;\n  static int[][] map;\n\n  static int[] par;\n  static boolean[] dp;\n\n  static void solve() throws Exception {\n    n = in.nextInt();\n    k = in.nextInt();\n    a = new int[n]; \n    for (int i = 0; i < n; i++) {a[i] = in.nextInt();}\n    dp = new boolean[k + 1];\n    // dp[i]: win(true) or loss(false) if \"I\" have i stones left and I am to play this round\n    dp[0] = false;\n    for (int i = 1; i <= k; i++) {\n      for (int x : a) {\n        if (x > i) {break;}\n        if (!dp[i - x]) {dp[i] = true; break;}\n      }\n    }\n    out.println(dp[k] ? \"First\" : \"Second\");\n  }\n\n\n  public static void main(String[] args) throws Exception {\n \n    // in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n    in = new FastReader();\n    out = new PrintWriter(System.out);\n \n    // int numOfTests = in.nextInt();\n    // for (int caseNum = 1; caseNum <= numOfTests; caseNum++) {\n    //   // Thread t = new Thread(null, new Main(), \"Main\", 1 << 28);\n    //   // t.start();\n    //   // t.join();\n    //   solve();\n    // }\n \n    // // Thread t = new Thread(null, new Main(), \"Main\", 1 << 28);\n    // // t.start();\n    // // t.join();\n    solve();\n \n    out.flush();\n    out.close();\n  }\n \n  @Override\n  public void run() {\n    try {\n      solve();\n    } catch (Exception e) {\n      e.printStackTrace(); \n    }\n  }\n \n  static class FastReader {\n    public BufferedReader br; \n    StringTokenizer st; \n    public FastReader() {br = new BufferedReader(new InputStreamReader(System.in));} \n    String next() { \n      while (st == null || !st.hasMoreElements()) { \n          try {st = new StringTokenizer(br.readLine());} \n          catch (IOException e) {e.printStackTrace();} \n      } \n      return st.nextToken(); \n    } \n    int nextInt() {return Integer.parseInt(next());} \n    long nextLong() {return Long.parseLong(next());} \n    double nextDouble() {return Double.parseDouble(next());} \n    String nextLine() {\n      String str = \"\"; \n        try {str = br.readLine();} \n        catch (IOException e) {e.printStackTrace();} \n        return str; \n    }\n  }\n\n  static void as(boolean result) throws Exception {\n    if (!result) {\n      throw new Exception();\n    }\n  }\n\n  static int modInverse(int a, int m) { \n    int m0 = m; \n    int y = 0, x = 1; \n    if (m == 1) {return 0;} \n    while (a > 1) { \n      // q is quotient \n      int q = a / m; \n      int t = m; \n      // m is remainder now, process \n      // same as Euclid's algo \n      m = a % m; \n      a = t; \n      t = y; \n      // Update x and y \n      y = x - q * y; \n      x = t; \n    } \n    // Make x positive \n    if (x < 0) \n      x += m0; \n    return x; \n  } \n} \n", "code2": "inputs = gets.chomp.split(\" \").map(&:to_i).sort\nans = 0\nis_all = inputs[0]\n\nuntil inputs.all?{|v| v == is_all} do\n    if inputs[0] + 2 <= inputs[2]\n        inputs[0] += 2\n    else\n        inputs[0] += 1\n        inputs[1] += 1\n    end\n    inputs.sort!\n    is_all = inputs[0]\n    ans += 1\nend\n\nputs ans", "label": 0, "name1": "s772358717.java", "name2": "s407672581.rb"}, {"id": 978, "code1": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int A = sc.nextInt();\n        int B = sc.nextInt();\n        int [] h = new int [N];\n        for(int i=0; i<N; i++){\n            h[i] = sc.nextInt();\n        }\n        Arrays.sort(h);\n        long min = 0;\n        long max = 1000000000;\n        long mid = 0;\n        while(max-min>1){\n            mid = max-(max-min)/2;\n            if(judge(mid,h,N,B,A-B)){\n                max = mid;\n            }else{\n                min = mid;\n            }\n        }\n        if(!judge(mid,h,N,B,A-B))mid++;\n        System.out.println(mid);\n    }\n    static boolean judge(long mid, int[]h, int N, int B, double C){\n        long Z=0;\n        for(int i=N-1; i>=0; i--){\n            long tmp = h[i]-mid*B;\n            if(tmp>0){\n                Z+=((long)(Math.ceil(tmp/C)));\n            }else{\n                break;\n            }\n        }\n        if(Z>mid)return false;\n        return true;\n    }\n}\n", "code2": "n,*a=`dd`.split.map &:to_i;a.sort!;r=0;b=[0]+n.times.map{|j|a[j]*(-1)**j%24};s=24;n.times{|j|(j+1..n).each{|k|s=[s,(b[j]-b[k])%24,(b[k]-b[j])%24].min}};r=[r,s].max;p r", "label": 0, "name1": "s057072996.java", "name2": "s643709986.rb"}, {"id": 643, "code1": "import java.util.*;\npublic class Main{\n    public static void main(String args[]) {\n        Scanner cin = new Scanner(System.in);\n        while(cin.hasNext()){\n        \tint n = cin.nextInt();\n        \tint[][] vote = readMatrix(cin,n,2);\n        \tSystem.out.println(getNum(vote,n));\n        }\n    }\n    public static long getNum(int[][] vote, int n){\n    \tlong[] result={vote[0][0],vote[0][1]};\n    \tlong result1;\n    \tfor(int i=1;i<n;i++){\n    \t\tresult1 = result[1];\n    \t\tif(result[0]>vote[i][0]){\n    \t\t\tif(result[0]%vote[i][0]!=0) result[0] += vote[i][0]-result[0]%vote[i][0];\n    \t\t}else{result[0]=vote[i][0];}\n    \t\tresult[1] = result[0]/vote[i][0]*vote[i][1];\n    \t\tif(result1>result[1]){\n    \t\t\tresult[1] = result1;\n    \t\t\tif(result[1]%vote[i][1]!=0) result[1] += vote[i][1]-result[1]%vote[i][1];\n    \t\t\t result[0] = result[1]/vote[i][1]*vote[i][0];\n    \t\t}\n    \t}\n    \treturn result[0]+result[1];\n    }\n    public static int[][] readMatrix(Scanner in,int n,int m){\n    \tint[][] mtx = new int[n][m];\n    \tfor(int i=0;i<n;i++){\n    \t\tfor(int j=0;j<m;j++){\n    \t\t\tmtx[i][j] = in.nextInt();\n    \t\t}\n    \t}\n    \treturn mtx;\n    }\n    \n}", "code2": "def g;gets.split.map &:to_i;end\nr=1..n=g[0]\nw=[0]+r.map{[0]+[1e9]*n}\nr.map{f,_,*t=g;t.map{|i|w[f][i]=1}}\nr.each{|k|r.each{|i|r.each{|j|(a=(b=w[i])[k]+w[k][j])<b[j]&&b[j]=a}}}\ng[0].times{s,d,v=g;puts v<(c=w[s][d]+1)?:NA:c}", "label": 0, "name1": "s502019413.java", "name2": "s754069394.rb"}, {"id": 527, "code1": "import java.util.Scanner;\n \npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0) break;\n            int[] s = new int[n];\n            double e = 0.0, v = 0.0;\n            for (int i = 0; i < n; i++) {\n                s[i] = sc.nextInt();\n                e += s[i];\n                v += s[i] * s[i];\n            }\n            e /= n;\n            v = v / n - e * e;\n            System.out.println(Math.sqrt(v));\n        }\n    }\n}\n", "code2": "ss = 0\n4.times do\n  ss += gets.strip.to_i\nend\n \nputs ss / 60\nputs ss % 60", "label": 0, "name1": "s749350396.java", "name2": "s733866069.rb"}, {"id": 884, "code1": "/*\n    Arnab Chanda \n*/\n\n// All imports here\n\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n// Template code starts here //\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Debugger debug = new Debugger(out);\n        Objectify objectify = new Objectify(debug);\n        Task solver = new Task();\n        int test = 1;\n        while(test-->0){\n            solver.solve(1, in, out, debug, objectify);\n        }\n\t\tout.close();\n\t}\n}\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n \n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n        tokenizer = null;\n    }\n \n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n \n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    public Double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    public float nextFloat() {\n        return Float.parseFloat(next());\n    }\n \n}\n\nclass Debugger{\n    PrintWriter out;\n\n    Debugger(PrintWriter out){    \n        this.out = out;\n    }\n\n    public <T> void printList(List<T> arrayList){\n        for( Object ob: arrayList){\n            out.print(ob+\" \");\n        }\n        out.println();\n    }\n\n    public <T> void printSet(Set<T> set){\n        for(Object ob: set){\n            out.print(ob+\" \");\n        }\n        out.println();\n    }\n\n    public <T> void printMap(Map<?,?> map){\n        for(Object ob: map.keySet()){\n            System.out.println(ob+\" : \"+map.get(ob));\n        }\n    }\n}\n\nclass Objectify{\n    \n    Debugger debug;\n\n    Objectify(Debugger ob){ debug = ob; }\n\n    public void printArr(int[] arr){ debug.printList(Arrays.stream(arr).boxed().collect(Collectors.toList())); }\n    public void printArr(double[] arr){ debug.printList(Arrays.stream(arr).boxed().collect(Collectors.toList())); }\n    public void printArr(long[] arr){ debug.printList(Arrays.stream(arr).boxed().collect(Collectors.toList())); }\n    public void printArr(char[] arr){ debug.printList( String.valueOf(arr).chars().mapToObj(c -> (char) c).collect(Collectors.toList())); }\n    public void printArr(String[] arr){ debug.printList(Arrays.asList(arr)); }\n\n    public void printMatrix(int[][] arr){ for(int a[]:arr) printArr(a); }\n    public void printMatrix(double[][] arr){ for(double a[]:arr) printArr(a); }\n    public void printMatrix(long[][] arr){ for(long a[]:arr) printArr(a); }\n    public void printMatrix(char[][] arr){ for(char a[]:arr) printArr(a); }\n    public void printMatrix(String[][] arr){ for(String a[]:arr) printArr(a); }\n\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n// Template code ends here\n\n\nclass Task {\n\n    final long MOD = (int)Math.pow(10,9)+7;\n\n    public void solve(int testNumber, InputReader sc, PrintWriter out, Debugger debug, Objectify objectify) {\n        \n        // write your code here\n        int k = sc.nextInt();\n\n        int A = sc.nextInt();\n        int B = sc.nextInt();\n\n        for(int i = A; i <= B; ++i){\n            if (i%k == 0){\n                out.println(\"OK\");\n                return;\n                // break;\n            }\n        }\n\n        out.println(\"NG\");\n    }\n}", "code2": "1000.times {\n\tputs \"Hello World\"\n}", "label": 0, "name1": "s434750672.java", "name2": "s880313677.rb"}, {"id": 782, "code1": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tString s;\n\t\t\tString[][] a = new String[n][];\n\t\t\tint p;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\ts = sc.next().replaceAll(\":\", \" \").replaceAll(\",\", \" \");\n\t\t\t\ta[i] = s.split(\" \");\n\t\t\t\tp = a[i].length-1;\n\t\t\t\ta[i][p] = a[i][p].substring(0,a[i][p].length()-1);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<String> list = new ArrayList<String>();\n\t\t\tfor(int i=1;i<a[0].length;i++) list.add(a[0][i]);\n\t\t\t\n\t\t\tboolean flag;\n\t\t\twhile(true){\n\t\t\t\tflag = false;\n\t\t\t\tfor(int i=1;i<n;i++){\n\t\t\t\t\tif(list.contains(a[i][0])==true){\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tlist.remove(list.indexOf(a[i][0]));\n\t\t\t\t\t\tfor(int j=1;j<a[i].length;j++){\n\t\t\t\t\t\t\tif(list.contains(a[i][j])==false) list.add(a[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag==false) break;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(list.size());\n\t\t}\t\n\t}\t\n}", "code2": "class UnionFind\n  def initialize(size)\n    @parent = (0...size).to_a\n    @rank = Array.new(size, 0)\n  end\n\n  def find(x)\n    return x if @parent[x] == x\n    return (@parent[x] = find(@parent[x]))\n  end\n\n  def unite(x, y)\n    x, y = find(x), find(y)\n    return if x == y\n    if @rank[x] < @rank[y]\n      @parent[x] = y\n    else\n      @parent[y] = x\n      @rank[x] += 1 if @rank[x] == @rank[y]\n    end\n  end\n\n  def same(x, y)\n    find(x) == find(y)\n  end\nend\n\nn, k, l = gets.split.map(&:to_i)\nroad = UnionFind.new(n)\nrail = UnionFind.new(n)\nk.times do\n  x, y = gets.split.map { |c| c.to_i - 1 }\n  road.unite(x, y)\nend\nl.times do\n  x, y = gets.split.map { |c| c.to_i - 1 }\n  rail.unite(x, y)\nend\nroad = n.times.map { |i| road.find(i) }\nrail = n.times.map { |i| rail.find(i) }\ninter = n.times.map { |i| road[i] + n * rail[i] }\nh = {}\ninter.each { |x| h[x] ||= 0; h[x] += 1 }\ninter.each { |x| puts h[x] }\n", "label": 0, "name1": "s663814901.java", "name2": "s716688657.rb"}, {"id": 112, "code1": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n    \tScanner sc = new Scanner(System.in);\n      \tint A,B,C;\n      \tA = sc.nextInt();\n      \tB = sc.nextInt();\n      \tC = sc.nextInt();\n      \tif ((A < C && C < B) || (B < C && C < A)) {\n            \tSystem.out.print(\"Yes\");\n        }  else {\n        \tSystem.out.print(\"No\");\n        }   \n    }\n}", "code2": "# frozen_string_literal: true\n\na, b, c = gets.split.map(&:to_i)\n\nif a < c && c < b || b < c && c < a\n  puts :Yes\nelse\n  puts :No\nend", "label": 1, "name1": "s403728510.java", "name2": "s741716266.rb"}, {"id": 990, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] d = in.nextIntArray(n);\n            int ans = 0;\n            LOOP:\n            for (int i = 24; i >= 0; i--) {\n                boolean[] vis = new boolean[n];\n                int[] time = new int[n + 1];\n                for (int j = 0; j < n; j++) {\n                    int idx = -1, t = 1 << 29;\n                    for (int k = 0; k < n; k++) {\n                        for (int r = 0; r < 2; r++) {\n                            int cur = r == 0 ? d[k] : 24 - d[k];\n                            if (!vis[k] && cur >= time[j] + i && (idx == -1 || cur < t)) {\n                                idx = k;\n                                t = cur;\n                                break;\n                            }\n                        }\n                    }\n                    if (idx == -1) continue LOOP;\n                    vis[idx] = true;\n                    time[j + 1] = t;\n                }\n                if ((24 - time[n]) % 24 >= i) {\n                    ans = i;\n                    break;\n                }\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        public int[] nextIntArray(final int n) {\n            final int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt();\n            }\n            return res;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n", "code2": "loop do\n  t = gets.to_i\n  break if t==0\n  total=0\n  gets.to_i.times do\n    s,f = gets.split.map(&:to_i)\n    total += s>f ? (24-s)+f : f-s\n  end\n  puts total>=t ? \"OK\" : t-total\nend", "label": 0, "name1": "s643732585.java", "name2": "s703099751.rb"}, {"id": 523, "code1": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // Your code here!\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long a = sc.nextLong();\n        long b = sc.nextLong();\n        long[] array = new long[n];\n        for (int i = 0; i < n; i++) {\n            array[i] = sc.nextLong();\n        }\n        \n        long ans = 0;\n        for (int i = 1; i < n; i++) {\n            long dis = array[i] - array[i-1];\n            if (dis * a < b) {\n                ans += dis * a;\n            } else {\n                ans += b;\n            }\n        }\n        \n        System.out.println(ans);\n    }\n}", "code2": "def main(argv)\n  n = gets.chomp.to_i\n  a = gets.chomp.split(' ').map(&:to_i)\n\n  as = [[]]\n  prev = a[0]\n  n.times do |i|\n    if prev != a[i] then\n      as.push([a[i]])\n      prev = a[i]\n    else\n      as[as.size - 1].push(a[i])\n    end\n  end\n  \n  puts as.map{|a| a.size / 2}.reduce(:+).to_s\nend\n\nif self.to_s == 'main' then\n  main(ARGV)\nend", "label": 0, "name1": "s129000734.java", "name2": "s355654198.rb"}, {"id": 472, "code1": "import java.util.*;\n\npublic class Main{\n    public static void main(String args[]){\n        Scanner sc = new Scanner(System.in);\n        \n        int N = sc.nextInt();\n        int[] a = new int[N];\n        int[] b = new int[N];\n        for(int i = 0; i < N; i++)\n            a[i] = sc.nextInt();\n        for(int i = 0; i < N; i++)\n            b[i] = sc.nextInt();\n        sc.close();\n        long sum1 = 0;\n        long sum2 = 0;\n        for(int i = 0; i < N; i++){\n            if(a[i] > b[i]){\n                sum1 += (a[i]-b[i]);\n            } else {\n                sum2 += (b[i]-a[i])/2;\n            }\n        }\n        if(sum1 <= sum2)\n            System.out.println(\"Yes\");\n        else\n            System.out.println(\"No\");\n\n    }\n}", "code2": "#input of int(split by space)\ndef get_i()\n  return gets.chomp.split(\" \").map(&:to_i)\nend\n#input of float(split by space)\ndef get_f()\n  return gets.chomp.split(\" \").map(&:to_f)\nend\n#input of string(split by space)\ndef get()\n  return gets.chomp.split(\" \")\nend\n#input of string(split per one character)\ndef get_nsp()\n  return gets.chomp.split(\"\")\nend\n#yes or no decision\ndef yn_judge(bool,y=\"Yes\",n=\"No\")\n  return bool ? y : n \nend\n#create of array\ndef array(size1,init=nil,size2=-1)\n  if size2==-1\n    return Array.new(size1){init}\n  else\n    return Array.new(size2){Array.new(size1){init}}\n  end\nend\n\ndef max(a,b)\n    return a>b ? a : b\nend\n\ndef min(a,b)\n    return a>b ? b : a\nend\n\nINF=Float::INFINITY\n\nN=gets.to_i\na=get_i\nb=get_i\nadd=0\nN.times do|i|\n    if a[i]>b[i]\n        add+=a[i]-b[i]\n    end\nend\nN.times do|i|\n  if a[i]<b[i]\n      r=(b[i]-a[i])/2\n      add-=r\n  end\nend\nif add>0\n    puts \"No\"\nelse\n    puts \"Yes\"\nend", "label": 1, "name1": "s462003664.java", "name2": "s323281467.rb"}, {"id": 468, "code1": "import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long[] a = new long[n];\n        long[] b = new long[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextLong();\n        }\n        for (int i = 0; i < n; i++) {\n            b[i] = sc.nextLong();\n        }\n        long sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += b[i] - a[i];\n        }\n\n        long cnt = 0;\n        for (int i = 0; i < n; i++) {\n            if (a[i] < b[i]) {\n                cnt += (b[i] - a[i] + 1) / 2;\n            }\n        }\n        if (cnt <= sum) {\n            System.out.println(\"Yes\");\n            return;\n        }\n        System.out.println(\"No\");\n    }\n}\n", "code2": "n = gets.chomp.to_i\na_arr = gets.chomp.split(\" \").map(&:to_i)\nb_arr = gets.chomp.split(\" \").map(&:to_i)\n\nsum_a = 0\nsum_b = 0\ncount1 = 0\ncount2 = 0\n(0..n-1).each do |i|\n  sum_a += a_arr[i]\n  sum_b += b_arr[i]\n  if a_arr[i] > b_arr[i]\n    count1 += a_arr[i] - b_arr[i]\n  else\n    count2 += ((b_arr[i] - a_arr[i]) / 2.to_f).ceil\n  end\nend\nif sum_b - sum_a >= [count1, count2].max\n  puts \"Yes\"\nelse\n  puts \"No\"\nend\n", "label": 1, "name1": "s202753514.java", "name2": "s183505009.rb"}, {"id": 490, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    private static class FastScanner {\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        public String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        int array[] = new int[3], num = 0;\n        int count = 0;\n\n        while (count < 3) {\n            num = sc.nextInt();\n            if (0 < num && num < 10) {\n                array[count] = num;\n                count++;\n            }\n        }\n\n\n        for (int i = 0; i < 3; i++) {\n            for (int j = i + 1; j < 3; j++) {\n                if (array[i] == array[j]) {\n                    count = count - 1;\n                }\n            }\n        }\n        if (count == 2) {\n            System.out.print(\"Yes\");\n        } else {\n            System.out.print(\"No\");\n        }\n    }\n}\n", "code2": "a, b, c = gets.chomp.split.map(&:to_i)\n\nif a == b && b == c\n  puts 'No'\nelsif a != b && b != c && a != c\n  puts 'No'\nelse\n  puts 'Yes'\nend", "label": 1, "name1": "s136290389.java", "name2": "s684013173.rb"}, {"id": 430, "code1": "import java.util.*;\n\npublic class Main {\n\tpublic static HashMap<String,HashSet<String>> map;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tmap = new HashMap<String, HashSet<String>>();\n\t\t\tString first = null;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tString[] s = sc.next().split(\":\");\n\t\t\t\tif(i == 0) first = s[0];\n\t\t\t\ts[1] = s[1].replaceAll(\"\\\\.\", \"\");\n\t\t\t\tString[] ss = s[1].split(\",\");\n\t\t\t\tmap.put(s[0], new HashSet<String>());\n\t\t\t\tfor(String tmp : ss){\n\t\t\t\t\tmap.get(s[0]).add(tmp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(String si : map.keySet()){\n\t\t\t\tfor(String sj : map.keySet()){\n\t\t\t\t\tif(map.get(si).contains(sj)){\n\t\t\t\t\t\tmap.get(si).remove(sj);\n\t\t\t\t\t\tmap.get(si).addAll(map.get(sj));\n\t\t\t\t\t}\n\t\t\t\t\tif(map.get(sj).contains(si)){\n\t\t\t\t\t\tmap.get(sj).remove(si);\n\t\t\t\t\t\tmap.get(sj).addAll(map.get(si));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(map.get(first).size());\n\t\t}\n\t}\n/*\n\tpublic static HashSet<String> solve(String group){\n\t\tfor(String s : map.get(group)){\n\n\t\t}\n\n\t}\n\t*/\n}", "code2": "### classes\n\nclass Group\n  attr_accessor :id, :n, :reqs, :deps, :ms\n\n  def initialize(_id)\n    @id = _id; @n = 0; @reqs = []; @deps = []; @ms = []\n  end\nend\n\n### main\n\nloop do\n  n = gets.to_i\n  break if n == 0\n\n  gids = {}\n  gn = 0\n  mlists = []\n\n  n.times do\n    gname, mlist = gets.strip.delete('.').split(':')\n    gids[gname] = gn\n    mlists << mlist\n    gn += 1\n  end\n  #p gids\n  #p mlists\n\n  grps = (0...n).map{|id| Group.new(id)}\n  mids = {}\n  mn = 0\n\n  for id in (0...n)\n    grp = grps[id]\n\n    for mem in mlists[id].split(',')\n      gid = gids[mem]\n      if gid.nil?\n        if mids[mem].nil?\n          mids[mem] = mn\n          mn += 1\n        end\n        grp.ms << mids[mem]\n      else\n        grp.deps << gid\n        grps[gid].reqs << id\n      end\n    end\n  end\n  #p grps\n\n  q = grps.select{|g| g.deps.empty?}\n  #p q\n\n  while ! q.empty?\n    grp = q.shift\n\n    for req in grp.reqs\n      greq = grps[req]\n      greq.ms += grp.ms\n      greq.ms.uniq!\n      greq.n += 1\n\n      if greq.n == greq.deps.length\n        q << greq\n      end\n    end\n  end\n  #p grps\n\n  puts grps.first.ms.length\nend", "label": 1, "name1": "s038642140.java", "name2": "s641255023.rb"}, {"id": 914, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tString Sa = scanner.next();\n\t\tString Sb = scanner.next();\n\t\tString Sc = scanner.next();\n\n\t\tchar[][] C = new char[3][100];\n\t\tC[0] = Sa.toCharArray();\n\t\tC[1] = Sb.toCharArray();\n\t\tC[2] = Sc.toCharArray();\n\n\t\tint[] t = new int[3];\n\t\tint now = 0;\n\t\tString ans = \"\";\n\t\twhile(true) {\n\t\t\tswitch(C[now][t[now]]) {\n\t\t\tcase 'a':\n\t\t\t\tt[now]++;\n\t\t\t\tnow = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tt[now]++;\n\t\t\t\tnow = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tt[now]++;\n\t\t\t\tnow = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(t[0]==Sa.length()&&now==0) {\n\t\t\t\tans = \"A\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(t[1]==Sb.length()&&now==1) {\n\t\t\t\tans = \"B\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(t[2]==Sc.length()&&now==2) {\n\t\t\t\tans = \"C\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t\tscanner.close();\n\t}\n\n}\n", "code2": "$N = gets.chomp.to_i\n\ns = []\n$N.times do\n  s << gets.chomp.to_i\nend\n\ndef max(a, b)\n  a < b ? b : a\nend\n\n# s = s.sort\nsum = s.reduce(:+)\n\n$table = Array.new(sum + 1, 0)\n\ndef point(n)\n  n % 10 == 0 ? 0 : n\nend\n\ndef max_a(arr)\n  res = -10_000_000_000_000_000_000\n  arr.each do |i|\n    res = i < res ? res : i\n  end\n  res\nend\n\n$N.times do |i|\n  (0...sum).each do |j|\n    current = sum - j\n    $table[current] = if s[i] <= current\n                        max($table[current], $table[current - s[i]] + s[i])\n                      else\n                        $table[current]\n                      end\n  end\nend\nputs max_a($table.map { |t| point(t) })\n", "label": 0, "name1": "s757722337.java", "name2": "s204912293.rb"}, {"id": 362, "code1": "import java.util.Scanner;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tprivate static final int INF = (int)1e9;\n\n\tstatic class Pair {\n\t\tint first;\n\t\tint second;\n\n\t\tpublic Pair(int first, int second) {\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn first + second;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\tif (other instanceof Pair) {\n\t\t\t\tPair p = (Pair)other;\n\n\t\t\t\treturn p.first == first && p.second == second;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner in = new Scanner(System.in)) {\n\t\t\tint n = in.nextInt();\n\t\t\tList<Integer>[] g = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tg[i] = new ArrayList<>();\n\n\t\t\tint m = in.nextInt();\n\t\t\tint r = in.nextInt();\n\t\t\tMap<Pair, Integer> dist = new HashMap<>();\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint f = in.nextInt();\n\t\t\t\tint t = in.nextInt();\n\t\t\t\tint w = in.nextInt();\n\n\t\t\t\tg[f].add(t);\n\t\t\t\tdist.put(new Pair(f, t), w);\n\t\t\t}\n\n\t\t\tdijkstra(g, n, dist, r);\n\t\t} catch (Exception ex) {\n\t\t\tthrow new RuntimeException(ex);\n\t\t}\n\t}\n\n\tpublic static void dijkstra(List<Integer> g[], int n, Map<Pair, Integer> dist, int s) {\n\t\tint[] d = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\td[i] = INF;\n\n\t\td[s] = 0;\n\t\tPriorityQueue<Pair> pq = new PriorityQueue<>((x, y) -> x.second-y.second);\n\t\tpq.add(new Pair(s, 0));\n\n\t\twhile (!pq.isEmpty()) {\n\t\t\tPair p = pq.remove();\n\n\t\t\tfor (int v : g[p.first]) {\n\t\t\t\tint dd = d[p.first] + dist.get(new Pair(p.first, v));\n\t\t\t\tif (dd < d[v]) {\n\t\t\t\t\td[v] = dd;\n\t\t\t\t\tpq.add(new Pair(v, d[v]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (d[i] == INF)\n\t\t\t\tSystem.out.println(\"INF\");\n\t\t\telse\n\t\t\t\tSystem.out.println(d[i]);\n\t\t}\n\t}\n}", "code2": "class PriorityQueue\n  def initialize es = [], &block\n    block = proc { |a, b| a < b } unless block_given?\n    @fun = block\n    @tree = []\n    @n = 0\n\n    es.each do |e| enqueue e end\n  end\n\n  def enqueue e\n    @tree[@n] = e\n    i = @n\n    @n += 1\n    until i.zero?\n      j = (i-1)/2\n      if @fun.(@tree[i], @tree[j])\n        @tree[i], @tree[j] = @tree[j], @tree[i]\n        i = j\n      else\n        break\n      end\n    end\n    self\n  end\n\n  alias push enqueue\n  alias << enqueue\n  alias insert enqueue\n\n  def dequeue\n    return nil if @n.zero?\n    @n -= 1\n    @tree.first.tap do\n      @tree[0] = @tree.pop\n      i = 0\n      loop do\n        l = i*2+1\n        r = i*2+2\n        break if @tree[l].nil?\n        j =\n          if @tree[r].nil?\n            l\n          else\n            @fun.(@tree[r], @tree[l]) ? r : l\n          end\n        if @fun.(@tree[j], @tree[i])\n          @tree[i], @tree[j] = @tree[j], @tree[i]\n          i = j\n        else\n          break\n        end\n      end\n    end\n  end\n\n  alias pop dequeue\n  alias remove dequeue\n\n  def peek\n    @tree.first\n  end\n\n  alias first peek\n  alias top peek\n\n  def to_a\n    [].tap do |arr|\n      while e = dequeue\n        arr << e\n      end\n    end\n  end\n\n  def empty?\n    @n == 0\n  end\nend\n\nv, e, r = gets.split.map(&:to_i)\ng = Array.new(v) { [] }\ne.times do\n  s, t, d = gets.split.map(&:to_i)\n  g[s] << [t, d]\nend\n\narr = Array.new(v) { Float::INFINITY }\narr[r] = 0\n\npq = PriorityQueue.new([[r, 0]]) { |(_, a), (_, b)| a < b }\nwhile h = pq.pop\n  i, d1 = h\n  g[i].each do |j, d2|\n    next if arr[j] <= d1+d2\n    arr[j] =d1+d2\n    pq.push [j, d1+d2]\n  end\nend\n\nputs arr.map { |i| i == Float::INFINITY ? \"INF\" : i }\n", "label": 1, "name1": "s004699498.java", "name2": "s636190295.rb"}, {"id": 730, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tint N,M;\n\tboolean[] first,second;\n\n\tpublic void solve() {\n\n\t\tN = nextInt();\n\t\tM = nextInt();\n\n\t\tfirst = new boolean[N];\n\t\tsecond = new boolean[N];\n\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tint a = nextInt()-1;\n\t\t\tint b = nextInt()-1;\n\n\t\t\tif(a == 0){\n\t\t\t\tfirst[b] = true;\n\t\t\t}\n\n\t\t\tif(b == N-1){\n\t\t\t\tsecond[a] = true;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1;i < N - 1;i++){\n\t\t\tif(first[i] && second[i]){\n\t\t\t\tout.println(\"POSSIBLE\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tout.println(\"IMPOSSIBLE\");\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}", "code2": "eval'X,Y='+`tr ' ' ,`;p (Y/X).bit_length", "label": 0, "name1": "s651303084.java", "name2": "s262263338.rb"}, {"id": 937, "code1": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] sa = br.readLine().split(\" \");\n\t\tint h = Integer.parseInt(sa[0]);\n\t\tint w = Integer.parseInt(sa[1]);\n\t\tchar[][] s = new char[h][w];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\ts[i] = br.readLine().toCharArray();\n\t\t}\n\t\tbr.close();\n\n\t\tint[] dx = {0, 0, -1, 1};\n\t\tint[] dy = {-1, 1, 0, 0};\n\t\tboolean[][] visit = new boolean[h][w];\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (visit[i][j]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlong kuro = 0;\n\t\t\t\tlong siro = 0;\n\t\t\t\tQueue<Integer> que = new ArrayDeque<Integer>();\n\t\t\t\tque.add(i * 1000 + j);\n\t\t\t\tvisit[i][j] = true;\n\t\t\t\twhile (!que.isEmpty()) {\n\t\t\t\t\tint cur = que.poll();\n\t\t\t\t\tint x = cur / 1000;\n\t\t\t\t\tint y = cur % 1000;\n\t\t\t\t\tif (s[x][y] == '#') {\n\t\t\t\t\t\tkuro++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsiro++;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int a = 0; a < 4; a++) {\n\t\t\t\t\t\tint xx = x + dx[a];\n\t\t\t\t\t\tint yy = y + dy[a];\n\t\t\t\t\t\tif (0 <= xx && xx < h && 0 <= yy && yy < w\n\t\t\t\t\t\t\t\t&& !visit[xx][yy] && s[x][y] != s[xx][yy]) {\n\t\t\t\t\t\t\tque.add(xx * 1000 + yy);\n\t\t\t\t\t\t\tvisit[xx][yy] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += kuro * siro;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n", "code2": "D = gets.to_i\nC = gets.chomp.split.map(&:to_i)\ns = D.times.map{gets.split.map(&:to_i)}\nc = Array.new(26, 0)\n\n(0..D-1).each do |i|\nans = 0\nboder = s[i][0]+c[0]\n\n  (0..25).each do |l|\n    c[l] += C[l]\n  end\n  (1..25).each do |e|\n    if s[i][e]+c[e] > boder\n      ans = e\n      boder = s[i][e]+c[e]\n    end\n  end\nc[ans] = 0\nputs ans+1\nend", "label": 0, "name1": "s886312040.java", "name2": "s863240765.rb"}, {"id": 628, "code1": "import java.util.*;\nimport java.io.*;\n\n\nclass Main {\n\n    public static void main(String[] args) throws IOException\n    {\n        PrintWriter out = new PrintWriter(System.out);\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        int n = Integer.parseInt(br.readLine());\n        Long arr[] = new Long[n];\n        StringTokenizer st1 = new StringTokenizer(br.readLine());\n        for(int i = 0 ; i < n ; i++)\n        {\n            arr[i] = Long.parseLong(st1.nextToken());\n        }\n        Arrays.sort(arr);\n        long sum = arr[n-1];\n        int ind = n-2;\n        for(int i = 0 ; i < n-2 ; i++)\n        {\n            sum += arr[ind];\n\n            if(i%2 != 0)\n                ind--;\n        }\n        out.println(sum);\n\n        out.flush();\n        out.close();\n\n    }\n\n    static class pair{\n        long x1;\n        long x2;\n\n        public pair(long x1 , long x2)\n        {\n            this.x1 = x1;\n            this.x2 = x2;\n        }\n\n    }\n\n}\n", "code2": "M=10**9+7\ngets\nhw=0;t=gets.split.map{|s|[hw<hw=h=s.to_i,h]}\nhw=0;a=gets.split.reverse.map{|s|[hw<hw=h=s.to_i,h]}.reverse\np t.zip(a).reduce(1){|p,((f1,h1),(f2,h2))|\n  break 0 if f1&&f2&&h1!=h2 || f1&&!f2&&h1>h2 || !f1&&f2&&h1<h2\n  !f1&&!f2 ? p*[h1,h2].min%M : p\n}\n", "label": 0, "name1": "s590431029.java", "name2": "s443550692.rb"}, {"id": 565, "code1": "import java.util.*;\n\npublic class Main {\n\tvoid solve() {\n\t\tScanner scan = new Scanner(System.in);\n\t\tlong n = scan.nextLong();\n\t\tlong k = scan.nextLong();\n\t\tif(n % k == 0) {\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\t\tn %= k;\n\t\tSystem.out.println(Math.min(n, k - n));\n\t\tscan.close();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\n}\n", "code2": "i = gets.split(\" \")\nif i[0].to_i < i[1].to_i then\n  if i[0].to_i < i[2].to_i and i[2].to_i < i[1].to_i then\n    print \"Yes\"\n  else\n    print \"No\"\n  end\n  else\n    if i[0].to_i > i[2].to_i and i[2].to_i > i[1].to_i then\n      print \"Yes\"\n    else\n      print \"No\"\n    end\n    end", "label": 0, "name1": "s393030652.java", "name2": "s608185400.rb"}, {"id": 465, "code1": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.Stack;\n\nclass Main{\n\tpublic static void main(String[] args) {\n\t\tint INF=1000000007;\n\t\tScanner sc=new Scanner(System.in);\n\t\tint V=sc.nextInt();\n\t\tArrayList<ArrayList<Integer>> v=new ArrayList<ArrayList<Integer>>();\n\t\tfor(int i=0; i<=V; i++) {\n\t\t\tv.add(new ArrayList<Integer>());\n\t\t}\n\t\tfor(int i=0; i<V-1; i++) {\n\t\t\tint a=sc.nextInt();\n\t\t\tint b=sc.nextInt();\n\t\t\t(v.get(a)).add(b);\n\t\t\t(v.get(b)).add(a);\n\t\t}\n\t\tint[] Fe=new int[V+1];\n\t\tint[] Su=new int[V+1];\n\t\tboolean[] Fe_V=new boolean[V+1];\n\t\tboolean[] Su_V=new boolean[V+1];\n\t\tArrays.fill(Fe, INF);\n\t\tArrays.fill(Su, INF);\n\t\tFe[1]=0;\n\t\tSu[V]=0;\n\t\tStack<Integer> Q=new Stack<Integer>();\n\t\tQ.add(1);\n\t\twhile(!Q.isEmpty()) {\n\t\t\tint tmp=Q.pop();\n\t\t\tfor(int i=0; i<v.get(tmp).size(); i++) {\n\t\t\t\tif(!Fe_V[v.get(tmp).get(i)] && Fe[tmp]+1<Fe[v.get(tmp).get(i)]) {\n\t\t\t\t\tFe_V[v.get(tmp).get(i)]=true;\n\t\t\t\t\tFe[v.get(tmp).get(i)]=Fe[tmp]+1;\n\t\t\t\t\tQ.push(v.get(tmp).get(i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tQ.add(V);\n\t\twhile(!Q.isEmpty()) {\n\t\t\tint tmp=Q.pop();\n\t\t\tfor(int i=0; i<v.get(tmp).size(); i++) {\n\t\t\t\tif(!Su_V[v.get(tmp).get(i)] && Su[tmp]+1<Su[v.get(tmp).get(i)]) {\n\t\t\t\t\tSu_V[v.get(tmp).get(i)]=true;\n\t\t\t\t\tSu[v.get(tmp).get(i)]=Su[tmp]+1;\n\t\t\t\t\tQ.push(v.get(tmp).get(i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint Su_w=0;\n\t\tint Fe_w=0;\n\t\tfor(int i=1; i<=V; i++) {\n\t\t\tif(Fe[i]<=Su[i]) {\n\t\t\t\tFe_w++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSu_w++;\n\t\t\t}\n\t\t}\n\t\tif(Su_w>=Fe_w) {\n\t\t\tSystem.out.println(\"Snuke\");\n\t\t\tSystem.out.flush();\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"Fennec\");\n\t\t\tSystem.out.flush();\n\t\t}\n\t}\n}", "code2": "n = gets.chomp.to_i\ntree = Array.new(n)\nn.times { |i| tree[i] = [] }\n(n - 1).times do\n  a, b = gets.chomp.split(' ').map { |x| x.to_i - 1 }\n  tree[a] << b\n  tree[b] << a\nend\n\nvisited = Hash.new(false)\ndistances = Array.new(n, 0)\ndistance = 0\nqueue = [0]\nuntil queue.empty?\n  size = queue.length\n  size.times do\n    q = queue.shift\n    next if visited[q]\n    distances[q] = distance\n    visited[q] = true\n    tree[q].each do |i|\n      next if visited[i]\n      queue << i\n    end\n  end\n  distance += 1\nend\n\nqueue = [n - 1]\nroute = []\nuntil queue.empty?\n  q = queue.shift\n  route.unshift(q)\n  tree[q].each do |i|\n    if distances[q] - distances[i] == 1\n      queue << i\n      break\n    end\n  end\nend\nvisited = Hash.new(false)\nstart_index = route.length % 2 == 0 ? route.length / 2 - 1 : route.length / 2\nqueue = [route[start_index]]\ncount = 0\nuntil queue.empty?\n  q = queue.pop\n  next if visited[q]\n  visited[q] = true\n  count += 1\n  tree[q].each do |i|\n    next if i == route[start_index + 1]\n    next if visited[i]\n    queue << i\n  end\nend\n\nputs count > n - count ? 'Fennec' : 'Snuke'", "label": 1, "name1": "s522721717.java", "name2": "s088298181.rb"}, {"id": 83, "code1": "import java.util.Scanner;\n\nclass Main\n{\n\tpublic static void main(String args[])\n\t{\n\t\tScanner sc = new Scanner(System.in).useDelimiter(\"[,\\n]\");\n\t\t\n\t\tint a = 0;\n\t\tint b = 0;\n\t\tint o = 0;\n\t\tint ab = 0;\n\t\t\n\t\twhile (sc.hasNext())\n\t\t{\n\t\t\tsc.nextInt();\n\t\t\tString str = sc.next();\n\t\t\tif (str.equals(\"A\"))\n\t\t\t{\n\t\t\t\ta++;\n\t\t\t}\n\t\t\telse if (str.equals(\"B\"))\n\t\t\t{\n\t\t\t\tb++;\n\t\t\t}\n\t\t\telse if (str.equals(\"O\"))\n\t\t\t{\n\t\t\t\to++;\n\t\t\t}\n\t\t\telse if (str.equals(\"AB\"))\n\t\t\t{\n\t\t\t\tab++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(a);\n\t\tSystem.out.println(b);\n\t\tSystem.out.println(ab);\n\t\tSystem.out.println(o);\n\t}\n}", "code2": "count = {\n  \"A\"  => 0,\n  \"B\"  => 0,\n  \"AB\" => 0,\n  \"O\"  => 0\n}\n\nwhile line = gets\n  data = line.chomp.split(\",\")\n  count[data[1]] += 1\nend\n\nputs count[\"A\"]\nputs count[\"B\"]\nputs count[\"AB\"]\nputs count[\"O\"]", "label": 1, "name1": "s541319729.java", "name2": "s431000983.rb"}, {"id": 649, "code1": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\n\npublic class Main {\n\n    static <T extends Comparable<? super T>> boolean nextPermutation(T[] sequence) {\n        int first = getFirst(sequence);\n        if (first == -1) return false;\n        int toSwap = sequence.length - 1;\n        while (sequence[first].compareTo(sequence[toSwap]) >= 0) --toSwap;\n        swap(sequence, first++, toSwap);\n        toSwap = sequence.length - 1;\n        while (first < toSwap) swap(sequence, first++, toSwap--);\n        return true;\n    }\n\n    static <T extends Comparable<? super T>> int getFirst(T[] sequence) {\n        for (int i = sequence.length - 2; i >= 0; --i)\n            if (sequence[i].compareTo(sequence[i + 1]) < 0) return i;\n        return -1;\n    }\n\n    static <T extends Comparable<? super T>> void swap(T[] sequence, int i, int j) {\n        T tmp = sequence[i];\n        sequence[i] = sequence[j];\n        sequence[j] = tmp;\n    }\n\n    public static void main(String[] args) {\n        FastScanner fs = new FastScanner();\n        int N = fs.nextInt();\n        Integer[] P = new Integer[N];\n        Integer[] Q = new Integer[N];\n        for (int i = 0; i < N; ++i) P[i] = fs.nextInt();\n        for (int i = 0; i < N; ++i) Q[i] = fs.nextInt();\n\n        Integer[] arr = new Integer[N];\n        for (int i = 0; i < N; ++i) arr[i] = i+1;\n\n        int cnt = 1, pNum = 0, qNum = 0;\n        do {\n            if (Arrays.toString(arr).equals(Arrays.toString(P))) pNum = cnt;\n            if (Arrays.toString(arr).equals(Arrays.toString(Q))) qNum = cnt;\n            ++cnt;\n        } while (nextPermutation(arr));\n\n        System.out.println(Math.abs(pNum - qNum));\n\n    }\n\n\n    static class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            }else{\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while(true){\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                }else if(b == -1 || !isPrintableChar(b)){\n                    return minus ? -n : n;\n                }else{\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        public int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        public double nextDouble() { return Double.parseDouble(next());}\n    }\n\n}", "code2": "n,k = gets.split.map(&:to_i)\nw = []\n(n).times do |i|\n  w[i] = gets.to_i\nend\nm = w.max\nans = (m..n*m).bsearch{|i|\n  count = 1\n  rest = i\n  for wi in w do\n    if rest >= wi\n      rest -= wi\n    else\n      count += 1\n      rest = i-wi\n    end\n  end\n  k >= count\n}\nprintf(\"%d\\n\",ans)\n", "label": 0, "name1": "s792830085.java", "name2": "s051438008.rb"}, {"id": 280, "code1": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String args[])\n    {\n        Scanner sc=new Scanner(System.in);\n       int ar[]=new int[] {0,0,0,0};\n       for(int i=0;i<3;i++)\n       {\n           int a=sc.nextInt();\n           int b=sc.nextInt();\n           ar[a-1]+=1;\n           ar[b-1]+=1;\n       }\n       \n       for(int i = 0; i < 4; i++) {\n\t\t\tif(ar[i] < 1 || ar[i] > 2) {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"YES\");\n       \n//       for(int i:ar)\n//       {\n//           if(i>2)\n//           {\n//               System.out.println(\"NO\");\n//               System.exit(0);\n//           }\n//       }\n//       System.out.println(\"YES\");\n    }\n}", "code2": "a = Array.new(3)\nb = Array.new(3)\n\ncounts = Hash.new(0)\n3.times do|i|\n  a, b = gets.split.map(&:to_i)\n  counts[a.to_s] += 1\n  counts[b.to_s] += 1\nend\n\nputs counts.sort { |(k1, v1), (k2, v2)| v1<=>v2 }.map { |k, v| v } == [1, 1, 2, 2] ? 'YES' : 'NO'\n", "label": 1, "name1": "s048278962.java", "name2": "s056579310.rb"}, {"id": 256, "code1": "import java.io.File;\nimport java.io.IOException;\nimport java.util.*;\n \npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\t//File file = new File(\"input.txt\");\n\t\t//Scanner in = new Scanner(file);\n\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\t\n\t\tString SS = in.next();\n\t\tString T = in.next();\n\t\t\n\t\tint index = SS.length() - T.length();\n\t\t\n\t\twhile(index >= 0){\n\t\t\tString s = SS.substring(index, index + T.length());\n\t\t\t\n\t\t\tboolean tf = true;\n\t\t\tfor(int i = 0; i < T.length(); i++){\n\t\t\t\tif(s.charAt(i) != '?' && s.charAt(i) != T.charAt(i)){\n\t\t\t\t\ttf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(tf){\n\t\t\t\tSS = new StringBuilder(SS).replace(index, index + s.length(), T).toString();\n\t\t\t\tSS = SS.replace('?', 'a');\n\t\t\t\tSystem.out.println(SS);\n\t\t\t\treturn;\n\t\t\t}else{\n\t\t\t\tindex--;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"UNRESTORABLE\");\n\t}\n}", "code2": "WORM_EATEN_S = STDIN.gets.strip!\nHINT = STDIN.gets.strip!\ncandidates = []\n\ndef apply_hint(given_str, start, hint)\n\n  if start + hint.length > given_str.length\n    return ''\n  end\n\n  applied = Marshal.load(Marshal.dump(given_str))\n\n  (0..hint.length-1).each do |idx|\n    target_char = given_str[start+idx]\n\n    unless ( target_char == '?' || target_char == hint[idx] )\n      return ''\n    end\n\n    applied[start+idx] = hint[idx]\n  end\n\n  return applied\nend\n\n# gather candidate strings\nresult = ''\n(0..WORM_EATEN_S.length-1).each do |idx|\n  result = apply_hint(Marshal.load(Marshal.dump(WORM_EATEN_S)), idx, HINT)\n  candidates.push(result.gsub(/\\?/, 'a')) if result != ''\nend\n\n# print the result\nif candidates.length == 0\n  puts 'UNRESTORABLE'\nelse\n  puts candidates.min\nend\n", "label": 1, "name1": "s419255365.java", "name2": "s297009778.rb"}, {"id": 263, "code1": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint A = sc.nextInt();\n\t\tint B = sc.nextInt();\n\t\tint C = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tint res = 0;\n\t\tres+=Math.min(A, K);\n\t\tK -= res;\n\t\tif(K==0) {\n\t\t\tSystem.out.println(res);\n\t\t\tSystem.exit(0);\n\t\t}\n\t\tK-=B;\n\t\tif(K>0) {\n\t\t\tres-=Math.min(K, C);\n\t\t}\n\t\tSystem.out.println(res);\n\n\t}\n}", "code2": "a, b, c, k = gets.split(\" \").map(&:to_i)\nsum = 0\nif k < a\n  sum = k\n  puts sum\n  exit\nelse\n  sum = a\n  k = k - a\nend\n\nif k < b\n  puts sum\n  exit\nelse\n  k = k - b\nend\n\nif k < c\n  sum = sum + (k * -1)\n  puts sum\nelse\n  sum = sum + (c * -1)\n  puts sum\nend", "label": 1, "name1": "s649759516.java", "name2": "s605447000.rb"}, {"id": 433, "code1": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Map;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class TaskX {\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tint n = in.nextInt();\n\t\t\tint k = in.nextInt();\n\t\t\tint l = in.nextInt();\n\t\t\tUnionFind u1 = new UnionFind(n);\n\t\t\tUnionFind u2 = new UnionFind(n);\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tint p = in.nextInt()-1;\n\t\t\t\tint q = in.nextInt()-1;\n\t\t\t\tu1.link(p, q);\n\t\t\t}\n\t\t\tfor (int i = 0; i < l; i++) {\n\t\t\t\tint r = in.nextInt()-1;\n\t\t\t\tint s = in.nextInt()-1;\n\t\t\t\tu2.link(r, s);\n\t\t\t}\n\t\t\tMap<Long, Integer> roots = new HashMap<Long, Integer>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tlong code = (long)u1.root(i)<< 32 | u2.root(i);\n\t\t\t\troots.merge(code, 1, Integer::sum);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i > 0)out.print(\" \");\n\t\t\t\tlong code = (long)u1.root(i) << 32 | u2.root(i);\n\t\t\t\tout.print(roots.get(code));\n\t\t\t}\n\n\t\t}\n\n\t\tpublic class UnionFind {\n\t\t\tint[] data;\n\n\t\t\tpublic UnionFind(int n) {\n\t\t\t\tdata = new int[n];\n\t\t\t\tArrays.fill(data, -1);\n\t\t\t}\n\n\t\t\tboolean link(int x, int y) {\n\t\t\t\tx = root(x);\n\t\t\t\ty = root(y);\n\t\t\t\tif (x != y) {\n\t\t\t\t\tif (data[y] < data[x]) {\n\t\t\t\t\t\tdata[y] += data[x];\n\t\t\t\t\t\tdata[x] = y;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdata[x] += data[y];\n\t\t\t\t\t\tdata[y] = x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn x != y;\n\t\t\t}\n\n\t\t\tint root(int x) {\n\t\t\t\treturn data[x] < 0 ? x : (data[x] = root(data[x]));\n\t\t\t}\n\t\t}\n\t}\n\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\n\t}\n\n}\n", "code2": "N, K, L = gets.split.map(&:to_i)\n\nroad = [*0..N]\nroad_r = Array.new(N + 1) { 1 }\n\nrail = [*0..N]\nrail_r = Array.new(N + 1) { 1 }\n\ndef root uf, i\n  uf[i] == i ? i : uf[i] = root(uf, uf[i])\nend\n\ndef set_union_find n, uf, rank\n  n.times do\n    x, y = gets.split.map(&:to_i)\n    x = root(uf, x)\n    y = root(uf, y)\n\n    next if x == y\n\n    if rank[x] > rank[y]\n      uf[y] = x\n    else\n      uf[x] = y\n      rank[y] += 1 if rank[x] == rank[y]\n    end\n  end\nend\n\nset_union_find K, road, road_r\nset_union_find L, rail, rail_r\n\nh = Hash.new {|h, k| h[k] = [] }\n(1..N).each do |i|\n  h[[root(road, i), root(rail, i)]] << i\nend\n\nresult = Array.new(N + 1) { 0 }\nh.values.each do |arr|\n  arr.each do |j|\n    result[j] = arr.size\n  end\nend\n\nputs (1..N).map {|i| result[i] }.join(' ')", "label": 1, "name1": "s544715299.java", "name2": "s244848536.rb"}, {"id": 828, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    private static class FastScanner {\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        public String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        int array[] = new int[3], num = 0;\n        int count = 0;\n\n        while (count < 3) {\n            num = sc.nextInt();\n            if (0 < num && num < 10) {\n                array[count] = num;\n                count++;\n            }\n        }\n\n\n        for (int i = 0; i < 3; i++) {\n            for (int j = i + 1; j < 3; j++) {\n                if (array[i] == array[j]) {\n                    count = count - 1;\n                }\n            }\n        }\n        if (count == 2) {\n            System.out.print(\"Yes\");\n        } else {\n            System.out.print(\"No\");\n        }\n    }\n}\n", "code2": "# 3_4_selectionsort\n# ALDS_1_2_B: Selection Sort\nN = gets.to_i\na = gets.split.map(&:to_i)\n# N = 6\n# a = [5,6,4,2,1,3]\n\ndef selection_sort(n,a)\n  count = 0\n  a.each_with_index do |val,i|\n\n    min_j = i\n    i.upto(n-1) do |j|\n      min_j = j if a[j] < a[min_j]\n    end\n    if min_j != i\n      a[i],a[min_j] = a[min_j],a[i]\n      count += 1\n    end\n\n  end\n  puts a.join(' ')\n  puts count\nend\nselection_sort(N,a)\n", "label": 0, "name1": "s136290389.java", "name2": "s889173849.rb"}, {"id": 266, "code1": "\nimport java.util.*;\n\npublic class Main {\n    public static void main(final String[] args) {\n        final Scanner sc = new Scanner(System.in);\n        // \u6574\u6570\u306e\u5165\u529b\n        // final int a = sc.nextInt();\n        // \u6587\u5b57\u5217\u306e\u5165\u529b\n        // final String s1 = sc.next();\n        final int a = sc.nextInt();\n        final int b = sc.nextInt();\n        final int c = sc.nextInt();\n        final int k = sc.nextInt();\n        sc.close();\n        int result = 0;\n        if (a >= k) {\n            result = k;\n        } else if (b >= k - a) {\n            result = a;\n        } else if (c >= k - b - a) {\n            result = 2 * a + b - k;\n        }\n\n        System.out.println(result);\n    }\n}\n", "code2": "cards = gets.split(' ').map!(&:to_i)\n# i = 1\n# max = 0\n# a = cards[0] + cards[1]\n# while i <= cards[0] && i <= cards[3]\n#     max = max + 1\n#     i = i + 1\n# end\n# while i <= cards[0] + cards[1] && i <= cards[3]\n#     i = i + 1\n# end\n# while i <= cards[0] + cards[1] + cards[2] && i <= cards[3]\n#     max = max - 1\n#     i = i + 1\n# end\ncase\nwhen cards[3] <= cards[0]\n    puts cards[3]\nwhen cards[3] <= cards[0] + cards[1]\n    puts cards[0]\nelse cards[3] > cards[0] + cards[1]\n    puts (cards[0] - (cards[3] - cards[0] - cards[1]))\nend", "label": 1, "name1": "s239119083.java", "name2": "s837052627.rb"}, {"id": 830, "code1": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tstatic final long mod = (long) 1e9 + 7;\n\tstatic final int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };\n\tstatic final int[] dx8 = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\tstatic final int inf = Integer.MAX_VALUE / 3;\n\tstatic final long linf = Long.MAX_VALUE / 3;\n\tstatic final double dinf = Double.MAX_VALUE / 3;\n\tstatic final double eps = 1e-10;\n\tstatic final double pi = Math.PI;\n\tstatic StringBuilder sb = new StringBuilder();\n\n\tstatic void solve() {\n\t\tint n = ni();\n\t\tchar s[] = ns(n);\n\t\t//\u5de6\u304b\u3089W\u3092\u5411\u3044\u3066\u308b\u4eba\u3001\u53f3\u304b\u3089E\u3092\u5411\u3044\u3066\u308b\u4eba\u3092\u6570\u3048\u308b\n\t\tint suml[] = new int[n+1];\n\t\tint sumr[] = new int[n+1];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tsuml[i+1] = suml[i] + (s[i]=='W'?1:0);\n\t\t\tsumr[n-i-1] = sumr[n-i] + (s[n-1-i]=='E'?1:0);\n\t\t}\n\t\t\n\t\tint ans = inf;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint t = suml[i]+sumr[i+1];\n\t\t\tans = min(ans, t);\n\t\t}\n\t\tout.println(ans);\n\t\t\n\t}\n\n\t//libraries\n\tstatic void reverse(int ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tint t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(long ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tlong t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(double ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tdouble t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic void reverse(char ar[]) {\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tchar t = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = t;\n\t\t}\n\t}\n\n\tstatic String getReverse(String s) {\n\t\tchar c[] = s.toCharArray();\n\t\treverse(c);\n\t\ts = String.valueOf(c);\n\t\treturn s;\n\t}\n\n\tstatic <T> void reverse(List<T> ls) {\n\t\tint sz = ls.size();\n\t\tfor (int i = 0; i < sz / 2; i++) {\n\t\t\tT t = ls.get(i);\n\t\t\tls.set(i, ls.get(sz - 1 - i));\n\t\t\tls.set(sz - 1 - i, t);\n\t\t}\n\t}\n\n\tstatic void sbnl() {//StringBuilder\u306b\u6539\u884c\u6587\u5b57\u3092append\u3059\u308b\n\t\tsb.append(\"\\n\");\n\t}\n\n\tstatic int lowerBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(int[] a, int x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int lowerBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(long[] a, long x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int lowerBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] < x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int upperBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] <= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rlowerBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] > x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int rupperBound(double[] a, double x) {\n\t\tint l = -1, r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint c = (l + r) / 2;\n\t\t\tif (a[c] >= x) {\n\t\t\t\tl = c;\n\t\t\t} else {\n\t\t\t\tr = c;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic <T> int lowerBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) >= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) >= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) >= 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int upperBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) > 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) > 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) > 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int rupperBound(List<T> ls, T x) throws RuntimeException {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) < 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) < 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) < 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic <T> int rlowerBound(List<T> ls, T x) {\n\t\tif (ls.size() == 0)\n\t\t\treturn -1;\n\t\tif (ls.get(0) instanceof Integer) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) <= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Long) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) <= 0 ? 1 : -1);\n\t\t} else if (ls.get(0) instanceof Double) {\n\t\t\treturn ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) <= 0 ? 1 : -1);\n\t\t} else {\n\t\t\tSystem.err.println(\n\t\t\t\t\tString.format(\"%s:\u6570\u5024\u3067\u306a\u3044\u30ea\u30b9\u30c8\u3092\u4e8c\u5206\u63a2\u7d22\u3057\u3066\u3044\u307e\u3059\u3002\", Thread.currentThread().getStackTrace()[1].getMethodName()));\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\n\tstatic int[] concat(int x, int arr[]) {\n\t\tint ret[] = new int[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 1, ret.length - 1);\n\t\tret[0] = x;\n\t\treturn ret;\n\t}\n\n\tstatic int[] concat(int arr[], int x) {\n\t\tint ret[] = new int[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 0, ret.length - 1);\n\t\tret[ret.length - 1] = x;\n\t\treturn ret;\n\t}\n\n\tstatic long[] concat(long x, long arr[]) {\n\t\tlong ret[] = new long[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 1, ret.length - 1);\n\t\tret[0] = x;\n\t\treturn ret;\n\t}\n\n\tstatic long[] concat(long arr[], long x) {\n\t\tlong ret[] = new long[arr.length + 1];\n\t\tSystem.arraycopy(arr, 0, ret, 0, ret.length - 1);\n\t\tret[ret.length - 1] = x;\n\t\treturn ret;\n\t}\n\n\tstatic int max(int x, int y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic int min(int x, int y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic int max(int x, int y, int z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic int min(int x, int y, int z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic long max(long x, long y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic long min(long x, long y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic long max(long x, long y, long z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic long min(long x, long y, long z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic double max(double x, double y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic double min(double x, double y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic double max(double x, double y, double z) {\n\t\tx = Math.max(x, y);\n\t\tx = Math.max(x, z);\n\t\treturn x;\n\t}\n\n\tstatic double min(double x, double y, double z) {\n\t\tx = Math.min(x, y);\n\t\tx = Math.min(x, z);\n\t\treturn x;\n\t}\n\n\tstatic void sort(int[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void sort(long[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void sort(double[] ar) {\n\t\tArrays.sort(ar);\n\t}\n\n\tstatic void rsort(int[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tint tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void rsort(long[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tlong tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void rsort(double[] ar) {\n\t\tArrays.sort(ar);\n\t\tint len = ar.length;\n\t\tfor (int i = 0; i < len / 2; i++) {\n\t\t\tdouble tmp = ar[i];\n\t\t\tar[i] = ar[len - 1 - i];\n\t\t\tar[len - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic void fill(int arr[], int x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(long arr[], long x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(boolean arr[], boolean x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(double arr[], double x) {\n\t\tArrays.fill(arr, x);\n\t}\n\n\tstatic void fill(int arr[][], int x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(long arr[][], long x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(double arr[][], double x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\tstatic void fill(boolean arr[][], boolean x) {\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tArrays.fill(arr[i], x);\n\t}\n\n\t//MOD culc\n\tstatic long plus(long x, long y) {\n\t\tlong res = (x + y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long sub(long x, long y) {\n\t\tlong res = (x - y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long mul(long x, long y) {\n\t\tlong res = (x * y) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long div(long x, long y) {\n\t\tlong res = x * pow(y, mod - 2) % mod;\n\t\treturn res < 0 ? res + mod : res;\n\t}\n\n\tstatic long pow(long x, long y) {\n\t\tif (y < 0)\n\t\t\treturn 0;\n\t\tif (y == 0)\n\t\t\treturn 1;\n\t\tif (y % 2 == 1)\n\t\t\treturn (x * pow(x, y - 1)) % mod;\n\t\tlong root = pow(x, y / 2);\n\t\treturn root * root % mod;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\t//input\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\tprivate static int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate static String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static long[] nla(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate static int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n}\n", "code2": "def selection(n, arr)\n    c = 0\n    0.upto(n-1) do |i|\n        minj = i\n        i.upto(n-1) do |j|\n            if arr[j] < arr[minj] then\n                minj = j\n            end\n        end\n        if i != minj then\n            arr[i], arr[minj] = arr[minj], arr[i]\n            c += 1\n        end\n    end\n    puts arr.join(\" \")\n    p c\nend\nselection(gets.to_i, gets.split.map(&:to_i))", "label": 0, "name1": "s594845311.java", "name2": "s594460948.rb"}, {"id": 414, "code1": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.util.NoSuchElementException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author HBonsai\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CMultipleClocks solver = new CMultipleClocks();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CMultipleClocks {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int N = in.nextInt();\n            long[] T = in.nextLongArray(N);\n            long ans = T[0];\n            for (int i = 1; i < N; i++) {\n                long gcd = gcd(ans, T[i]);\n                ans = T[i] * (ans / gcd);\n            }\n            out.println(ans);\n        }\n\n        private static long gcd(long m, long n) {\n            if (m < n) return gcd(n, m);\n            if (n == 0) return m;\n            return gcd(n, m % n);\n        }\n\n    }\n\n    static class FastScanner implements Closeable {\n        private final InputStream in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        public FastScanner(InputStream in) {\n            this.in = in;\n        }\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        public boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n            return hasNextByte();\n        }\n\n        public long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        public int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] res = new long[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextLong();\n            }\n            return res;\n        }\n\n        public void close() {\n            try {\n                in.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n}\n\n", "code2": "n = gets.to_i\nx = gets.to_i\n(n - 1).times do\n  x = x.lcm(gets.to_i)\nend\nputs x", "label": 1, "name1": "s654794279.java", "name2": "s903706562.rb"}, {"id": 427, "code1": "\nimport java.util.HashMap;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main \n{\n\tstatic HashMap<String, String> groupdef;\n\tstatic String firstgroup;\n\tstatic TreeSet<String> members;\n\tstatic TreeSet<String> checked;\n\t\n\tstatic void get(String g)\n\t{\n\t\tString con = groupdef.get(g);\n//\t\tSystem.out.println(\"Getting \" + g + \"...\");\n\t\tif(checked.contains(g))return;\n\t\t\n\t\tint start = 0;\n\t\tint mem = 0;\n\t\tfor(int i = 0; i < con.length(); i++)\n\t\t{\n\t\t\tif(con.charAt(i) == ',' || con.charAt(i) == '.')\n\t\t\t{\n\t\t\t\tString word = con.substring(start, i);\n\t\t\t\tstart = i+1;\n\t\t\t\t\n\t\t\t\tif(groupdef.containsKey(word))\n\t\t\t\t{\n\t\t\t\t\tget(word);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmembers.add(word);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tchecked.add(g);\n//\t\tcache.put(g, mem);\n\t}\n\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0)break;\n\t\t\tgroupdef = new HashMap<String, String>();\n//\t\t\tcache = new HashMap<String, Integer>();\n\t\t\tmembers = new TreeSet<String>();\n\t\t\tchecked = new TreeSet<String>();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tString s = sc.next();\n\t\t\t\tint lim = s.indexOf(':');\n\t\t\t\tString groupname = s.substring(0, lim);\n\t\t\t\tString groupcon = s.substring(lim+1);\n\t\t\t\tif(i == 0)firstgroup = groupname;\n\t\t\t\tgroupdef.put(groupname, groupcon);\n\t\t\t}\n\t\t\t\n\t\t\tget(firstgroup);\n\t\t\tSystem.out.println(members.size());\n//\t\t\tSystem.out.println(members);\n\t\t}\n\t\t\n\n\t}\n\n}\n\n", "code2": "def find(x, root)\n  return unless @group[x]\n  return true if @group[x].include?(root)\n  @group[x].each do |m|\n    return true if find(m, root)\n  end\n  false\nend\n\nwhile n = gets.to_i\n  break if n == 0\n  root = ''\n  @group = {}\n  n.times do |i|\n    g, m = gets.split(':')\n    root = g if i == 0\n    ms = m[0..-3].split(',')\n    ms.each{ |m| @group[m] ||= []; @group[m] << g }\n  end\n  cnt = 0\n  leaf = @group.keys\n  @group.values.each{ |vs| vs.each{ |v| leaf.delete(v) } }\n  leaf.each do |name|\n    if find(name, root)\n      cnt += 1\n    end\n  end\n  p cnt\nend", "label": 1, "name1": "s001547590.java", "name2": "s748086673.rb"}, {"id": 831, "code1": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    int n;\n    char[] cs;\n\n    public static void main(String args[]) {\n        new Main().run();\n    }\n\n    void run() {\n        FastReader sc = new FastReader();\n        n = sc.nextInt();\n        cs = sc.next().toCharArray();\n        solve();\n    }\n\n    void solve() {\n        int[] sumEastL = new int[n];\n        if (cs[0] == 'E') {\n            sumEastL[0] = 1;\n        }\n        for (int i = 1; i < n; i++) {\n            sumEastL[i] = sumEastL[i - 1] + (cs[i] == 'E' ? 1 : 0);\n        }\n        int min = 10000000;\n        for (int i = 0; i < n; i++) {\n            int num = sumEastL[n - 1] - sumEastL[i] + (i > 0 ? i - sumEastL[i - 1] : 0);\n            if (min > num) {\n                min = num;\n            }\n        }\n        System.out.println(min);\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n", "code2": "# 3_4_selectionsort\n# ALDS_1_2_B: Selection Sort\nN = gets.to_i\na = gets.split.map(&:to_i)\n# N = 6\n# a = [5,6,4,2,1,3]\n\ndef selection_sort(n,a)\n  count = 0\n  a.each_with_index do |val,i|\n\n    min_j = i\n    i.upto(n-1) do |j|\n      min_j = j if a[j] < a[min_j]\n    end\n    if min_j != i\n      a[i],a[min_j] = a[min_j],a[i]\n      count += 1\n    end\n\n  end\n  puts a.join(' ')\n  puts count\nend\nselection_sort(N,a)\n", "label": 0, "name1": "s171588206.java", "name2": "s889173849.rb"}, {"id": 204, "code1": "\nimport static java.lang.Math.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic int modP = 1000000007;\n\n\tstatic class TaskX {\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tint n = in.nextInt();\n\t\t\tlong[] t = in.nextLongArray(n), a = in.nextLongArray(n);\n\n\t\t\tlong[] tCalc = new long[n];\n\t\t\tArrays.fill(tCalc, -1);\n\n\t\t\tlong[] aCalc = new long[n];\n\t\t\tArrays.fill(aCalc, -1);\n\n\t\t\tlong[] tDef = new long[n];\n\t\t\tlong[] aDef = new long[n];\n\n\t\t\tlong tMax = -1, aMax = -1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (tMax < t[i]) {\n\t\t\t\t\ttMax = t[i];\n\t\t\t\t\ttDef[i] = t[i];\n\t\t\t\t} else {\n\t\t\t\t\ttCalc[i] = tMax;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = n-1; i >= 0; i--) {\n\t\t\t\tif (aMax < a[i]) {\n\t\t\t\t\taMax = a[i];\n\t\t\t\t\taDef[i] = a[i];\n\t\t\t\t} else {\n\t\t\t\t\taCalc[i] = aMax;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (aCalc[i] == -1 && tCalc[i] == -1) {\n\t\t\t\t\tif (aDef[i] != tDef[i]) {\n\t\t\t\t\t\tout.println(0);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else if (aCalc[i] == -1) {\n\t\t\t\t\tif (aDef[i] > tCalc[i]) {\n\t\t\t\t\t\tout.println(0);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else if (tCalc[i] == -1) {\n\t\t\t\t\tif (tDef[i] > aCalc[i]) {\n\t\t\t\t\t\tout.println(0);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong ans = 1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (tCalc[i] == -1 || aCalc[i] == -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tans = ans * min(aCalc[i],tCalc[i]) % modP;\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\n\t}\n\n}\n", "code2": "N = gets.to_i\nA = gets.split.map(&:to_i)\nT = gets.split.map(&:to_i)\n\nputs (0...N).reduce(1) { |a,i|\n  amin = (i == 0 || A[i] > A[i-1]) ? A[i] : 1\n  tmin = (i == N-1 || T[i] > T[i+1]) ? T[i] : 1\n  a = (a * [[A[i],T[i]].min - [amin, tmin].max + 1, 0].max) % 1000000007\n}\n", "label": 1, "name1": "s083135979.java", "name2": "s632068488.rb"}, {"id": 755, "code1": "// -*- coding: utf-8 -*-\n//import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream;\n    if (args.length > 0 && args[0].equals(\"devTesting\")) {\n      try {\n        inputStream = new FileInputStream(args[1]);\n      } catch(FileNotFoundException e) {\n        throw new RuntimeException(e);\n      }\n    } else {\n      inputStream = System.in;\n    }\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskC solver = new TaskC();\n    int testCase = 1;\n    solver.solve(1, in, out);\n    out.close();\n  }\n  \n  static class TaskC {\n    long h, w;\n    \n    void solve(int testNumber, InputReader in, PrintWriter out) {\n      h = in.nextInt();\n      w = in.nextInt();\n      char[][] superpost = new char[(int) h][];\n      for (int i = 0; i < h; ++i)\n        superpost[i] = in.next().toCharArray();\n      for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j)\n          if (i % 2 == 0 && j < w - 1 || j == 0 || superpost[i][j] == '#')\n            out.print('#');\n          else\n            out.print('.');\n        out.println();\n      }\n      out.println();\n      for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j)\n          if (i % 2 == 1 && j > 0 || j == w - 1 || superpost[i][j] == '#')\n            out.print('#');\n          else\n            out.print('.');\n          out.println();\n      }\n    }\n    \n  }\n      \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      try {\n        return reader.readLine();\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    public boolean hasInput() {\n      try {\n        if (tokenizer != null && tokenizer.hasMoreTokens()) {\n          return true;\n        }\n        reader.mark(1);\n        int ch = reader.read();\n        if (ch != -1) {\n          reader.reset();\n          return true;\n        }\n        return false;\n      } catch(IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    \n  }\n}\n", "code2": "#!/usr/local/bin/ruby\nn=gets.to_i\nputs rec=gets.split(\" \").map(&:to_i).sort.join(\" \")", "label": 0, "name1": "s133216279.java", "name2": "s940788758.rb"}, {"id": 550, "code1": "import java.io.*;\nimport java.util.*;\nimport static java.lang.System.out;\n\npublic class Main {\n    static MyReader in = new MyReader();\n\n    public static void main(String[] args) {\n        int N = in.i();\n        int k = ((int)Math.sqrt(1 + 8 * N) + 1) / 2;\n        out.println(k * (k - 1) / 2 == N ? solve(k) : \"No\");\n    }\n\n    static String solve(int k) {\n        StringBuilder sb = new StringBuilder(\"Yes\\n\");\n        sb.append(k).append('\\n');\n\n        for (int i = 1; i < k; i++) {\n            sb.append(k - 1).append(' ');\n\n            int t = 1 + i * (i - 1) / 2;\n            for (int j = 1; j < i; j++) {\n                sb.append(t++).append(' ');\n            }\n\n            for (int j = i; j < k; j++) {\n                sb.append(t).append(' ');\n                t += j;\n            }\n            sb.append('\\n');\n        }\n\n        sb.append(k - 1).append(' ');\n        int t = 1;\n        for (int i = 2; i <= k; i++) {\n            sb.append(t).append(' ');\n            t += i;\n        }\n\n        return sb.toString();\n    }\n}\n\nclass MyReader extends BufferedReader {\n    char[] cbuf = new char[1024];\n    int head = 0;\n    int tail = 0;\n\n    MyReader() {\n        super(new InputStreamReader(System.in));\n    }\n\n    char next() {\n        if (head == tail) {\n            try {\n                tail = super.read(cbuf, 0, cbuf.length);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            head = 0;\n        }\n        return cbuf[head++];\n    }\n\n    void back() {\n        head--;\n    }\n\n    boolean minus() {\n        boolean minus;\n        while (true) {\n            char c = next();\n            if (!isDelimiter(c)) {\n                if (!(minus = c == '-')) back();\n                return minus;\n            }\n        }\n    }\n\n    void skip() {\n        while (isDelimiter(next()));\n        back();\n    }\n\n    char[] s(int N) {\n        char[] cbuf = new char[N];\n        read(cbuf, 0, N);\n        return cbuf;\n    }\n\n    public int read(char[] cbuf, int off, int len) {\n        skip();\n        int i;\n        for (i = 0; i < cbuf.length; i++) {\n            char c = next();\n            if (isDelimiter(c)) {\n                break;\n            }\n            cbuf[i] = c;\n        }\n        return i;\n    }\n\n    boolean isDelimiter(char c) {\n        return c == ' ' || c == '\\n' || c == '\\r';\n    }\n\n    int i() {\n        boolean minus = minus();\n        int n = 0;\n        while (true) {\n            int k = next() - '0';\n            if (k < 0 || 9 < k) break;\n            n = 10 * n + k;\n        }\n        return minus ? -n : n;\n    }\n\n    int[] ii(final int N) {\n        int[] a = new int[N];\n        for (int j = 0; j < a.length; j++) a[j] = i();\n        return a;\n    }\n\n    long l() {\n        boolean minus = minus();\n        long n = 0;\n        while (true) {\n            int k = next() - '0';\n            if (k < 0 || 9 < k) break;\n            n = 10 * n + k;\n        }\n        return minus ? -n : n;\n    }\n}\n", "code2": "h=Hash.new(0)\n$<.map{|l|h[l.chop.split(?,)[1]]+=1}\np h[?A],h[?B],h[\"AB\"],h[?O]", "label": 0, "name1": "s799940458.java", "name2": "s471451546.rb"}, {"id": 934, "code1": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] sa = br.readLine().split(\" \");\n\t\tint h = Integer.parseInt(sa[0]);\n\t\tint w = Integer.parseInt(sa[1]);\n\t\tchar[][] s = new char[h][w];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\ts[i] = br.readLine().toCharArray();\n\t\t}\n\t\tbr.close();\n\n\t\tint[] dx = {0, 0, -1, 1};\n\t\tint[] dy = {-1, 1, 0, 0};\n\t\tboolean[][] visit = new boolean[h][w];\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (visit[i][j]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlong kuro = 0;\n\t\t\t\tlong siro = 0;\n\t\t\t\tQueue<Integer> que = new ArrayDeque<Integer>();\n\t\t\t\tque.add(i * 1000 + j);\n\t\t\t\tvisit[i][j] = true;\n\t\t\t\twhile (!que.isEmpty()) {\n\t\t\t\t\tint cur = que.poll();\n\t\t\t\t\tint x = cur / 1000;\n\t\t\t\t\tint y = cur % 1000;\n\t\t\t\t\tif (s[x][y] == '#') {\n\t\t\t\t\t\tkuro++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsiro++;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int a = 0; a < 4; a++) {\n\t\t\t\t\t\tint xx = x + dx[a];\n\t\t\t\t\t\tint yy = y + dy[a];\n\t\t\t\t\t\tif (0 <= xx && xx < h && 0 <= yy && yy < w\n\t\t\t\t\t\t\t\t&& !visit[xx][yy] && s[x][y] != s[xx][yy]) {\n\t\t\t\t\t\t\tque.add(xx * 1000 + yy);\n\t\t\t\t\t\t\tvisit[xx][yy] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += kuro * siro;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n", "code2": "eval\"N,*A=\"+`dd`.split*?,;p (0..2*N).bsearch{|x,*y|N.times{|i|[-1,1].map{|s|A[j=N-1+i*s]>x==A[j+s]&.>(x)&&y<<=A[j]<=x}};y[0]}", "label": 0, "name1": "s886312040.java", "name2": "s661607401.rb"}, {"id": 982, "code1": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic boolean p[];\n\tpublic static void main(String[] args) {\n\t\t// TODO \u30c4\u7be0\u30a5\u30c4\u7763\u30e7\u30c4\u9752\u30ab\u30c4\u9752\u30e3\u30c4\u3064\u30a6\u30c4\u3065\u30a7\u30c4\u3064\u30b9\u30c4\u03b4\u30bd\u30c4\u30c3\u30c4\u30c9\u30c4\u30fb\u30c4\u30b9\u30c4\u30bf\u30c4\u30d6\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n,i,count;\n\t\twhile(true){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tcount=0;\n\t\t\tp=new boolean[n];\n\t\t\tArrays.fill(p, true);\n\t\t\tp[0]=p[1]=false;\n\t\t\tprime(p,n);\n\n\t\t\tfor(i=n-1;1<=i/2;i--){\n\t\t\t\tif(p[i]){\n\t\t\t\t\tif(i!=n-i){\n\t\t\t\t\t\tp[i]=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(p[n-i]){\n\t\t\t\t\t\tp[n-i]=false;\n\t\t\t\t\t\t//System.out.printf(\"%d %d\\n\",i,n-i);\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\tstatic void prime(boolean p[],int n){\n\t\tint i,j;\n\t\tfor(i=2;i<n;i++){\n\t\t\tif(p[i]){\n\t\t\t\tfor(j=2*i;j<n;j+=i){\n\t\t\t\t\tp[j]=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "code2": "n,*a=`dd`.split.map &:to_i;a.sort!;b=[0]+n.times.map{|j|a[j]*(-1)**j%24};s=24;n.times{|j|(j+1..n).each{|k|s=[s,(b[j]-b[k])%24,(b[k]-b[j])%24].min}};p s", "label": 0, "name1": "s079698951.java", "name2": "s732644795.rb"}, {"id": 876, "code1": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int a=sc.nextInt(),b=sc.nextInt(),ab=sc.nextInt(),x=sc.nextInt(),y=sc.nextInt();\n        if(ab*2>a+b){\n          System.out.println(a*x+b*y);\n        }else if(x>y&&ab*2<a){\n          System.out.println(ab*2*x);\n        }else if(x<y&&ab*2<b){\n          System.out.println(ab*2*y);\n        }else if(x>y){\n          System.out.println(ab*2*y+a*(x-y));\n        }else if(x<y){\n          System.out.println(ab*2*x+b*(y-x));\n        }else{\n          System.out.println(ab*2*x);\n        }\n\n\n    }\n}", "code2": "k = gets.chomp.to_i\na, b = gets.chomp.split(\" \").map{|e|e.to_i}\n\ndef check(k,a,b)\n\tn = k\n\twhile n<=1000 do\n\t\tif a<=n && n<=b then return \"OK\" end\n\t\tn += k\n\tend\n\treturn \"NG\"\nend\n\nprint check(k,a,b)", "label": 0, "name1": "s137655006.java", "name2": "s182072052.rb"}, {"id": 967, "code1": "\npublic class Main {\n\n\n  private static void solve() {\n    int N = ni();\n    int C = ni();\n    int[][] D = ntable(C, C);\n    int[][] c = ntable(N, N);\n\n    int[][] dp = new int[C][3];\n    for (int i = 0; i < C; i++) {\n      for (int x = 0; x < N; x++) {\n        for (int y = 0; y < N; y++) {\n          dp[i][(x + y) % 3] += D[c[x][y] - 1][i];\n        }\n      }\n    }\n\n    int min = Integer.MAX_VALUE;\n    for (int i = 0; i < C; i++) {\n      for (int j = 0; j < C; j++) {\n        if (i == j)\n          continue;\n        for (int k = 0; k < C; k++) {\n          if (i == k || j == k)\n            continue;\n\n          int now = dp[i][0] + dp[j][1] + dp[k][2];\n          min = Math.min(now, min);\n        }\n      }\n    }\n    System.out.println(min);\n  }\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n", "code2": "n, a, b=gets.strip.split.map(&:to_i)\nh = readlines.map {|line| line.strip.to_i }\nc=a-b\n\nok=h.inject(:+)\nng=0\n\nuntil ok-ng==1\n  mid = (ok+ng)/2\n  remains = h.map {|e| e-mid*b }.select {|e| e>0 }\n  r_c = remains.map {|e| e/c + ((e.ceil%c).zero? ? 0 : 1) }.inject(0, :+)\n  if r_c > mid\n    ng=mid.to_i\n  else\n    ok=mid.to_i\n  end\nend\n\np ok", "label": 0, "name1": "s175876855.java", "name2": "s037770959.rb"}, {"id": 264, "code1": "\nimport java.util.*;\n\npublic class Main {\n    public static void main(final String[] args) {\n        final Scanner sc = new Scanner(System.in);\n        // \u6574\u6570\u306e\u5165\u529b\n        // final int a = sc.nextInt();\n        // \u6587\u5b57\u5217\u306e\u5165\u529b\n        // final String s1 = sc.next();\n        final int a = sc.nextInt();\n        final int b = sc.nextInt();\n        final int c = sc.nextInt();\n        final int k = sc.nextInt();\n        sc.close();\n        int result = 0;\n        if (a >= k) {\n            result = k;\n        } else if (b >= k - a) {\n            result = a;\n        } else if (c >= k - b - a) {\n            result = 2 * a + b - k;\n        }\n\n        System.out.println(result);\n    }\n}\n", "code2": "imput = gets.chomp.split(\" \")\n#puts imput\na = imput[0].to_i\nb = imput[1].to_i\nc = imput[2].to_i\nk = imput[3].to_i\n#puts a,b,c,k\nif (a >= k) then\n    puts k\nelse\n    if (a + b >= k) then\n        puts a\n    else\n        puts (a - (k-a-b))\n        #puts k\n    end\nend\n  ", "label": 1, "name1": "s239119083.java", "name2": "s251719998.rb"}, {"id": 407, "code1": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int N = sc.nextInt();\n        int[] a = new int[N];\n        for (int i=0; i<N; i++) {\n            a[i] = sc.nextInt();\n        }\n\n        int[] ans = solve(N, a);\n\n        for (int i=0; i<N; i++) {\n            System.out.println(ans[i]);\n        }\n    }\n\n    private static int[] solve(int N, int[] a) {\n        int[] ans = new int[N];\n        int total = Math.abs(a[0]) + Math.abs(a[N-1]);\n\n        for (int i=0; i<N-1; i++) {\n            total += Math.abs(a[i+1] - a[i]);\n        }\n\n        for (int i=0; i<N; i++) {\n            ans[i] = total;\n\n            if (i == 0) {\n                if (0 <= a[i] && a[i] <= a[i+1]\n                        || a[i+1] <= a[i] && a[i] <= 0) {\n//                    System.err.println(\"ans[\" + i + \"] : skip\");\n                    continue;\n                }\n                ans[i] = total - Math.abs(a[i] - 0) - Math.abs(a[i] - a[i+1]) + Math.abs(a[i+1] - 0);\n//                System.err.println(\"ans[\" + i + \"] = \" + ans[i]);\n            } else if (i == N-1) {\n                if (0 <= a[i] && a[i] <= a[i-1]\n                        || a[i-1] <= a[i] && a[i] <= 0) {\n//                    System.err.println(\"ans[\" + i + \"] : skip\");\n                    continue;\n                }\n\n                ans[i] = total - Math.abs(a[i] - 0) - Math.abs(a[i] - a[i-1]) + Math.abs(a[i-1] - 0);\n//                System.err.println(\"ans[\" + i + \"] = \" + ans[i]);\n            }\n            else if (a[i-1] <= a[i] && a[i] <= a[i+1]\n                    || a[i+1] <= a[i] && a[i] < a[i-1]) {\n//                System.err.println(\"ans[\" + i + \"] : skip\");\n                continue;\n            } else {\n                ans[i] = total - Math.abs(a[i] - a[i-1]) - Math.abs(a[i] - a[i+1]) + Math.abs(a[i+1] - a[i-1]);\n//                System.err.println(\"ans[\" + i + \"] = \" + ans[i]);\n            }\n        }\n\n        return ans;\n    }\n}", "code2": "N = gets.chomp.to_i\nA = gets.chomp.split.map(&:to_i)\nA.push(0)\nA.unshift(0)\nsum = 0\nbalance = Array.new(N,0)\n1.upto(A.length-1) do |n|\n\tsum += (A[n-1]-A[n]).abs\n\tif n<balance.length+1\n\t\tbalance[n-1] = (A[n-1]-A[n+1]).abs-((A[n-1]-A[n]).abs+(A[n]-A[n+1]).abs)\n\tend\nend\nbalance.each do |b|\n\tp b+sum\nend", "label": 1, "name1": "s919464469.java", "name2": "s447319638.rb"}, {"id": 3, "code1": "\nimport java.util.Scanner;\n\n/**\n * Created by enpingkuang on 2020/9/10 10:58 \u4e0b\u5348\n */\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String s = scanner.next();\n        long sum = 0;\n        int length = s.length();\n        for(int i = 0;i<length;i++){\n            sum += (s.charAt(i)-'0');\n        }\n        System.out.println(sum % 9==0?\"Yes\":\"No\");\n    }\n}\n", "code2": "s = gets.to_s\n\nd_sum = 0\n0.upto(s.size-1) do |i|\n  d_sum += s[i].to_i\nend\n\nif d_sum % 9 == 0\n  puts \"Yes\"\nelse\n  puts \"No\"\nend", "label": 1, "name1": "s939687060.java", "name2": "s099992332.rb"}]